<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://lee989898.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lee989898.github.io/" rel="alternate" type="text/html" /><updated>2021-12-06T19:05:54+09:00</updated><id>https://lee989898.github.io/feed.xml</id><title type="html">LEE</title><subtitle>공부 블로그</subtitle><entry><title type="html">__SSL/TLS__</title><link href="https://lee989898.github.io/sc-20" rel="alternate" type="text/html" title="__SSL/TLS__" /><published>2021-12-03T01:06:00+09:00</published><updated>2021-12-03T01:06:00+09:00</updated><id>https://lee989898.github.io/sc-20</id><content type="html" xml:base="https://lee989898.github.io/sc-20">&lt;h3 id=&quot;ssltls&quot;&gt;&lt;strong&gt;SSL/TLS&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Secure sockets layer (SSL)​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;1996, Netscape​&lt;/li&gt;
  &lt;li&gt;1999, TLS로​&lt;/li&gt;
  &lt;li&gt;웹기반 전자상거래를 위해 TCP layer에서 메시지와 무결성과 비밀성 제공​&lt;/li&gt;
  &lt;li&gt;Web-server와 web-browser간 보안​&lt;/li&gt;
  &lt;li&gt;HTTPS – 현재 대부분 서버에서 사용​&lt;/li&gt;
  &lt;li&gt;Handshake (암호spec, session관리), record (암호,무결성등 보안서비스) protocols로 나뉜다​&lt;/li&gt;
  &lt;li&gt;인증수행-&amp;gt;세션키분배-&amp;gt;암호화 메시지 송수신 순서​&lt;/li&gt;
  &lt;li&gt;지원하는 보안서비스 ​
    &lt;ul&gt;
      &lt;li&gt;Server/client authentication, confidentiality, integrity&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;부인방지기능은 제공안됨 – 전자서명 사용해야​&lt;/li&gt;
  &lt;li&gt;단순히 web-server와 web-browser간의 모든 data를 암호화하면 안전? No, replay attack (관찰된 통신내용을 동일하게 재생하면 같은 결과를 얻을 수 있다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Secure sockets layer (SSL) 표준​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;User authentication​&lt;/li&gt;
  &lt;li&gt;Confidentiality​&lt;/li&gt;
  &lt;li&gt;Integrity​
​
&lt;img src=&quot;/assets/built/images/sc/sc31.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;TLS/SSL Protocol 구성​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Handshake protocol​
    &lt;ul&gt;
      &lt;li&gt;Client, server 간 인증, 암호 알고리즘 합의, 키교환 등 수행​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Record protocol​
    &lt;ul&gt;
      &lt;li&gt;데이터를 인증, 암호화처리하고 메시지 송수신​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Change cipher spec​
    &lt;ul&gt;
      &lt;li&gt;암호 spec을 변경담당​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Alter protocol​
    &lt;ul&gt;
      &lt;li&gt;에러처리​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Handshake Protocol&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;핸드셰이크는 서버를 확인하고 데이터가 전송되기 전에 클라이언트와 서버가 암호화 세트에 동의하도록 한다&lt;/li&gt;
  &lt;li&gt;Record protocol의 의한 data송수신보다 먼저 수행되어 다음의 session정보를 생성, 관리​
    &lt;ul&gt;
      &lt;li&gt;Session ID​&lt;/li&gt;
      &lt;li&gt;Certification​&lt;/li&gt;
      &lt;li&gt;Cipher spec: 압축, MAC algorithm​&lt;/li&gt;
      &lt;li&gt;Compression method: 암호화 이전 압축 algorithm​&lt;/li&gt;
      &lt;li&gt;Master secret key: 48bit&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Handshake Protocol&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;3개의 필드로 이루어진 메시지 교환
    &lt;ul&gt;
      &lt;li&gt;type: 메시지 종류 명시&lt;/li&gt;
      &lt;li&gt;length: 메시지 길이&lt;/li&gt;
      &lt;li&gt;content: 메시지 종류에 따른 값들&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;4단계 진행
    &lt;ul&gt;
      &lt;li&gt;1단계: Security capability establish​&lt;/li&gt;
      &lt;li&gt;2단계: Server authentication &amp;amp; key exchange​&lt;/li&gt;
      &lt;li&gt;3단계: Client authentication &amp;amp; key exchange​&lt;/li&gt;
      &lt;li&gt;4단계: Change cipher specs​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc32.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1단계: Security capability establish​
    &lt;ul&gt;
      &lt;li&gt;1~3​&lt;/li&gt;
      &lt;li&gt;Hello 메시지 교환으로 session ID, 키교환알고리즘, 인증 알고리즘, 암호알고리즘, 압축 알고리즘 결정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Server authentication &amp;amp; key exchange​
    &lt;ul&gt;
      &lt;li&gt;4~6​&lt;/li&gt;
      &lt;li&gt;4: 서버의 인증서와 검증위한 인증서체인, 공개키전송​&lt;/li&gt;
      &lt;li&gt;5: client 인증서 요구(opt)​&lt;/li&gt;
      &lt;li&gt;6: 2단계 종료메시지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;3단계: Client authentication &amp;amp; key exchange​
    &lt;ul&gt;
      &lt;li&gt;7~9​&lt;/li&gt;
      &lt;li&gt;7: client 인증서전송​&lt;/li&gt;
      &lt;li&gt;8: 48byte premaster secrete 전송​&lt;/li&gt;
      &lt;li&gt;9: client 인증서 검증&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;4단계: Change cipher specs​
    &lt;ul&gt;
      &lt;li&gt;10~11​&lt;/li&gt;
      &lt;li&gt;암호사양변경 메시지 교환을 통해 다음 세션에 적용될 암호 spec 결정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Record Protocol&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;메시지를 최대 16KB 단위로 fragment​&lt;/li&gt;
  &lt;li&gt;MAC 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc33.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1: 메시지를 최대 16KB 단위로 fragment​&lt;/li&gt;
  &lt;li&gt;2: 압축 (opt)​&lt;/li&gt;
  &lt;li&gt;3: MAC 추가​&lt;/li&gt;
  &lt;li&gt;4: Encryption​&lt;/li&gt;
  &lt;li&gt;5: SSL reacord header 추가&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Changes from SSL 3.0 to TLS&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Transport Layer Security [RFC2246]​&lt;/li&gt;
  &lt;li&gt;Additional Alerts added​&lt;/li&gt;
  &lt;li&gt;Modification to hash calculations​&lt;/li&gt;
  &lt;li&gt;Protocol version 3.1 in ClientHello, ServerHello&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="security" /><summary type="html">SSL/TLS</summary></entry><entry><title type="html">__IPSEC__</title><link href="https://lee989898.github.io/sc-21" rel="alternate" type="text/html" title="__IPSEC__" /><published>2021-12-03T01:06:00+09:00</published><updated>2021-12-03T01:06:00+09:00</updated><id>https://lee989898.github.io/sc-21</id><content type="html" xml:base="https://lee989898.github.io/sc-21">&lt;h3 id=&quot;ipsec&quot;&gt;&lt;strong&gt;IPSEC&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;IPSEC&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;IP 주소 위장 방지(출발지 인증)​&lt;/li&gt;
  &lt;li&gt;IP 데이터그램의 변경 및 재전송 방지​&lt;/li&gt;
  &lt;li&gt;IP 데이터 그램을 위한 기밀성, 무결성 제공​&lt;/li&gt;
  &lt;li&gt;보안  프로토콜 선택(시스템들이 필요로 하는)​&lt;/li&gt;
  &lt;li&gt;암호 알고리즘 선택(선택된 프로토콜에서 사용되도록)​&lt;/li&gt;
  &lt;li&gt;암호키 생성,분배(요청된 서비스의 제공에 필요) ​&lt;/li&gt;
  &lt;li&gt;Application​
    &lt;ul&gt;
      &lt;li&gt;VPN (virtual Private Network): 가상 전용회선​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;IPSEC 구성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;IPsec AH(인증 헤더) 프로토콜​
    &lt;ul&gt;
      &lt;li&gt;데이터 근원 인증,비연결형 무결성 제공 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;캡슐화 보안페이로드 (ESP ) – 데이터기밀성, 제한된 트래칙 흐름 기밀성, 비연결형 무결성, 데이터 근원인증, 재전송공격 방지 제공​&lt;/li&gt;
  &lt;li&gt;IKE 프로토콜 ​
    &lt;ul&gt;
      &lt;li&gt;통신당사자간 키관리 프로토콜​&lt;/li&gt;
      &lt;li&gt;암호알고리즘 선택협상, 키분배 위해 사용​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Transport and Tunnel Modes&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc34.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Transport mode​
    &lt;ul&gt;
      &lt;li&gt;End to end between hosts​&lt;/li&gt;
      &lt;li&gt;관련 hosts들이 IPSec을 지원해야​&lt;/li&gt;
      &lt;li&gt;IP 상위 프로토콜 (TCP, Application) 안전하게 전송​&lt;/li&gt;
      &lt;li&gt;IP header에 IPSec header정보 추가​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc35.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Tunnel mode​
    &lt;ul&gt;
      &lt;li&gt;터널내의 모든 IP 트래픽 보호​&lt;/li&gt;
      &lt;li&gt;터널의 시작,종류 지점에 IPSec gateway​&lt;/li&gt;
      &lt;li&gt;터널 시작 gateway에서 새 IP header와 Ipsec header 추가하고, 종료 gateway에서 제거​&lt;/li&gt;
      &lt;li&gt;라우터가 내부 패킷을 검사하지 않음&lt;/li&gt;
      &lt;li&gt;소스 및 목적지 주소가 다를 수 있음&lt;/li&gt;
      &lt;li&gt;방화벽에서 구현 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="security" /><summary type="html">IPSEC</summary></entry><entry><title type="html">__Kerberos​__</title><link href="https://lee989898.github.io/sc-18" rel="alternate" type="text/html" title="__Kerberos​__" /><published>2021-12-01T01:06:00+09:00</published><updated>2021-12-01T01:06:00+09:00</updated><id>https://lee989898.github.io/sc-18</id><content type="html" xml:base="https://lee989898.github.io/sc-18">&lt;h3 id=&quot;kerberos&quot;&gt;&lt;strong&gt;Kerberos​&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Kerberos?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Symmetric key 기반 분산 인증 시스템​&lt;/li&gt;
  &lt;li&gt;사용자가 서버의 서비스에 액세스하려는 경우 (예, 프린터서버, 네트워크 디스크 등)​&lt;/li&gt;
  &lt;li&gt;세 가지 위협 존재:​
    &lt;ul&gt;
      &lt;li&gt;사용자가 다른 사용자로 가장​&lt;/li&gt;
      &lt;li&gt;사용자가 워크스테이션의 네트워크 주소를 변경&lt;/li&gt;
      &lt;li&gt;사용자는 교환을 도청하고 재생 공격을 사용​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Client들이 원격으로 서버에 자원, 서비스 요청시마다 인증반복​&lt;/li&gt;
  &lt;li&gt;매번 passwd 입력 안해도 되며, 각 서버가 사용자들의 비번을 저장할 필요없다​&lt;/li&gt;
  &lt;li&gt;경쟁자: SSL&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;​Kerberos Design 요구사항​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;사용자는 워크스테이션 세션(로그인 세션)이 시작될 때 한 번 자신을 식별해야 한다&lt;/li&gt;
  &lt;li&gt;암호는 네트워크를 통해 일반 텍스트로 전송되지 않습니다(또는 메모리에 저장)&lt;/li&gt;
  &lt;li&gt;각 서버가 사용자들의 비번을 저장할 필요없어야 ​함&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;System Components​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Server, User​&lt;/li&gt;
  &lt;li&gt;AS(Authentication Server)​
    &lt;ul&gt;
      &lt;li&gt;모든 user/server 들의 password 안다​&lt;/li&gt;
      &lt;li&gt;TGS 에 제시할 ticket 발급​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TGS(Ticket Granting Server)​
    &lt;ul&gt;
      &lt;li&gt;서버는 ticket만 받는다​&lt;/li&gt;
      &lt;li&gt;서비스 요청시, 한 user는 한 server에 한 ticket제시​&lt;/li&gt;
      &lt;li&gt;Server에 제시할 ticket 발급역할​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;시스템 구성도&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc28.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Protocol​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;User/TGS는 AS에, server는 TGS에 등록(passwd)되어 있다  (or PKI사용)​&lt;/li&gt;
  &lt;li&gt;User가 서비스 필요​&lt;/li&gt;
  &lt;li&gt;서비스 제공할 server 찾는다​&lt;/li&gt;
  &lt;li&gt;해당 server 관리하는 TGS 찾는다​&lt;/li&gt;
  &lt;li&gt;AS에 TGS에 보낼 ticket요청&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;User는 AS에게  UserID, TGS이름을 $K_{user-AS}$로 암호화하여 보낸다&lt;/li&gt;
  &lt;li&gt;AS는 User와 TGS간의 통신을 위한 세션키1 $K_{user-TGS}$ 를 생성​ 세션키1, UserID 를 $K_{AS-TGS}$로 암호화하여 User에게 발급할 Ticket을 생성​ 세션키1과 Ticket을 $K_{user-AS}$로 암호화하여 보낸다​&lt;/li&gt;
  &lt;li&gt;받은 2를 $K_{user-AS}$복호화해서 세션키1 $K_{user-TGS}$ 와 Ticket을 얻는다. ​UserID를 세션키1로 암호화해서 Ticket과 함께 TGS로 보낸다​&lt;/li&gt;
  &lt;li&gt;받은 3을 $K_{user-TGS}$와 $K_{AS-TGS}$ 로 복호화해서 User정보와 요구내용 확인, ​TGS는 User와 Server간의 통신을 위한 세션키2 $K_{user-server}$ 생성 ​세션키2, UserID 를 $K_{TGS-server}$로 암호화하여 User에게 발급할 Ticket을 생성​ 세션키2와 Ticket을 $K_{user-TGS}$로 암호화하여 보낸다​&lt;/li&gt;
  &lt;li&gt;받은 4를 $K_{user-TGS}$로 복호화해서 세션키2 $K_{user-server}$와 Ticket(user, Server)를 얻는다. Server에게 $K_{user-server}$로 암호화한 UserID와 Ticket을 전송한다​&lt;/li&gt;
  &lt;li&gt;Server는 받는 5의 Ticket을 $K_{TGS-server}$로 복호화 하여 세션키2 $K_{user-server}$을 얻는다. 이걸로 UserID를 복호화해서  사용자확인을 한다.​&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Drawbacks of Kerberos&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;단일 실패 지점: 중앙 서버의 지속적인 가용성이 필요. Kerberos 서버가 다운되면 아무도 로그인할 수 없다&lt;/li&gt;
  &lt;li&gt;Kerberos에는 엄격한 시간 요구 사항이 있으므로 관련된 호스트의 시계가 구성된 제한 내에서 동기화되어야 함&lt;/li&gt;
  &lt;li&gt;관리 프로토콜은 표준화되지 않았으며 서버 구현에 따라 다르다&lt;/li&gt;
  &lt;li&gt;모든 인증은 중앙 집중식 KDC에 의해 제어되므로 이 인증 인프라가 손상되면 공격자가 모든 사용자를 가장할 수 있음&lt;/li&gt;
  &lt;li&gt;다른 호스트 이름이 필요한 각 네트워크 서비스에는 고유한 Kerberos 키 세트가 필요합니다. 이는 가상 호스팅 및 클러스터를 복잡하게 만든다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="security" /><summary type="html">Kerberos​</summary></entry><entry><title type="html">__Dos​__</title><link href="https://lee989898.github.io/sc-19" rel="alternate" type="text/html" title="__Dos​__" /><published>2021-12-01T01:06:00+09:00</published><updated>2021-12-01T01:06:00+09:00</updated><id>https://lee989898.github.io/sc-19</id><content type="html" xml:base="https://lee989898.github.io/sc-19">&lt;h3 id=&quot;dos&quot;&gt;&lt;strong&gt;Dos​&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Dos (Denial of Service)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;서비스 거부​&lt;/li&gt;
  &lt;li&gt;시스템 자원(cpu, memory, network, storage 등)을 고갈시켜 정상적인 접근에 대한 서비스를 제공할 수 없도록 만드는 행위​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Dos attack type​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Error trigger Dos attack​&lt;/li&gt;
  &lt;li&gt;OS,application의 약점에 attack packet 전송해서 system error 유발 (slammer worm)​&lt;/li&gt;
  &lt;li&gt;Ping of death, Land, Teardrop​&lt;/li&gt;
  &lt;li&gt;Flooding Dos attack​&lt;/li&gt;
  &lt;li&gt;packet, traffic을 과중하게 발생하여 server, network resource 고갈​&lt;/li&gt;
  &lt;li&gt;TCP syn flooding​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;TCP syn flooding​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;TCP 3-way handshaking의 취약점 이용​&lt;/li&gt;
  &lt;li&gt;공격자가 src IP 주소를 위조해서 TCP SYN를  동시에 대량전송​&lt;/li&gt;
  &lt;li&gt;서버는 TCP ACK를 보내고, 자원할당 후 응답 기다림​&lt;/li&gt;
  &lt;li&gt;정상적인 접근방해+엉뚱한 피해자​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc29.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;DDoS Attack​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Distributed Denial of Service​&lt;/li&gt;
  &lt;li&gt;다수의 pc가 동시에 Dos 공격​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;BotNet?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Bot(=zombie): 악성sw에 감염되어 자신도 모르게 해커의 조종을 받는 컴퓨터​&lt;/li&gt;
  &lt;li&gt;BotNet: 명령제어서버(C&amp;amp;C,command and control)를 통해 원격제어되는 악성코드에 감염된 컴퓨터(bot)들의 네트워크 ​&lt;/li&gt;
  &lt;li&gt;대부분 사어버테러의 주요 원인&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc30.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;DDos 종류&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Standard DoS: 알려진 취약점 집중공격​&lt;/li&gt;
  &lt;li&gt;Tool을 이용한 DoS: TFN, TFN2K, Trinoo, Loki, Stacheldraht, Jolt, Land, teardrop…​&lt;/li&gt;
  &lt;li&gt;Traffic anomalie 공격: bandwidth점유, ICMP, TCP, UDP flooding​&lt;/li&gt;
  &lt;li&gt;Spoofed SYN flooding: spoof된 source IP로 TCP syn보냄​&lt;/li&gt;
  &lt;li&gt;Connection Per Second(CPS) flood: zombie로 부터 connection flooding​&lt;/li&gt;
  &lt;li&gt;Established Connection flood: zombie로 부터 established connection flood​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Why DDos?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Simple​&lt;/li&gt;
  &lt;li&gt;Easy: just use tools​&lt;/li&gt;
  &lt;li&gt;Effective​&lt;/li&gt;
  &lt;li&gt;공격자추적이 어렵다​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="security" /><summary type="html">Dos​</summary></entry><entry><title type="html">근사 알고리즘</title><link href="https://lee989898.github.io/algorithm-09" rel="alternate" type="text/html" title="근사 알고리즘" /><published>2021-11-29T01:09:00+09:00</published><updated>2021-11-29T01:09:00+09:00</updated><id>https://lee989898.github.io/algorithm-09</id><content type="html" xml:base="https://lee989898.github.io/algorithm-09">&lt;h3 id=&quot;근사-알고리즘&quot;&gt;&lt;strong&gt;근사 알고리즘&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;근사-알고리즘-1&quot;&gt;근사 알고리즘&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-완전 문제 해결 방법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;문제의 크기가 작다면 완전 탐색 알고리즘 사용&lt;/li&gt;
  &lt;li&gt;문제의 특별한 경우(들)에는 다항 시간 알고리즘을 찾으려고 노력&lt;/li&gt;
  &lt;li&gt;문제의 최적해에 매우 근사한 해를 구하는 것이 허용된다면 비교적 빠른 근사 알고리즘을 찾으려고 노력&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;근사 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;NP-완전 문제와 같이 지금까지 알려진 실용적인 다항 시간 알고리즘이 없거나 최적의 해를 반드시 찾을 필요가 없을 때 사용&lt;/li&gt;
  &lt;li&gt;대부분의 근사 알고리즘은 특정 문제에만 적용되는 휴리스틱에 기초&lt;/li&gt;
  &lt;li&gt;휴리스틱은 경험을 통해 얻는 상식적인 접근법&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;근사 비율&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;근사해의 값과 최적해의 값의 비율&lt;/li&gt;
  &lt;li&gt;정의: 근사 비율 p
    &lt;ul&gt;
      &lt;li&gt;f: 목적 함수&lt;/li&gt;
      &lt;li&gt;$S_a$: 근사해&lt;/li&gt;
      &lt;li&gt;$S^*$: 최적해&lt;/li&gt;
      &lt;li&gt;$S_a$는 다음 부등식을 만족시켜야 한다
        &lt;ul&gt;
          &lt;li&gt;최소화 문제: $\frac{f(S_a)} {f(S^*)}$&amp;lt;= p&lt;/li&gt;
          &lt;li&gt;최대화 문제: $\frac{f(S^*)} {f(S_a)}$&amp;lt;= p&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;p-근사 알고리즘: 근사비율이 p인 알고리즘&lt;/li&gt;
  &lt;li&gt;1에 가까울수록 정확도가 높은 알고리즘&lt;/li&gt;
  &lt;li&gt;근사 비율은 보통 2를 사용&lt;/li&gt;
  &lt;li&gt;대부분의 경우에 목적 함수의 최적 값인 $f(S^*)$를 알 수 없기 때문에 근사 비율 계산 불가&lt;/li&gt;
  &lt;li&gt;$f(S^*)$를 대신할 수 있는 $f(S_a)$의 상한을 구하여 근사 비율을 계산&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;정점 커버 찾기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무방향 그래프에서 각 간선의 양쪽 끝의 두 정점들 중에서 적어도 1개의 정점을 포함하는 정점들의 집합&lt;/li&gt;
  &lt;li&gt;크기 = 정점 커버내에 있는 정점들의 수&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그래프는 여러 개의 정점 커버들을 가질 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;무방향 그래프내에 있는 최소 크기의 정점 커버를 찾아라
    &lt;ul&gt;
      &lt;li&gt;정점 지향 전략&lt;/li&gt;
      &lt;li&gt;간선 지향 전략&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;정점 지향 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;그래프의 모든 정점들을 차수(한 정점에 인접한 정점들의 수) 기준으로 내림차순으로 정렬한다&lt;/li&gt;
  &lt;li&gt;차수가 가장 큰 정점을 선택한다&lt;/li&gt;
  &lt;li&gt;선택된 정점에 인접한 모든 간선을 제거한다&lt;/li&gt;
  &lt;li&gt;남은 그래프에서 과정 2와 3을 반복한다&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;간선 지향 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;그래프의 한 간선 (u, v)를 임의로 선택한다&lt;/li&gt;
  &lt;li&gt;u와 v를 정점 커버에 포함시키고 u와 v에 인접한 간선들은 모두 그래프에서 제거한다&lt;/li&gt;
  &lt;li&gt;남은 간선들 중 임의로 한 간선을 선택하고 같은 과정을 반복한다. 선택할 간선들이 더 이상 남아 있지 않으면 종료한다&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;근사 정점 커버 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Approx_Vertex_Cover(G)&lt;br /&gt;
// 입력: 그래프 G = (V, E)&lt;br /&gt;
// 출력: C - 정점 커버&lt;br /&gt;
1 C = $\emptyset$&lt;br /&gt;
2 $E^&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$ = E  
3 while ( $E^&lt;/code&gt;$ $\neq$  $\emptyset$){&lt;br /&gt;
4   $E^&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$에서 임의로 간선 (u,v)를 선택한다  
5   C = C {u} {v}  
6   $E^&lt;/code&gt;$에서 정점 u나 v에 인접한 모든 간선들을 제거한다&lt;br /&gt;
    }&lt;br /&gt;
7 return C&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;시간 복잡도: O(&lt;/td&gt;
          &lt;td&gt;E&lt;/td&gt;
          &lt;td&gt;)&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;해밀토니안 회로&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;해밀토니안 회로: 그래프의 한 정점에서 출발하여 다른 모든 정점을 1번씩만 방문하고 출발 정점으로 돌아오는 경로&lt;/li&gt;
  &lt;li&gt;완전 그래프에는 반드시 해밀토니안 회로가 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;외판원 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;가중 완전 그래프의 최단 거리 해밀토니안 회로를 찾아라&lt;/li&gt;
  &lt;li&gt;NP-완전 문제&lt;/li&gt;
  &lt;li&gt;다음 조건들을 만족시켜야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;가중치가 있는 완전 무방향 그래프 G = (V, E)의 각 간선 (u, v) $\in$ E는 음이 아닌 가중치 c(u, v)를 가진다&lt;/li&gt;
  &lt;li&gt;모든 정점 u,v,w $\in$ V에 대해서 거리 함수 c가 다음과 같은 삼각 부등식을 만족한다
    &lt;ul&gt;
      &lt;li&gt;c(u,v) &amp;lt;= c(u, w) + c(w, v)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;근사 외판원 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;아이디어&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;프림의 최소 비용 신장 트리 알고리즘을 이용하여 주어진 그래프에서 최소 비용 신장 트리를 찾는다&lt;/li&gt;
  &lt;li&gt;이 트리에 깊이 우선 탐색을 하여 정점들의 방문 순서를 구한다&lt;/li&gt;
  &lt;li&gt;이 순서를 따라 정점들을 방문하면서 다시 방문하는 정점을 순서에서 제거하여 외판원 문제의 근사해를 구한다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Approx_MST_TSP(G, c)&lt;br /&gt;
// 입력: G = (V, E) - 가중 완전 그래프, c - G의 간선들의 가중치(삼각 부등식을 만족)&lt;br /&gt;
// 출력: 해밀토니안 회로 H&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;임의의 정점 r $\in$ V를 출발 정점으로 선택한다&lt;/li&gt;
  &lt;li&gt;Prim의 최소 비용 신장 트리 알고리즘을 이용하여 r이 루트 노드인 그래프 G의 최소 비용 신장 트리 T를 구한다&lt;/li&gt;
  &lt;li&gt;트리 T의 루트 노드에서 시작하여 깊이 우선 탐색을 하면서 노드들을 방문한 순서대로 나열한 목록 H를 구한다&lt;/li&gt;
  &lt;li&gt;목록 H에 있는 정점들을 출발 정점을 제외하고 처음부터 순서대로 스캔하면서 중복하여 나타나는 정점들을 H에서 제거한다&lt;/li&gt;
  &lt;li&gt;return H&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;시간복잡도: O($n^2$)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="algorithm" /><summary type="html">근사 알고리즘</summary></entry><entry><title type="html">FPLs</title><link href="https://lee989898.github.io/pl-20" rel="alternate" type="text/html" title="FPLs" /><published>2021-11-24T19:18:00+09:00</published><updated>2021-11-24T19:18:00+09:00</updated><id>https://lee989898.github.io/pl-20</id><content type="html" xml:base="https://lee989898.github.io/pl-20">&lt;h3 id=&quot;fpls&quot;&gt;&lt;strong&gt;FPLs&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;lisp&quot;&gt;Lisp​&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Lisp은 심볼(문자열) 처리를 위한 언어로 개발되었다&lt;br /&gt;
심볼들을 표현하기 위한 데이터 구조로 리스트, 즉 링크드 리스트를 기본으로 한다&lt;br /&gt;
이러한 이유로 데이터 연산은 자연스레 링크(포인터) 조작을 포함한다&lt;br /&gt;
Lisp이라는 이름은 리스트 프로세싱의 합성어로서, 말 그대로 리스트 처리에 적합하도록 설계되었다&lt;/p&gt;

&lt;p&gt;Lisp의 데이터 타입은 아톰과 리스트, 두 가지이다&lt;br /&gt;
아톰은 식별자처럼 생긴 심볼들이거나 숫자 형태의 상수를 말한다&lt;br /&gt;
아톰에 값이 없을 수 있어서 nil도 가능하다&lt;br /&gt;
리스트는 리스트 요소가 연결되어 있고, 리스트 요소는 두개의 링크(포인터), 데이터 포인터와 넥스트 포인터로 구성된다&lt;br /&gt;
데이터 포인터는 아톰을 가리키거나 중첩리스트를 가리킨다&lt;br /&gt;
넥스트 포인터는 다른 리스트 요소를 가리키거나 nil(리스트의 끝을 나타냄)이다&lt;/p&gt;

&lt;p&gt;Lisp 프로그램에서 리스트는 괄호를 써서 나타내는데, 중첩 리스트는 괄호 안에 괄호를 써서 나타낸다&lt;/p&gt;

&lt;p&gt;ex) (A, B, C, D)&lt;br /&gt;
A,B,C,D는 각각이 아톰이며, (A,B,C,D)는 리스트이다&lt;/p&gt;

&lt;p&gt;산술 연산자로 +, - , incf, decf가 있고, 비교 연산자로 =, /= , &amp;lt;, max, min이 있다&lt;br /&gt;
부울 값에 대한 논리 연산자로 loand,logor 등이 있다&lt;br /&gt;
컨트롤 스트럭처로 selection, recursiong, iteration이 있는데, iteration은 명령형 언어의 특성으로, Lisp이 순수 함수 언어가 아니라는 것을 보여준다&lt;br /&gt;
함수 정의는 (defun 함수명 (파라미터1… 파라미터n)표현식)형식을 따르고, 함수 적용(호출)은 (함수명 파라미터1 … 파라미터n)의 형식을 따른다&lt;/p&gt;

&lt;p&gt;Lisp으로 작성된 팩토리알 함수는&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(DEFUN factorial (X))
    (IF &amp;lt;= n 1)
            1
            (* n factorial (-n 1)))
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;과 같다&lt;/p&gt;

&lt;p&gt;미리 정의된 함수 중의 몇몇은 실제로는 함수가 아니라 매크로이다&lt;br /&gt;
예를 들어, 두개의 파라미터, 죽 변수와 리스트를 받아들이는 DOLIST는 매크로이다&lt;br /&gt;
DOLIST(x ‘(1 2 3)) (print x))는 리스트 요소 1,2,3,nil로 구성된 리스트를 생성한다&lt;/p&gt;

&lt;p&gt;매크로의 실행은 다음 두 단계로 이루어진다&lt;br /&gt;
우선, 매크로를 미리 정의딘 Lisp 코드로 펼치고, 다음에, 펼친 Lisp 코드를 평가(실행)한다&lt;/p&gt;

&lt;p&gt;사용자는 DEFMACRO를 써서 자신이 원하는 매크로를 정의할 수 있다&lt;/p&gt;

&lt;p&gt;Lisp에서 괄호 앞의 ‘(QUOTE)는 괄호 속의 표현식을 평가(실행)하지 말고, 그 객체(표현식)를 결과로서 반환하라는 뜻이다&lt;br /&gt;
예를 들어 ‘(a(* 3 4)c)는 (a 12 c)를 결과로 반환한다&lt;br /&gt;
중첩된 괄호 속의 (* 3 4)는 평가한다는 것에 주의하자&lt;/p&gt;

&lt;p&gt;Lisp은 컴파일러가 아닌 인터프리터에 의해 실행된다&lt;br /&gt;
Lisp 프로그램에서는 함수 정의 및 함수 적용(호출)을 “괄호에 의한 리스트 표시 방식”으로 표현된다&lt;br /&gt;
함수 정의는 (함수명(람다 (파라미터1 … 파라미터n) 표현식)) 으로 정의하며, 함수 적용은 (함수명 파라미터1 … 파라미터n)으로 호출한다&lt;br /&gt;
예를 들어, (+ 5 7)은 12이고, (+ 3 4 7 6)은 20이다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;scheme&quot;&gt;Scheme​&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Scheme은 Lisp으로부터 유래되었으나 함수를 일등 시민으로 취급한다&lt;br /&gt;
Scheme에서는 함수가 표현식의 결과 값일 수 있고, 함수가 리스트의 요소로 사용될 수 있으며, 함수가 파라미터로 패스될 수 있고, 함수가 함수의 결과로서 반환될 수 있다&lt;/p&gt;

&lt;p&gt;Scheme은 단순한 신택스와 시맨틱스를 갖는, 타입이 없는 작은 언어이다&lt;/p&gt;

&lt;p&gt;Scheme 인터프리터는 상호작용 모드로 동작하면서, read-evaluate-print 순환(REPL)을 무한으로 반복한다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;사용자가 입력한 표현식을 읽어서&lt;/li&gt;
  &lt;li&gt;EVAL 함수에 의해 표현식을 해석하고&lt;/li&gt;
  &lt;li&gt;결과값을 화면에 display한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;EVAL 함수는 다음과 같이 표현식을 평가한다&lt;br /&gt;
리터럴의 평가는 그 자체를 결과로 displaat한다&lt;br /&gt;
원시 함수를 포함하는 표현식의 평가는 다음과 같이 실행한다&lt;br /&gt;
첫째, 특별한 순서 없이, 파라미터 표현식의 각각 평가한다&lt;br /&gt;
둘째, 파라미터 값에 원시 함수의 적용을 평가한다&lt;br /&gt;
끝으로, 결과값을 display한다&lt;/p&gt;

&lt;p&gt;원시 산술 함수는 +,-,*,/,modulo,round,max,min,log,sin,sqrt 등이다&lt;br /&gt;
음수에 대한 sqrt는 허수이다&lt;/p&gt;

&lt;p&gt;함수 정의는 (LAMBDA (x) (* x x))의 형식을 가지며, 함수 적용은 ((LAMBDA(x) (* x x)) 7)의 형식을 갖는다&lt;/p&gt;

&lt;p&gt;DEFINE 함수는 이름을 값이나 람다 함수에 바인딩하는 특수한 함수이다&lt;br /&gt;
(DEFINE symbol expression)의 형식을 가지며, 그 예로 (DFINE pi 3.141592), (DEFINE two_pi (* 2 pi))을 들 수 있다&lt;/p&gt;

&lt;p&gt;DEFINE 함수가 이름을 람다 표현식에 바인딩하는 형식은 (DEFINE (function_name parameters) (expression))이다&lt;br /&gt;
예를 들면, 제곱수를 (DEFINE (square number) (* number number))와 같이 정의하고, 직각삼각형의 빗변의 길이를 (DEFINE (hypotenuse side1 side2)(SQRT(+(square side1)(square side2))))와 같이 정의한다&lt;/p&gt;

&lt;p&gt;출력 함수는 EVAL 함수의 적용을 통해 그 결과를 display한다&lt;/p&gt;

&lt;p&gt;논리적 술어(predicate)함수는 부울 값을 반환한다&lt;br /&gt;
Scheme의 논리적 술어 함수는 =, &amp;lt;&amp;gt;, &amp;gt;,&amp;lt;,&amp;gt;=, &amp;lt;=, EVEN?, ODD?, ZERO?가 있다&lt;br /&gt;
리스트가 부울식으로서 해석될 때에는 비어있지 않은 리스트는 참이고, 비어있는 리스트는 거짓이다&lt;/p&gt;

&lt;p&gt;컨트롤 플로우는 택인 컨스트럭트(IF)와 평가 컨트롤(COND)이 있다&lt;br /&gt;
if는 3개의 파라미터(논리적 술어 표현식, then 표현식, else 표현식)를 갖는다&lt;br /&gt;
그 형식은 (IF 논리적 술어 then 표현식 else 표현식)이고, 사용 예를 들면 DEFINE(factorial n)(IF (&amp;lt;+ n 1)1(*n(factorial(-n 1))))이다&lt;/p&gt;

&lt;p&gt;평가 컨트롤은 여럿 중에서 하나 이상이 선택 및 실행되는 COND와 recursion이 있다&lt;br /&gt;
COND의 형식은&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(DEFINE (leap? year))
    (COND
        ((ZERO? (MODULO year 400)) #T)
        ((ZERO? (MODULO year 100)) #F)
        (ELSE (ZERO? (MODULO year 4)))))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;와 같다&lt;/p&gt;

&lt;p&gt;리스트 함수에는 QUOTE,CAR,CDR,CONS 함수가 있다&lt;br /&gt;
QUOTE는 그 자체를 결과로 반환하며, ‘로 표시한다&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(QUOTE A) returns A ​
(QUOTE (A B C)) returns (A B C)​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CAR 함수는&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(CAR '((A B) C D)) returns (A B) ​
(CAR 'A) is an error because A is not a list ​
(CAR '(A)) returns A ​
(CAR '()) is an error ​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CDR 함수는 ​&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(CDR '((A B) C D)) returns (C D) ​
(CDR 'A) is an error ​
(CDR '(A)) returns () ​
(CDR '()) is an error​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CONS 함수는 ​&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(CONS 'A '()) returns (A) ​
(CONS 'A '(B C)) returns (A B C)​
(CONS '() '(A B)) returns (() A B)​
(CONS '(A B) '(C D)) returns ((A B) C D)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CAR, CDR을 가지고 a_list의 두번째 리스트 요소를 결과값으로 반환하는 함수를 정의하면, (DEFINE (second a_list)(CAR(CDR a_list)))가 된다&lt;br /&gt;
이것은 a_list에서 첫째 요소를 제외한 나머지를 반환하고, 이중에서 첫째 요소를 반환한다는 뜻이다&lt;br /&gt;
리스트를 생성하기 위해 CAR CDR의 연속으로 적용해 보면, (CADDAR ‘((A B (C)D)E)) == (C) 임을 알 수 있다&lt;/p&gt;

&lt;p&gt;리스트 함수는 다수의 파라미터로부터 하나의 리스트를 생성한다&lt;br /&gt;
CONS는 생성할 수도 있으나, List함수가 편리하다&lt;/p&gt;

&lt;p&gt;논리적 술어 함수 중에서 EQ? NULL? LIST?는 심볼 아톰과 리스트에도 적용할 수 있다&lt;br /&gt;
EQV?은 숫자 아톰과 심볼 아톰에 모두 적용할 수 있다&lt;/p&gt;

&lt;p&gt;Scheme에서 함수 정의의 예를 들어 보자&lt;br /&gt;
멤버 함수는 파라미터 간의 소속관계를 평가한다&lt;br /&gt;
리스트의 맨앞 리스트 요소에서부터 차례로 비교하기 위해, COND와 EQ, CAR, CDR을 사용한다&lt;br /&gt;
append 함수는 앞의 파라미터에 뒤의 파라미터를 잇는다&lt;br /&gt;
list1의 리스트 요소를 앞에서부터 하나씩 새로운 리스트에 넣기를 반복한다&lt;br /&gt;
list1의 리스트의 요소를 모두 새로운 리스트에 넣고 나면, 이때 lsit1은 NULL이 되므로, list2의 요소를 새로운 리스트에 넣으면 된다&lt;br /&gt;
이를 위해 COND와 NULL?, CONS, CAR, CDR을 이용한다&lt;/p&gt;

&lt;p&gt;두개의 리스트가 같은지 판단하려면, 각 리스트의 맨앞 요소에서부터 하나씩 같은지 비교하기를 반복한다&lt;br /&gt;
이를 위해 COND, EQ?, CAR, CDR 등을 이용한다&lt;/p&gt;

&lt;p&gt;반복 처리는 모두 recursion을 이용한다&lt;br /&gt;
즉, 이들 모두 recursion으로 프로그래밍 된다&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root1 = (-b + sqrt(b2 - 4 ac))/2a, root 2 = (-b - sqrt(b2 - 4 ac))/2 a​

(DEFINE (quadratic_roots a b c) ​

  (LET ( ​

     (root_part_over_2a ​

                    (/ (SQRT (− (* b b) (* 4 a c))) (* 2 a))) ​

     (minus_b_over_2a (/ (− 0 b) (* 2 a))) ​

         ) ​

  (LIST (+ minus_b_over_2a root_part_over_2a) ​

                  (− minus_b_over_2a root_part_over_2a)) ​

))​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;LET 함수는 로컬 변수를 생성한다&lt;br /&gt;
표현을 쉽게 하기 위해 루트 부분과 루트가 없는 부분(이것을 마이너스 부분)으로 나누어, 이들을 각각 로컬 변수 root_part_over_2a, minus_b_over_2a로 언급한다&lt;br /&gt;
LIST 함수에서 이들을 언급하며 근의 공식 함수를 정의한다&lt;/p&gt;

&lt;p&gt;함수의 합성은 두개의 함수를 파리미터로 받아들여 합성 함수를 결과로 반환한다&lt;br /&gt;
합성 함수는 DEFINE (compose f g)(LAMBDA(x) (f(g(x))))로 정의한다&lt;br /&gt;
CADDR을 (DEFINE (third a_list) ((compose CAR (compose CDR CDR)) a_list))와 같이 정의한다&lt;/p&gt;

&lt;p&gt;리스트의 모든 요소에 적용하는 함수로 map 함수를 정의해 보자&lt;br /&gt;
함수 정의의 형식은 (DEFINE (mao fun a_list) 표현식)이며, a-list의 모든 요소에 함수 fun을 적용하라는 의미이다&lt;br /&gt;
즉, 함수 map을 정의하는데 파라미터로서 fun이라는 함수를 쓴다&lt;br /&gt;
따라서 이것은 고차 함수이다&lt;/p&gt;

&lt;p&gt;처리 목적에 맞게 처리하려면, 리스트 요소를 하나씩 반환하는 함수가 필요하며, 이렇게 반환된 리스트 요소에 fun을 적용하기를 반복하면 된다&lt;br /&gt;
위의 map 함수 정의에서 (COND … NULL? … ELSE …) 부분은 리스트 요소를 하나씩 꺼내는 처리 로직을 수행한다&lt;br /&gt;
맵함수 사용 예: (map (LAMBDA(num)(*num num num))’(3 4 2 6))은 (27 64 8 216)를 반환한다&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; (DEFINE (adder a_list) ​

      (COND ​

          ((NULL? a_list) 0) ​

          (ELSE (+ (CAR a_list) (adder (CDR a_list)))) ))​

(adder '(3 4 5)) ​

   (+ 3 (adder (4 5))) ​

   (+ 3 (+ 4 (adder (5)))) ​

   (+ 3 (+ 4 (+ 5 (adder ())))) ​

   (+ 3 (+ 4 (+ 5 0))) ​

   (+ 3 (+ 4 5)) ​

   (+ 3 9) ​

   (12)​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;리스트에 있는 아톰의 합을 구하는 프로그램을 작성해보면, 코드는 위에서 보듯이 매우 간결하다&lt;br /&gt;
실제 평가 과정을 보면, recursion이 있어 매우 복잡해 보이지만 이것은 인터프리터의 역할이다&lt;/p&gt;

&lt;p&gt;만일 EVAL 함수를 써서 코딩하면, 아래 프로그램이 된다&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Alternative code with EVAL function:​

(DEFINE (adder a_list) ​

    (COND ​

        ((NULL? a_list) 0) ​

        (ELSE (EVAL (CONS '+ a_list))) ​

))​

(adder '(3 4 5)) ​

(EVAL (+ 3 4 5) ​

(12)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;ml&quot;&gt;ML​&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;ML은 타입 검사를 엄격하게 수행하는 언어이다&lt;br /&gt;
평가 환경은 프로그램에서 명시적 또는 암묵적으로 선언된 모든 변수명을 그 유형(타입)과 함께 테이블을 포함한다&lt;br /&gt;
이 테이블은 컴파일러의 심볼 테이블과 유사하다&lt;br /&gt;
ML 신택스는 Lisp이나 Scheme에 비해 IPL과 더욱 유사하다&lt;br /&gt;
산술 표현식은 인픽스 방식으로 표현된다&lt;/p&gt;

&lt;p&gt;함수 정의는 함수명(파라미터) = 표현식;의 신택스를 갖는다&lt;br /&gt;
예를 들어, fun circumf( r ) = 3.14159&lt;em&gt;r&lt;/em&gt;r;로 정의 되었다면, 함수 circumf는 부동점 파라미터를 받아서 부동점 결과를 생산한다&lt;br /&gt;
이 값의 타입은 표현식의 값으로부터 추론된다&lt;br /&gt;
함수 적용은 circumf(1.3)과 같이 호출된다&lt;/p&gt;

&lt;p&gt;ML의 컨트롤 플로우는 if 표현식 then 표현식1 else 표현식2에 의한다&lt;br /&gt;
ML에서는 주어진 파라미터에 대한 패턴 매칭을 통해 함수의 반환값을 정의하는 특정 표현식을 선택하기도 한다&lt;br /&gt;
예를 들어, 팩토리알을 구할 떄&lt;br /&gt;
fun fact(n : int): int = if n &amp;lt;= 1 then 1 else n * fact(n − 1);로 표현할 수도 있지만, ​fun fact(0) = 1 | fact(1) = 1 | fact(n : int): int = n * fact(n − 1);로 표현할 수도 있다.&lt;br /&gt;
후자에서는 Fact(0), Fact(1)의 값을 구할 때, 두개의 식 fun fact(0) = 1, fact(1) = 1에 대한 패턴 매칭을 통해 그 결과값을 선택할 수 있다&lt;/p&gt;

&lt;p&gt;ML에서는 h, t는 각각 헤드와 테일을 나타내며, CAR, CDR과 같다&lt;br /&gt;
그리고 ::는 CONS와 같다&lt;br /&gt;
두개의 리스트를 append하는 함수는&lt;br /&gt;
fun append([], lis2) = lis2 | append(h :: t, lis2) = h :: append(t, lis2);로 정의된다.&lt;/p&gt;

&lt;p&gt;주어진 리스트에서 리스트 요소의 개수를 구하는 함수는&lt;br /&gt;
fun length([]) = 0 | length(h :: t) = 1 + length(t);이다&lt;/p&gt;

&lt;p&gt;ML에서 값을 선언하는 방법은 변수명에 값을 바인딩하는 것이다&lt;br /&gt;
그 형식은 val new_name = expression이다&lt;br /&gt;
만일 새로운 값을 바인딩하려면 새로운 변수명에 새로운 값을 바인딩하여 테이블에 새로운 엔트리로 생성해야 한다&lt;br /&gt;
val의 정상적인 사용은 표현식에서 사용하는 변수에 대해, Let안에서 바인딩하는 것이다&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Let val radius = 2.7 ​

      val pi = 3.14159 ​

   in pi * radius * radius ​

   end;​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;예에서 radius와 pi는 표현식에 제한된 변수임을 명확히 선언하고 있다&lt;/p&gt;

&lt;p&gt;많이 쓰이는 고차 함수로 리스트를 필터링하는 filter함수가 있다&lt;br /&gt;
필터는 다음과 같이 동작한다&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;필터는 술어 함수를 파라미터로 받아들여서, 술어 만족 여부에 따라 필터링하는 함수를 반환한다(술어 함수는 종종 fn으로 정의된 람다 표현식으로 주어진다)&lt;/li&gt;
  &lt;li&gt;반환된 필터링 함수는 리스트를 파라미터로 받아들여서 다음과 같이 처리한다
    &lt;ul&gt;
      &lt;li&gt;각 리스트 요소에 대해 술어함수를 적용하여 술어 조건을 만족시키는지 검사&lt;/li&gt;
      &lt;li&gt;그 결과가 참이면, 리스트 요소를 새로운 리스트(결과 리스트)에 추가한나다&lt;/li&gt;
      &lt;li&gt;참이 아니면, 스킵한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이렇게 생성된 새로운 리스트를 결과로 반환한다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;필터의 사용을 보면 Filter(fn(x)) =&amp;gt; x &amp;lt;100, [25, 1, 50, 711, 100, 150, 27, 161, 3]);는 결과로서 100보다 작은 요소만으로 구성된 새로운 리스트 [25, 1, 50, 27, 3]를 반환한다&lt;/p&gt;

&lt;p&gt;많이 쓰이는 다른 함수로 map함수가 있다&lt;br /&gt;
map함수는 파라미터로 함수 (fa)를 받아 들여서 새로운 함수를 만든다&lt;br /&gt;
새로운 함수는 파라미터로 리스트를 받아 들인다&lt;br /&gt;
각 리스트 요소에 파라미터로 받은 함수(fa)를 적용한다&lt;/p&gt;

&lt;p&gt;합성 함수는 val h = g o f로 정의하며, 이것은 h(x) = g(f(x))와 같다&lt;/p&gt;

&lt;p&gt;커링은 하나 이상의 파라미터를 가진 함수를 하나의 파라미터를 가진 함수로 교체하는 것이다&lt;br /&gt;
하나의 파라미터를 가진 함수는 함수를 반환하며, 반환된 이 함수는 초기 함수의 다른 파라미터를 받아 들여 결과를 반환한다&lt;br /&gt;
예를 들어, (DEFINE (add x y)(+ x y))의 커리 함수는 DEFINE (add y) (LAMBDA (x) (+ y x))이며, 이것이 호출되면, 그 결과는 (+ y x)으로 리덕션된다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;haskell&quot;&gt;Haskell​&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Haskell은 순수 함수 언어로 알려져 있다&lt;br /&gt;
연산자는 표시 방식만 다를 뿐 다른 FPL과 거의 같다&lt;/p&gt;

&lt;p&gt;Haskell 역시 앞에서 Scheme에서 본 것과 유사한 let 컨스트럭트를 지원한다&lt;/p&gt;

&lt;p&gt;다른 언어와 다르게 지연 평가를 수행하며, 표현식은 값이 필요할 때에만 평가된다&lt;/p&gt;

&lt;p&gt;이에 비해 이른(eager) 평가에서는 함수가 호출되기 전에 미리 함수에 대한 파라미터를 평가한다&lt;br /&gt;
따라서 엄격한 시맨틱스를 갖는다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;support-fp-in-ipl&quot;&gt;Support FP in IPL&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;자바 스크립트에서는 이름을 가진 함수를 정의할 수 있다&lt;br /&gt;
ex) 함수명 (파라미터 여러개) { 표현식 (블록)}&lt;/p&gt;

&lt;p&gt;여기서 함수명을 빼면 익명의 함수를 정의하게 된다&lt;/p&gt;

&lt;p&gt;파이썬에는 람다 표현식이 가능하다&lt;br /&gt;
즉, lambda a,b: 2*a-b라고 하면, 파라미터 a,b로 이름이 없는 익명의 함수를 정의하는 것이다&lt;br /&gt;
파라미터와 함수 바디를 콜론으로 구분한다&lt;/p&gt;

&lt;p&gt;파이썬에서는 고차 함수 filter와 map를 정의할 수 있다&lt;br /&gt;
이들은 첫째 파라미터로 모두 람다 표현식을 사용하며, 두번째 파라미터로 시퀀스 타입을 사용한다&lt;br /&gt;
두 함수 모두 두번째 파라미터와 동일한 타입의 시퀀스를 결과로 반환한다.&lt;br /&gt;
예를 들어 map(lambda x : x**3, [2, 4, 6, 8]이라고 하면, 반환 결과는 [8, 64, 216, 512]이다.&lt;br /&gt;
이 예에서 첫번째 파라미터는 함수(표현식)임을 기억하라.&lt;/p&gt;

&lt;p&gt;이 map은 2004년 구글의 MapReduce의 map과 같은 의미이며, ​병렬 처리의 한 방법으로 유명해졌다. ​&lt;/p&gt;

&lt;p&gt;파이썬은 파라미터의 개수를 제한하고, ​명시적으로 새로운 함수를 정의하고 적용할 수 있도록 partial 함수를 지원한다.&lt;br /&gt;
먼저 제한적으로 적용하려는 함수를 임포트하고,​ (여기서 add5는 add a b : a + b에서 파라미터를 ​한 개로 줄여서 add + 5로 정의한 것이다.)​ 명령문 add5=partial (add, 5)은 함수 add+5를 add5로 정의하고, ​함수 add5(15)를 적용(호출)하면 결과는 20이다. ​&lt;/p&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="pl" /><summary type="html">FPLs</summary></entry><entry><title type="html">__침입탐지__</title><link href="https://lee989898.github.io/sc-16" rel="alternate" type="text/html" title="__침입탐지__" /><published>2021-11-24T01:06:00+09:00</published><updated>2021-11-24T01:06:00+09:00</updated><id>https://lee989898.github.io/sc-16</id><content type="html" xml:base="https://lee989898.github.io/sc-16">&lt;h3 id=&quot;침입탐지&quot;&gt;&lt;strong&gt;침입탐지&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;IDS(침입탐지 시스템)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;침입탐지시스템​&lt;/li&gt;
  &lt;li&gt;침입행위에 대한 탐지를 수행하고 탐지시 대응할 수 있도록 지원하는 일련의 시스템​&lt;/li&gt;
  &lt;li&gt;Intrusion?​
    &lt;ul&gt;
      &lt;li&gt;시스템에 허가되지 않은 방법으로 내부 자원에 접근​&lt;/li&gt;
      &lt;li&gt;Login 시도 (ID, PWD 추측)​&lt;/li&gt;
      &lt;li&gt;불법적으로 데이터 도용시도 (rootkit)​&lt;/li&gt;
      &lt;li&gt;Root/관리자 권한 획득시도​&lt;/li&gt;
      &lt;li&gt;메일발송 실행파일을 숨겨놓고 메일전송시도​&lt;/li&gt;
      &lt;li&gt;Backdoor 접근시도&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;패킷 필터링
    &lt;ul&gt;
      &lt;li&gt;오직 TCP/IP 헤더만 본다&lt;/li&gt;
      &lt;li&gt;패킷 간의 연관성을 알아 내기 어렵다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;IDS
    &lt;ul&gt;
      &lt;li&gt;depp packet inspection: 패킷 콘테츠 까지 검사한다&lt;/li&gt;
      &lt;li&gt;다수의 패킷을 검사한다
        &lt;ul&gt;
          &lt;li&gt;port scanning&lt;/li&gt;
          &lt;li&gt;network mapping&lt;/li&gt;
          &lt;li&gt;Dos attack&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Dectection 방법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;Signature-based dectection​
    &lt;ul&gt;
      &lt;li&gt;침입사건들을 패턴화(signature)​
    + Signature example​&lt;/li&gt;
      &lt;li&gt;실행 파일 첨부 메일 유형​&lt;/li&gt;
      &lt;li&gt;파일 읽기 시도 유형​&lt;/li&gt;
      &lt;li&gt;로그인 시도 유형​
    + 장점​&lt;/li&gt;
      &lt;li&gt;known attack에 대해 효율적​
    + 단점​&lt;/li&gt;
      &lt;li&gt;Unknown attack에 취약​&lt;/li&gt;
      &lt;li&gt;새로운 공격유형 발견때마다 signature 생성해야​&lt;/li&gt;
      &lt;li&gt;일반적으로 False negative rate 높음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Anomaly-based dectection​
    &lt;ul&gt;
      &lt;li&gt;정상범위를 벗어나는 사건을 탐지​
    + Anomaly example​&lt;/li&gt;
      &lt;li&gt;휴일에 traffic 량이 평소보다 20%증가​&lt;/li&gt;
      &lt;li&gt;일반사용자가 갑자기 1000통 메일발송​&lt;/li&gt;
      &lt;li&gt;특정 호스트에 단시간 주문요청 100%증가​&lt;/li&gt;
      &lt;li&gt;국내 사용자 카드가 해외에서 결재​
    + 장점​&lt;/li&gt;
      &lt;li&gt;Machine learning 처리​&lt;/li&gt;
      &lt;li&gt;Unknown attac에 대해 효율적​
    + 단점​&lt;/li&gt;
      &lt;li&gt;정상범위 정의 어려움​&lt;/li&gt;
      &lt;li&gt;비정상탐지까지 기다려야​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;IDS types&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;Network-based IDS​&lt;/li&gt;
  &lt;li&gt;Wireless IDS (wireless IDS)​&lt;/li&gt;
  &lt;li&gt;Host-based IDS​&lt;/li&gt;
  &lt;li&gt;Distributed Host-based IDS&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Network-based IDS​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Example​
    &lt;ul&gt;
      &lt;li&gt;Network 망에 곳곳에 traffic을 모니터, 분석하여 침입탐지​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Example​
    &lt;ul&gt;
      &lt;li&gt;Ddos, worm  ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점 ​
    &lt;ul&gt;
      &lt;li&gt;Host는 부하적음 (하나의  NIDS로 여러 host보호)​&lt;/li&gt;
      &lt;li&gt;조기 탐지가능​&lt;/li&gt;
      &lt;li&gt;취약한 부분의 packet 을 정밀분석하여 다양한 침입탐지 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;각 host 내부는 탐지제한​&lt;/li&gt;
      &lt;li&gt;전체 network 망에 부하&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Wireless IDS (wireless IDS)​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무선통신 WLAN network망의 traffic 분석​&lt;/li&gt;
  &lt;li&gt;장점​
    &lt;ul&gt;
      &lt;li&gt;무선통신의 취약성위협 탐지​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;Network 부하, 비용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Host-based IDS​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;특정 host 컴퓨터내부를 모니터링, 분석하여 탐지​&lt;/li&gt;
  &lt;li&gt;Example​
    &lt;ul&gt;
      &lt;li&gt;로그분석, 파일시스템 기록분석, 실행코드분석 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점​
    &lt;ul&gt;
      &lt;li&gt;악성sw 탐지용이​&lt;/li&gt;
      &lt;li&gt;내부공격자 탐지​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;각 host마다 다름​&lt;/li&gt;
      &lt;li&gt;Host 부하&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Distributed Host-based IDS&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;여러 HIDS들이 연계하여 전체적으로 host들을 분석하여 탐지 ​&lt;/li&gt;
  &lt;li&gt;장점​
    &lt;ul&gt;
      &lt;li&gt;효율적이고 정확성​&lt;/li&gt;
      &lt;li&gt;공격들의 연관관계 파악용이​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;HIDS보다 복잡, 부담&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Honey Pot&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;꿀단지​&lt;/li&gt;
  &lt;li&gt;의도적으로 해커의 침입을 유도하는 시스템​&lt;/li&gt;
  &lt;li&gt;해커 정보수집, 공격유형파악, 대응전략수립, 법적증거 ​&lt;/li&gt;
  &lt;li&gt;침입자 활동감시, 로그기록&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;IDS 평가 기준&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;False Positive rate​
    &lt;ul&gt;
      &lt;li&gt;정상을 침입으로 판단하는 확률​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;False Negative​
    &lt;ul&gt;
      &lt;li&gt;침입을 정상으로 판단하는 확률​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;True Positive rate​&lt;/li&gt;
  &lt;li&gt;True Negative rate​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;IPS (Intrusion Prevention System)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;침입방지시스템​&lt;/li&gt;
  &lt;li&gt;IDS+침입방지기능​&lt;/li&gt;
  &lt;li&gt;Example​
    &lt;ul&gt;
      &lt;li&gt;IDS로 침입탐지하고 계정, 연결 등 차단​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="security" /><summary type="html">침입탐지</summary></entry><entry><title type="html">POSIX Thread Programming</title><link href="https://lee989898.github.io/st-10" rel="alternate" type="text/html" title="POSIX Thread Programming" /><published>2021-11-24T01:06:00+09:00</published><updated>2021-11-24T01:06:00+09:00</updated><id>https://lee989898.github.io/st-10</id><content type="html" xml:base="https://lee989898.github.io/st-10">&lt;h3 id=&quot;posix-thread-programming&quot;&gt;&lt;strong&gt;POSIX Thread Programming&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;thread-overview-&quot;&gt;Thread Overview ​&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스처럼 독립적으로 수행되는 프로그램 코드​
    &lt;ul&gt;
      &lt;li&gt;“경량 프로세스(light-weight process)”라고도 함​&lt;/li&gt;
      &lt;li&gt;“프로세스 내에서 독립적으로, 순차적으로 수행되는 instruction stream 또는 제어의 흐름”이라고도 함​&lt;/li&gt;
      &lt;li&gt;여러 스레드는 동시에 실행이 가능​&lt;/li&gt;
      &lt;li&gt;스레드들의 실행에 관한 스케쥴링은 OS가 담당​&lt;/li&gt;
      &lt;li&gt;싱글 코어에서도 여러 스레드의 실행이 가능 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;한 프로세스내의 스레드들은 같은 주소 공간을 사용 ​
    &lt;ul&gt;
      &lt;li&gt;공유 매모리를 이용하여 스레드간의 통신을 이용함으로써 복잡한 프로세스간 통신(IPC) 기능을 사용하지 않아도 됨​&lt;/li&gt;
      &lt;li&gt;스레드간의 통신 비용이 IPC 비용보다 낮음​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st25.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Process는 실행을 위하여 resource들이 필요하며 실행 상태를 메모리에 저장 ​
    &lt;ul&gt;
      &lt;li&gt;Process ID, group ID, … ​&lt;/li&gt;
      &lt;li&gt;Program instructions​&lt;/li&gt;
      &lt;li&gt;Registers, Stack​&lt;/li&gt;
      &lt;li&gt;Heap ​&lt;/li&gt;
      &lt;li&gt;File descriptor, …​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Thread는 Process 내부에 존재하면서 resource들을 같이 사용 ​
    &lt;ul&gt;
      &lt;li&gt;Registers, stack, 등은 thread 별로 따로 존재  ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st26.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;공통 스레드 구현​
    &lt;ul&gt;
      &lt;li&gt;병렬 소스 코드 내에서 호출되는 서브루틴 라이브러리&lt;/li&gt;
      &lt;li&gt;직렬 또는 병렬 소스 코드에 포함된 컴파일러 지시문 세트&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스레드 구현은 컴퓨팅에서 새로운 것이 아니다
    &lt;ul&gt;
      &lt;li&gt;역사적으로 하드웨어 공급업체는 고유한 스레드 버전을 구현했다&lt;/li&gt;
      &lt;li&gt;이러한 구현은 서로 상당히 다르다&lt;/li&gt;
      &lt;li&gt;프로그래머가 휴대용 스레드 응용 프로그램을 개발하기 어려움​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;관련 없는 표준화 노력으로 인해 두 개의 매우 다른 스레드 구현이 발생했다
    &lt;ul&gt;
      &lt;li&gt;POSIX Threads (Pthread)​&lt;/li&gt;
      &lt;li&gt;OpenMP​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;pthread-introduction-&quot;&gt;Pthread Introduction ​&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;IEEE POSIX (Portable Operating System Interface for UNIX) 1003.1c Standard​
    &lt;ul&gt;
      &lt;li&gt;과거에 하드웨어 업체별로 각각 제작되어 사용되었던 스레드에 관한 구현을 표준화 ​&lt;/li&gt;
      &lt;li&gt;이 표준에 따라 구현된 스레드를 POSIX Thread 또는 Pthread로 부름​
        &lt;ul&gt;
          &lt;li&gt;스레드를 생성하고 동기화하는 system call 들로 구성​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;표준화는 계속 진행 중​
        &lt;ul&gt;
          &lt;li&gt;가장 최근의  표준은 IEEE Std 1003.1, 2004 Edition​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;C-프로그래밍 언어의 type과 procedure call의 집합으로 정의 ​
    &lt;ul&gt;
      &lt;li&gt;
        &lt;pthread.h&gt; header 파일 및 thread library로 구현​
&lt;/pthread.h&gt;
        &lt;ul&gt;
          &lt;li&gt;libc library의 일부로 구현되기도 함​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;우수한 성능 : 프로세스와 비교​
    &lt;ul&gt;
      &lt;li&gt;스레드 생성에 드는 OS overhead가 프로세스 생성에 비해 현격히 낮음​
        &lt;ul&gt;
          &lt;li&gt;50,000번의 프로세스 생성(fork() 사용) vs. 스레드 생성(pthread_create() 사용) ​&lt;/li&gt;
          &lt;li&gt;실행 시간의 단위는 second, time 커맨드에 의해 측정​&lt;/li&gt;
          &lt;li&gt;스레드 관리에 드는 resource도 프로세스에 비해 현격히 적음​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pthread에서는 ​
    &lt;ul&gt;
      &lt;li&gt;Parallelism 생성​&lt;/li&gt;
      &lt;li&gt;동기화(synchronization)​을 지원함​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Communication에 대한 explicit한 지원은 없음​
    &lt;ul&gt;
      &lt;li&gt;Shared-memory 모델이므로 communication은 implicit하게 일어남​
​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스레드의 상태​
    &lt;ul&gt;
      &lt;li&gt;준비(ready) : 스레드가 실행될 수 있는 상태​&lt;/li&gt;
      &lt;li&gt;실행(running) : CPU의 서비스를 받고 있는 상태​&lt;/li&gt;
      &lt;li&gt;블록(block) : sleep(), read(), 세마포어 연산 등으로 기다리는 상태​&lt;/li&gt;
      &lt;li&gt;종료(terminated) : 스레드가 종료 또는 취소된 상태​
​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;준비 상태​
    &lt;ul&gt;
      &lt;li&gt;스레드가 처음 생성되면 준비 상태로 감​&lt;/li&gt;
      &lt;li&gt;CPU의 서비스를 받을 수 있는 상태​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실행 상태​
    &lt;ul&gt;
      &lt;li&gt;OS의 스케줄러에 의해 CPU의 서비스를 받고 있는 상태​&lt;/li&gt;
      &lt;li&gt;스케줄링에 의해 준비상태로 갈 수 있음​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;블록 상태​
    &lt;ul&gt;
      &lt;li&gt;실행 상태에서 즉시 처리할 수 없는 작업을 만나는 경우​
        &lt;ul&gt;
          &lt;li&gt;read(), wait(), sleep(), 세마포어/뮤텍스/조건변수를 기다리는 경우​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;원하는 조건이 만족되면 준비 상태가 됨​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;종료 상태​
    &lt;ul&gt;
      &lt;li&gt;스레드 시작함수에서 return 또는 pthread_exit()가 호출된 경우​&lt;/li&gt;
      &lt;li&gt;사용하던 자원의 대부분을 시스템에 반납​&lt;/li&gt;
      &lt;li&gt;종료 상태 값을 부모 스레드에게 넘겨주기 위한 자원은 부모 스레드에서 pthread_join()을 통해 읽어가면 완전히 삭제​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Application 프로그램은 하나의 스레드로 시작​
    &lt;ul&gt;
      &lt;li&gt;Main 스레드 또는 master 스레드로 불림 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;pthread_create() 호출에 의해 새로운 child 스레드를 생성​
    &lt;ul&gt;
      &lt;li&gt;새로운 child 스레드의 생성은 procedure 호출의 형태를 띔​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;pthread_exit() 또는 pthread_join() 호출에 의해 새로 생성되었던 스레드 종료​
    &lt;ul&gt;
      &lt;li&gt;Master 스레드만 남게 됨​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st27.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;스레드 생성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int pthread_create (​
  pthread_t   *thread, // 생성된 스레드의 핸들 ​
  pthread_attr_t   *attr, // 스레드 속성을 지정하는 인자​
  void   *(*start_routine) (void *), // 스레드 시작함수(start routine) 주소​
  void   *arg ) // 스레드 시작 함수의 인자(들)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;thread : 새로운 child 스레드가 성공적으로 생성될 경우 생성된 스레드의 핸들​&lt;/li&gt;
  &lt;li&gt;attr : 생성되는 child 스레드의 속성을 지정(디폴트 값은 NULL)​&lt;/li&gt;
  &lt;li&gt;start_routine : 새로 생성되는 child 스레드를 지정하는 함수의 시작 주소​&lt;/li&gt;
  &lt;li&gt;arg : 시작 함수들의 인자(들)​&lt;/li&gt;
  &lt;li&gt;리턴 값 ​
    &lt;ul&gt;
      &lt;li&gt;성공시 0을 리턴​&lt;/li&gt;
      &lt;li&gt;에러 발생시 에러코드의 정수 값(errno)을 리턴​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Pthread 프로그램 컴파일&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;일반적으로 –lpthread 옵션이 필요​
    &lt;ul&gt;
      &lt;li&gt;스레드 라이브러리가 다른 라이브러리(예 : libc)에 통합된 경우는 불필요 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;-D_REENTRANT 옵션​
    &lt;ul&gt;
      &lt;li&gt;멀티 스레드 환경에서 싱글 스레드의 경우와 구별된 errno를 사용하도록 함​&lt;/li&gt;
      &lt;li&gt;일반 함수들이 멀티 스레드 환경에 적합하게 동작하도록 함​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컴파일 예제​
    &lt;ul&gt;
      &lt;li&gt;Linux/GCC의 경우​
        &lt;ul&gt;
          &lt;li&gt;% gcc test.c –lpthread (-lpthread 옵션에 –D_REENTRANT 포함)​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Solaris/Studio 컴파일러의 경우​
        &lt;ul&gt;
          &lt;li&gt;% cc –mt test.c (-mt 옵션에 –D_REENTRANT 포함, 스레드 라이브러리는 libc 라이브러리에 포함됨) ​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;스레드 종료&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void  pthread_exit(void   *retval);​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;생성된 child 스레드의 종료​
    &lt;ul&gt;
      &lt;li&gt;프로세스와 마찬가지로 return을 만나면 종료​&lt;/li&gt;
      &lt;li&gt;또는 pthread_exit() 호출시 종료​&lt;/li&gt;
      &lt;li&gt;pthread_exit() 호출에 의해 child 스레드가 종료할 경우 할당되었던 자원들은 반납되지 않음​&lt;/li&gt;
      &lt;li&gt;나중에 pthread_join() 호출에 의해 반납됨 ​&lt;/li&gt;
      &lt;li&gt;Detach 된 스레드는 예외  ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int  pthread_join(pthread_t   thrd,   void   **thread_return);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Parent 스레드에서 호출​
    &lt;ul&gt;
      &lt;li&gt;자신이 생성한 child 스레드가 종료할 때까지 기다림​
        &lt;ul&gt;
          &lt;li&gt;thrd​
            &lt;ul&gt;
              &lt;li&gt;종료를 기다릴 스레드의 핸들​&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;thread_return​
            &lt;ul&gt;
              &lt;li&gt;child 스레드의 종료 상태가 저장됨​&lt;/li&gt;
              &lt;li&gt;NULL로 하면 종료 상태를 받지 않음​&lt;/li&gt;
              &lt;li&gt;child 스레드의 종료값은 return, pthread_exit()로 남길 수 있음​&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Child 스레드가 종료되기 전에 parent 스레드가 먼저 종료되지 않게 할 때 사용​
    &lt;ul&gt;
      &lt;li&gt;Parent 스레드가 종료하면 child 스레드가 함께 종료되며​&lt;/li&gt;
      &lt;li&gt;Child 스레드의 작업이 모두 이루어 지지 않은 상태일 수 있음​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Child 스레드의 종료 시점을 정확히 파악하여 어떤 작업을 하고 싶거나 종료 상태 값을 얻기 위해 사용​&lt;/li&gt;
  &lt;li&gt;종료된 child 스레드에 할당되었던 resource 들은 반납됨 ​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;스레드 Detach&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int   pthread_detach(pthread_t   thrd);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Detached 스레드​
    &lt;ul&gt;
      &lt;li&gt;Join이 가능한 스레드(pthread_join()을 사용)와 대비​&lt;/li&gt;
      &lt;li&gt;Parent 스레드가 생성한 child 스레드에 대해 pthread_detach()를 호출하면 parent 스레드가 나중에 wait하지 않음​
        &lt;ul&gt;
          &lt;li&gt;빠른 스레드의 실행에 도움이 됨​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Detach 된 스레드에 pthread_join()를 호출하면 error 발생​&lt;/li&gt;
      &lt;li&gt;Detach 된 스레드는 pthread_join() 호출 없이 할당되었던 resources 들이 반납됨 
​
        &lt;blockquote&gt;
          &lt;p&gt;스레드 Attribute&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스레드의 attribute는 스레드가 생성될 때 설정됨
    &lt;ul&gt;
      &lt;li&gt;이미 생성된 스레드의 attribute 값을 바꾸는 것은 제한적인 경우에만 가능 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;따라서 pthread_create를 호출하기 전에 원하는 attribute 값들을 설정해야 ​&lt;/li&gt;
  &lt;li&gt;Attribute 설정과 관련된 pthread API
    &lt;ul&gt;
      &lt;li&gt;pthread_attr_init()​&lt;/li&gt;
      &lt;li&gt;pthread_attr_destroy()​&lt;/li&gt;
      &lt;li&gt;pthread_attr_setdetachstate()​&lt;/li&gt;
      &lt;li&gt;pthread_attr_getstacksize()​&lt;/li&gt;
      &lt;li&gt;pthread_attr_setstacksize()​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스레드는 joinable 또는 detached 스레드로 생성 가능​&lt;/li&gt;
  &lt;li&gt;Default stack size는 OS 마다 다른 값을 지정​&lt;/li&gt;
  &lt;li&gt;최소 스택 크기는 변수 PTHREAD_STACK_MIN에 저장된다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;기타 스레드 Attribute들&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Guard size: 스택 오버플로로부터 보호하기 위해 사용&lt;/li&gt;
  &lt;li&gt;스케줄링 속성 상속(스레드 생성에서) or not&lt;/li&gt;
  &lt;li&gt;Scheduling parameter(s): 특히 스레드 우선순위&lt;/li&gt;
  &lt;li&gt;Scheduling policy: FIFO or Round Robin​&lt;/li&gt;
  &lt;li&gt;Contention scope: 이 스레드는 어떤 스레드와 CPU를 놓고 경쟁하는가&lt;/li&gt;
  &lt;li&gt;Stack address: 스택의 위치를 ​​명시적으로 지정&lt;/li&gt;
  &lt;li&gt;Lazy stack allocation: 요청 시 할당(lazy) 또는 한 번에 모두 선행&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;synchronization&quot;&gt;Synchronization​&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;스레드의 동기화 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;여러 스레드가 공유 데이터에 접근하여 값들을 읽거나 저장
    &lt;ul&gt;
      &lt;li&gt;Run time 에 공유 데이터가 어떤 값을 가질지 예측하기 어려움​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Data race 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;두 개 이상의 스레드가 같은 변수를 access, 그 중 적어도 하나의 access는 write 연산을 실행​&lt;/li&gt;
  &lt;li&gt;Access들이 동시에 발생, 그러나 동기화되지 않은 상태로&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;기본적인 동기화 Mechanism: Mutex&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;스레드들이 서로 배타적으로 공유데이터에 접근하도록 하기위해 Mutex (mutual exclusion)를 사용​
    &lt;ul&gt;
      &lt;li&gt;스레드들은 거의 독립적으로 실행​&lt;/li&gt;
      &lt;li&gt;Common한 data structure를 사용함​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Mutex외에도 세마포어를 많이 사용​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Mutex 사용방법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Critical 영역에 들어가기 전에 mutex 를 잠금​&lt;/li&gt;
  &lt;li&gt;Critical 영역에서 나오면서 mutex 잠금을 해제​&lt;/li&gt;
  &lt;li&gt;다른 스레드들은 이 mutex 잠금이 해제될 때까지 대기​&lt;/li&gt;
  &lt;li&gt;Mutex 사용 절차&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pthread_mutex_t mutex; // 뮤텍스 선언​
Pthread_mutex_init(&amp;amp;mutex); // 뮤텍스 초기화 작업​
pthread_mutex_lock(mutex); // 뮤텍스 잠금​
... // 공유데이터(크리티컬 영역) 액세스​
pthread_mutex_unlock(mutex); // 뮤텍스 잠금 해제​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Mutex 선언 및 초기화&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Mutex의 변수 타입 : pthread_mutex_t​&lt;/li&gt;
  &lt;li&gt;여러 스레드들이 사용하므로 전역 변수로 선언​&lt;/li&gt;
  &lt;li&gt;반드시 초기화를 해야 사용 가능​&lt;/li&gt;
  &lt;li&gt;초기화 방법​
    &lt;ul&gt;
      &lt;li&gt;함수를 통한 초기화​&lt;/li&gt;
      &lt;li&gt;매크로를 통한 초기화​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Mutex 초기화에 특별한 타입을 지정하지 않음 ​&lt;/li&gt;
  &lt;li&gt;단 한 번의 잠금만 허용​
    &lt;ul&gt;
      &lt;li&gt;스레드 A가 잠금을 하고 있는 상황에서 스레드 B가 잠금을 시도하면 B는 A의 잠금이 해제될 때까지 기다림​&lt;/li&gt;
      &lt;li&gt;A에 의해 잠긴 뮤텍스에 대해 A가 다시 잠금을 시도하면 deadlock이 발생하여 A는 영원히 블록 상태가 됨​&lt;/li&gt;
      &lt;li&gt;이러한 현상을 피하기 위해 pthread_mutex_trylock()을 사용​&lt;/li&gt;
      &lt;li&gt;Mutex를 얻지 못하는 경우 블록되지 않고 바로 리턴되고 EBUSY 에러 발생​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;잠금되어 있는 않은 mutex에 잠금해제를 시도하면 아무 동작을 하지 않음​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Mutex의 삭제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;더 이상 mutex를 사용하지 않을 때 삭제​&lt;/li&gt;
  &lt;li&gt;잠금 상태의 mutex를 삭제하려 시도하면 에러 발생​
    &lt;ul&gt;
      &lt;li&gt;EBUSY 에러 발생​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Mutex의 현재 상태(잠금, 잠금해제) 확인 함수는 없음​&lt;/li&gt;
  &lt;li&gt;안전하게 mutex를 삭제하기 위해서는 삭제 전에 무조건 mutex를 해제해야 함​&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pthread_mutex_unlock(&amp;amp;mutex);​
pthread_mutex_destory(&amp;amp;mutex);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Mutex와 deadlock&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Deadlock​
    &lt;ul&gt;
      &lt;li&gt;두 개의 스레드가 두 개의 mutex를 사용​&lt;/li&gt;
      &lt;li&gt;각 스레드가 mutex를 하나씩 잠그고 있는 상태에서 상대방의 mutex 해제를 기다리는 현상​&lt;/li&gt;
      &lt;li&gt;deadlock이 발생하면 프로그램은 영원히 블록​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Deadlock을 피하는 방법​
    &lt;ul&gt;
      &lt;li&gt;Mutex를 잠그는데 일정한 순서를 정하여 사용​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;성능​
    &lt;ul&gt;
      &lt;li&gt;Mutex를 많이 사용하면 프로그램의 성능이 저하됨​&lt;/li&gt;
      &lt;li&gt;Mutex를 얻은 상태에서 처리하는 작업의 양(Critical Section)을 최소화 해야 함​
        &lt;ul&gt;
          &lt;li&gt;Mutex가 잠긴 동안 다른 스레드가 블록될 가능성이 높으며 Critical Section이 길수록 전체 프로그램 성능이 저하될 수 있음​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;다른 data structure에 대해서는 다른 lock을 적용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Spin Lock​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Mutex lock 과 달리, lock을 얻을때까지 CPU cycle을 소비하면서 계속 spinning 함​
    &lt;ul&gt;
      &lt;li&gt;Mutex lock : lock을 얻지 못하면 바로 sleep 모드로 들어감 ​&lt;/li&gt;
      &lt;li&gt;Adaptive mutex lock : 잠깐 동안 spinning 하다가 sleep 모드로 들어감 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Spin lock APIs​
    &lt;ul&gt;
      &lt;li&gt;pthread_spin_init() ​
        &lt;ul&gt;
          &lt;li&gt;PTHREAD_PROCESS_PRIVATE : 생성되는 spin lock이 프로세스에 private 하게 사용될 경우 ​&lt;/li&gt;
          &lt;li&gt;PTHREAD_PROCESS_SHARED : 다른 프로세스와 공유할 경우​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;pthread_spin_lock()​&lt;/li&gt;
      &lt;li&gt;pthread_spin_unlock()​&lt;/li&gt;
      &lt;li&gt;pthread_spin_destroy()​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;pthread_spin_trylock() ​
    &lt;ul&gt;
      &lt;li&gt;Lock을 얻으려 시도​&lt;/li&gt;
      &lt;li&gt;Lock을 얻는 경우나 얻지 못하는 경우 모두 바로 리턴&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Barrier&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Barrier: 글로벌 동기화
    &lt;ul&gt;
      &lt;li&gt;특히 SPMD(동일한 기능의 여러 복사본을 병렬로 실행할 때)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Simple use of barriers: all threads hit the same one​
    &lt;ul&gt;
      &lt;li&gt;work_on_my_subgrid();​&lt;/li&gt;
      &lt;li&gt;barrier;​&lt;/li&gt;
      &lt;li&gt;read_neighboring_values();​&lt;/li&gt;
      &lt;li&gt;barrier;​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;more complicated: barriers on branches (or loops)​
    &lt;ul&gt;
      &lt;li&gt;if (thread_id % 2 == 0) {​&lt;/li&gt;
      &lt;li&gt;work1();​&lt;/li&gt;
      &lt;li&gt;barrier; } ​&lt;/li&gt;
      &lt;li&gt;else ​&lt;/li&gt;
      &lt;li&gt;barrier;​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 스레드 라이브러리에 Barrier가 제공되지 않는다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Barrier APIs​
    &lt;ul&gt;
      &lt;li&gt;pthread_barrier_init(&amp;amp;barrier, attr, no_of_threads) ​
        &lt;ul&gt;
          &lt;li&gt;pthread_barrier_t  barrier;​&lt;/li&gt;
          &lt;li&gt;Default value of attr is “NULL”​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;pthread_barrier_destroy(&amp;amp;barrier)​&lt;/li&gt;
      &lt;li&gt;pthread_barrier_wait(&amp;amp;barrier)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;semaphore--conditional-variable&quot;&gt;Semaphore &amp;amp; Conditional Variable​&lt;/h2&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="system" /><summary type="html">POSIX Thread Programming</summary></entry><entry><title type="html">__방화벽__</title><link href="https://lee989898.github.io/sc-17" rel="alternate" type="text/html" title="__방화벽__" /><published>2021-11-24T01:06:00+09:00</published><updated>2021-11-24T01:06:00+09:00</updated><id>https://lee989898.github.io/sc-17</id><content type="html" xml:base="https://lee989898.github.io/sc-17">&lt;h3 id=&quot;방화벽&quot;&gt;&lt;strong&gt;방화벽&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Firewalls?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;조직의 내부망을 외부 인터넷과 격리시켜 일부 패킷은 통과시키고 나머지는 차단하는 HW와 SW의 조합&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc24.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Firewall 서비스&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Traffic monitoring​&lt;/li&gt;
  &lt;li&gt;Traffic control​&lt;/li&gt;
  &lt;li&gt;NAT – 내부 network 보호​&lt;/li&gt;
  &lt;li&gt;VPN – 내부 traffic 노출차단&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Firewalls을 쓰는 이유&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;서비스 거부 공격 방지:
    &lt;ul&gt;
      &lt;li&gt;SYN 플러딩: 공격자가 많은 가짜 TCP 연결을 설정하고 “실제” 연결을 위한 리소스가 남지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;내부 데이터의 불법적인 수정/접근을 방지한다
    &lt;ul&gt;
      &lt;li&gt;예: 공격자가 CIA의 홈페이지를 다른 것으로 교체&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;내부 네트워크(인증된 사용자/호스트 집합)에 대한 승인된 액세스만 허용&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Firewall types&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;Stateless packet filter​&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;지나는 packet에 대해 미리 정의된 규칙에 따라 pass/block 결정​&lt;/li&gt;
  &lt;li&gt;Packet의 다음 정보를 기반으로 결정​
    &lt;ul&gt;
      &lt;li&gt;source IP address, destination IP address​&lt;/li&gt;
      &lt;li&gt;TCP/UDP source and destination port numbers​&lt;/li&gt;
      &lt;li&gt;ICMP message type​&lt;/li&gt;
      &lt;li&gt;TCP SYN and ACK bits​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;example 1: block incoming and outgoing BitTorrent traffic source or dest port = 6881-6889​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;example 2: Block outbound Web access, port=80.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ACL: 규칙이 있는 테이블, 들어오는 패킷에 위에서 아래로 적용: (액션, 조건) pair&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;장점​
    &lt;ul&gt;
      &lt;li&gt;Simple : 동작방식이 직관적이며 간단, 구현용이​&lt;/li&gt;
      &lt;li&gt;Fast​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;application layer protocol의 취약점공격에 차단 불가능​&lt;/li&gt;
      &lt;li&gt;사용자/application 별 서비스 제공불가능 ​&lt;/li&gt;
      &lt;li&gt;필터링시 사용 정보가 제한되어서 정교한 필터링 불가능​&lt;/li&gt;
      &lt;li&gt;IP주소 위변조 여부 판단 불가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Statefull packet filter​&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;동일한 상태정보를 가지는 패킷들을(packet flow) 그룹으로 필터링​
    &lt;ul&gt;
      &lt;li&gt;상태정보: src IP/port, dst IP/port ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점​
    &lt;ul&gt;
      &lt;li&gt;정교한 필터링​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;상태정보 테이블 검사수행에 따른 성능저하​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Application gateway&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;애플리케이션 데이터 및 IP/TCP/UDP 필드에서 패킷을 필터링한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;장점​
    &lt;ul&gt;
      &lt;li&gt;Application layer protocol 공격 차단​&lt;/li&gt;
      &lt;li&gt;사용자 인증가능​&lt;/li&gt;
      &lt;li&gt;정교한 Log, audit 가능​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;응용 프로그램마다 다른 응용 프로그램 게이트웨이가 필요하다(텔넷, http, ftp, 이메일 …)&lt;/li&gt;
      &lt;li&gt;모든 데이터가 게이트웨이를 통과하기 때문에 성능이 저하됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;방화벽 및 게이트웨이의 한계&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;IP spoofing: 라우터는 데이터가 “실제로” 청구된 소스에서 오는지 알 수 없다&lt;/li&gt;
  &lt;li&gt;여러 앱의 경우. 특별한 대우가 필요하며 각각의 앱이 있다&lt;/li&gt;
  &lt;li&gt;클라이언트 소프트웨어는 게이트웨이에 접속하는 방법을 알아야 한다.
    &lt;ul&gt;
      &lt;li&gt;예를 들어, 웹 브라우저에서 프록시의 IP 주소를 설정해야 한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;내부 공격자 방어에 취약​&lt;/li&gt;
  &lt;li&gt;데이터 내용은 미확인 – 문서 등 내부에 심겨진 악성코드 방어 취약&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="security" /><summary type="html">방화벽</summary></entry><entry><title type="html">분기 한정</title><link href="https://lee989898.github.io/algorithm-08" rel="alternate" type="text/html" title="분기 한정" /><published>2021-11-22T01:09:00+09:00</published><updated>2021-11-22T01:09:00+09:00</updated><id>https://lee989898.github.io/algorithm-08</id><content type="html" xml:base="https://lee989898.github.io/algorithm-08">&lt;h3 id=&quot;분기-한정&quot;&gt;&lt;strong&gt;분기 한정&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;분기 한정&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;안내 표지판과 같은 지표를 활용하여 최종 해를 찾는 기법&lt;/li&gt;
  &lt;li&gt;상태 공간 트리 이용&lt;/li&gt;
  &lt;li&gt;최적화 문제에만 적용 가능&lt;/li&gt;
  &lt;li&gt;최적 해를 구하기 위해 모든 해를 다 고려해야 하므로 트리의 노드를 순회하는 방법과 무관&lt;/li&gt;
  &lt;li&gt;하지만 최적의 해에 더 빨리 도달하기 위해 가장 좋은 한계값을 가진 노드를 먼저 탐색하는 최선 우선 탐색 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;분기 한정의 핵심 원리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;상태 공간 트리의 각 노드를 탐색할 때마다, 그 노드가 유망한 지를 알기 위해 한계값(그 노드로부터 확장하여 얻을 수 있는 실현    가능한 해의 한계)을 계산한다.&lt;/li&gt;
  &lt;li&gt;만약 그 한계값이 그 때까지 찾은 최고 해의 값보다 더 좋으면 그 노드는 유망하다고 판단하고 확장을 하면서 탐색을 계속한다. 그렇지 않으면 그 노드는 유망하지 않다고 판단하고 탐색을 멈춘다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;노드에서 탐색 중단 이유&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;노드의 한계값이 그 때까지 찾은 최고 해의 값보다 못하다&lt;/li&gt;
  &lt;li&gt;노드는 문제의 제약 사항들을 만족시키지 못하므로 실현 가능한 해가 될 수 없다&lt;/li&gt;
  &lt;li&gt;노드가 나타내는 실형 가능한 해들의 부분 집합이 더 이상의 추가 선택들을 할 수 없는 경우에 해당한다
    &lt;ul&gt;
      &lt;li&gt;세 번째 경우에 실현 가능한 해에 대한 목적 함수의​ 값이 그때까지 찾은 최고 해의 값보다 더 좋다면 ​최고 해의 값을 목적 함수의 값으로 갱신한다.​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;최선 우선 탐색&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;최적의 해에 더 빨리 도달하기 위한 전략&lt;/li&gt;
  &lt;li&gt;너비 우선 탐색 사용&lt;/li&gt;
  &lt;li&gt;한 유망한 노드의 모든 자식 노드들을 만든 후 남아 있는 유망하나 확장되지 않은 노드들 중에서 최고의 한계값을 가진 노드를먼저 확장&lt;/li&gt;
  &lt;li&gt;최고의 한계값을 가진 노드를 우선적으로 선택하기 위해서 우선 순위 대기열 사용&lt;/li&gt;
  &lt;li&gt;우선 순위 대기열은 힙을 사용하여 효과적으로 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;너비 우선 탐색&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;트리의 노드들을 다음과 같은 순서로 탐색&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;트리의 루트 노드를 먼저 탐색&lt;/li&gt;
  &lt;li&gt;다음으로 트리의 수준 1에 있는 모든 노드를 왼쪽에서 오른쪽으로 탐색&lt;/li&gt;
  &lt;li&gt;다음으로 수준 2에 있는 모든 노드들을 왼쪽에서 오른쪽으로 탐색&lt;/li&gt;
  &lt;li&gt;마지막 수준까지 이 과정을 반복&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;최선 우선 탐색 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;v,u : 트리의 노드&lt;/li&gt;
  &lt;li&gt;value(v): 노드 v에 대응되는 실현 가능한 해의 값&lt;/li&gt;
  &lt;li&gt;bound(v): 노드 v의 한계값&lt;/li&gt;
  &lt;li&gt;best: 현재까지 찾은 최고 해&lt;/li&gt;
  &lt;li&gt;PQ: 상태 공간 트리를 대신하는 우선 순위 대기열
    &lt;ul&gt;
      &lt;li&gt;PQ는 유망하나 확장되지 않은 노드들 포함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Best-First-Branch-and-Bound(state-space-tree T)​
// 입력: T – 상태 공간 트리​
// 출력: 최적 해의 값​
1  initialize(PQ) // PQ를 빈 대기열로 초기화​
2  v = T의 루트 노드​
3  best = value(v)​
4  insert(PQ, v)           // 노드 v를 PQ에 삽입​
5  while (not empty(PQ)) { // PQ에 노드들이 남아 있는지 확인​
6    v = remove(PQ) // PQ에서 최고 한계값을 가진 노드를 제거​
7    if (bound(v) &amp;gt; best) // 노드 v가 유망한지 확인​
8       for (each child u of v) {​
9           if (value(u) &amp;gt; best) best = value(u)​
10          if (bound(u) &amp;gt; best) insert(PQ, u)  }  }​
11  return best​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;배낭 채우기 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;N(&amp;gt;=1)개의 물건들 중에서 배낭의 용량 C를 초과하지 않고 배낭에 넣을 수 있는 물건들의 최대 가치를 구하라&lt;/li&gt;
  &lt;li&gt;각 물건은 배낭에 넣거나 넣지 않을 수 있더&lt;/li&gt;
  &lt;li&gt;$w_i$: 물건 i, 1&amp;lt;=i&amp;lt;=N,의 무게&lt;/li&gt;
  &lt;li&gt;$v_i$: 물건 i, 1&amp;lt;=i&amp;lt;=N, 의 가치&lt;/li&gt;
  &lt;li&gt;가정: 물건들이 단위 무게당 가치($v_i$ / $w_i$)의 내림차순으로 정렬되어 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;배낭 채우기 상태 공간 트리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;루트 노드: 배낭에 물건들을 넣기 전의 초기 상태&lt;/li&gt;
  &lt;li&gt;트리의 수준 i, 1&amp;lt;=i&amp;lt;=N, 에 있는 각 노드는 첫 번째 물건부터 i번째까지의 물건들 중에서 배낭에 포함된 물건들의 특정 선택을 나타낸다. 이 특정 선택은 루트 노드부터 그 노드까지의 경로에 의해 유일무이하게 결정된다&lt;/li&gt;
  &lt;li&gt;한 노드의 왼쪽에 있는 자식 노드는 다음 물건을 배낭에 넣는 경우를 나타내고 오른쪽에 있는 자식 노드는 다음 물건을 배낭에 넣지 않는 경우를 나타낸다. 이 선택의 총 무게 w와 총 가치 v를 해당 노드에 한계값과 같이 저장한다. 그 노드의 한계값은 이 선택 후 남은 물건들 중 일부를 포함시킴으로써 얻을 수 있는 배낭의 물건들의 가치에 대한 상한을 나타낸다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;노드의 한계값 계산 방법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;배낭에 이미 포함된 물건들의 총 가치 v에 배낭의 남은 용량(C - w)를 전부 다음 물건으로만 채운 경우의 가치를 더한다(w는 배낭에 이미 포함된 물건들의 총 무게). 즉, 트리의 수준 i, 0 &amp;lt;= i &amp;lt; N, 에 있는 노드의 한계값은 다음과 같이 계산된다&lt;/li&gt;
  &lt;li&gt;한계값 &amp;gt;= 실현 가능한 해의 값&lt;/li&gt;
  &lt;li&gt;트리의 수준 n에 있는 노드의 한계값 = v&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;최선 우선 탐색 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;상태 공간 트리의 각 노드에 다음 값들을 저장한다.​
    &lt;ul&gt;
      &lt;li&gt;level: 트리에서 노드의 수준​&lt;/li&gt;
      &lt;li&gt;weight: 이미 선택된 물건들의 총 무게​&lt;/li&gt;
      &lt;li&gt;value: 이미 선택된 물건들의 총 가치​&lt;/li&gt;
      &lt;li&gt;bound: 한계값​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;root: 루트 노드​&lt;/li&gt;
  &lt;li&gt;u, v:  노드 ​&lt;/li&gt;
  &lt;li&gt;maxValue: 지금까지 찾은 최고 해의 값​&lt;/li&gt;
  &lt;li&gt;PQ: 상태 공간 트리를 대신하는 우선 순위 대기열​
    &lt;ul&gt;
      &lt;li&gt;주: PQ는 유망하나 확장되지 않은 노드들 포함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;KnapsackBandB(N, Wt[0 . . N – 1], Val[0 . . N – 1], C)​
// 입력: N – 물건들의 수​
// Wt[0 . . N – 1]– 각 물건의 무게를 저장하는 배열​
// Val[0 . . N – 1] – 각 물건의 가치를 저장하는 배열​
// C – 배낭의 용량​
// 출력: 배낭에 넣을 수 있는 물건들의 최대 가치​
1  initialize(PQ) // PQ를 빈 대기열로 초기화​
2  maxValue = 0 // maxValue를 0으로 초기화​
3  root.level = 0​
4  root.weight = 0​
5  root.value = 0
6  root.bound = computeBound(root) // 루트 노드의 한계값 계산​
7  insert(PQ, root)          // root를 PQ에 삽입
8  while (not empty(PQ)) {          // PQ가 비어 있지 않은 동안 반복​
9    v = remove(PQ)          // PQ에서 최대 한계값을 가진 노드 v를 끄집어 낸다​
10   if (v.bound &amp;gt; maxValue) {          // 노드 v가 유망하면 확장​
11      u.level = v.level + 1          // 노드 u를 노드 v의 자식 노드로 만든다​
12      u.weight = v.weight + Wt[v.level] // u는 다음 물건을 넣는 경우​
13      u.value = v.value + Val[v.level];​
14      if (u.weight &amp;lt;= C and u.value &amp;gt; maxValue)​
15         maxValue = u.value                // maxValue를 더 나은 해의 값으로 바꾼다​
16      u.bound = computeBound(u) // 자식 노드의 한계값을 계산​
17      if (u.bound &amp;gt; maxValue)​
18         insert(PQ, u);  // u가 유망하므로 PQ에 삽입​
19      w.level = v.level + 1                 // 노드 w는 다음 물건을 넣지 않는 경우​
20      w.weight = v.weight  ​
21      w.value = v.value​
22      w.bound = computeBound(w) // 자식 노드의 한계값 계산​
23      if (w.bound &amp;gt; maxValue)​
24         insert(PQ, w);  // w가 유망하므로 PQ에 삽입​
     }}​
25  return maxValue 

computeBound(u) // 노드 u의 한계값을 계산
// 입력: u - 트리의 노드
// 출력: u의 한계값
1 if(u.weight &amp;gt;= C) return 0
2 else if(u.level &amp;lt; N)
            return u.value + (C - u.wight) x (Val[u.level]/Wt[u.leve])
3 else return u.value

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;시간 복잡도: O($2^n$)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;일 배정 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;N(&amp;gt;1) 명의 사람에게 N개의 일을 배정&lt;/li&gt;
  &lt;li&gt;한 사람에게 정확하게 하나의 일만 배정&lt;/li&gt;
  &lt;li&gt;모든 일은 정확하게 한 사람에게 배정&lt;/li&gt;
  &lt;li&gt;C[i,j], 1&amp;lt;= i, j&amp;lt;=N: 사람 i를 일 j에 배정하는 비용&lt;/li&gt;
  &lt;li&gt;총 배정 비용이 최소가 되도록 일을 배정&lt;/li&gt;
  &lt;li&gt;비용 행렬의 각 행에서 한 요소를 선택하는 문제와 같다&lt;/li&gt;
  &lt;li&gt;선택된 요소들은 다른 열에 있어야 하고 총 배정 비용이 가장 작아야 한다&lt;/li&gt;
  &lt;li&gt;가능한 해는 n-짝(n-tuple)($j_1$,$j_2$, … ,$j_n$)으로 나타낼 수 있다. $j_i$, 1 &amp;lt;=i &amp;lt;= n, 는 사람 i에게 배정된 일의 번호&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;완전 탐색 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;아이디어: 가능한 일 배정과 1부터 N사이의 정수들의 순열과 일대일 대응 관계가 있다는 사실을 이용&lt;/li&gt;
  &lt;li&gt;알고리즘: 1부터 N사이의 정수들의 모든 순열을 생성하고 각 순열에 대응하는 일 배정의 총 비용을 계산한 후 총 비용이 가장 작은 일 배정을 선택한다&lt;/li&gt;
  &lt;li&gt;시간 복잡도: 1부터 N사이의 정수들의 모든 순열의 수 = N!(&amp;gt;$2^n$)
    &lt;ul&gt;
      &lt;li&gt;O(N!)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;분기 한정 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;상태 공간 트리 = N항(N-ary) 트리​&lt;/li&gt;
  &lt;li&gt;해: 루트 노드로부터 잎까지의 경로​&lt;/li&gt;
  &lt;li&gt;살아 있는 노드: 아직 가지 치지 않은 유망한 잎​&lt;/li&gt;
  &lt;li&gt;현재 트리의 살아 있는 노드들중에서 가장 유망한 노드의 모든 자식 노드들을 생성 ​&lt;/li&gt;
  &lt;li&gt;가장 유망한 노드 = 한계값이 가장 작은 노드​&lt;/li&gt;
  &lt;li&gt;최선 우선 탐색 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;최선 우선 탐색 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;상태 공간 트리의 각 노드에 다음 값들을 저장한다
    &lt;ul&gt;
      &lt;li&gt;personNumber: 사람의 번호​&lt;/li&gt;
      &lt;li&gt;jobNumber: 일의 번호​&lt;/li&gt;
      &lt;li&gt;sumAssignedCost: 현재까지 배정된 일들의 비용들의 합​&lt;/li&gt;
      &lt;li&gt;bound: 한계값​&lt;/li&gt;
      &lt;li&gt;parent: 부모 노드​&lt;/li&gt;
      &lt;li&gt;assigned: 사람들에 일들의 배정 여부를 저장하는 배열&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;root: 루트 노드&lt;/li&gt;
  &lt;li&gt;child: 자식 노드&lt;/li&gt;
  &lt;li&gt;queue: 살아 있는 노드들을 포함하는 우선 순위 대기열&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;일 배정 분기 한정 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;JobAssignmentBandB(N, C[0 . . N – 1, 0 . . N – 1])​
// 입력: N – 사람들(일들)의 수​
//        C[0 . . N – 1, 0 . . N – 1]) – 특정 사람에게 특정 일을 배정하는 비용 배열​
// 출력: 일 배정 결과와 최소 배정 비용​
1  Initialize(queue) // queue를 빈 대기열로 초기화​
// 루트 노드의 값들을 초기화​
2  root.personNumber = -1​
3  root.jobNumber = -1​
4  root.sumAssignedCost = 0​
5  root.parent = null​
6  for (i = 0; i &amp;lt; N; i++) root.assigned[i] = false​
// 루트 노드의 한계값 계산​
7  root.bound = computeBound(-1, -1, root.assigned)​
// 루트 노드를 queue에 삽입​
8  queue.insert(root)
// queue가 비어 있지 않은 한 한계값이 최소인 살아 있는 노드를 ​
// 찾아서 그 노드의 자식 노드들을 queue에 추가​
9  while ( not queue.empty( )) {​
      // 최소 한계값을 가진 노드를 queue에서 끄집어 낸다​
10   minNode = queue.remove( )​
11   i = minNode.personNumber + 1  // i는 일을 배정할 다음 사람​
12   if (i = N) {​
13      모든 사람들에게 일들이 배정된 결과를 출력한다​
14      최소 배정 비용을 반환한다
      }
// 사람 i에 배정 가능한 일을 배정하는 모든 자식 노드를 만들어 queue에 추가​
15  for (j = 0; j &amp;lt; N; j++) {​
16      if ( not minNode.assigned[j] ) { // 일 j가 배정되지 않았는지 확인 ​
17         child.personNumber = i​
18         child.jobNumber = j​
19         for (k = 0; k &amp;lt; N; k++) child.assigned[k] = minNode.assigned[k]​
20         child.assigned[j] = true
21         child.parent = minNode​
            // 배정된 일들의 총 비용에 새로 배정된 일의 비용을 더한다​
22         child.sumAssignedCost = minNode.sumAssignedCost + C[i][j]​
            // 새 자식 노드의 한계값 계산​
23         child.bound = child.sumAssignedCost + computeBound(i, j, child.assigned)​
            // 새 자식 노드를 queue에 추가​
24        queue.insert(child)  }​
        }​
     }

computeBound(x,y,assigned)
// 입력: x - 방금 배정된 사람의 번호
//      y - 방금 배정된 일의 번호
//      assigned - 사람들에 일들의 배정 여부를 알려 주는 배열
// 출력: 남은 사람들에게 남은 일들을 배정하는 데 드는 총 비용의 하한
1 bound = 0
2 for (i = x + 1; i &amp;lt; N; i++){
3       minCost = $\infty$
4       minIndex = -1
5       for ( j = 0; j &amp;lt; N; j ++){ // 사람 i에 일을 배정하는 최소 비용을 찾는다
6           if(not assigned[j] and (j !=y) and C[i][j] &amp;lt; minCost){
7               minIndex = j
8               minCost = C[i][j]}}
            bound = bound + minCost // 다음 사람에게 배정 가능한 일의 최소 비용을
                                    // 더한다
            }
9 return bound

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;시간복잡도: O(N!)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="algorithm" /><summary type="html">분기 한정</summary></entry></feed>