<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://lee989898.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lee989898.github.io/" rel="alternate" type="text/html" /><updated>2021-11-24T19:27:29+09:00</updated><id>https://lee989898.github.io/feed.xml</id><title type="html">LEE</title><subtitle>공부 블로그</subtitle><entry><title type="html">__침입탐지__</title><link href="https://lee989898.github.io/sc-16" rel="alternate" type="text/html" title="__침입탐지__" /><published>2021-11-24T01:06:00+09:00</published><updated>2021-11-24T01:06:00+09:00</updated><id>https://lee989898.github.io/sc-16</id><content type="html" xml:base="https://lee989898.github.io/sc-16">&lt;h3 id=&quot;침입탐지&quot;&gt;&lt;strong&gt;침입탐지&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;IDS(침입탐지 시스템)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;침입탐지시스템​&lt;/li&gt;
  &lt;li&gt;침입행위에 대한 탐지를 수행하고 탐지시 대응할 수 있도록 지원하는 일련의 시스템​&lt;/li&gt;
  &lt;li&gt;Intrusion?​
    &lt;ul&gt;
      &lt;li&gt;시스템에 허가되지 않은 방법으로 내부 자원에 접근​&lt;/li&gt;
      &lt;li&gt;Login 시도 (ID, PWD 추측)​&lt;/li&gt;
      &lt;li&gt;불법적으로 데이터 도용시도 (rootkit)​&lt;/li&gt;
      &lt;li&gt;Root/관리자 권한 획득시도​&lt;/li&gt;
      &lt;li&gt;메일발송 실행파일을 숨겨놓고 메일전송시도​&lt;/li&gt;
      &lt;li&gt;Backdoor 접근시도&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;패킷 필터링
    &lt;ul&gt;
      &lt;li&gt;오직 TCP/IP 헤더만 본다&lt;/li&gt;
      &lt;li&gt;패킷 간의 연관성을 알아 내기 어렵다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;IDS
    &lt;ul&gt;
      &lt;li&gt;depp packet inspection: 패킷 콘테츠 까지 검사한다&lt;/li&gt;
      &lt;li&gt;다수의 패킷을 검사한다
        &lt;ul&gt;
          &lt;li&gt;port scanning&lt;/li&gt;
          &lt;li&gt;network mapping&lt;/li&gt;
          &lt;li&gt;Dos attack&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Dectection 방법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;Signature-based dectection​
    &lt;ul&gt;
      &lt;li&gt;침입사건들을 패턴화(signature)​
    + Signature example​&lt;/li&gt;
      &lt;li&gt;실행 파일 첨부 메일 유형​&lt;/li&gt;
      &lt;li&gt;파일 읽기 시도 유형​&lt;/li&gt;
      &lt;li&gt;로그인 시도 유형​
    + 장점​&lt;/li&gt;
      &lt;li&gt;known attack에 대해 효율적​
    + 단점​&lt;/li&gt;
      &lt;li&gt;Unknown attack에 취약​&lt;/li&gt;
      &lt;li&gt;새로운 공격유형 발견때마다 signature 생성해야​&lt;/li&gt;
      &lt;li&gt;일반적으로 False negative rate 높음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Anomaly-based dectection​
    &lt;ul&gt;
      &lt;li&gt;정상범위를 벗어나는 사건을 탐지​
    + Anomaly example​&lt;/li&gt;
      &lt;li&gt;휴일에 traffic 량이 평소보다 20%증가​&lt;/li&gt;
      &lt;li&gt;일반사용자가 갑자기 1000통 메일발송​&lt;/li&gt;
      &lt;li&gt;특정 호스트에 단시간 주문요청 100%증가​&lt;/li&gt;
      &lt;li&gt;국내 사용자 카드가 해외에서 결재​
    + 장점​&lt;/li&gt;
      &lt;li&gt;Machine learning 처리​&lt;/li&gt;
      &lt;li&gt;Unknown attac에 대해 효율적​
    + 단점​&lt;/li&gt;
      &lt;li&gt;정상범위 정의 어려움​&lt;/li&gt;
      &lt;li&gt;비정상탐지까지 기다려야​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;IDS types&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;Network-based IDS​&lt;/li&gt;
  &lt;li&gt;Wireless IDS (wireless IDS)​&lt;/li&gt;
  &lt;li&gt;Host-based IDS​&lt;/li&gt;
  &lt;li&gt;Distributed Host-based IDS&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Network-based IDS​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Example​
    &lt;ul&gt;
      &lt;li&gt;Network 망에 곳곳에 traffic을 모니터, 분석하여 침입탐지​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Example​
    &lt;ul&gt;
      &lt;li&gt;Ddos, worm  ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점 ​
    &lt;ul&gt;
      &lt;li&gt;Host는 부하적음 (하나의  NIDS로 여러 host보호)​&lt;/li&gt;
      &lt;li&gt;조기 탐지가능​&lt;/li&gt;
      &lt;li&gt;취약한 부분의 packet 을 정밀분석하여 다양한 침입탐지 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;각 host 내부는 탐지제한​&lt;/li&gt;
      &lt;li&gt;전체 network 망에 부하&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Wireless IDS (wireless IDS)​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무선통신 WLAN network망의 traffic 분석​&lt;/li&gt;
  &lt;li&gt;장점​
    &lt;ul&gt;
      &lt;li&gt;무선통신의 취약성위협 탐지​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;Network 부하, 비용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Host-based IDS​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;특정 host 컴퓨터내부를 모니터링, 분석하여 탐지​&lt;/li&gt;
  &lt;li&gt;Example​
    &lt;ul&gt;
      &lt;li&gt;로그분석, 파일시스템 기록분석, 실행코드분석 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점​
    &lt;ul&gt;
      &lt;li&gt;악성sw 탐지용이​&lt;/li&gt;
      &lt;li&gt;내부공격자 탐지​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;각 host마다 다름​&lt;/li&gt;
      &lt;li&gt;Host 부하&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Distributed Host-based IDS&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;여러 HIDS들이 연계하여 전체적으로 host들을 분석하여 탐지 ​&lt;/li&gt;
  &lt;li&gt;장점​
    &lt;ul&gt;
      &lt;li&gt;효율적이고 정확성​&lt;/li&gt;
      &lt;li&gt;공격들의 연관관계 파악용이​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;HIDS보다 복잡, 부담&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Honey Pot&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;꿀단지​&lt;/li&gt;
  &lt;li&gt;의도적으로 해커의 침입을 유도하는 시스템​&lt;/li&gt;
  &lt;li&gt;해커 정보수집, 공격유형파악, 대응전략수립, 법적증거 ​&lt;/li&gt;
  &lt;li&gt;침입자 활동감시, 로그기록&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;IDS 평가 기준&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;False Positive rate​
    &lt;ul&gt;
      &lt;li&gt;정상을 침입으로 판단하는 확률​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;False Negative​
    &lt;ul&gt;
      &lt;li&gt;침입을 정상으로 판단하는 확률​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;True Positive rate​&lt;/li&gt;
  &lt;li&gt;True Negative rate​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;IPS (Intrusion Prevention System)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;침입방지시스템​&lt;/li&gt;
  &lt;li&gt;IDS+침입방지기능​&lt;/li&gt;
  &lt;li&gt;Example​
    &lt;ul&gt;
      &lt;li&gt;IDS로 침입탐지하고 계정, 연결 등 차단​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="security" /><summary type="html">침입탐지</summary></entry><entry><title type="html">__방화벽__</title><link href="https://lee989898.github.io/sc-17" rel="alternate" type="text/html" title="__방화벽__" /><published>2021-11-24T01:06:00+09:00</published><updated>2021-11-24T01:06:00+09:00</updated><id>https://lee989898.github.io/sc-17</id><content type="html" xml:base="https://lee989898.github.io/sc-17">&lt;h3 id=&quot;방화벽&quot;&gt;&lt;strong&gt;방화벽&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Firewalls?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;조직의 내부망을 외부 인터넷과 격리시켜 일부 패킷은 통과시키고 나머지는 차단하는 HW와 SW의 조합&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc24.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Firewall 서비스&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Traffic monitoring​&lt;/li&gt;
  &lt;li&gt;Traffic control​&lt;/li&gt;
  &lt;li&gt;NAT – 내부 network 보호​&lt;/li&gt;
  &lt;li&gt;VPN – 내부 traffic 노출차단&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Firewalls을 쓰는 이유&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;서비스 거부 공격 방지:
    &lt;ul&gt;
      &lt;li&gt;SYN 플러딩: 공격자가 많은 가짜 TCP 연결을 설정하고 “실제” 연결을 위한 리소스가 남지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;내부 데이터의 불법적인 수정/접근을 방지한다
    &lt;ul&gt;
      &lt;li&gt;예: 공격자가 CIA의 홈페이지를 다른 것으로 교체&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;내부 네트워크(인증된 사용자/호스트 집합)에 대한 승인된 액세스만 허용&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Firewall types&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;Stateless packet filter​&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;지나는 packet에 대해 미리 정의된 규칙에 따라 pass/block 결정​&lt;/li&gt;
  &lt;li&gt;Packet의 다음 정보를 기반으로 결정​
    &lt;ul&gt;
      &lt;li&gt;source IP address, destination IP address​&lt;/li&gt;
      &lt;li&gt;TCP/UDP source and destination port numbers​&lt;/li&gt;
      &lt;li&gt;ICMP message type​&lt;/li&gt;
      &lt;li&gt;TCP SYN and ACK bits​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;example 1: block incoming and outgoing BitTorrent traffic source or dest port = 6881-6889​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;example 2: Block outbound Web access, port=80.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ACL: 규칙이 있는 테이블, 들어오는 패킷에 위에서 아래로 적용: (액션, 조건) pair&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;장점​
    &lt;ul&gt;
      &lt;li&gt;Simple : 동작방식이 직관적이며 간단, 구현용이​&lt;/li&gt;
      &lt;li&gt;Fast​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;application layer protocol의 취약점공격에 차단 불가능​&lt;/li&gt;
      &lt;li&gt;사용자/application 별 서비스 제공불가능 ​&lt;/li&gt;
      &lt;li&gt;필터링시 사용 정보가 제한되어서 정교한 필터링 불가능​&lt;/li&gt;
      &lt;li&gt;IP주소 위변조 여부 판단 불가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Statefull packet filter​&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;동일한 상태정보를 가지는 패킷들을(packet flow) 그룹으로 필터링​
    &lt;ul&gt;
      &lt;li&gt;상태정보: src IP/port, dst IP/port ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점​
    &lt;ul&gt;
      &lt;li&gt;정교한 필터링​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;상태정보 테이블 검사수행에 따른 성능저하​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Application gateway&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;애플리케이션 데이터 및 IP/TCP/UDP 필드에서 패킷을 필터링한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;장점​
    &lt;ul&gt;
      &lt;li&gt;Application layer protocol 공격 차단​&lt;/li&gt;
      &lt;li&gt;사용자 인증가능​&lt;/li&gt;
      &lt;li&gt;정교한 Log, audit 가능​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;응용 프로그램마다 다른 응용 프로그램 게이트웨이가 필요하다(텔넷, http, ftp, 이메일 …)&lt;/li&gt;
      &lt;li&gt;모든 데이터가 게이트웨이를 통과하기 때문에 성능이 저하됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;방화벽 및 게이트웨이의 한계&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;IP spoofing: 라우터는 데이터가 “실제로” 청구된 소스에서 오는지 알 수 없다&lt;/li&gt;
  &lt;li&gt;여러 앱의 경우. 특별한 대우가 필요하며 각각의 앱이 있다&lt;/li&gt;
  &lt;li&gt;클라이언트 소프트웨어는 게이트웨이에 접속하는 방법을 알아야 한다.
    &lt;ul&gt;
      &lt;li&gt;예를 들어, 웹 브라우저에서 프록시의 IP 주소를 설정해야 한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;내부 공격자 방어에 취약​&lt;/li&gt;
  &lt;li&gt;데이터 내용은 미확인 – 문서 등 내부에 심겨진 악성코드 방어 취약&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="security" /><summary type="html">방화벽</summary></entry><entry><title type="html">분기 한정</title><link href="https://lee989898.github.io/algorithm-08" rel="alternate" type="text/html" title="분기 한정" /><published>2021-11-22T01:09:00+09:00</published><updated>2021-11-22T01:09:00+09:00</updated><id>https://lee989898.github.io/algorithm-08</id><content type="html" xml:base="https://lee989898.github.io/algorithm-08">&lt;h3 id=&quot;분기-한정&quot;&gt;&lt;strong&gt;분기 한정&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;분기 한정&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;안내 표지판과 같은 지표를 활용하여 최종 해를 찾는 기법&lt;/li&gt;
  &lt;li&gt;상태 공간 트리 이용&lt;/li&gt;
  &lt;li&gt;최적화 문제에만 적용 가능&lt;/li&gt;
  &lt;li&gt;최적 해를 구하기 위해 모든 해를 다 고려해야 하므로 트리의 노드를 순회하는 방법과 무관&lt;/li&gt;
  &lt;li&gt;하지만 최적의 해에 더 빨리 도달하기 위해 가장 좋은 한계값을 가진 노드를 먼저 탐색하는 최선 우선 탐색 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;분기 한정의 핵심 원리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;상태 공간 트리의 각 노드를 탐색할 때마다, 그 노드가 유망한 지를 알기 위해 한계값(그 노드로부터 확장하여 얻을 수 있는 실현    가능한 해의 한계)을 계산한다.&lt;/li&gt;
  &lt;li&gt;만약 그 한계값이 그 때까지 찾은 최고 해의 값보다 더 좋으면 그 노드는 유망하다고 판단하고 확장을 하면서 탐색을 계속한다. 그렇지 않으면 그 노드는 유망하지 않다고 판단하고 탐색을 멈춘다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;노드에서 탐색 중단 이유&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;노드의 한계값이 그 때까지 찾은 최고 해의 값보다 못하다&lt;/li&gt;
  &lt;li&gt;노드는 문제의 제약 사항들을 만족시키지 못하므로 실현 가능한 해가 될 수 없다&lt;/li&gt;
  &lt;li&gt;노드가 나타내는 실형 가능한 해들의 부분 집합이 더 이상의 추가 선택들을 할 수 없는 경우에 해당한다
    &lt;ul&gt;
      &lt;li&gt;세 번째 경우에 실현 가능한 해에 대한 목적 함수의​ 값이 그때까지 찾은 최고 해의 값보다 더 좋다면 ​최고 해의 값을 목적 함수의 값으로 갱신한다.​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;최선 우선 탐색&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;최적의 해에 더 빨리 도달하기 위한 전략&lt;/li&gt;
  &lt;li&gt;너비 우선 탐색 사용&lt;/li&gt;
  &lt;li&gt;한 유망한 노드의 모든 자식 노드들을 만든 후 남아 있는 유망하나 확장되지 않은 노드들 중에서 최고의 한계값을 가진 노드를먼저 확장&lt;/li&gt;
  &lt;li&gt;최고의 한계값을 가진 노드를 우선적으로 선택하기 위해서 우선 순위 대기열 사용&lt;/li&gt;
  &lt;li&gt;우선 순위 대기열은 힙을 사용하여 효과적으로 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;너비 우선 탐색&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;트리의 노드들을 다음과 같은 순서로 탐색&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;트리의 루트 노드를 먼저 탐색&lt;/li&gt;
  &lt;li&gt;다음으로 트리의 수준 1에 있는 모든 노드를 왼쪽에서 오른쪽으로 탐색&lt;/li&gt;
  &lt;li&gt;다음으로 수준 2에 있는 모든 노드들을 왼쪽에서 오른쪽으로 탐색&lt;/li&gt;
  &lt;li&gt;마지막 수준까지 이 과정을 반복&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;최선 우선 탐색 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;v,u : 트리의 노드&lt;/li&gt;
  &lt;li&gt;value(v): 노드 v에 대응되는 실현 가능한 해의 값&lt;/li&gt;
  &lt;li&gt;bound(v): 노드 v의 한계값&lt;/li&gt;
  &lt;li&gt;best: 현재까지 찾은 최고 해&lt;/li&gt;
  &lt;li&gt;PQ: 상태 공간 트리를 대신하는 우선 순위 대기열
    &lt;ul&gt;
      &lt;li&gt;PQ는 유망하나 확장되지 않은 노드들 포함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Best-First-Branch-and-Bound(state-space-tree T)​
// 입력: T – 상태 공간 트리​
// 출력: 최적 해의 값​
1  initialize(PQ) // PQ를 빈 대기열로 초기화​
2  v = T의 루트 노드​
3  best = value(v)​
4  insert(PQ, v)           // 노드 v를 PQ에 삽입​
5  while (not empty(PQ)) { // PQ에 노드들이 남아 있는지 확인​
6    v = remove(PQ) // PQ에서 최고 한계값을 가진 노드를 제거​
7    if (bound(v) &amp;gt; best) // 노드 v가 유망한지 확인​
8       for (each child u of v) {​
9           if (value(u) &amp;gt; best) best = value(u)​
10          if (bound(u) &amp;gt; best) insert(PQ, u)  }  }​
11  return best​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;배낭 채우기 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;N(&amp;gt;=1)개의 물건들 중에서 배낭의 용량 C를 초과하지 않고 배낭에 넣을 수 있는 물건들의 최대 가치를 구하라&lt;/li&gt;
  &lt;li&gt;각 물건은 배낭에 넣거나 넣지 않을 수 있더&lt;/li&gt;
  &lt;li&gt;$w_i$: 물건 i, 1&amp;lt;=i&amp;lt;=N,의 무게&lt;/li&gt;
  &lt;li&gt;$v_i$: 물건 i, 1&amp;lt;=i&amp;lt;=N, 의 가치&lt;/li&gt;
  &lt;li&gt;가정: 물건들이 단위 무게당 가치($v_i$ / $w_i$)의 내림차순으로 정렬되어 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;배낭 채우기 상태 공간 트리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;루트 노드: 배낭에 물건들을 넣기 전의 초기 상태&lt;/li&gt;
  &lt;li&gt;트리의 수준 i, 1&amp;lt;=i&amp;lt;=N, 에 있는 각 노드는 첫 번째 물건부터 i번째까지의 물건들 중에서 배낭에 포함된 물건들의 특정 선택을 나타낸다. 이 특정 선택은 루트 노드부터 그 노드까지의 경로에 의해 유일무이하게 결정된다&lt;/li&gt;
  &lt;li&gt;한 노드의 왼쪽에 있는 자식 노드는 다음 물건을 배낭에 넣는 경우를 나타내고 오른쪽에 있는 자식 노드는 다음 물건을 배낭에 넣지 않는 경우를 나타낸다. 이 선택의 총 무게 w와 총 가치 v를 해당 노드에 한계값과 같이 저장한다. 그 노드의 한계값은 이 선택 후 남은 물건들 중 일부를 포함시킴으로써 얻을 수 있는 배낭의 물건들의 가치에 대한 상한을 나타낸다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;노드의 한계값 계산 방법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;배낭에 이미 포함된 물건들의 총 가치 v에 배낭의 남은 용량(C - w)를 전부 다음 물건으로만 채운 경우의 가치를 더한다(w는 배낭에 이미 포함된 물건들의 총 무게). 즉, 트리의 수준 i, 0 &amp;lt;= i &amp;lt; N, 에 있는 노드의 한계값은 다음과 같이 계산된다&lt;/li&gt;
  &lt;li&gt;한계값 &amp;gt;= 실현 가능한 해의 값&lt;/li&gt;
  &lt;li&gt;트리의 수준 n에 있는 노드의 한계값 = v&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;최선 우선 탐색 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;상태 공간 트리의 각 노드에 다음 값들을 저장한다.​
    &lt;ul&gt;
      &lt;li&gt;level: 트리에서 노드의 수준​&lt;/li&gt;
      &lt;li&gt;weight: 이미 선택된 물건들의 총 무게​&lt;/li&gt;
      &lt;li&gt;value: 이미 선택된 물건들의 총 가치​&lt;/li&gt;
      &lt;li&gt;bound: 한계값​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;root: 루트 노드​&lt;/li&gt;
  &lt;li&gt;u, v:  노드 ​&lt;/li&gt;
  &lt;li&gt;maxValue: 지금까지 찾은 최고 해의 값​&lt;/li&gt;
  &lt;li&gt;PQ: 상태 공간 트리를 대신하는 우선 순위 대기열​
    &lt;ul&gt;
      &lt;li&gt;주: PQ는 유망하나 확장되지 않은 노드들 포함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;KnapsackBandB(N, Wt[0 . . N – 1], Val[0 . . N – 1], C)​
// 입력: N – 물건들의 수​
// Wt[0 . . N – 1]– 각 물건의 무게를 저장하는 배열​
// Val[0 . . N – 1] – 각 물건의 가치를 저장하는 배열​
// C – 배낭의 용량​
// 출력: 배낭에 넣을 수 있는 물건들의 최대 가치​
1  initialize(PQ) // PQ를 빈 대기열로 초기화​
2  maxValue = 0 // maxValue를 0으로 초기화​
3  root.level = 0​
4  root.weight = 0​
5  root.value = 0
6  root.bound = computeBound(root) // 루트 노드의 한계값 계산​
7  insert(PQ, root)          // root를 PQ에 삽입
8  while (not empty(PQ)) {          // PQ가 비어 있지 않은 동안 반복​
9    v = remove(PQ)          // PQ에서 최대 한계값을 가진 노드 v를 끄집어 낸다​
10   if (v.bound &amp;gt; maxValue) {          // 노드 v가 유망하면 확장​
11      u.level = v.level + 1          // 노드 u를 노드 v의 자식 노드로 만든다​
12      u.weight = v.weight + Wt[v.level] // u는 다음 물건을 넣는 경우​
13      u.value = v.value + Val[v.level];​
14      if (u.weight &amp;lt;= C and u.value &amp;gt; maxValue)​
15         maxValue = u.value                // maxValue를 더 나은 해의 값으로 바꾼다​
16      u.bound = computeBound(u) // 자식 노드의 한계값을 계산​
17      if (u.bound &amp;gt; maxValue)​
18         insert(PQ, u);  // u가 유망하므로 PQ에 삽입​
19      w.level = v.level + 1                 // 노드 w는 다음 물건을 넣지 않는 경우​
20      w.weight = v.weight  ​
21      w.value = v.value​
22      w.bound = computeBound(w) // 자식 노드의 한계값 계산​
23      if (w.bound &amp;gt; maxValue)​
24         insert(PQ, w);  // w가 유망하므로 PQ에 삽입​
     }}​
25  return maxValue 

computeBound(u) // 노드 u의 한계값을 계산
// 입력: u - 트리의 노드
// 출력: u의 한계값
1 if(u.weight &amp;gt;= C) return 0
2 else if(u.level &amp;lt; N)
            return u.value + (C - u.wight) x (Val[u.level]/Wt[u.leve])
3 else return u.value

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;시간 복잡도: O($2^n$)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;일 배정 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;N(&amp;gt;1) 명의 사람에게 N개의 일을 배정&lt;/li&gt;
  &lt;li&gt;한 사람에게 정확하게 하나의 일만 배정&lt;/li&gt;
  &lt;li&gt;모든 일은 정확하게 한 사람에게 배정&lt;/li&gt;
  &lt;li&gt;C[i,j], 1&amp;lt;= i, j&amp;lt;=N: 사람 i를 일 j에 배정하는 비용&lt;/li&gt;
  &lt;li&gt;총 배정 비용이 최소가 되도록 일을 배정&lt;/li&gt;
  &lt;li&gt;비용 행렬의 각 행에서 한 요소를 선택하는 문제와 같다&lt;/li&gt;
  &lt;li&gt;선택된 요소들은 다른 열에 있어야 하고 총 배정 비용이 가장 작아야 한다&lt;/li&gt;
  &lt;li&gt;가능한 해는 n-짝(n-tuple)($j_1$,$j_2$, … ,$j_n$)으로 나타낼 수 있다. $j_i$, 1 &amp;lt;=i &amp;lt;= n, 는 사람 i에게 배정된 일의 번호&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;완전 탐색 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;아이디어: 가능한 일 배정과 1부터 N사이의 정수들의 순열과 일대일 대응 관계가 있다는 사실을 이용&lt;/li&gt;
  &lt;li&gt;알고리즘: 1부터 N사이의 정수들의 모든 순열을 생성하고 각 순열에 대응하는 일 배정의 총 비용을 계산한 후 총 비용이 가장 작은 일 배정을 선택한다&lt;/li&gt;
  &lt;li&gt;시간 복잡도: 1부터 N사이의 정수들의 모든 순열의 수 = N!(&amp;gt;$2^n$)
    &lt;ul&gt;
      &lt;li&gt;O(N!)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;분기 한정 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;상태 공간 트리 = N항(N-ary) 트리​&lt;/li&gt;
  &lt;li&gt;해: 루트 노드로부터 잎까지의 경로​&lt;/li&gt;
  &lt;li&gt;살아 있는 노드: 아직 가지 치지 않은 유망한 잎​&lt;/li&gt;
  &lt;li&gt;현재 트리의 살아 있는 노드들중에서 가장 유망한 노드의 모든 자식 노드들을 생성 ​&lt;/li&gt;
  &lt;li&gt;가장 유망한 노드 = 한계값이 가장 작은 노드​&lt;/li&gt;
  &lt;li&gt;최선 우선 탐색 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;최선 우선 탐색 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;상태 공간 트리의 각 노드에 다음 값들을 저장한다
    &lt;ul&gt;
      &lt;li&gt;personNumber: 사람의 번호​&lt;/li&gt;
      &lt;li&gt;jobNumber: 일의 번호​&lt;/li&gt;
      &lt;li&gt;sumAssignedCost: 현재까지 배정된 일들의 비용들의 합​&lt;/li&gt;
      &lt;li&gt;bound: 한계값​&lt;/li&gt;
      &lt;li&gt;parent: 부모 노드​&lt;/li&gt;
      &lt;li&gt;assigned: 사람들에 일들의 배정 여부를 저장하는 배열&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;root: 루트 노드&lt;/li&gt;
  &lt;li&gt;child: 자식 노드&lt;/li&gt;
  &lt;li&gt;queue: 살아 있는 노드들을 포함하는 우선 순위 대기열&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;일 배정 분기 한정 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;JobAssignmentBandB(N, C[0 . . N – 1, 0 . . N – 1])​
// 입력: N – 사람들(일들)의 수​
//        C[0 . . N – 1, 0 . . N – 1]) – 특정 사람에게 특정 일을 배정하는 비용 배열​
// 출력: 일 배정 결과와 최소 배정 비용​
1  Initialize(queue) // queue를 빈 대기열로 초기화​
// 루트 노드의 값들을 초기화​
2  root.personNumber = -1​
3  root.jobNumber = -1​
4  root.sumAssignedCost = 0​
5  root.parent = null​
6  for (i = 0; i &amp;lt; N; i++) root.assigned[i] = false​
// 루트 노드의 한계값 계산​
7  root.bound = computeBound(-1, -1, root.assigned)​
// 루트 노드를 queue에 삽입​
8  queue.insert(root)
// queue가 비어 있지 않은 한 한계값이 최소인 살아 있는 노드를 ​
// 찾아서 그 노드의 자식 노드들을 queue에 추가​
9  while ( not queue.empty( )) {​
      // 최소 한계값을 가진 노드를 queue에서 끄집어 낸다​
10   minNode = queue.remove( )​
11   i = minNode.personNumber + 1  // i는 일을 배정할 다음 사람​
12   if (i = N) {​
13      모든 사람들에게 일들이 배정된 결과를 출력한다​
14      최소 배정 비용을 반환한다
      }
// 사람 i에 배정 가능한 일을 배정하는 모든 자식 노드를 만들어 queue에 추가​
15  for (j = 0; j &amp;lt; N; j++) {​
16      if ( not minNode.assigned[j] ) { // 일 j가 배정되지 않았는지 확인 ​
17         child.personNumber = i​
18         child.jobNumber = j​
19         for (k = 0; k &amp;lt; N; k++) child.assigned[k] = minNode.assigned[k]​
20         child.assigned[j] = true
21         child.parent = minNode​
            // 배정된 일들의 총 비용에 새로 배정된 일의 비용을 더한다​
22         child.sumAssignedCost = minNode.sumAssignedCost + C[i][j]​
            // 새 자식 노드의 한계값 계산​
23         child.bound = child.sumAssignedCost + computeBound(i, j, child.assigned)​
            // 새 자식 노드를 queue에 추가​
24        queue.insert(child)  }​
        }​
     }

computeBound(x,y,assigned)
// 입력: x - 방금 배정된 사람의 번호
//      y - 방금 배정된 일의 번호
//      assigned - 사람들에 일들의 배정 여부를 알려 주는 배열
// 출력: 남은 사람들에게 남은 일들을 배정하는 데 드는 총 비용의 하한
1 bound = 0
2 for (i = x + 1; i &amp;lt; N; i++){
3       minCost = $\infty$
4       minIndex = -1
5       for ( j = 0; j &amp;lt; N; j ++){ // 사람 i에 일을 배정하는 최소 비용을 찾는다
6           if(not assigned[j] and (j !=y) and C[i][j] &amp;lt; minCost){
7               minIndex = j
8               minCost = C[i][j]}}
            bound = bound + minCost // 다음 사람에게 배정 가능한 일의 최소 비용을
                                    // 더한다
            }
9 return bound

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;시간복잡도: O(N!)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="algorithm" /><summary type="html">분기 한정</summary></entry><entry><title type="html">__Diffie-Hellman__</title><link href="https://lee989898.github.io/sc-14" rel="alternate" type="text/html" title="__Diffie-Hellman__" /><published>2021-11-17T01:06:00+09:00</published><updated>2021-11-17T01:06:00+09:00</updated><id>https://lee989898.github.io/sc-14</id><content type="html" xml:base="https://lee989898.github.io/sc-14">&lt;h3 id=&quot;diffie-hellman&quot;&gt;&lt;strong&gt;Diffie-Hellman&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Diffie-Hellman&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;보안성 없는 매체를 통한 Symmetric key 공유&lt;/li&gt;
  &lt;li&gt;송/수신자를 위한 일회용 Secret/shared session key agreement protocol&lt;/li&gt;
  &lt;li&gt;이산대수문제&lt;/li&gt;
  &lt;li&gt;IPSEC, 상용sw에 자주 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Steps&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;p,g: 큰 정수, 1 &amp;lt; q &amp;lt; p, 모든 사용자에 공개&lt;/li&gt;
  &lt;li&gt;Alice는 임의로 a 생성, A = $g^a$ mod p 계산&lt;/li&gt;
  &lt;li&gt;Bob은 임의로 b 생성, B = $g^b$ mod p 계산&lt;/li&gt;
  &lt;li&gt;A,B를 서로 교환&lt;/li&gt;
  &lt;li&gt;Alice와 Bob은 K=$g^{ab}$ mod p&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Deiffie-Hellman의 취약성: 중간자 공격&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Man in the middle attack: Trudy poses as Alice and as Bob
    &lt;ul&gt;
      &lt;li&gt;Diffe-Hellman은 매우 복잡한 프로토콜이지만, 제 3자가 x 또는 y 값을 알아내지 않아도 되기 때문에 중간에서 밥과 앨리스를 속이는 것이 가능하다.​&lt;/li&gt;
      &lt;li&gt;중간자 공격 절차​
        &lt;ol&gt;
          &lt;li&gt;앨리스가 x를 선택한 후 R1=Gx를 계산하여 R1을 밥에게 전송​&lt;/li&gt;
          &lt;li&gt;제 3자가 R1을 가로챈 후, z를 선택한 다음 R2=Gz mod N을 계산하여 R2를 앨리스와 밥에게 전송​&lt;/li&gt;
          &lt;li&gt;밥이 y를 선택한 다음 R3=Gy mod N을 계산해서 R3을 앨리스에게 전송, R3을 제 3자가 가로챔​&lt;/li&gt;
          &lt;li&gt;앨리스와 제 3자가 공유한 키 K1=Gxz mod N을 계산​&lt;/li&gt;
          &lt;li&gt;제 3자와 밥은 공유한 키 K2=Gzy mod N을 계산​&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;경우 앨리스와 밥은 제 3자와 공유한 키를 서로간의 공유한 키로 생각​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자 인증을 하지 않아서 발생하는 문제 -&amp;gt; 전자서명, 인증서&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="security" /><summary type="html">Diffie-Hellman</summary></entry><entry><title type="html">__DRM(Digital Right Managemment__</title><link href="https://lee989898.github.io/sc-15" rel="alternate" type="text/html" title="__DRM(Digital Right Managemment__" /><published>2021-11-17T01:06:00+09:00</published><updated>2021-11-17T01:06:00+09:00</updated><id>https://lee989898.github.io/sc-15</id><content type="html" xml:base="https://lee989898.github.io/sc-15">&lt;h3 id=&quot;drmdigital-right-managemment&quot;&gt;&lt;strong&gt;DRM(Digital Right Managemment&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;DRM&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;digital 저작권 관리&lt;/li&gt;
  &lt;li&gt;Digital contents의 불법 사용을 제한/방지하고, 저작권을 보고하기 위한 기술 및 서비스&lt;/li&gt;
  &lt;li&gt;Digital contents
    &lt;ul&gt;
      &lt;li&gt;audio,video,image,text,multimedia,sw 등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;저작권이란&lt;/li&gt;
  &lt;li&gt;Copyright​&lt;/li&gt;
  &lt;li&gt;저작자가 자신이 창작한 저작물에 대해 갖는 권리(저작권법)​
    &lt;ol&gt;
      &lt;li&gt;복제권: 저작자는 저작물을 복제할 권리를 갖는다​&lt;/li&gt;
      &lt;li&gt;공연권​&lt;/li&gt;
      &lt;li&gt;공중송신권​&lt;/li&gt;
      &lt;li&gt;전시권: 원본이나 복제물을 전시할 권리​&lt;/li&gt;
      &lt;li&gt;배포권: 원본이나 복제물을 배포. 다만, 저작자의 허락을 받아 판매등의 방법으로 거래에 제공된 경우는 제외​&lt;/li&gt;
      &lt;li&gt;대여권: 영리를 목적으로 대여할 권리​&lt;/li&gt;
      &lt;li&gt;2차적 저작물작성권: 원저작물로 하는 2차적저작물을 작성하여 이용할 권리​&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Common DRM business model&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Provider​
    &lt;ul&gt;
      &lt;li&gt;저자물(권) 소유​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Distributor​
    &lt;ul&gt;
      &lt;li&gt;유통을 담당하는 배급자​&lt;/li&gt;
      &lt;li&gt;합법적인 소비자에게만 제공해야​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Clearinghouse​
    &lt;ul&gt;
      &lt;li&gt;디지털 상품에 대한 권리발급​&lt;/li&gt;
      &lt;li&gt;배급료, 사용료 처리 (Log기록)​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Consumer​
    &lt;ul&gt;
      &lt;li&gt;Clearinghouse에 사용료지급하고  distributor로부터 컨텐츠제공받음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;주요기술 1: Stegano graphy(숨겨진 글)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;평범해 보이는 미디어에 내용을 아는 수신자만 알아볼 수 있도록 은밀히 정보를 숨기는 기술​&lt;/li&gt;
  &lt;li&gt;암호화알고리즘이 안전하지 않을 때 유용&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;주요기술 2: Watermark&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;빛을 비출때나 반사될 때 더 밝게 보이는, 인지할 수 있는 종이의 무늬나 그림​&lt;/li&gt;
  &lt;li&gt;지폐, 상표, 문서 등의 위조 방지에 많이 사용된다&lt;/li&gt;
  &lt;li&gt;Digital watermarking​
    &lt;ul&gt;
      &lt;li&gt;Text, image, video, audio 등의 원본 데이터에 본래 소유주만이 아는 mark를 사람의 감각으로 식별할 수 없게 삽입하는 기술​&lt;/li&gt;
      &lt;li&gt;일부 digital data가 손상되더라도 인간은 감지할 수 없음​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;복제방지, 원본여부, 재생횟수제한, 유효기간설정, 시간제한 등에 활용&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="security" /><summary type="html">DRM(Digital Right Managemment</summary></entry><entry><title type="html">프로세스통신-socket</title><link href="https://lee989898.github.io/st-09" rel="alternate" type="text/html" title="프로세스통신-socket" /><published>2021-11-16T01:06:00+09:00</published><updated>2021-11-16T01:06:00+09:00</updated><id>https://lee989898.github.io/st-09</id><content type="html" xml:base="https://lee989898.github.io/st-09">&lt;h3 id=&quot;프로세스통신-socket&quot;&gt;&lt;strong&gt;프로세스통신-socket&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Socket&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Pipe는 통신하는 프로세스들을 하나의 시스템 내부로 한정 ​&lt;/li&gt;
  &lt;li&gt;Socket은 같은 시스템에 속한 프로세스들 뿐만 아니라, 서로 다른 시스템들에 속한 프로세스들 간의 통신을 가능케 함​
    &lt;ul&gt;
      &lt;li&gt;socket() 시스템 호출에 의해 만들어 짐 ​&lt;/li&gt;
      &lt;li&gt;응용 프로그램의 관점에서는 pipe와 마찬가지로 파일 디스크립터를 통해 접근(read, write, 등) 가능​&lt;/li&gt;
      &lt;li&gt;Kernel의 관점에서 socket은 IPC를 위한 통신의 끝점(또는 출입구)에 해당함​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;전혀 관계없는 프로세스간에 통신을 위해 socket을 식별할 목적으로 이름을 붙임​
    &lt;ul&gt;
      &lt;li&gt;파일 이름 또는 번호​&lt;/li&gt;
      &lt;li&gt;bind() 시스템 호출 사용​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;이름 붙이기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Linux 도메인에서는 socket 이름으로 파일 이름 사용 (경로명 포함)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;INET(Internet) 도메인에서는 socket 이름으로 포트번호 사용​&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;Well-known port: ftp는 21번, telnet은 23번, 등등. ​&lt;/li&gt;
      &lt;li&gt;통신 상대 프로세스가 속한 컴퓨터 시스템 이름(IP address) + 
  포트 번호&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st21.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Stream Socket을 이용한 IPC&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Virtual circuit​
    &lt;ul&gt;
      &lt;li&gt;통신 대상에 연결(논리적 접속)을 설정​&lt;/li&gt;
      &lt;li&gt;그 연결을 통하여 데이터를 송수신​&lt;/li&gt;
      &lt;li&gt;송수신이 끝나면 연결 해제​&lt;/li&gt;
      &lt;li&gt;연결형 통신이라고 부름 : 전화에 비유​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Stream socket​
    &lt;ul&gt;
      &lt;li&gt;Virtual circuit 기능을 이용하여 구현한 socket​&lt;/li&gt;
      &lt;li&gt;프로세스간에 대량의 데이터를 송수신하는 경우 이용 ​&lt;/li&gt;
      &lt;li&gt;통신의 신뢰성 보증​&lt;/li&gt;
      &lt;li&gt;송신한 정보가 없어지거나 바뀌지 않음​&lt;/li&gt;
      &lt;li&gt;올바른 순서로 수신됨​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;연결형 프로토콜의 예 : TCP (Transmission Control Protocol)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Client :​
    &lt;ul&gt;
      &lt;li&gt;Socket 작성 : socket() 시스템 호출​&lt;/li&gt;
      &lt;li&gt;Socket에 이름 붙임 : bind()  생략 가능​&lt;/li&gt;
      &lt;li&gt;Server에 접속 요구 : connect()​&lt;/li&gt;
      &lt;li&gt;데이터 송수신 : read()/write()  socket이 파일 디스크립터로 접근 가능하므로​&lt;/li&gt;
      &lt;li&gt;Socket 제거 : close()​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Server : ​
    &lt;ul&gt;
      &lt;li&gt;Socket 작성 : socket() 시스템 호출​&lt;/li&gt;
      &lt;li&gt;Socket에 이름 붙임 : bind()​&lt;/li&gt;
      &lt;li&gt;Client의 접속 요구 받을 준비 : listen()​&lt;/li&gt;
      &lt;li&gt;접속 요구 허가 : accept()​&lt;/li&gt;
      &lt;li&gt;데이터 송수신 : read()/write()​&lt;/li&gt;
      &lt;li&gt;Socket 제거 : close()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st22.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Datagram Socket을 이용한 IPC&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Datagram​
    &lt;ul&gt;
      &lt;li&gt;통신 대상에 연결(논리적 접속)을 설정할 필요 없음​&lt;/li&gt;
      &lt;li&gt;개개의 데이터를 그때 그때 상대방에게 보냄​&lt;/li&gt;
      &lt;li&gt;비 연결형 통신이라고 부름 : 편지에 비유​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Datagram socket​
    &lt;ul&gt;
      &lt;li&gt;Datagram 기능을 이용하여 구현한 socket​&lt;/li&gt;
      &lt;li&gt;프로세스간에 작은 데이터를 계속해서 보내는 통신​&lt;/li&gt;
      &lt;li&gt;매번 데이터를 보낼 때마다 상대방을 지정 ​&lt;/li&gt;
      &lt;li&gt;전송 데이터의 신뢰성이 보증되지 않음 : 시간, 순서, 등​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;비 연결형 프로토콜의 예 : UDP (User Datagram Protocol)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Client :​
    &lt;ul&gt;
      &lt;li&gt;Socket 작성 : socket() 시스템 호출​&lt;/li&gt;
      &lt;li&gt;Socket에 이름 붙임 : bind()  생략 가능​&lt;/li&gt;
      &lt;li&gt;데이터 송신 : sendto() ​&lt;/li&gt;
      &lt;li&gt;데이터 수신 : recvfrom()​&lt;/li&gt;
      &lt;li&gt;Socket 제거 : close()​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Server : ​
    &lt;ul&gt;
      &lt;li&gt;Socket 작성 : socket() 시스템 호출​&lt;/li&gt;
      &lt;li&gt;Socket에 이름 붙임 : bind()​&lt;/li&gt;
      &lt;li&gt;데이터 수신 : recvfrom()​&lt;/li&gt;
      &lt;li&gt;데이터 송신 : sendto()​&lt;/li&gt;
      &lt;li&gt;Socket 제거 : close()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;socket() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int socket(int domain, int type, int protocol)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;소켓을 생성​
    &lt;ul&gt;
      &lt;li&gt;int domain :  사용하는 도메인의 종류​&lt;/li&gt;
      &lt;li&gt;int type :      사용하는 소켓 타입​&lt;/li&gt;
      &lt;li&gt;int protocol : 사용하는 프로토콜의 종류​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정상 종료시 생성된 소켓에 대한 파일 디스크립터 반환, 에러시 -1 반환&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Domain의 종류 ​
    &lt;ul&gt;
      &lt;li&gt;PF_UNIX : unix domain ​&lt;/li&gt;
      &lt;li&gt;PF_INET : inet domain​&lt;/li&gt;
      &lt;li&gt;그 이외​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Socket type의 종류​
    &lt;ul&gt;
      &lt;li&gt;Sock_stream : stream socket​&lt;/li&gt;
      &lt;li&gt;Sock_dgram : datagram socket​&lt;/li&gt;
      &lt;li&gt;그 이외​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용되는 고유의 protocol 지정. 대부분 0을 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;bind() system call​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int bind(int sockfd, struct sockaddr *my_addr, int len)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;int sockfd : socket() 시스템 호출에서 돌려 받은 socket 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;struct sockaddr *my_addr : 이름을 붙일 구조체​
    &lt;ul&gt;
      &lt;li&gt;struct sockaddr *my_addr 에는 다음을 지정​
        &lt;ul&gt;
          &lt;li&gt;Unix domain 또는 Inet domain 중 어느 쪽을 사용할 지​&lt;/li&gt;
          &lt;li&gt;Socket 이름​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;int len :  이름이 붙여진 구조체(*my_addr)의 길이​&lt;/li&gt;
  &lt;li&gt;Unix Domain에서 socket의 주소 정보는 socketaddr_un 구조체에서 정의​
```
#include &amp;lt;sys/un.h&amp;gt;​
#define UNIX_PATH_MAX 108​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;struct sockaddr_un {​
    sa_family_t   sun_family;     /* sa_family_t는 short과 같은 타입&lt;em&gt;/​
     /&lt;/em&gt; PF_UNIX 설정 &lt;em&gt;/​
    char sun_path[UNIX_PATH_MAX];   /&lt;/em&gt; 경로명 */​&lt;/p&gt;

&lt;p&gt;};&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ Inet Domain에서 socket의 주소 정보는 socketaddr_in 구조체에서 정의​

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;#include &amp;lt;netinet/in.h&amp;gt;​&lt;/p&gt;

&lt;p&gt;struct sockaddr_in {​
    sa_family_t     sin_family;   /* PF_INET 설정 &lt;em&gt;/
    u_int16_t        sin_port;      /&lt;/em&gt; 포트 번호 &lt;em&gt;/​
    struct in_addr   sin_addr;    /&lt;/em&gt; IP 주소 */​&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;}; ​ struct in_addr { u_int32_t  s_addr; };  /* IP 주소 */ ```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;connect() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;netinet/in.h&amp;gt;​
#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int connect(int sockfd, const struct socketaddr *serv_addr, socklen_t addr_len)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;스트림 소켓 이용시 client에서 호출 (서버에 접속 요청)​&lt;/li&gt;
  &lt;li&gt;정상 종료시 0을 반환, 에러시 -1 반환​
    &lt;ul&gt;
      &lt;li&gt;int sockfd : socket 파일 디스크립터를 지정​&lt;/li&gt;
      &lt;li&gt;struct sockaddr *serv_addr : 접속하고 싶은 서버의 소켓 주소 정보 ​&lt;/li&gt;
      &lt;li&gt;socklen_t addr_len : 서버의 소켓 주소 정보 구조체의 길이​
​
        &lt;blockquote&gt;
          &lt;p&gt;listen() system call&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/socket.h&amp;gt;​

int listen(int sockfd, int backlog)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;스트림 소켓 이용시 server에서 호출 정상 종료시 0을 반환, 에러시 -1 반환​&lt;/li&gt;
  &lt;li&gt;int sockfd : socket 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;int backlog : 연결 요청에 대한 대기열의 최대 길이(대개 5)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;accept() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int accept(int sockfd, struct sockaddr *client_addr, socklen_t *addrlen)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;스트림 소켓 이용시 server에서 호출​&lt;/li&gt;
  &lt;li&gt;정상 종료시 소켓에 대한 새로운 파일 디스크립터를 반환, 에러시 -1 반환​&lt;/li&gt;
  &lt;li&gt;int sockfd : socket 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;struct sockaddr *client_addr : client의 socket 주소 정보 구조체를 가리키는 포인터​&lt;/li&gt;
  &lt;li&gt;socklen_t *addrlen : client의 socket 주소 정보 구조체의 길이&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;send() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int send(int sockfd, const void *buf, size_t len, int flags)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Send() : 소켓으로 데이터 보냄&lt;/li&gt;
  &lt;li&gt;정상 종료시 실제 보낸 바이트 수를 반환, 에러시 -1 반환​&lt;/li&gt;
  &lt;li&gt;int sockfd : accept로 반환된 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;const void *buf : 송신 버퍼의 시작 주소​&lt;/li&gt;
  &lt;li&gt;size_t len : 송신 데이터의 길이​&lt;/li&gt;
  &lt;li&gt;int flags : 송신 옵션&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;recv() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int recv(int sockfd, void *buf, size_t len, int flags)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Recv() : 소켓으로부터 데이터 받음&lt;/li&gt;
  &lt;li&gt;정상 종료시 실제 받은 바이트 수를 반환, 에러시 -1 반환​&lt;/li&gt;
  &lt;li&gt;int sockfd : accept로 반환된 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;void *buf : 수신 버퍼의 시작 주소​&lt;/li&gt;
  &lt;li&gt;size_t len : 수신 데이터의 길이​&lt;/li&gt;
  &lt;li&gt;int flags : 수신 옵션&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;sendto() system call​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;​

int sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *to, socklen_t tolen)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Sendto() : 데이터그램 소켓으로 데이터 보냄​&lt;/li&gt;
  &lt;li&gt;정상 종료시 실제 보낸 바이트 수를 반환, 에러시 -1 반환​&lt;/li&gt;
  &lt;li&gt;int sockfd : 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;const void *buf : 송신 버퍼의 시작 주소​&lt;/li&gt;
  &lt;li&gt;size_t len : 송신 데이터의 길이​&lt;/li&gt;
  &lt;li&gt;int flags : 송신 옵션 ​&lt;/li&gt;
  &lt;li&gt;const struct sockaddr *to : 받을 곳의 소켓 주소 정보 구조체를 가리키는 포인터​&lt;/li&gt;
  &lt;li&gt;socklen_t tolen : 받을 곳의 소켓 주소 정보 구조체의 길이​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;recvfrom() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlen)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;Recvfrom() : 데이터그램 소켓에서 데이터 받음​&lt;/li&gt;
  &lt;li&gt;정상 종료시 실제 받은 바이트 수를 반환, 에러시 -1 반환​&lt;/li&gt;
  &lt;li&gt;int sockfd : 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;void *buf : 수신 버퍼의 시작 주소​&lt;/li&gt;
  &lt;li&gt;size_t len : 수신 데이터의 길이​&lt;/li&gt;
  &lt;li&gt;int flags : 수신 옵션​&lt;/li&gt;
  &lt;li&gt;struct sockaddr *from : 보내는 곳의 소켓 주소 정보 구조체를 가리키는 포인터​&lt;/li&gt;
  &lt;li&gt;socklen_t tolen : 보내는 곳의 소켓 주소 정보 구조체의 길이&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="system" /><summary type="html">프로세스통신-socket</summary></entry><entry><title type="html">되추적</title><link href="https://lee989898.github.io/algorithm-07" rel="alternate" type="text/html" title="되추적" /><published>2021-11-15T01:09:00+09:00</published><updated>2021-11-15T01:09:00+09:00</updated><id>https://lee989898.github.io/algorithm-07</id><content type="html" xml:base="https://lee989898.github.io/algorithm-07">&lt;h3 id=&quot;되추적&quot;&gt;&lt;strong&gt;되추적&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;되추적&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;완전 탐색을 개선한 기법&lt;/li&gt;
  &lt;li&gt;후보 해들을 단계적으로 만들어 가는 과정에서 후보 해들을 평가&lt;/li&gt;
  &lt;li&gt;만약 한 후보 해가 최종 해가 될 수 없다고 판단되면 탐색을 멈추고 다른 후보 해를 탐색&lt;/li&gt;
  &lt;li&gt;최적화 문제와 결정 문제 해결 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;하산 길 선택&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;하산 길에 갈림길에 안내 표지판이 없다면
    &lt;ol&gt;
      &lt;li&gt;갈림길에서 한 길을 선택한 후 그 길을 따라 계속해서 간다&lt;/li&gt;
      &lt;li&gt;길이 끊기면 절벽에 도달하면 갈림길로 되돌아온다&lt;/li&gt;
      &lt;li&gt;갈림길에서 다른 길을 선택해서 간다&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;상태공간트리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;특정 알고리즘의 진행 과정을 나타낸 트리&lt;/li&gt;
  &lt;li&gt;노드: 한 해의 구성요소들에 대한 특정 선택&lt;/li&gt;
  &lt;li&gt;후보 해: 루트 노드에서 종단 노드까지의 경로&lt;/li&gt;
  &lt;li&gt;후보 해 중에 해가 있음&lt;/li&gt;
  &lt;li&gt;해가 될 가능성이 전혀 없는 노드의 자손 노드들을 고려하지 않음&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;예: 미로 찾기&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;노드의 유망성
    &lt;ul&gt;
      &lt;li&gt;해가 될 가능성이 있는 노드는 유망하고 아니면 유망하지 않다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;되추적이란?
    &lt;ul&gt;
      &lt;li&gt;어떤 노드의 유망성을 점검한 후, 유망하지 않다고 판정이 되면 그 노드의 부모 노드로 돌아가서 다음 자식 노드에 대한 탐색을 계속한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;상태 공간 트리에서 깊이 우선 탐색
    &lt;ul&gt;
      &lt;li&gt;유망한 노드만 자식 노드 탐색&lt;/li&gt;
      &lt;li&gt;유망하지 않은 노드는 가지 쳐서 탐색 중단&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;순열 생성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&amp;lt;1,2, …, N&amp;gt;의 모든 순열을 생성하라&lt;/li&gt;
  &lt;li&gt;예: N = 3인 경우
    &lt;ul&gt;
      &lt;li&gt;&amp;lt;1,2,3&amp;gt;, &amp;lt;1,3,2&amp;gt;, &amp;lt;2,1,3&amp;gt;, &amp;lt;2,3,1&amp;gt;, &amp;lt;3,1,2&amp;gt;, &amp;lt;3,2,1&amp;gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag19.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;아이디어: 배열의 첫 번째, 두 번째와 세 번째 요소를 각각 첫 번째 요소와 교환한 후 배열의 나머지 부분에 대해 순열을 생성하는 일을 재귀적으로 반복한다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;permute(A[], k) // &amp;lt;A[k], A[k + 1], ..., A[N-1]&amp;gt;의 모든 순열을 생성
// 입력: A[0 .. N - 1] - 순열을 저장하는 배열, k - 배열 A의 지수
// 출력: &amp;lt;A[k], A[k + 1],..., A[N-1]&amp;gt;의 모든 수열
1 if (k = N) { A[0 .. N - 1]을 출력한다; return}
2 for(i = 1; i &amp;lt;= N; i++) // A[k]를 i로 정하기 전에 가능한지 확인
3   if(promising(A,k,i)) { // A[k]를 i로 정하는 것이 가능한 경우
4       A[k] = i
7       permute(A, k+1)} // A[k+1], ..., A[N-1]&amp;gt; 의 모든 순열을 생성

// 최초호출: permute(A[], 0) 

// A[k]를 i로 정하는 것이 가능한지 확인
promising(A[],k,i)
1 flag = true
2 j = 0
3 while(j &amp;lt; k &amp;amp;&amp;amp; flag){
4 if(j = A[j]) flag = false
5 j++       }
6 return flag

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;해밀토니안 회로 찾기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;헤밀토니안 회로: 연결된 무방향 그래프에서 한 정점에서 출발하여 모든 정점을 정확히 한번씩 방문하고 다시 출발 정점으로 돌아오는 경로&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;헤밀토니안 회로 찾기 문제: 연결된 무방향 그래프에서 해밀토니안 회로를 찾아라&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;가정: n - 그래프내의 정점들의 수
    &lt;ol&gt;
      &lt;li&gt;트리의 루트 노드에 시작 정점을 놓는다&lt;/li&gt;
      &lt;li&gt;for(i = 1; i &amp;lt; n; i++)&lt;/li&gt;
    &lt;/ol&gt;
    &lt;ul&gt;
      &lt;li&gt;트리의 수준 i에 i번째로 방문할 정점으로 시작 정점을 제외한 모든 정점을 선택하는 것을 고려한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;i번째 방문 정점 j의 선택 조건
    &lt;ol&gt;
      &lt;li&gt;i가 (n-1)이라면 j는 시작 정점과 인접해야 한다&lt;/li&gt;
      &lt;li&gt;i가 (n-1)보다 작다면 루트 노드로부터 j까지의 경로상의 (i-1)번째 정점과 인접해야 한다&lt;/li&gt;
      &lt;li&gt;j는 루트 노드로부터 j까지의 경로상에서 j 전에 방문한 (i-1)개의 정점들 중 하나가 되어서는 안된다&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위 조건들을 만족하면 트리의 다음 수준 (i + 1)에 대해 같은 과정을 계속하고 아니면 해 탐색을 멈추고 부모 노드로 되돌아가서 i번째로 방문할 정점으로 아직 선택안한 정점들 중의 하나를 선택하고 조건을 확인한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;n: 정점들의 수&lt;/li&gt;
  &lt;li&gt;i, 1 &amp;lt;= i &amp;lt;= n : 정점의 번호&lt;/li&gt;
  &lt;li&gt;1: 시작 정점&lt;/li&gt;
  &lt;li&gt;그래프 G = (V,E)는 인접 행렬 G로 표현한다.
    &lt;ul&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;G[i - 1][j - 1] = { 1, (i,j) $\in$ E&lt;/td&gt;
              &lt;td&gt;0, (i,j) $\notin$ E}&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;path[i], 0&amp;lt;= i &amp;lt;= n-1: 해밀토니안 회로에서 i번째 정점&lt;/li&gt;
  &lt;li&gt;path[0] = 1&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hamiltonian(G[][], i)
// 입력: i - 그래프의 정점
//      G[0 .. n - 1][0 .. n - 1] - 그래프의 인접 행렬
// 출력: 해밀토니안 회로
1 if (valid(G,i))
2   if ( i = n - 1) { path[0 .. n - 1]을 출력한다; return}
5   else // i번째로 방문할 정점을 모든 정점을 시도해 본다
6       for( j = 2; j &amp;lt;= n; j++){
7           path[i + 1] = j
8           hamiltonian(G,i + 1)
    }
// 최초 호출: hamiltonian(G, 0)

boolean valid(G[][], i) // 경로상의 i번째 정점이 유효한 선택인지 확인
1 if(i = n - 1 and G[path[n-1]-1][path[0] - 1] = 0)
    // 경로상의 마지막 정저이 첫 번째 정점과 인접하지 않은 경우
2   return false
3 else if( i &amp;gt; 0 and G[path[i - 1]- 1][path[i] - 1] = 0)
    // 경로상의 i번째 정점이 이미 선택되었는지를 확인
4   return false
5 else { // 경로상의 j번째 정점이 이미 선택되었는지를 확인
6    j = 1
7    while(j &amp;lt; i){
8       if(path[i] = path[j]) return false
9       j++ }
    }
10 return true

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;시간 복잡도: O($n^n)$&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;그래프 색칠하기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;m-색칠하기 문제: 무방향 그래프에서 최대 m(&amp;gt;1)개의 색들을 사용하여 인접한 정점들을 서로 다른 색으로 칠하라&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;응용 분야: 지도 색칠하기&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;지도에서 각 국가는 그래프에서 한 정점으로 나타내고 국경을 맞대고 있는 두 개의 국가들은 대응하는 정점들 사이의 간선으로 나타내면 모든 지도는 그에 상응하는 평면 그래프로 표현할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag20.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;m-색칠하기 상태 공간 트리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;수준 i, 1&amp;lt;=i&amp;lt;=n,에서 정점 i에 가능한 m개의 색들을 각각 시도해 본다(n은 정점들의 수)&lt;/li&gt;
  &lt;li&gt;루트 노드에서 종단 노드까지의 경로가 각각 후보 해가 된다. 이 경로상의 어떤 두 개의 인접한 정점들이 같은 색인지를 확인하여 같은 색이면 그 경로는 더 이상 고려하지 않고 가지 친다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;m-색칠하기 되추적 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;n: 정점들의 수&lt;/li&gt;
  &lt;li&gt;m: 색들의 수&lt;/li&gt;
  &lt;li&gt;i, 1&amp;lt;= i &amp;lt;= n: 정점의 번호&lt;/li&gt;
  &lt;li&gt;1: 시작 정점&lt;/li&gt;
  &lt;li&gt;그래프 G = (V,E)는 인접 행렬 G로 표현한다
    &lt;ul&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;G[i-1][j-1] = {1, (i,j) $\in$ E&lt;/td&gt;
              &lt;td&gt;0, (i,j) $\notin$ E}&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;vcolor[i], 1&amp;lt;=i&amp;lt;=n: 정점 i에 칠해진 색&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;m_coloring(G[][], i)
// 입력: G[0 .. n - 1][0 .. n - 1] - 그래프의 인접 행렬
//      i - 그래프의 정점
// 출력: vcolor[1..n] - 정점들에 칠해진 색들의 배열
1 if (valid(G, i))
2   if ( i = n){
3       vcolor[1 .. n] 을 출력한다
4       return
5   } else { //다음 정점에 모든 색을 시도해 본다
6       for( c = 1; c &amp;lt;= m; c++){
7           vcolor[i + 1] = c
8           m_coloring(G, i + 1) }
    }
// 최초 호출: hamiltonian(G,0)

// 정점 i에 칠해진 색이 유효한지 확인한다
boolean valid(int G[][], i)
1 j = 1
2 while(j &amp;lt; i){
    // i의 색이 인접한 정점(들)의 색과 같은지 확인
3   if (G[i - 1][j - 1] = 1 and vcolor[i] = vcolor[j])
4       return false
5   j++
    }
6 return true

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;시간복잡도: O($m^n$)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="algorithm" /><summary type="html">되추적</summary></entry><entry><title type="html">Key Management (KDC &amp;amp; CA)</title><link href="https://lee989898.github.io/sc-13" rel="alternate" type="text/html" title="Key Management (KDC &amp;amp; CA)" /><published>2021-11-11T01:06:00+09:00</published><updated>2021-11-11T01:06:00+09:00</updated><id>https://lee989898.github.io/sc-13</id><content type="html" xml:base="https://lee989898.github.io/sc-13">&lt;h3 id=&quot;key-management-kdc--ca&quot;&gt;&lt;strong&gt;Key Management (KDC &amp;amp; CA)&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Session Key&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Session: 회기, 입회기간&lt;/li&gt;
  &lt;li&gt;통신 seesion이 시작될 때 생성되서 종료될때 폐기되는 동적 대칭키&lt;/li&gt;
  &lt;li&gt;통신 session마다 다른 키를 사용하면 안전&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;다중사용자가 세션키사용 할 경우&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;2명의 사용자 간에 1개의 비밀키 사용&lt;/li&gt;
  &lt;li&gt;3명의 사용자 간에 3개의 비밀키 사용&lt;/li&gt;
  &lt;li&gt;사용자 1명 추가 시 3개의 비밀키가 추가로 필요&lt;/li&gt;
  &lt;li&gt;n명이면 n(n-1)/2 만큼의 키가 필요&lt;/li&gt;
  &lt;li&gt;대칭키 유지 및 관리 부하&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;KDC (Key Distribution Centre)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;중앙의 신뢰할 수 있는 키관리, 분배 책임주체&lt;/li&gt;
  &lt;li&gt;사용자들은 KDC 등록신청하면, KDC가 각 사용자들과 비밀키를 공유&lt;/li&gt;
  &lt;li&gt;각 사용자는 이 키를 사용하여 KDC와 통신한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc23.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Operation&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Alice와 Bob은 KDC와의 통신을 위한 $K_{A-KDC}$, $K_{B-KDC}$ 를 알고 있다. Alice는 KDC와 통신하여 세션키 R1 과 $K_{B-KDC}$(A,R1)을 얻는다.
Alice는 Bob에게 $K_{B-KDC}$(A,R1)을 보내고 Bob은 R1을 추출해낸다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;KDC 장단점&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;KDC의 장점
    &lt;ul&gt;
      &lt;li&gt;비밀키 방식은 비교적 속도가 빠름&lt;/li&gt;
      &lt;li&gt;서버를 사용하지 않는 경우보다 키 관리를 쉽게 해줌&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;KDC의 단점
    &lt;ul&gt;
      &lt;li&gt;단일 실패 지점 (SPoF, Single Point of Failure)
        &lt;ul&gt;
          &lt;li&gt;KDC가 고장나면 전혀 서비스를 할 수 없음&lt;/li&gt;
          &lt;li&gt;해결책: 미러 서버 가동
            &lt;ul&gt;
              &lt;li&gt;서버와 미러간의 일관성 문제 발생 가능&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;+KDC가 공격되면 모든 비밀키가 노출될 수 있음&lt;/li&gt;
      &lt;li&gt;KDC의 신뢰성이 매우 중요함&lt;/li&gt;
      &lt;li&gt;KDC에 대한 병목현상 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hierarchical Key Control&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;단일 KDC는 대규모 네트워크에서 비효율적&lt;/li&gt;
  &lt;li&gt;KDC를 계층화
    &lt;ul&gt;
      &lt;li&gt;local KDC
        &lt;ul&gt;
          &lt;li&gt;single LAN or building&lt;/li&gt;
          &lt;li&gt;같은 domain 에서의 통신시 키 분배&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;global KDC
        &lt;ul&gt;
          &lt;li&gt;다른 domain 간의 통신시 키 선택&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;KDC의 손상시 지역에 한정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;CA (Certification Authorities)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;for public key cryptography&lt;/li&gt;
  &lt;li&gt;전자서명을 위해선 신뢰성 있는 공개키 보관장소 필요 해커가 다른 사용자의 공개키를 자기것인 척 하는 것을 방지&lt;/li&gt;
  &lt;li&gt;공인인증서의 발급과 관리하는 기관&lt;/li&gt;
  &lt;li&gt;Role
    &lt;ul&gt;
      &lt;li&gt;사용자들의 공개키를 저장하고 관리&lt;/li&gt;
      &lt;li&gt;사용자들이 요청시 해당 공개키를 서명해서 전송(public key certificate, 공개키 인증서)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Operation&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Bob은 CA에 공개 키를 등록한다
    &lt;ul&gt;
      &lt;li&gt;Bob은 CA에 신원증멸 을 제공한다&lt;/li&gt;
      &lt;li&gt;CA는 Bob을 공개 키에 바인딩하는 인증서를 생성한다&lt;/li&gt;
      &lt;li&gt;CA가 디지털 서명한 Bob의 공개 키를 포함하는 인증서: CA는 “이것은 B의 공개 키이다”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Alice가 Bob의 공개 키를 원할 때:
    &lt;ul&gt;
      &lt;li&gt;Bob의 인증서를 얻는다.&lt;/li&gt;
      &lt;li&gt;CA의 공개 키를 Bob의 인증서에 적용하고 Bob의 공개 키를 가져온다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;공개키 인증서 (공인인증서, Public Key Certificate)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;특정 공개키가 해당 사용자의 공개키임을 신뢰할수있는 기관에서 보증하는 문서 -&amp;gt; 사용자 인증&lt;/li&gt;
  &lt;li&gt;사용자 공개키에 공인인증기관의 전자서명을 첨부한 것&lt;/li&gt;
  &lt;li&gt;4요소
    &lt;ul&gt;
      &lt;li&gt;공개키인증서: 공개키가 누구것인지, 대칭되는 비밀키는 누가 갖고있는지&lt;/li&gt;
      &lt;li&gt;인증서정책: 인증서 사용방식&lt;/li&gt;
      &lt;li&gt;인증서경로: 인증서를 연결하는 방식&lt;/li&gt;
      &lt;li&gt;인증서 철회리스트: 유효성확인&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;공개키 기반구조 (PKI, Public key Infrastructure)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;정의​
    &lt;ul&gt;
      &lt;li&gt;공개키 방식을 통해 암호화 및 전자서명/인증서의 사용을 가능하도록 해주는 기반구조로 X.509(표준), PGP, AADS/X9.59 등 있다​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;​구성 요소​
    &lt;ul&gt;
      &lt;li&gt;사용자 : 개인이나 기관 또는 응용 서비스​&lt;/li&gt;
      &lt;li&gt;인증기관(CA) : 공개키 인증서발급 및 관리​&lt;/li&gt;
      &lt;li&gt;등록기관(registration authority: RA): 사용자 인증서 신청시 인증기관대신 신분확인​&lt;/li&gt;
      &lt;li&gt;저장소(repository): 인증서,사용자정보,인증서취소,상호인증서 등을 저장 검색​&lt;/li&gt;
      &lt;li&gt;인증서정책(policy): 권한, 사용범위 정의​&lt;/li&gt;
      &lt;li&gt;공개키인증서​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;국내 인증기관(CA)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;전자서명법​
    &lt;ul&gt;
      &lt;li&gt;공인인증서: 전자서명을 생성하기 위하여 이용된 정보가 가입자에게 유일하게 속한다는 사실등을 확인하고 증명하는 전자정보. 이름, 유효기관, 발급기관, 전자서명방식, 인증번호등 포함​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;공인인증기관(CA) : 공인인증서의 발급과 관리를 담당하는 기관으로 금융결제원, 한국정보인증, 한국증권전산, 한국전자인증, 한국전산원, 한국무역정보통신, 코스콤​&lt;/li&gt;
  &lt;li&gt;주요역할​
    &lt;ul&gt;
      &lt;li&gt;공개키와 비밀키 생성, 인증서 발급/폐지​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;등록기관(RA, Registration Authority)​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;인증기관의 위임을 받아 사용자가 신청시 신원확인 및 공개키 생성/등록을 수행&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;국내 공인 인증서 발급절차​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;발급기관(CA or RA)에 공인인증서 발급신청(직접방문, 신분증제출)​&lt;/li&gt;
  &lt;li&gt;발급기관에서 등록확인서 발급 (참조번호, 인가코드)​&lt;/li&gt;
  &lt;li&gt;발급기관 홈페이지접속해서 공인인증서 발급 신청​&lt;/li&gt;
  &lt;li&gt;공인인증서 파일이 발급​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="security" /><summary type="html">Key Management (KDC &amp;amp; CA)</summary></entry><entry><title type="html">Concurrency</title><link href="https://lee989898.github.io/pl-18" rel="alternate" type="text/html" title="Concurrency" /><published>2021-11-10T19:18:00+09:00</published><updated>2021-11-10T19:18:00+09:00</updated><id>https://lee989898.github.io/pl-18</id><content type="html" xml:base="https://lee989898.github.io/pl-18">&lt;h3 id=&quot;comcurrency&quot;&gt;&lt;strong&gt;Comcurrency&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Concurrency&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;동시 실행은
    &lt;ul&gt;
      &lt;li&gt;인스트럭션 수준&lt;/li&gt;
      &lt;li&gt;문장 수준&lt;/li&gt;
      &lt;li&gt;서브프로그램 수준&lt;/li&gt;
      &lt;li&gt;프로그램 수준​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이렇게 4개 수준에서 이루어 질 수 있다.&lt;br /&gt;
인스트럭션 수준에서는 두개 이상의 머신 인스트럭션을 동시에 실행한다. ​
문장 수준에서는 두개 이상의 고급언어 문장을 동시에 실행한다. ​&lt;br /&gt;
서브프로그램 수준에서는 두개 이산의 서브프로그램을 동시에 실행한다.&lt;br /&gt;
프로그램 수준에서는 두개 이상의 프로그램을 동시에 실행한다. ​&lt;/p&gt;

&lt;p&gt;동시 실행 통제 메커니즘은 프로그래밍의 유연성을 증가시킨다.&lt;br /&gt;
동시 실행 통제 메커니즘은 원래 운영체제의 문제를 풀기 위해 발명되었으나, ​다양한 응용 프로그램에서도 요구된다.&lt;/p&gt;

&lt;p&gt;프로그램 수준의 동시 실행 사례는 웹에서 볼 수 있다.&lt;br /&gt;
웹 브라우저는 다음과 같은 여러가지 기능을 동시에 실행해야 한다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;웹 서버에게 데이터를 주고 받기 ​&lt;/li&gt;
  &lt;li&gt;텍스트와 이미지를 스크린에 렌더링하기​&lt;/li&gt;
  &lt;li&gt;마우스와 키보드에 의한 사용자 액션에 대응하기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;IE9는 별도의 코어를 사용하여 클라이언트 측의 스크립트 코드를 인터프러터 방식으로 처리한다.  ​&lt;/p&gt;

&lt;p&gt;문장 수준의 동시 실행은 프로그램 수준의 경우와 매우 다르다.&lt;br /&gt;
언어 설계자는 문장 수준의 동시 실행을 위해 다음에 대해 중점을 둔다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;데이터를 다수의 메모리에 어떻게 분산시킬 것인가? ​&lt;/li&gt;
  &lt;li&gt;어느 문장을 동시 실행할 것인가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;동시 실행 알고리즘은 확장성이 있어야 한다.&lt;br /&gt;
사용하는 프로세서의 수를 증가시킬수록 실행 속도가 증가하면, ​ 확장성이 있다고 말한다.&lt;/p&gt;

&lt;p&gt;알고리즘은 이식성이 있어야 한다.&lt;br /&gt;
알고리듬이 다른 아키텍처의 기계에서 효율적으로 실행된다면, ​ 
이 알고리듬은 이식성이 있다고 말한다.&lt;br /&gt;
이식성은 하드웨어의 수명이 비교적 짧아지고 있어서, 매우 중요하다.&lt;/p&gt;

&lt;p&gt;플린은 컴퓨터를 다음과 같이 분류하였다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SISD는 하나의 인스트럭션이 하나의 데이터를 처리하는 것으로, ​
프로세서가 하나인 컴퓨터가 이에 속한다. ​&lt;/li&gt;
  &lt;li&gt;SIMD는 하나의 인스트럭션으로 여러 데이터를 처리한다. ​
벡터 프로세서가 이에 속하며, 벡터 프로세서는 ​
벡터 연산자의 여러 오퍼랜드를 저장하는 여러 개의 레지스터를 갖고 있어서, ​
이들 여러 오퍼랜드에 대해 하나의 인스트럭션을 실행한다.  ​&lt;/li&gt;
  &lt;li&gt;MISD는 하나의 데이터에 대해 다수의 인스트럭션을 차례로 동시 실행한다. ​마치 파이프라인처럼… 파이프라인 컴퓨터가 이에 속한다. ​&lt;/li&gt;
  &lt;li&gt;MIMD는 다수의 인스트럭션이 다수의 데이터를 동시 실행한다. ​
MIMD는 여러 개의 프로세서로 구성되며, 각 프로세서는 자신의 인스트럭션 스트림을 처리한다. ​MIMD 컴퓨터에는 분산형과 공유 메모리형, 두가지 유형이 있다. ​
분산 MIMD 머신은 하나의 랙에 구성되거나 각 지역에 분산되어 구성되며, ​각 프로세서는 자신의 고유 메모리를 갖는다. ​
공유메모리 MIMD 머신은 여러 프로세서가 하나의 메모리를 공유하며, ​
메모리 액세스의 충돌을 방지하기 위한 동기화 수단을 제공해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;플린의 분류에 따라, 각각의 머신을 그림으로 표현하면 이 아래 그림과 같다. PU는 프로세싱 유닛으로 싱글 코어 및 멀티코어 프로세서이다.&lt;/p&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl48.png&quot; width=&quot;25%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;동시 실행을 필요로 하는 이유는 다음과 같다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로그램이 하드웨어를 동시에 사용하도록 설계되었다면, ​
멀티 프로세서 머신에서 프로그램의 실행 속도는 빠르다.  ​&lt;/li&gt;
  &lt;li&gt;프로그램이 컴퓨트 바운드가 아니라면, ​
싱글 프로세서 머신에서 실행하더라도, ​
동시 실행하도록 짜여진 프로그램은 순차 실행하도록 짜여진 프로그램보다 빠르다. ​&lt;/li&gt;
  &lt;li&gt;동시 실행은 문제 해결책에 대한 다른 방식의 개념화 방법을 제공한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;문제의 해결책을 설계할 때 Recursion이 자연스러운 방법인 경우가 있는 것처럼, ​동시 실행이 자연스러운 문제가 많이 있다. ​
예를 들어 시뮬레이션은 여러 개의 엔티티를 포함하고, ​
여러 엔티티가 자신에게 주어진 역할을 수행한다. ​
이때 각 엔티티는 서로 종속되어 있지 않기 때문에 동시 실행이 가능하다.  ​
이와 같이 문제에 따라서 동시 실행이 자연스러운 경우가 있다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;어플리케이션 프로그램을 여러 머신에 분산시켜야 하는 경우가 있다.  ​이때, 각 머신은 특정 타스크(동시 실행 통제 메커니즘)를 실행하면서, 프로그램 실행을 동기화해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Semaphore&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;프로그램이 여러 서브프로그램으로 구성되어 있을 때, ​
동일 프로그램 내의 다른 서브프로그램과 동시 실행되는 서브프로그램을 
Task 또는 Process라고 한다. ​&lt;/p&gt;

&lt;p&gt;자바에서는 특정 메소드, 즉 run method가 Task의 역할을 하며, ​
이 메소드는 쓰레드라고 불리는 객체 내에서 실행된다.  ​
​
동시 실행되는 Task들 간에 실행 순서를 통제하는 것을 동기화라고 한다.&lt;br /&gt;
협력적 동기화는 타스크 A가 Task B의 종료를 기다렸다가, Task B의 종료 후 Task A가 실행하는 방식으로, 실행 순서를 통제한다.&lt;br /&gt;
경쟁적 동기화는 Task A, B가 공유 변수(데이터 위치) x를 접근할 필요가 있다면, ​Task B가 x를 접근하고 있는 동안, ​&lt;/p&gt;

&lt;p&gt;Task A는 Task B가 x의 접근을 종료하기를 기다리는 방식으로 실행 순서를 통제한다.&lt;/p&gt;

&lt;p&gt;가장 단순한 형태의 협력적 동기화의 예로 생산자-소비자 문제를 들 수 있다. ​&lt;/p&gt;

&lt;p&gt;하나의 서브 프로그램(생산자)이 데이터를 생산하고, ​다른 서브프로그램(소비자)이 그것을 소비한다.&lt;br /&gt;
생산된 데이터는 보통 스토리지 버퍼에 저장된다. ​&lt;/p&gt;

&lt;p&gt;경쟁적 동기화는 두 Task가 정확히 동시에 공유 변수에 대한 접근을 방지해야 한다.​&lt;/p&gt;

&lt;p&gt;만일 TOTAL이 공유 변수이고, ​
Task A가 TOTAL+1, Task B가 TOTAL*2라면, ​
Task A, B가 동시에 TOTAL을 변경하고자 한다면, ​
이들 간에 공유 변수에 대한 레이스 컨디션이 발생한다.&lt;br /&gt;
이를 해결하기 위해 상호배제를 보장해 줘야 하는데, ​이때 데드락이 발생할 수 있다. 따라서 데드락 방지책도 함께 제공해야한다&lt;/p&gt;

&lt;p&gt;동시 실행을 위한 언어 설계 시, 고려사항은 다음과 같다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;경쟁 및 협업 동기화​&lt;/li&gt;
  &lt;li&gt;Task 스케줄링​&lt;/li&gt;
  &lt;li&gt;Task를 언제 어떻게 생성하고, Task의 실행을 언제 어떻게 시작 및 종료시킬 것인가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;세마포어는 Task 동기화에 사용되는 단순한 메커니즘이다.&lt;br /&gt;
세마포어는 카운터(정수)와 Task 서술자를 저장하는 큐로 구성되며, ​
Task 서술자는 Task 실행 상태에 관한 모든 관련 정보를 저장한다.&lt;br /&gt;
연산자는 wait, release가 있다.&lt;/p&gt;

&lt;p&gt;협력 동기화를 위한 세마포어 변수는 다음과 같다.&lt;br /&gt;
엠티스팟 세마포어는 엠티스팟 카운터와 엠티스팟 큐로 구성되며, ​&lt;/p&gt;

&lt;p&gt;풀스팟 세마포어는 풀스팟 카운터와 풀스팟 튜로 구성된다.&lt;br /&gt;
엠티스팟 카운터는 버퍼의 비어있는 칸의 수를 나타내고,​
풀 카운터는 버퍼의 채워진 칸의 수를 나타낸다. ​
 ​
엠티스팟 큐는 버퍼에 빈칸이 생기기(즉, 아이템이 나가기)를 기다리는 생산자의 Task를 저장하고, 풀스팟 큐는 버퍼에 아이템이 채워지기를 기다리는 소비자의 Task를 저장한다.&lt;/p&gt;

&lt;p&gt;협력 동기화를 위해 필요한 공유 버퍼에 대한 연산자는 ​
디파짓과 펫치가 있다. ​&lt;/p&gt;

&lt;p&gt;먼저 디파짓을 살펴 보면, ​
디파짓은 공유 버퍼에 데이터를 넣기 위한 생산자의 액션으로 다음과 같이 진행된다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;버퍼에 빈칸이 있는지 엠티스팟 세마포어를 검사한다. ​&lt;/li&gt;
  &lt;li&gt;만일 적어도 하나 있으면, 디파짓을 실행하고, 엠티스팟의 카운터를 -1 하고, 풀스팟의 카운터를 +1한다. (버퍼에 채워진 칸이 하나 이상 있다는 것을 나타냄)​&lt;/li&gt;
  &lt;li&gt;만일 버퍼가 꽉차면, 엠티스팟 큐에 생산자의 타스크 서술자를 넣고, 버퍼에 빈칸이 생길 때까지 기다린다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음, 펫치를 살펴 보자.&lt;br /&gt;
펫치는 버퍼로부터 데이터를 빼내기 위한 소비자의 액션으로 다음과 같이 진행된다.&lt;br /&gt;
버퍼가 비어있지 않은지 풀스팟 세마포어를 검사한다.&lt;br /&gt;
만일 비어있지 않다면, 펫치를 실행하고(버퍼로부터 데이터를 빼내고), 엠티스팟 카운터를 -1하고, 풀스팟 카운터를 +1한다.&lt;br /&gt;
만일 버퍼가 비어있다면, 풀스팟 큐에 소비자의 타스크 서술자를 넣고, 데이터가 생길 때까지 기다린다.&lt;/p&gt;

&lt;p&gt;앞의 버퍼에 대한 연산에서 보았듯이, 디파짓과 펫치는 ​
세마포어의 카운터와 버퍼에 대한 조작(+, -, 디파짓, 펫치)을 수반한다. ​
 ​
디파짓과 펫치는, ​
이 연산을 세마포어에 대해 직접 수행할 수 있지만, ​
세마포어에 대한 ‘연산’을 별도로 정의하고,  ​
이를 통해 세마포어 조작을 간접적으로 수행하기도 한다. ​&lt;/p&gt;

&lt;p&gt;이때 세마포어에 대한 연산은 wait(빨간불)과 release(초록불)이다. ​
wait에서, 카운터가 0보다 크면 카운터 -1한다. ​
만일 카운터가 0보다 크지 않으면, 큐에 Task 서술자를 넣고 기다린다. ​
release에서, 큐가 비어 있으면, 카운터를 +1한다. ​
만일 큐가 비어 있지 않으면, 큐에서 Task를 빼서 실행한다.&lt;/p&gt;

&lt;p&gt;컴피티션이 언제 어디에서 일어나는가? ​
Shared variable을 서로 갱신하겠다고 동시에 요청할 때 발생한다.&lt;br /&gt;
이때 shared variable에 대한 mutual exclusion(상호배제)를 위해 ​
별도의 세마포어가 필요하다.&lt;br /&gt;
그런데 이 세마포어는 카운터가 필요없다.&lt;br /&gt;
이러한 이유로 이진 세마포어로 정의한다. ​&lt;/p&gt;

&lt;p&gt;만일 앞의 shared buffer의 협력적 동기화 문제에서, ​
한번에 하나의 타스크만 버퍼에 접근할 수 있다고 제한한다면, ​
Shared buffer에 대한 별도의 이진 세마포어가 필요하다. ​&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Monitor&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;세마포어의 사용은 동기화의 신뢰성 문제를 야기한다.&lt;/p&gt;

&lt;p&gt;모니터는 이와 같이 동기화의 신뢰성 문제를 해결하기 위한 방법으로, ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;공유 데이터 구조를 연산자로 캡슐화하여 ​&lt;/li&gt;
  &lt;li&gt;프로그래머로부터 공유 데이터구조의 상세 사항을 숨긴다.&lt;br /&gt;
이렇게 하여 동기화에 대한 책임을 런타임 시스템으로 돌린다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;모니터는 class로 구현될 수 있다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;공유 데이터 타입을 갖는 추상 데이터 타입으로 표현 ​&lt;/li&gt;
  &lt;li&gt;이 클래스의 객체에 대한 접근은 액세스 메소드에 동기화 modifier를 추가하여 통제한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;모니터는 concurrent pascal, ada, java 등에서 지원된다.&lt;/p&gt;

&lt;p&gt;사용자 프로그램은 모니터를 사용하여 공유 버퍼에 접근한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;공유 데이터는 사용자 프로그램 안에 없고, 모니터 안에 있다. ​&lt;/li&gt;
  &lt;li&gt;액세스 메커니즘은 모니터(런타임 시스템)의 일부분으로, 상호 배제를 보장한다. 즉, 모니터가 바쁠 땐, 모니터에 대한 호출이 block되고 큐에 들어가서 기다린다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl49.png&quot; width=&quot;25%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 모니터를 표현한 것이다. ​
모니터는 상호배제만을 제공하기 때문에, ​
협력 동기화에서 요구되는 프로세스 간의 협력은 프로그래머가 코딩해야 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;자바 쓰레드&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;쓰레드는 run 메소드를 실행하는 프로세스이다.&lt;br /&gt;
즉, run 메소드는 쓰레드에 할당되어야 실행된다.&lt;br /&gt;
쓰레드 클라스는 쓰레드가 아닌 다른 클라스의 부모가 될 수 없고, ​쓰레드의 서브 클래스에게 서비스를 제공한다. ​&lt;/p&gt;

&lt;p&gt;Run method는 자바에서 동시 실행 단위로서, ​
Run 메소드 코드는 main 메소드, 다른 run 메소드 등과 동시 실행 된다. ​&lt;/p&gt;

&lt;p&gt;Run 메소드로 클라스를 정의하는 방법은 두 가지가 있다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;첫째 방법은, 쓰레드 클래스의 서브클래스를 정의하여 서브 클라스의 run 메소드로 오버라이드하는 방법이다. 만일 새로운 서브 클래스가 다른 부모를 갖고 있으면, 이 방법은 동작하지 않는다. ​&lt;/li&gt;
  &lt;li&gt;둘째 방법은, 다른 부모로부터 상속된 서브 클래스를 정의하고 runnable 인터페이스를 구현하는 방법이다. Runnable은 run 메소드 프로토콜을 제공하기 때문에, runnable로 구현된 어떤 클래스도 run 메소드를 정의한다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정리하면, 쓰레드 클래스는 다른 클라스의 부모가 될 수 없기 때문에, ​
어플리케이션 클라스의 메소드를 쓰레드로 실행하려면 runnable로 실행해야 한다. ​&lt;/p&gt;

&lt;p&gt;​쓰레드 클라스는 동시 실행 자바 프로그램을 생성한다.&lt;br /&gt;
쓰레드 클라스는 컨스트럭트, 메소드 등으로 구성된다. ​&lt;/p&gt;

&lt;p&gt;쓰레드 클라스의 메소드는 ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Run 메소드는 쓰레드의 액션을 서술한다. ​&lt;/li&gt;
  &lt;li&gt;Start 메소드는 run 메소드를 호출하여, 그 쓰레드의 동시 실행을 시작한다.​&lt;/li&gt;
  &lt;li&gt;setPriority 메소드는 쓰레드의 우선순위를 변경하고 ​&lt;/li&gt;
  &lt;li&gt;getPriority 메소드는 쓰레드의 현재 우선순위를 반환한다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​아래 코드는 run 메소드로 쓰레드의 액션을 서술하고, ​
Start 메소드로 그 쓰레드의 동시 실행을 시작하는 것을 보여준다.&lt;/p&gt;

&lt;p&gt;Yield 메소드는 동시 실행중인 쓰레드로부터 프로세서의 자발적인 포기를 요구한다.&lt;br /&gt;
이 쓰레드는 즉시 프로세서를 포기하고 ready 큐로 들어 간다.&lt;br /&gt;
Sleep 메소드는 쓰레드가 지정된 시간이 지난 후에 block되기를 원한다.&lt;br /&gt;
이 쓰레드는 ready 큐에 들어간다. ​
Join 메소드는 메소드에게, ​다른 쓰레드의 run 메소드가 종료될 때까지, ​실행을 msec 단위로 지연시킬 것을 강요한다.  ​
아래 코드는 join 메소드의 사용 예를 보여준다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void run() {​

 
 Thread myTh = new Thread();​

 myTh.start();​

 // do part of the computation of this thread​

 myTh.join(); // Wait for myTh to complete​

 // do the rest of the computation of this thread​

}​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;세마포어 클라스는 카운팅 세마포어를 구현한다.&lt;br /&gt;
객체는 카운터만 있고, 큐는 없다.&lt;br /&gt;
메소드는 acquire 메소드(wait)와 release(release) 메소드가 있다.&lt;br /&gt;
아래 코드는 이들 메소드의 사용 예를 보여주고 있다.&lt;br /&gt;
디파짓과 펫치의 앞뒤에 이들 메소드가 있음을 주의하라. ​&lt;/p&gt;

&lt;p&gt;acquire()는 세마포어 -1 한다. ​
release()는 세마포어 +1 한다.&lt;br /&gt;
여기서 세마포어는 fullspot, emptyspot이다.&lt;/p&gt;

&lt;p&gt;자바 쓰레드에서 상호배제는 모니터 개념으로 구현한다.&lt;br /&gt;
이때 메소드는 synchronize로 지정된다.&lt;br /&gt;
ManageBuf에서 디파짓과 펫치를 synchronize로 정의하여, ​
동일한 객체에 대해 실행할 때 서로 방해하는 것을 방지한다. ​&lt;/p&gt;

&lt;p&gt;아래 코드는 모니터 개념으로 구현된 ManageBuf에서 ​
메소드가 synchronized로 지정된 예를 보여준다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ManageBuf {​

  private int [100] buf;​

   . . .​

  public synchronized void deposit(int item) { . . . }​

  public synchronized int fetch() { . . . }​

   . . .​

}​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;모니터는 상호배제를 구현하므로, 프로세스 간의 협력적 동기화를 구현하지 못한다.&lt;br /&gt;
따라서 프로세스 간의 협력 동기화의 구현을 위해, ​쓰레드 대기 리스트(wait list of threads)와 wait, notify, notifyAll을 구현한다.&lt;br /&gt;
각각의 객체(P-C 문제에서 producer, consumer가 객체)는 쓰레드 대기 리스트를 가지며, ​대기 리스트에 있는 쓰레드들은 이 객체로부터 자신의 실행에 필요한 ​이벤트를 기다리고 있는 것이다.&lt;br /&gt;
wait 메소드는 쓰레드를 대기 리스트에 넣고 기다리게 한다.&lt;br /&gt;
Notify 메소드는 어떤 대기 쓰레드에게 ‘기다리고 있는 이벤트가 발생했음’을 알린다. ​ 
Notify 메소드가 특정 쓰레드를 깨울 수는 없고, ​JVM이 쓰레드 대기 리스트에서 무작위로 하나를 선택한다.&lt;br /&gt;
NotifyAll 메소드는 ‘객체에서 발생된 이벤트’를 기다리고 있는 쓰레드를 ​모두 깨워서 task-ready queue에 넣는다.&lt;br /&gt;
이렇게 하는 이유는 대기 리스트에 있는 쓰레드들이 기다리고 있는 조건이 ​모두 다를 수 있기 때문이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;자바 쓰레드: Lock&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;자바 쓰레드는 lock을 지원한다.&lt;br /&gt;
자바 쓰레드에 미리 정의된 ReentrantLock 클라스는 ​Lock 인터페이스를 구현하는 데 사용되며, ​lock 인터페이스는 lock, unlock, tryLock 메소드를 선언한다.&lt;br /&gt;
lock 메소드는 try 블록을 사용하여 크리티칼 코드(크리티칼 섹션)를 둘러싼다.&lt;br /&gt;
unlock 메소드의 호출은 finally 절 안에 있어야 하며, lock의 해제를 보장한다.  ​&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Statement-Level Concurrency&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;고성능 포트란에서 두 개의 리스트에서 ​서로 대응되는 요소 간의 연산을 병렬 처리하고자 할 때 다음과 같은 문장이 추가된다.&lt;br /&gt;
PROCESSOR proc(n) -&amp;gt; 배열 처리 문장을 동시 실행(병렬 처리)하기 위해 프로세서 n개를 할당 ​DISTRIBUTE (BLOCK vs. CYCLIC) -&amp;gt; 같은 크기의 블록으로 나누어져 프로세서에 할당, 돌아가면서 하나씩 프로세서에 할당 ​ALIGN array1_elt WITH array2_elt -&amp;gt; 배열1에 배열2를 대응시킴&lt;/p&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="pl" /><summary type="html">Comcurrency</summary></entry><entry><title type="html">NP-완전</title><link href="https://lee989898.github.io/algorithm-06" rel="alternate" type="text/html" title="NP-완전" /><published>2021-11-09T01:09:00+09:00</published><updated>2021-11-09T01:09:00+09:00</updated><id>https://lee989898.github.io/algorithm-06</id><content type="html" xml:base="https://lee989898.github.io/algorithm-06">&lt;h3 id=&quot;np-완전&quot;&gt;&lt;strong&gt;NP-완전&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;문제의 분류&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;풀 수 있는(solvable) 문제​
    &lt;ul&gt;
      &lt;li&gt;P 문제: 다항 시간 내에 풀 수 있는 문제 ​&lt;/li&gt;
      &lt;li&gt;NP 문제: 다항 시간 내에 풀 수 없는 문제​
        &lt;ul&gt;
          &lt;li&gt;비결정론적 다항 시간 알고리즘으로 해결할 수 있는 문제​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;NP-완전 문제: 지수 시간 내에 풀 수 있는 문제​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;풀 수 없는(unsolvable) 문제​
    &lt;ul&gt;
      &lt;li&gt;예: 정지 문제(Halting Problem)​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag14.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;결정 문제​
    &lt;ul&gt;
      &lt;li&gt;Yes 혹은 No의 해를 요구하는 문제​&lt;/li&gt;
      &lt;li&gt;예: 무방향그래프의 정점 s 에서 정점 f 까지 가는 경로의 거리가 K(상수) 이하인 경로가 있는가?​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최적화 문제​
    &lt;ul&gt;
      &lt;li&gt;최적의 해를 요구하는 문제​&lt;/li&gt;
      &lt;li&gt;예: 무방향그래프의 정점 s 에서 정점 f 까지 가는 최단 경로의 거리는 얼마인가?​&lt;/li&gt;
      &lt;li&gt;최적화 문제는 모두 대응하는 결정 문제로 바꾼 다음 해결한다.​&lt;/li&gt;
      &lt;li&gt;최적화 문제는 대응하는 결정 문제보다 풀기가 쉽지 않다. ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;비결정론적 다항 시간 알고리즘에 의해 해결할 수 있는 결정 문제들의 집합​&lt;/li&gt;
  &lt;li&gt;비결정론적 다항 시간 알고리즘이란?​
    &lt;ul&gt;
      &lt;li&gt;한 결정 문제의 사례 I를 입력으로 받아 다음을 수행하는 2 단계 알고리즘​&lt;/li&gt;
      &lt;li&gt;비결정론적 ‘추측’ 단계: 주어진 사례 I에 대한 해 S를 ‘추측’한다.​&lt;/li&gt;
      &lt;li&gt;결정론적 ‘확인’ 단계: 사례 I와 해 S를 입력으로 받아 S가 I에  대한 해임을 결정론적 다항 시간에 확인하고 그 해가 맞으면 ‘Yes’ 라고 답하고 해가 아니라면 ‘No’ 라고 답하거나 알고리즘이 종료되지 않게 한다. ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;NP 문제는 해가 Yes 라는 근거가 주어졌을 때 그 해가 옳은 근거임을 다항 시간에 확인해 줄 수 있다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-완전 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;NP에 속하는 문제​&lt;/li&gt;
  &lt;li&gt;어떤 NP-완전 문제를 다항 시간 알고리즘에 의해 풀 수 있다면 나머지 모든 NP-완전 문제들도 다항 시간 알고리즘에 의해 풀 수 있다.​&lt;/li&gt;
  &lt;li&gt;NP-완전 문제는 결정 문제만으로 국한한다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-완전 문제의 핵심 원리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;결정 문제의 변환을 이용한 해결 과정​
    &lt;ul&gt;
      &lt;li&gt;결정 문제 A를 다항 시간에 해결할 수 있는지 알고 싶다.​&lt;/li&gt;
      &lt;li&gt;가정​
        &lt;ul&gt;
          &lt;li&gt;다항 시간에 해결 가능한 결정 문제 B를 이미 알고 있다.​&lt;/li&gt;
          &lt;li&gt;문제 A를 다항 시간에 문제 B로 변환할 수 있고 문제 B의 해(Yes 혹은 No)가 문제 A의 해와 항상 일치한다.​
            &lt;ol&gt;
              &lt;li&gt;문제 A의 사례를 문제 B의 사례로 변환한다. ​&lt;/li&gt;
              &lt;li&gt;변환된 문제 B의 사례를 문제 B의 알고리즘을 이용하여 해결한다.&lt;br /&gt;
주: 문제 A도 다항 시간에 해결할 수 있다.​&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다항 시간에 해결할 수 있는 결정 문제가 아직까지 발견되지   않았다. 따라서 문제 A를 다항 시간에 해결할 수 있는지는 알 수 없다. ​&lt;/li&gt;
  &lt;li&gt;NP-완전 문제들은 서로 다항 시간에 변환 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-완전 정의&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;결정 문제 D는 다음 조건들을 만족시켜야 한다. ​
    &lt;ol&gt;
      &lt;li&gt;문제 D는 NP에 속한다.​&lt;/li&gt;
      &lt;li&gt;NP에 속한 모든 문제는 다항 시간에 문제 D로  변환 가능하다.​&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-hard&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;NP-완전보다 넓은 범위의 문제를 포함한다. ​&lt;/li&gt;
  &lt;li&gt;문제 A가 다음 조건을 만족하면 NP-hard이다.​
    &lt;ul&gt;
      &lt;li&gt;NP에 속한 모든 문제는 다항 시간에 문제 A로 변환 가능하다. ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;NP-완전 문제는 NP-hard에 속한다. ​&lt;/li&gt;
  &lt;li&gt;NP-hard 문제는 반드시 NP 문제일 필요는 없다.​&lt;/li&gt;
  &lt;li&gt;NP-hard는 최적화 문제도 포함한다.​&lt;/li&gt;
  &lt;li&gt;문제 A가 다음 조건들을 만족하면 NP-완전이다. ​
    &lt;ol&gt;
      &lt;li&gt;A는 NP에 속한다.​&lt;/li&gt;
      &lt;li&gt;A는 NP-hard이다. ​&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag15.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;한 문제가 NP-hard에 속한다는 것을 증명하는 것은 매우 어렵다. 왜냐하면 NP에 속한 모든 문제를 다항 시간에 그 문제로 변환 가능함을 보여야 하기 때문이다. ​&lt;/li&gt;
  &lt;li&gt;정리: 한 NP-hard 문제를 다항 시간에 주어진 문제로 변환 가능하다면 그 문제는 NP-hard에 속한다. ​&lt;/li&gt;
  &lt;li&gt;한 문제가 NP-hard에 속한다는 증명은 이 정리를 이용한다.​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;문제 A의 NP-완전 증명 방법​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;문제 A가 NP에 속함을 보인다.​&lt;/li&gt;
  &lt;li&gt;한 NP-hard 문제 C의 사례를 다항 시간에 문제 A의 사례로 변환하는 알고리즘을 작성한다.​&lt;/li&gt;
  &lt;li&gt;2의 알고리즘을 수행하여 얻은 결과 사례 C와 사례 A의 Yes/No 해가 일치함을 보인다.​&lt;br /&gt;
주: 어떤 문제가 NP-완전 문제임을 증명하는 것은 쉽지 않다. ​&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-완전 문제​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;논리곱 정규형-만족​&lt;/li&gt;
  &lt;li&gt;완전 부분 그래프​&lt;/li&gt;
  &lt;li&gt;정점 커버​&lt;/li&gt;
  &lt;li&gt;부분 집합의 합​&lt;/li&gt;
  &lt;li&gt;그래프 색칠하기​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;논리곱 정규형-만족 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;부울 연산식은 논리곱 정규형으로 표현될 수 있다.&lt;/li&gt;
  &lt;li&gt;문제: 논리곱 정규형의 주어진 부울 연산식의 값이 true가 되도록 부울 연산식의 변수들에 true나 false 값을 할당할 수 있는가?&lt;/li&gt;
  &lt;li&gt;예: a,b,c -부울 변수,$\bar{a}$, $\bar{b}$ , $\bar{c}$ : a,b,c의 역&lt;br /&gt;
부울 연산삭: ($\bar{a}$ $\lor$ $\bar{b}$ $\lor$ c) $\land$ ($\bar{a}$ $\lor$ b) $\land$ (a $\lor$ $\bar{b}$ $\lor$ $\bar{c}$ )
해: a = true, b = true, c = true&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;완전 부분 그래프​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무방향 그래프 내에 있는 최대 크기의 완전 부분 그래프를 찾아라&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/ag/ag16.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;정점 커버​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무방향 그래프 내에 있는 최소 크기의 정점 커버를 찾아라&lt;/li&gt;
  &lt;li&gt;정점 커버: 무방향 그래프에서 각 간선의 양쪽 끝의 두 정점들 중에서 적어도 1개의 정점을 포함하는 정점들의 집합&lt;/li&gt;
  &lt;li&gt;예: 아래 그래프에서 최소 크기의 정점 커버 C = {a,c,e}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/ag/ag17.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;부분 집합의 합 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;정수들의 집합 S의 요소들의 합이 K가 되는 S의 부분 집합을 찾아라.&lt;/li&gt;
  &lt;li&gt;예: S = {10,20,40,70,80}, K = 160
    &lt;ul&gt;
      &lt;li&gt;부분 집합{10,70,80}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;그래프 색칠하기 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무방향 그래프에서 인접한 정점들을 서로 다른색으로 가장 적은 수의 색을 사용하여 색칠하라&lt;/li&gt;
  &lt;li&gt;예: 아래 그래프에서 a,c: 빨강, b,d: 초록, e: 파랑&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/ag/ag18.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="algorithm" /><summary type="html">NP-완전</summary></entry></feed>