<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://lee989898.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lee989898.github.io/" rel="alternate" type="text/html" /><updated>2021-11-30T10:42:36+09:00</updated><id>https://lee989898.github.io/feed.xml</id><title type="html">LEE</title><subtitle>공부 블로그</subtitle><entry><title type="html">근사 알고리즘</title><link href="https://lee989898.github.io/algorithm-09" rel="alternate" type="text/html" title="근사 알고리즘" /><published>2021-11-29T01:09:00+09:00</published><updated>2021-11-29T01:09:00+09:00</updated><id>https://lee989898.github.io/algorithm-09</id><content type="html" xml:base="https://lee989898.github.io/algorithm-09">&lt;h3 id=&quot;근사-알고리즘&quot;&gt;&lt;strong&gt;근사 알고리즘&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;근사-알고리즘-1&quot;&gt;근사 알고리즘&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-완전 문제 해결 방법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;문제의 크기가 작다면 완전 탐색 알고리즘 사용&lt;/li&gt;
  &lt;li&gt;문제의 특별한 경우(들)에는 다항 시간 알고리즘을 찾으려고 노력&lt;/li&gt;
  &lt;li&gt;문제의 최적해에 매우 근사한 해를 구하는 것이 허용된다면 비교적 빠른 근사 알고리즘을 찾으려고 노력&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;근사 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;NP-완전 문제와 같이 지금까지 알려진 실용적인 다항 시간 알고리즘이 없거나 최적의 해를 반드시 찾을 필요가 없을 때 사용&lt;/li&gt;
  &lt;li&gt;대부분의 근사 알고리즘은 특정 문제에만 적용되는 휴리스틱에 기초&lt;/li&gt;
  &lt;li&gt;휴리스틱은 경험을 통해 얻는 상식적인 접근법&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;근사 비율&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;근사해의 값과 최적해의 값의 비율&lt;/li&gt;
  &lt;li&gt;정의: 근사 비율 p
    &lt;ul&gt;
      &lt;li&gt;f: 목적 함수&lt;/li&gt;
      &lt;li&gt;$S_a$: 근사해&lt;/li&gt;
      &lt;li&gt;$S^*$: 최적해&lt;/li&gt;
      &lt;li&gt;$S_a$는 다음 부등식을 만족시켜야 한다
        &lt;ul&gt;
          &lt;li&gt;최소화 문제: $\frac{f(S_a)} {f(S^*)}$&amp;lt;= p&lt;/li&gt;
          &lt;li&gt;최대화 문제: $\frac{f(S^*)} {f(S_a)}$&amp;lt;= p&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;p-근사 알고리즘: 근사비율이 p인 알고리즘&lt;/li&gt;
  &lt;li&gt;1에 가까울수록 정확도가 높은 알고리즘&lt;/li&gt;
  &lt;li&gt;근사 비율은 보통 2를 사용&lt;/li&gt;
  &lt;li&gt;대부분의 경우에 목적 함수의 최적 값인 $f(S^*)$를 알 수 없기 때문에 근사 비율 계산 불가&lt;/li&gt;
  &lt;li&gt;$f(S^*)$를 대신할 수 있는 $f(S_a)$의 상한을 구하여 근사 비율을 계산&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;정점 커버 찾기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무방향 그래프에서 각 간선의 양쪽 끝의 두 정점들 중에서 적어도 1개의 정점을 포함하는 정점들의 집합&lt;/li&gt;
  &lt;li&gt;크기 = 정점 커버내에 있는 정점들의 수&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그래프는 여러 개의 정점 커버들을 가질 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;무방향 그래프내에 있는 최소 크기의 정점 커버를 찾아라
    &lt;ul&gt;
      &lt;li&gt;정점 지향 전략&lt;/li&gt;
      &lt;li&gt;간선 지향 전략&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;정점 지향 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;그래프의 모든 정점들을 차수(한 정점에 인접한 정점들의 수) 기준으로 내림차순으로 정렬한다&lt;/li&gt;
  &lt;li&gt;차수가 가장 큰 정점을 선택한다&lt;/li&gt;
  &lt;li&gt;선택된 정점에 인접한 모든 간선을 제거한다&lt;/li&gt;
  &lt;li&gt;남은 그래프에서 과정 2와 3을 반복한다&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;간선 지향 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;그래프의 한 간선 (u, v)를 임의로 선택한다&lt;/li&gt;
  &lt;li&gt;u와 v를 정점 커버에 포함시키고 u와 v에 인접한 간선들은 모두 그래프에서 제거한다&lt;/li&gt;
  &lt;li&gt;남은 간선들 중 임의로 한 간선을 선택하고 같은 과정을 반복한다. 선택할 간선들이 더 이상 남아 있지 않으면 종료한다&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;근사 정점 커버 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Approx_Vertex_Cover(G)&lt;br /&gt;
// 입력: 그래프 G = (V, E)&lt;br /&gt;
// 출력: C - 정점 커버&lt;br /&gt;
1 C = $\emptyset$&lt;br /&gt;
2 $E^&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$ = E  
3 while ( $E^&lt;/code&gt;$ $\neq$  $\emptyset$){&lt;br /&gt;
4   $E^&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$에서 임의로 간선 (u,v)를 선택한다  
5   C = C {u} {v}  
6   $E^&lt;/code&gt;$에서 정점 u나 v에 인접한 모든 간선들을 제거한다&lt;br /&gt;
    }&lt;br /&gt;
7 return C&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;시간 복잡도: O(&lt;/td&gt;
          &lt;td&gt;E&lt;/td&gt;
          &lt;td&gt;)&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;해밀토니안 회로&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;해밀토니안 회로: 그래프의 한 정점에서 출발하여 다른 모든 정점을 1번씩만 방문하고 출발 정점으로 돌아오는 경로&lt;/li&gt;
  &lt;li&gt;완전 그래프에는 반드시 해밀토니안 회로가 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;외판원 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;가중 완전 그래프의 최단 거리 해밀토니안 회로를 찾아라&lt;/li&gt;
  &lt;li&gt;NP-완전 문제&lt;/li&gt;
  &lt;li&gt;다음 조건들을 만족시켜야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;가중치가 있는 완전 무방향 그래프 G = (V, E)의 각 간선 (u, v) $\in$ E는 음이 아닌 가중치 c(u, v)를 가진다&lt;/li&gt;
  &lt;li&gt;모든 정점 u,v,w $\in$ V에 대해서 거리 함수 c가 다음과 같은 삼각 부등식을 만족한다
    &lt;ul&gt;
      &lt;li&gt;c(u,v) &amp;lt;= c(u, w) + c(w, v)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;근사 외판원 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;아이디어&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;프림의 최소 비용 신장 트리 알고리즘을 이용하여 주어진 그래프에서 최소 비용 신장 트리를 찾는다&lt;/li&gt;
  &lt;li&gt;이 트리에 깊이 우선 탐색을 하여 정점들의 방문 순서를 구한다&lt;/li&gt;
  &lt;li&gt;이 순서를 따라 정점들을 방문하면서 다시 방문하는 정점을 순서에서 제거하여 외판원 문제의 근사해를 구한다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Approx_MST_TSP(G, c)&lt;br /&gt;
// 입력: G = (V, E) - 가중 완전 그래프, c - G의 간선들의 가중치(삼각 부등식을 만족)&lt;br /&gt;
// 출력: 해밀토니안 회로 H&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;임의의 정점 r $\in$ V를 출발 정점으로 선택한다&lt;/li&gt;
  &lt;li&gt;Prim의 최소 비용 신장 트리 알고리즘을 이용하여 r이 루트 노드인 그래프 G의 최소 비용 신장 트리 T를 구한다&lt;/li&gt;
  &lt;li&gt;트리 T의 루트 노드에서 시작하여 깊이 우선 탐색을 하면서 노드들을 방문한 순서대로 나열한 목록 H를 구한다&lt;/li&gt;
  &lt;li&gt;목록 H에 있는 정점들을 출발 정점을 제외하고 처음부터 순서대로 스캔하면서 중복하여 나타나는 정점들을 H에서 제거한다&lt;/li&gt;
  &lt;li&gt;return H&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;시간복잡도: O($n^2$)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="algorithm" /><summary type="html">근사 알고리즘</summary></entry><entry><title type="html">Pl 20</title><link href="https://lee989898.github.io/pl-20" rel="alternate" type="text/html" title="Pl 20" /><published>2021-11-24T19:18:00+09:00</published><updated>2021-11-24T19:18:00+09:00</updated><id>https://lee989898.github.io/pl-20</id><content type="html" xml:base="https://lee989898.github.io/pl-20">&lt;h3 id=&quot;__&quot;&gt;&lt;em&gt;__&lt;/em&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;lisp&quot;&gt;Lisp​&lt;/h2&gt;

&lt;p&gt;Lisp은 심볼(문자열) 처리를 위한 언어로 개발되었다&lt;br /&gt;
심볼들을 표현하기 위한 데이터 구조로 리스트, 즉 링크드 리스트를 기본으로 한다&lt;br /&gt;
이러한 이유로 데이터 연산은 자연스레 링크(포인터) 조작을 포함한다&lt;br /&gt;
Lisp이라는 이름은 리스트 프로세싱의 합성어로서, 말 그대로 리스트 처리에 적합하도록 설계되었다&lt;/p&gt;

&lt;p&gt;Lisp의 데이터 타입은 아톰과 리스트, 두 가지이다&lt;br /&gt;
아톰은 식별자처럼 생긴 심볼들이거나 숫자 형태의 상수를 말한다&lt;br /&gt;
아톰에 값이 없을 수 있어서 nil도 가능하다&lt;br /&gt;
리스트는 리스트 요소가 연결되어 있고, 리스트 요소는 두개의 링크(포인터), 데이터 포인터와 넥스트 포인터로 구성된다&lt;br /&gt;
데이터 포인터는 아톰을 가리키거나 중첩리스트를 가리킨다&lt;br /&gt;
넥스트 포인터는 다른 리스트 요소를 가리키거나 nil(리스트의 끝을 나타냄)이다&lt;/p&gt;

&lt;p&gt;Lisp 프로그램에서 리스트는 괄호를 써서 나타내는데, 중첩 리스트는 괄호 안에 괄호를 써서 나타낸다&lt;/p&gt;

&lt;p&gt;ex) (A, B, C, D)&lt;br /&gt;
A,B,C,D는 각각이 아톰이며, (A,B,C,D)는 리스트이다&lt;/p&gt;

&lt;p&gt;산술 연산자로 +, - , incf, decf가 있고, 비교 연산자로 =, /= , &amp;lt;, max, min이 있다&lt;br /&gt;
부울 값에 대한 논리 연산자로 loand,logor 등이 있다&lt;br /&gt;
컨트롤 스트럭처로 selection, recursiong, iteration이 있는데, iteration은 명령형 언어의 특성으로, Lisp이 순수 함수 언어가 아니라는 것을 보여준다&lt;br /&gt;
함수 정의는 (defun 함수명 (파라미터1… 파라미터n)표현식)형식을 따르고, 함수 적용(호출)은 (함수명 파라미터1 … 파라미터n)의 형식을 따른다&lt;/p&gt;

&lt;p&gt;Lisp으로 작성된 팩토리알 함수는&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(DEFUN factorial (X))
    (IF &amp;lt;= n 1)
            1
            (* n factorial (-n 1)))
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;과 같다&lt;/p&gt;

&lt;p&gt;미리 정의된 함수 중의 몇몇은 실제로는 함수가 아니라 매크로이다&lt;br /&gt;
예를 들어, 두개의 파라미터, 죽 변수와 리스트를 받아들이는 DOLIST는 매크로이다&lt;br /&gt;
DOLIST(x ‘(1 2 3)) (print x))는 리스트 요소 1,2,3,nil로 구성된 리스트를 생성한다&lt;/p&gt;

&lt;p&gt;매크로의 실행은 다음 두 단계로 이루어진다&lt;br /&gt;
우선, 매크로를 미리 정의딘 Lisp 코드로 펼치고, 다음에, 펼친 Lisp 코드를 평가(실행)한다&lt;/p&gt;

&lt;p&gt;사용자는 DEFMACRO를 써서 자신이 원하는 매크로를 정의할 수 있다&lt;/p&gt;

&lt;p&gt;Lisp에서 괄호 앞의 ‘(QUOTE)는 괄호 속의 표현식을 평가(실행)하지 말고, 그 객체(표현식)를 결과로서 반환하라는 뜻이다&lt;br /&gt;
예를 들어 ‘(a(* 3 4)c)는 (a 12 c)를 결과로 반환한다&lt;br /&gt;
중첩된 괄호 속의 (* 3 4)는 평가한다는 것에 주의하자&lt;/p&gt;

&lt;p&gt;Lisp은 컴파일러가 아닌 인터프리터에 의해 실행된다&lt;br /&gt;
Lisp 프로그램에서는 함수 정의 및 함수 적용(호출)을 “괄호에 의한 리스트 표시 방식”으로 표현된다&lt;br /&gt;
함수 정의는 (함수명(람다 (파라미터1 … 파라미터n) 표현식)) 으로 정의하며, 함수 적용은 (함수명 파라미터1 … 파라미터n)으로 호출한다&lt;br /&gt;
예를 들어, (+ 5 7)은 12이고, (+ 3 4 7 6)은 20이다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;scheme&quot;&gt;Scheme​&lt;/h2&gt;

&lt;p&gt;Scheme은 Lisp으로부터 유래되었으나 함수를 일등 시민으로 취급한다&lt;br /&gt;
Scheme에서는 함수가 표현식의 결과 값일 수 있고, 함수가 리스트의 요소로 사용될 수 있으며, 함수가 파라미터로 패스될 수 있고, 함수가 함수의 결과로서 반환될 수 있다&lt;/p&gt;

&lt;p&gt;Scheme은 단순한 신택스와 시맨틱스를 갖는, 타입이 없는 작은 언어이다&lt;/p&gt;

&lt;p&gt;Scheme 인터프리터는 상호작용 모드로 동작하면서, read-evaluate-print 순환(REPL)을 무한으로 반복한다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;사용자가 입력한 표현식을 읽어서&lt;/li&gt;
  &lt;li&gt;EVAL 함수에 의해 표현식을 해석하고&lt;/li&gt;
  &lt;li&gt;결과값을 화면에 display한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;EVAL 함수는 다음과 같이 표현식을 평가한다&lt;br /&gt;
리터럴의 평가는 그 자체를 결과로 displaat한다&lt;br /&gt;
원시 함수를 포함하는 표현식의 평가는 다음과 같이 실행한다&lt;br /&gt;
첫째, 특별한 순서 없이, 파라미터 표현식의 각각 평가한다&lt;br /&gt;
둘째, 파라미터 값에 원시 함수의 적용을 평가한다&lt;br /&gt;
끝으로, 결과값을 display한다&lt;/p&gt;

&lt;p&gt;원시 산술 함수는 +,-,*,/,modulo,round,max,min,log,sin,sqrt 등이다&lt;br /&gt;
음수에 대한 sqrt는 허수이다&lt;/p&gt;

&lt;p&gt;함수 정의는 (LAMBDA (x) (* x x))의 형식을 가지며, 함수 적용은 ((LAMBDA(x) (* x x)) 7)의 형식을 갖는다&lt;/p&gt;

&lt;p&gt;DEFINE 함수는 이름을 값이나 람다 함수에 바인딩하는 특수한 함수이다&lt;br /&gt;
(DEFINE symbol expression)의 형식을 가지며, 그 예로 (DFINE pi 3.141592), (DEFINE two_pi (* 2 pi))을 들 수 있다&lt;/p&gt;

&lt;p&gt;DEFINE 함수가 이름을 람다 표현식에 바인딩하는 형식은 (DEFINE (function_name parameters) (expression))이다&lt;br /&gt;
예를 들면, 제곱수를 (DEFINE (square number) (* number number))와 같이 정의하고, 직각삼각형의 빗변의 길이를 (DEFINE (hypotenuse side1 side2)(SQRT(+(square side1)(square side2))))와 같이 정의한다&lt;/p&gt;

&lt;p&gt;출력 함수는 EVAL 함수의 적용을 통해 그 결과를 display한다&lt;/p&gt;

&lt;p&gt;논리적 술어(predicate)함수는 부울 값을 반환한다&lt;br /&gt;
Scheme의 논리적 술어 함수는 =, &amp;lt;&amp;gt;, &amp;gt;,&amp;lt;,&amp;gt;=, &amp;lt;=, EVEN?, ODD?, ZERO?가 있다&lt;br /&gt;
리스트가 부울식으로서 해석될 때에는 비어있지 않은 리스트는 참이고, 비어있는 리스트는 거짓이다&lt;/p&gt;

&lt;p&gt;컨트롤 플로우는 택인 컨스트럭트(IF)와 평가 컨트롤(COND)이 있다&lt;br /&gt;
if는 3개의 파라미터(논리적 술어 표현식, then 표현식, else 표현식)를 갖는다&lt;br /&gt;
그 형식은 (IF 논리적 술어 then 표현식 else 표현식)이고, 사용 예를 들면 DEFINE(factorial n)(IF (&amp;lt;+ n 1)1(*n(factorial(-n 1))))이다&lt;/p&gt;

&lt;p&gt;평가 컨트롤은 여럿 중에서 하나 이상이 선택 및 실행되는 COND와 recursion이 있다&lt;br /&gt;
COND의 형식은&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(DEFINE (leap? year))
    (COND
        ((ZERO? (MODULO year 400)) #T)
        ((ZERO? (MODULO year 100)) #F)
        (ELSE (ZERO? (MODULO year 4)))))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;와 같다&lt;/p&gt;

&lt;p&gt;리스트 함수에는 QUOTE,CAR,CDR,CONS 함수가 있다&lt;br /&gt;
QUOTE는 그 자체를 결과로 반환하며, ‘로 표시한다&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(QUOTE A) returns A ​
(QUOTE (A B C)) returns (A B C)​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CAR 함수는&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(CAR '((A B) C D)) returns (A B) ​
(CAR 'A) is an error because A is not a list ​
(CAR '(A)) returns A ​
(CAR '()) is an error ​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CDR 함수는 ​&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(CDR '((A B) C D)) returns (C D) ​
(CDR 'A) is an error ​
(CDR '(A)) returns () ​
(CDR '()) is an error​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CONS 함수는 ​&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(CONS 'A '()) returns (A) ​
(CONS 'A '(B C)) returns (A B C)​
(CONS '() '(A B)) returns (() A B)​
(CONS '(A B) '(C D)) returns ((A B) C D)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CAR, CDR을 가지고 a_list의 두번째 리스트 요소를 결과값으로 반환하는 함수를 정의하면, (DEFINE (second a_list)(CAR(CDR a_list)))가 된다&lt;br /&gt;
이것은 a_list에서 첫째 요소를 제외한 나머지를 반환하고, 이중에서 첫째 요소를 반환한다는 뜻이다&lt;br /&gt;
리스트를 생성하기 위해 CAR CDR의 연속으로 적용해 보면, (CADDAR ‘((A B (C)D)E)) == (C) 임을 알 수 있다&lt;/p&gt;

&lt;p&gt;리스트 함수는 다수의 파라미터로부터 하나의 리스트를 생성한다&lt;br /&gt;
CONS는 생성할 수도 있으나, List함수가 편리하다&lt;/p&gt;

&lt;p&gt;논리적 술어 함수 중에서 EQ? NULL? LIST?는 심볼 아톰과 리스트에도 적용할 수 있다&lt;br /&gt;
EQV?은 숫자 아톰과 심볼 아톰에 모두 적용할 수 있다&lt;/p&gt;

&lt;p&gt;Scheme에서 함수 정의의 예를 들어 보자&lt;br /&gt;
멤버 함수는 파라미터 간의 소속관계를 평가한다&lt;br /&gt;
리스트의 맨앞 리스트 요소에서부터 차례로 비교하기 위해, COND와 EQ, CAR, CDR을 사용한다&lt;br /&gt;
append 함수는 앞의 파라미터에 뒤의 파라미터를 잇는다&lt;br /&gt;
list1의 리스트 요소를 앞에서부터 하나씩 새로운 리스트에 넣기를 반복한다&lt;br /&gt;
list1의 리스트의 요소를 모두 새로운 리스트에 넣고 나면, 이때 lsit1은 NULL이 되므로, list2의 요소를 새로운 리스트에 넣으면 된다&lt;br /&gt;
이를 위해 COND와 NULL?, CONS, CAR, CDR을 이용한다&lt;/p&gt;

&lt;p&gt;두개의 리스트가 같은지 판단하려면, 각 리스트의 맨앞 요소에서부터 하나씩 같은지 비교하기를 반복한다&lt;br /&gt;
이를 위해 COND, EQ?, CAR, CDR 등을 이용한다&lt;/p&gt;

&lt;p&gt;반복 처리는 모두 recursion을 이용한다&lt;br /&gt;
즉, 이들 모두 recursion으로 프로그래밍 된다&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root1 = (-b + sqrt(b2 - 4 ac))/2a, root 2 = (-b - sqrt(b2 - 4 ac))/2 a​

(DEFINE (quadratic_roots a b c) ​

  (LET ( ​

     (root_part_over_2a ​

                    (/ (SQRT (− (* b b) (* 4 a c))) (* 2 a))) ​

     (minus_b_over_2a (/ (− 0 b) (* 2 a))) ​

         ) ​

  (LIST (+ minus_b_over_2a root_part_over_2a) ​

                  (− minus_b_over_2a root_part_over_2a)) ​

))​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;LET 함수는 로컬 변수를 생성한다&lt;br /&gt;
표현을 쉽게 하기 위해 루트 부분과 루트가 없는 부분(이것을 마이너스 부분)으로 나누어, 이들을 각각 로컬 변수 root_part_over_2a, minus_b_over_2a로 언급한다&lt;br /&gt;
LIST 함수에서 이들을 언급하며 근의 공식 함수를 정의한다&lt;/p&gt;

&lt;p&gt;함수의 합성은 두개의 함수를 파리미터로 받아들여 합성 함수를 결과로 반환한다&lt;br /&gt;
합성 함수는 DEFINE (compose f g)(LAMBDA(x) (f(g(x))))로 정의한다&lt;br /&gt;
CADDR을 (DEFINE (third a_list) ((compose CAR (compose CDR CDR)) a_list))와 같이 정의한다&lt;/p&gt;

&lt;p&gt;리스트의 모든 요소에 적용하는 함수로 map 함수를 정의해 보자&lt;br /&gt;
함수 정의의 형식은 (DEFINE (mao fun a_list) 표현식)이며, a-list의 모든 요소에 함수 fun을 적용하라는 의미이다&lt;br /&gt;
즉, 함수 map을 정의하는데 파라미터로서 fun이라는 함수를 쓴다&lt;br /&gt;
따라서 이것은 고차 함수이다&lt;/p&gt;

&lt;p&gt;처리 목적에 맞게 처리하려면, 리스트 요소를 하나씩 반환하는 함수가 필요하며, 이렇게 반환된 리스트 요소에 fun을 적용하기를 반복하면 된다&lt;br /&gt;
위의 map 함수 정의에서 (COND … NULL? … ELSE …) 부분은 리스트 요소를 하나씩 꺼내는 처리 로직을 수행한다&lt;br /&gt;
맵함수 사용 예: (map (LAMBDA(num)(*num num num))’(3 4 2 6))은 (27 64 8 216)를 반환한다&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; (DEFINE (adder a_list) ​

      (COND ​

          ((NULL? a_list) 0) ​

          (ELSE (+ (CAR a_list) (adder (CDR a_list)))) ))​

(adder '(3 4 5)) ​

   (+ 3 (adder (4 5))) ​

   (+ 3 (+ 4 (adder (5)))) ​

   (+ 3 (+ 4 (+ 5 (adder ())))) ​

   (+ 3 (+ 4 (+ 5 0))) ​

   (+ 3 (+ 4 5)) ​

   (+ 3 9) ​

   (12)​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;리스트에 있는 아톰의 합을 구하는 프로그램을 작성해보면, 코드는 위에서 보듯이 매우 간결하다&lt;br /&gt;
실제 평가 과정을 보면, recursion이 있어 매우 복잡해 보이지만 이것은 인터프리터의 역할이다&lt;/p&gt;

&lt;p&gt;만일 EVAL 함수를 써서 코딩하면, 아래 프로그램이 된다&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Alternative code with EVAL function:​

(DEFINE (adder a_list) ​

    (COND ​

        ((NULL? a_list) 0) ​

        (ELSE (EVAL (CONS '+ a_list))) ​

))​

(adder '(3 4 5)) ​

(EVAL (+ 3 4 5) ​

(12)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;ml&quot;&gt;ML​&lt;/h2&gt;

&lt;p&gt;ML은 타입 검사를 엄격하게 수행하는 언어이다&lt;br /&gt;
평가 환경은 프로그램에서 명시적 또는 암묵적으로 선언된 모든 변수명을 그 유형(타입)과 함께 테이블을 포함한다&lt;br /&gt;
이 테이블은 컴파일러의 심볼 테이블과 유사하다&lt;br /&gt;
ML 신택스는 Lisp이나 Scheme에 비해 IPL과 더욱 유사하다&lt;br /&gt;
산술 표현식은 인픽스 방식으로 표현된다&lt;/p&gt;

&lt;p&gt;함수 정의는 함수명(파라미터) = 표현식;의 신택스를 갖는다&lt;br /&gt;
예를 들어, fun circumf( r ) = 3.14159&lt;em&gt;r&lt;/em&gt;r;로 정의 되었다면, 함수 circumf는 부동점 파라미터를 받아서 부동점 결과를 생산한다&lt;br /&gt;
이 값의 타입은 표현식의 값으로부터 추론된다&lt;br /&gt;
함수 적용은 circumf(1.3)과 같이 호출된다&lt;/p&gt;

&lt;p&gt;ML의 컨트롤 플로우는 if 표현식 then 표현식1 else 표현식2에 의한다&lt;br /&gt;
ML에서는 주어진 파라미터에 대한 패턴 매칭을 통해 함수의 반환값을 정의하는 특정 표현식을 선택하기도 한다&lt;br /&gt;
예를 들어, 팩토리알을 구할 떄&lt;br /&gt;
fun fact(n : int): int = if n &amp;lt;= 1 then 1 else n * fact(n − 1);로 표현할 수도 있지만, ​fun fact(0) = 1 | fact(1) = 1 | fact(n : int): int = n * fact(n − 1);로 표현할 수도 있다.&lt;br /&gt;
후자에서는 Fact(0), Fact(1)의 값을 구할 때, 두개의 식 fun fact(0) = 1, fact(1) = 1에 대한 패턴 매칭을 통해 그 결과값을 선택할 수 있다&lt;/p&gt;

&lt;p&gt;ML에서는 h, t는 각각 헤드와 테일을 나타내며, CAR, CDR과 같다&lt;br /&gt;
그리고 ::는 CONS와 같다&lt;br /&gt;
두개의 리스트를 append하는 함수는&lt;br /&gt;
fun append([], lis2) = lis2 | append(h :: t, lis2) = h :: append(t, lis2);로 정의된다.&lt;/p&gt;

&lt;p&gt;주어진 리스트에서 리스트 요소의 개수를 구하는 함수는&lt;br /&gt;
fun length([]) = 0 | length(h :: t) = 1 + length(t);이다&lt;/p&gt;

&lt;p&gt;ML에서 값을 선언하는 방법은 변수명에 값을 바인딩하는 것이다&lt;br /&gt;
그 형식은 val new_name = expression이다&lt;br /&gt;
만일 새로운 값을 바인딩하려면 새로운 변수명에 새로운 값을 바인딩하여 테이블에 새로운 엔트리로 생성해야 한다&lt;br /&gt;
val의 정상적인 사용은 표현식에서 사용하는 변수에 대해, Let안에서 바인딩하는 것이다&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Let val radius = 2.7 ​

      val pi = 3.14159 ​

   in pi * radius * radius ​

   end;​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;예에서 radius와 pi는 표현식에 제한된 변수임을 명확히 선언하고 있다&lt;/p&gt;

&lt;p&gt;많이 쓰이는 고차 함수로 리스트를 필터링하는 filter함수가 있다&lt;br /&gt;
필터는 다음과 같이 동작한다&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;필터는 술어 함수를 파라미터로 받아들여서, 술어 만족 여부에 따라 필터링하는 함수를 반환한다(술어 함수는 종종 fn으로 정의된 람다 표현식으로 주어진다)&lt;/li&gt;
  &lt;li&gt;반환된 필터링 함수는 리스트를 파라미터로 받아들여서 다음과 같이 처리한다
    &lt;ul&gt;
      &lt;li&gt;각 리스트 요소에 대해 술어함수를 적용하여 술어 조건을 만족시키는지 검사&lt;/li&gt;
      &lt;li&gt;그 결과가 참이면, 리스트 요소를 새로운 리스트(결과 리스트)에 추가한나다&lt;/li&gt;
      &lt;li&gt;참이 아니면, 스킵한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이렇게 생성된 새로운 리스트를 결과로 반환한다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;필터의 사용을 보면 Filter(fn(x)) =&amp;gt; x &amp;lt;100, [25, 1, 50, 711, 100, 150, 27, 161, 3]);는 결과로서 100보다 작은 요소만으로 구성된 새로운 리스트 [25, 1, 50, 27, 3]를 반환한다&lt;/p&gt;

&lt;p&gt;많이 쓰이는 다른 함수로 map함수가 있다&lt;br /&gt;
map함수는 파라미터로 함수 (fa)를 받아 들여서 새로운 함수를 만든다&lt;br /&gt;
새로운 함수는 파라미터로 리스트를 받아 들인다&lt;br /&gt;
각 리스트 요소에 파라미터로 받은 함수(fa)를 적용한다&lt;/p&gt;

&lt;p&gt;합성 함수는 val h = g o f로 정의하며, 이것은 h(x) = g(f(x))와 같다&lt;/p&gt;

&lt;p&gt;커링은 하나 이상의 파라미터를 가진 함수를 하나의 파라미터를 가진 함수로 교체하는 것이다&lt;br /&gt;
하나의 파라미터를 가진 함수는 함수를 반환하며, 반환된 이 함수는 초기 함수의 다른 파라미터를 받아 들여 결과를 반환한다&lt;br /&gt;
예를 들어, (DEFINE (add x y)(+ x y))의 커리 함수는 DEFINE (add y) (LAMBDA (x) (+ y x))이며, 이것이 호출되면, 그 결과는 (+ y x)으로 리덕션된다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;haskell&quot;&gt;Haskell​&lt;/h2&gt;

&lt;p&gt;Haskell은 순수 함수 언어로 알려져 있다&lt;br /&gt;
연산자는 표시 방식만 다를 뿐 다른 FPL과 거의 같다&lt;/p&gt;

&lt;p&gt;Haskell 역시 앞에서 Scheme에서 본 것과 유사한 let 컨스트럭트를 지원한다&lt;/p&gt;

&lt;p&gt;다른 언어와 다르게 지연 평가를 수행하며, 표현식은 값이 필요할 때에만 평가된다&lt;/p&gt;

&lt;p&gt;이에 비해 이른(eager) 평가에서는 함수가 호출되기 전에 미리 함수에 대한 파라미터를 평가한다&lt;br /&gt;
따라서 엄격한 시맨틱스를 갖는다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;support-fp-in-ipl&quot;&gt;Support FP in IPL&lt;/h2&gt;

&lt;p&gt;자바 스크립트에서는 이름을 가진 함수를 정의할 수 있다&lt;br /&gt;
ex) 함수명 (파라미터 여러개) { 표현식 (블록)}&lt;/p&gt;

&lt;p&gt;여기서 함수명을 빼면 익명의 함수를 정의하게 된다&lt;/p&gt;

&lt;p&gt;파이썬에는 람다 표현식이 가능하다&lt;br /&gt;
즉, lambda a,b: 2*a-b라고 하면, 파라미터 a,b로 이름이 없는 익명의 함수를 정의하는 것이다&lt;br /&gt;
파라미터와 함수 바디를 콜론으로 구분한다&lt;/p&gt;

&lt;p&gt;파이썬에서는 고차 함수 filter와 map를 정의할 수 있다&lt;br /&gt;
이들은 첫째 파라미터로 모두 람다 표현식을 사용하며, 두번째 파라미터로 시퀀스 타입을 사용한다&lt;br /&gt;
두 함수 모두 두번째 파라미터와 동일한 타입의 시퀀스를 결과로 반환한다.&lt;br /&gt;
예를 들어 map(lambda x : x**3, [2, 4, 6, 8]이라고 하면, 반환 결과는 [8, 64, 216, 512]이다.&lt;br /&gt;
이 예에서 첫번째 파라미터는 함수(표현식)임을 기억하라.&lt;/p&gt;

&lt;p&gt;이 map은 2004년 구글의 MapReduce의 map과 같은 의미이며, ​병렬 처리의 한 방법으로 유명해졌다. ​&lt;/p&gt;

&lt;p&gt;파이썬은 파라미터의 개수를 제한하고, ​명시적으로 새로운 함수를 정의하고 적용할 수 있도록 partial 함수를 지원한다.&lt;br /&gt;
먼저 제한적으로 적용하려는 함수를 임포트하고,​ (여기서 add5는 add a b : a + b에서 파라미터를 ​한 개로 줄여서 add + 5로 정의한 것이다.)​ 명령문 add5=partial (add, 5)은 함수 add+5를 add5로 정의하고, ​함수 add5(15)를 적용(호출)하면 결과는 20이다. ​&lt;/p&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="pl" /><summary type="html">__</summary></entry><entry><title type="html">POSIX Thread Programming</title><link href="https://lee989898.github.io/st-10" rel="alternate" type="text/html" title="POSIX Thread Programming" /><published>2021-11-24T01:06:00+09:00</published><updated>2021-11-24T01:06:00+09:00</updated><id>https://lee989898.github.io/st-10</id><content type="html" xml:base="https://lee989898.github.io/st-10">&lt;h3 id=&quot;posix-thread-programming&quot;&gt;&lt;strong&gt;POSIX Thread Programming&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;thread-overview-&quot;&gt;Thread Overview ​&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스처럼 독립적으로 수행되는 프로그램 코드​
    &lt;ul&gt;
      &lt;li&gt;“경량 프로세스(light-weight process)”라고도 함​&lt;/li&gt;
      &lt;li&gt;“프로세스 내에서 독립적으로, 순차적으로 수행되는 instruction stream 또는 제어의 흐름”이라고도 함​&lt;/li&gt;
      &lt;li&gt;여러 스레드는 동시에 실행이 가능​&lt;/li&gt;
      &lt;li&gt;스레드들의 실행에 관한 스케쥴링은 OS가 담당​&lt;/li&gt;
      &lt;li&gt;싱글 코어에서도 여러 스레드의 실행이 가능 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;한 프로세스내의 스레드들은 같은 주소 공간을 사용 ​
    &lt;ul&gt;
      &lt;li&gt;공유 매모리를 이용하여 스레드간의 통신을 이용함으로써 복잡한 프로세스간 통신(IPC) 기능을 사용하지 않아도 됨​&lt;/li&gt;
      &lt;li&gt;스레드간의 통신 비용이 IPC 비용보다 낮음​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st25.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Process는 실행을 위하여 resource들이 필요하며 실행 상태를 메모리에 저장 ​
    &lt;ul&gt;
      &lt;li&gt;Process ID, group ID, … ​&lt;/li&gt;
      &lt;li&gt;Program instructions​&lt;/li&gt;
      &lt;li&gt;Registers, Stack​&lt;/li&gt;
      &lt;li&gt;Heap ​&lt;/li&gt;
      &lt;li&gt;File descriptor, …​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Thread는 Process 내부에 존재하면서 resource들을 같이 사용 ​
    &lt;ul&gt;
      &lt;li&gt;Registers, stack, 등은 thread 별로 따로 존재  ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st26.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;공통 스레드 구현​
    &lt;ul&gt;
      &lt;li&gt;병렬 소스 코드 내에서 호출되는 서브루틴 라이브러리&lt;/li&gt;
      &lt;li&gt;직렬 또는 병렬 소스 코드에 포함된 컴파일러 지시문 세트&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스레드 구현은 컴퓨팅에서 새로운 것이 아니다
    &lt;ul&gt;
      &lt;li&gt;역사적으로 하드웨어 공급업체는 고유한 스레드 버전을 구현했다&lt;/li&gt;
      &lt;li&gt;이러한 구현은 서로 상당히 다르다&lt;/li&gt;
      &lt;li&gt;프로그래머가 휴대용 스레드 응용 프로그램을 개발하기 어려움​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;관련 없는 표준화 노력으로 인해 두 개의 매우 다른 스레드 구현이 발생했다
    &lt;ul&gt;
      &lt;li&gt;POSIX Threads (Pthread)​&lt;/li&gt;
      &lt;li&gt;OpenMP​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;pthread-introduction-&quot;&gt;Pthread Introduction ​&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;IEEE POSIX (Portable Operating System Interface for UNIX) 1003.1c Standard​
    &lt;ul&gt;
      &lt;li&gt;과거에 하드웨어 업체별로 각각 제작되어 사용되었던 스레드에 관한 구현을 표준화 ​&lt;/li&gt;
      &lt;li&gt;이 표준에 따라 구현된 스레드를 POSIX Thread 또는 Pthread로 부름​
        &lt;ul&gt;
          &lt;li&gt;스레드를 생성하고 동기화하는 system call 들로 구성​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;표준화는 계속 진행 중​
        &lt;ul&gt;
          &lt;li&gt;가장 최근의  표준은 IEEE Std 1003.1, 2004 Edition​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;C-프로그래밍 언어의 type과 procedure call의 집합으로 정의 ​
    &lt;ul&gt;
      &lt;li&gt;
        &lt;pthread.h&gt; header 파일 및 thread library로 구현​
&lt;/pthread.h&gt;
        &lt;ul&gt;
          &lt;li&gt;libc library의 일부로 구현되기도 함​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;우수한 성능 : 프로세스와 비교​
    &lt;ul&gt;
      &lt;li&gt;스레드 생성에 드는 OS overhead가 프로세스 생성에 비해 현격히 낮음​
        &lt;ul&gt;
          &lt;li&gt;50,000번의 프로세스 생성(fork() 사용) vs. 스레드 생성(pthread_create() 사용) ​&lt;/li&gt;
          &lt;li&gt;실행 시간의 단위는 second, time 커맨드에 의해 측정​&lt;/li&gt;
          &lt;li&gt;스레드 관리에 드는 resource도 프로세스에 비해 현격히 적음​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pthread에서는 ​
    &lt;ul&gt;
      &lt;li&gt;Parallelism 생성​&lt;/li&gt;
      &lt;li&gt;동기화(synchronization)​을 지원함​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Communication에 대한 explicit한 지원은 없음​
    &lt;ul&gt;
      &lt;li&gt;Shared-memory 모델이므로 communication은 implicit하게 일어남​
​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스레드의 상태​
    &lt;ul&gt;
      &lt;li&gt;준비(ready) : 스레드가 실행될 수 있는 상태​&lt;/li&gt;
      &lt;li&gt;실행(running) : CPU의 서비스를 받고 있는 상태​&lt;/li&gt;
      &lt;li&gt;블록(block) : sleep(), read(), 세마포어 연산 등으로 기다리는 상태​&lt;/li&gt;
      &lt;li&gt;종료(terminated) : 스레드가 종료 또는 취소된 상태​
​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;준비 상태​
    &lt;ul&gt;
      &lt;li&gt;스레드가 처음 생성되면 준비 상태로 감​&lt;/li&gt;
      &lt;li&gt;CPU의 서비스를 받을 수 있는 상태​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실행 상태​
    &lt;ul&gt;
      &lt;li&gt;OS의 스케줄러에 의해 CPU의 서비스를 받고 있는 상태​&lt;/li&gt;
      &lt;li&gt;스케줄링에 의해 준비상태로 갈 수 있음​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;블록 상태​
    &lt;ul&gt;
      &lt;li&gt;실행 상태에서 즉시 처리할 수 없는 작업을 만나는 경우​
        &lt;ul&gt;
          &lt;li&gt;read(), wait(), sleep(), 세마포어/뮤텍스/조건변수를 기다리는 경우​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;원하는 조건이 만족되면 준비 상태가 됨​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;종료 상태​
    &lt;ul&gt;
      &lt;li&gt;스레드 시작함수에서 return 또는 pthread_exit()가 호출된 경우​&lt;/li&gt;
      &lt;li&gt;사용하던 자원의 대부분을 시스템에 반납​&lt;/li&gt;
      &lt;li&gt;종료 상태 값을 부모 스레드에게 넘겨주기 위한 자원은 부모 스레드에서 pthread_join()을 통해 읽어가면 완전히 삭제​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Application 프로그램은 하나의 스레드로 시작​
    &lt;ul&gt;
      &lt;li&gt;Main 스레드 또는 master 스레드로 불림 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;pthread_create() 호출에 의해 새로운 child 스레드를 생성​
    &lt;ul&gt;
      &lt;li&gt;새로운 child 스레드의 생성은 procedure 호출의 형태를 띔​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;pthread_exit() 또는 pthread_join() 호출에 의해 새로 생성되었던 스레드 종료​
    &lt;ul&gt;
      &lt;li&gt;Master 스레드만 남게 됨​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st27.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;스레드 생성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int pthread_create (​
  pthread_t   *thread, // 생성된 스레드의 핸들 ​
  pthread_attr_t   *attr, // 스레드 속성을 지정하는 인자​
  void   *(*start_routine) (void *), // 스레드 시작함수(start routine) 주소​
  void   *arg ) // 스레드 시작 함수의 인자(들)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;thread : 새로운 child 스레드가 성공적으로 생성될 경우 생성된 스레드의 핸들​&lt;/li&gt;
  &lt;li&gt;attr : 생성되는 child 스레드의 속성을 지정(디폴트 값은 NULL)​&lt;/li&gt;
  &lt;li&gt;start_routine : 새로 생성되는 child 스레드를 지정하는 함수의 시작 주소​&lt;/li&gt;
  &lt;li&gt;arg : 시작 함수들의 인자(들)​&lt;/li&gt;
  &lt;li&gt;리턴 값 ​
    &lt;ul&gt;
      &lt;li&gt;성공시 0을 리턴​&lt;/li&gt;
      &lt;li&gt;에러 발생시 에러코드의 정수 값(errno)을 리턴​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Pthread 프로그램 컴파일&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;일반적으로 –lpthread 옵션이 필요​
    &lt;ul&gt;
      &lt;li&gt;스레드 라이브러리가 다른 라이브러리(예 : libc)에 통합된 경우는 불필요 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;-D_REENTRANT 옵션​
    &lt;ul&gt;
      &lt;li&gt;멀티 스레드 환경에서 싱글 스레드의 경우와 구별된 errno를 사용하도록 함​&lt;/li&gt;
      &lt;li&gt;일반 함수들이 멀티 스레드 환경에 적합하게 동작하도록 함​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컴파일 예제​
    &lt;ul&gt;
      &lt;li&gt;Linux/GCC의 경우​
        &lt;ul&gt;
          &lt;li&gt;% gcc test.c –lpthread (-lpthread 옵션에 –D_REENTRANT 포함)​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Solaris/Studio 컴파일러의 경우​
        &lt;ul&gt;
          &lt;li&gt;% cc –mt test.c (-mt 옵션에 –D_REENTRANT 포함, 스레드 라이브러리는 libc 라이브러리에 포함됨) ​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;스레드 종료&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void  pthread_exit(void   *retval);​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;생성된 child 스레드의 종료​
    &lt;ul&gt;
      &lt;li&gt;프로세스와 마찬가지로 return을 만나면 종료​&lt;/li&gt;
      &lt;li&gt;또는 pthread_exit() 호출시 종료​&lt;/li&gt;
      &lt;li&gt;pthread_exit() 호출에 의해 child 스레드가 종료할 경우 할당되었던 자원들은 반납되지 않음​&lt;/li&gt;
      &lt;li&gt;나중에 pthread_join() 호출에 의해 반납됨 ​&lt;/li&gt;
      &lt;li&gt;Detach 된 스레드는 예외  ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int  pthread_join(pthread_t   thrd,   void   **thread_return);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Parent 스레드에서 호출​
    &lt;ul&gt;
      &lt;li&gt;자신이 생성한 child 스레드가 종료할 때까지 기다림​
        &lt;ul&gt;
          &lt;li&gt;thrd​
            &lt;ul&gt;
              &lt;li&gt;종료를 기다릴 스레드의 핸들​&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;thread_return​
            &lt;ul&gt;
              &lt;li&gt;child 스레드의 종료 상태가 저장됨​&lt;/li&gt;
              &lt;li&gt;NULL로 하면 종료 상태를 받지 않음​&lt;/li&gt;
              &lt;li&gt;child 스레드의 종료값은 return, pthread_exit()로 남길 수 있음​&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Child 스레드가 종료되기 전에 parent 스레드가 먼저 종료되지 않게 할 때 사용​
    &lt;ul&gt;
      &lt;li&gt;Parent 스레드가 종료하면 child 스레드가 함께 종료되며​&lt;/li&gt;
      &lt;li&gt;Child 스레드의 작업이 모두 이루어 지지 않은 상태일 수 있음​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Child 스레드의 종료 시점을 정확히 파악하여 어떤 작업을 하고 싶거나 종료 상태 값을 얻기 위해 사용​&lt;/li&gt;
  &lt;li&gt;종료된 child 스레드에 할당되었던 resource 들은 반납됨 ​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;스레드 Detach&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int   pthread_detach(pthread_t   thrd);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Detached 스레드​
    &lt;ul&gt;
      &lt;li&gt;Join이 가능한 스레드(pthread_join()을 사용)와 대비​&lt;/li&gt;
      &lt;li&gt;Parent 스레드가 생성한 child 스레드에 대해 pthread_detach()를 호출하면 parent 스레드가 나중에 wait하지 않음​
        &lt;ul&gt;
          &lt;li&gt;빠른 스레드의 실행에 도움이 됨​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Detach 된 스레드에 pthread_join()를 호출하면 error 발생​&lt;/li&gt;
      &lt;li&gt;Detach 된 스레드는 pthread_join() 호출 없이 할당되었던 resources 들이 반납됨 
​
        &lt;blockquote&gt;
          &lt;p&gt;스레드 Attribute&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스레드의 attribute는 스레드가 생성될 때 설정됨
    &lt;ul&gt;
      &lt;li&gt;이미 생성된 스레드의 attribute 값을 바꾸는 것은 제한적인 경우에만 가능 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;따라서 pthread_create를 호출하기 전에 원하는 attribute 값들을 설정해야 ​&lt;/li&gt;
  &lt;li&gt;Attribute 설정과 관련된 pthread API
    &lt;ul&gt;
      &lt;li&gt;pthread_attr_init()​&lt;/li&gt;
      &lt;li&gt;pthread_attr_destroy()​&lt;/li&gt;
      &lt;li&gt;pthread_attr_setdetachstate()​&lt;/li&gt;
      &lt;li&gt;pthread_attr_getstacksize()​&lt;/li&gt;
      &lt;li&gt;pthread_attr_setstacksize()​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스레드는 joinable 또는 detached 스레드로 생성 가능​&lt;/li&gt;
  &lt;li&gt;Default stack size는 OS 마다 다른 값을 지정​&lt;/li&gt;
  &lt;li&gt;최소 스택 크기는 변수 PTHREAD_STACK_MIN에 저장된다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;기타 스레드 Attribute들&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Guard size: 스택 오버플로로부터 보호하기 위해 사용&lt;/li&gt;
  &lt;li&gt;스케줄링 속성 상속(스레드 생성에서) or not&lt;/li&gt;
  &lt;li&gt;Scheduling parameter(s): 특히 스레드 우선순위&lt;/li&gt;
  &lt;li&gt;Scheduling policy: FIFO or Round Robin​&lt;/li&gt;
  &lt;li&gt;Contention scope: 이 스레드는 어떤 스레드와 CPU를 놓고 경쟁하는가&lt;/li&gt;
  &lt;li&gt;Stack address: 스택의 위치를 ​​명시적으로 지정&lt;/li&gt;
  &lt;li&gt;Lazy stack allocation: 요청 시 할당(lazy) 또는 한 번에 모두 선행&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;synchronization&quot;&gt;Synchronization​&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;스레드의 동기화 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;여러 스레드가 공유 데이터에 접근하여 값들을 읽거나 저장
    &lt;ul&gt;
      &lt;li&gt;Run time 에 공유 데이터가 어떤 값을 가질지 예측하기 어려움​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Data race 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;두 개 이상의 스레드가 같은 변수를 access, 그 중 적어도 하나의 access는 write 연산을 실행​&lt;/li&gt;
  &lt;li&gt;Access들이 동시에 발생, 그러나 동기화되지 않은 상태로&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;기본적인 동기화 Mechanism: Mutex&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;스레드들이 서로 배타적으로 공유데이터에 접근하도록 하기위해 Mutex (mutual exclusion)를 사용​
    &lt;ul&gt;
      &lt;li&gt;스레드들은 거의 독립적으로 실행​&lt;/li&gt;
      &lt;li&gt;Common한 data structure를 사용함​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Mutex외에도 세마포어를 많이 사용​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Mutex 사용방법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Critical 영역에 들어가기 전에 mutex 를 잠금​&lt;/li&gt;
  &lt;li&gt;Critical 영역에서 나오면서 mutex 잠금을 해제​&lt;/li&gt;
  &lt;li&gt;다른 스레드들은 이 mutex 잠금이 해제될 때까지 대기​&lt;/li&gt;
  &lt;li&gt;Mutex 사용 절차&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pthread_mutex_t mutex; // 뮤텍스 선언​
Pthread_mutex_init(&amp;amp;mutex); // 뮤텍스 초기화 작업​
pthread_mutex_lock(mutex); // 뮤텍스 잠금​
... // 공유데이터(크리티컬 영역) 액세스​
pthread_mutex_unlock(mutex); // 뮤텍스 잠금 해제​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Mutex 선언 및 초기화&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Mutex의 변수 타입 : pthread_mutex_t​&lt;/li&gt;
  &lt;li&gt;여러 스레드들이 사용하므로 전역 변수로 선언​&lt;/li&gt;
  &lt;li&gt;반드시 초기화를 해야 사용 가능​&lt;/li&gt;
  &lt;li&gt;초기화 방법​
    &lt;ul&gt;
      &lt;li&gt;함수를 통한 초기화​&lt;/li&gt;
      &lt;li&gt;매크로를 통한 초기화​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Mutex 초기화에 특별한 타입을 지정하지 않음 ​&lt;/li&gt;
  &lt;li&gt;단 한 번의 잠금만 허용​
    &lt;ul&gt;
      &lt;li&gt;스레드 A가 잠금을 하고 있는 상황에서 스레드 B가 잠금을 시도하면 B는 A의 잠금이 해제될 때까지 기다림​&lt;/li&gt;
      &lt;li&gt;A에 의해 잠긴 뮤텍스에 대해 A가 다시 잠금을 시도하면 deadlock이 발생하여 A는 영원히 블록 상태가 됨​&lt;/li&gt;
      &lt;li&gt;이러한 현상을 피하기 위해 pthread_mutex_trylock()을 사용​&lt;/li&gt;
      &lt;li&gt;Mutex를 얻지 못하는 경우 블록되지 않고 바로 리턴되고 EBUSY 에러 발생​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;잠금되어 있는 않은 mutex에 잠금해제를 시도하면 아무 동작을 하지 않음​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Mutex의 삭제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;더 이상 mutex를 사용하지 않을 때 삭제​&lt;/li&gt;
  &lt;li&gt;잠금 상태의 mutex를 삭제하려 시도하면 에러 발생​
    &lt;ul&gt;
      &lt;li&gt;EBUSY 에러 발생​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Mutex의 현재 상태(잠금, 잠금해제) 확인 함수는 없음​&lt;/li&gt;
  &lt;li&gt;안전하게 mutex를 삭제하기 위해서는 삭제 전에 무조건 mutex를 해제해야 함​&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pthread_mutex_unlock(&amp;amp;mutex);​
pthread_mutex_destory(&amp;amp;mutex);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Mutex와 deadlock&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Deadlock​
    &lt;ul&gt;
      &lt;li&gt;두 개의 스레드가 두 개의 mutex를 사용​&lt;/li&gt;
      &lt;li&gt;각 스레드가 mutex를 하나씩 잠그고 있는 상태에서 상대방의 mutex 해제를 기다리는 현상​&lt;/li&gt;
      &lt;li&gt;deadlock이 발생하면 프로그램은 영원히 블록​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Deadlock을 피하는 방법​
    &lt;ul&gt;
      &lt;li&gt;Mutex를 잠그는데 일정한 순서를 정하여 사용​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;성능​
    &lt;ul&gt;
      &lt;li&gt;Mutex를 많이 사용하면 프로그램의 성능이 저하됨​&lt;/li&gt;
      &lt;li&gt;Mutex를 얻은 상태에서 처리하는 작업의 양(Critical Section)을 최소화 해야 함​
        &lt;ul&gt;
          &lt;li&gt;Mutex가 잠긴 동안 다른 스레드가 블록될 가능성이 높으며 Critical Section이 길수록 전체 프로그램 성능이 저하될 수 있음​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;다른 data structure에 대해서는 다른 lock을 적용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Spin Lock​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Mutex lock 과 달리, lock을 얻을때까지 CPU cycle을 소비하면서 계속 spinning 함​
    &lt;ul&gt;
      &lt;li&gt;Mutex lock : lock을 얻지 못하면 바로 sleep 모드로 들어감 ​&lt;/li&gt;
      &lt;li&gt;Adaptive mutex lock : 잠깐 동안 spinning 하다가 sleep 모드로 들어감 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Spin lock APIs​
    &lt;ul&gt;
      &lt;li&gt;pthread_spin_init() ​
        &lt;ul&gt;
          &lt;li&gt;PTHREAD_PROCESS_PRIVATE : 생성되는 spin lock이 프로세스에 private 하게 사용될 경우 ​&lt;/li&gt;
          &lt;li&gt;PTHREAD_PROCESS_SHARED : 다른 프로세스와 공유할 경우​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;pthread_spin_lock()​&lt;/li&gt;
      &lt;li&gt;pthread_spin_unlock()​&lt;/li&gt;
      &lt;li&gt;pthread_spin_destroy()​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;pthread_spin_trylock() ​
    &lt;ul&gt;
      &lt;li&gt;Lock을 얻으려 시도​&lt;/li&gt;
      &lt;li&gt;Lock을 얻는 경우나 얻지 못하는 경우 모두 바로 리턴&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Barrier&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Barrier: 글로벌 동기화
    &lt;ul&gt;
      &lt;li&gt;특히 SPMD(동일한 기능의 여러 복사본을 병렬로 실행할 때)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Simple use of barriers: all threads hit the same one​
    &lt;ul&gt;
      &lt;li&gt;work_on_my_subgrid();​&lt;/li&gt;
      &lt;li&gt;barrier;​&lt;/li&gt;
      &lt;li&gt;read_neighboring_values();​&lt;/li&gt;
      &lt;li&gt;barrier;​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;more complicated: barriers on branches (or loops)​
    &lt;ul&gt;
      &lt;li&gt;if (thread_id % 2 == 0) {​&lt;/li&gt;
      &lt;li&gt;work1();​&lt;/li&gt;
      &lt;li&gt;barrier; } ​&lt;/li&gt;
      &lt;li&gt;else ​&lt;/li&gt;
      &lt;li&gt;barrier;​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 스레드 라이브러리에 Barrier가 제공되지 않는다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Barrier APIs​
    &lt;ul&gt;
      &lt;li&gt;pthread_barrier_init(&amp;amp;barrier, attr, no_of_threads) ​
        &lt;ul&gt;
          &lt;li&gt;pthread_barrier_t  barrier;​&lt;/li&gt;
          &lt;li&gt;Default value of attr is “NULL”​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;pthread_barrier_destroy(&amp;amp;barrier)​&lt;/li&gt;
      &lt;li&gt;pthread_barrier_wait(&amp;amp;barrier)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;semaphore--conditional-variable&quot;&gt;Semaphore &amp;amp; Conditional Variable​&lt;/h2&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="system" /><summary type="html">POSIX Thread Programming</summary></entry><entry><title type="html">__방화벽__</title><link href="https://lee989898.github.io/sc-17" rel="alternate" type="text/html" title="__방화벽__" /><published>2021-11-24T01:06:00+09:00</published><updated>2021-11-24T01:06:00+09:00</updated><id>https://lee989898.github.io/sc-17</id><content type="html" xml:base="https://lee989898.github.io/sc-17">&lt;h3 id=&quot;방화벽&quot;&gt;&lt;strong&gt;방화벽&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Firewalls?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;조직의 내부망을 외부 인터넷과 격리시켜 일부 패킷은 통과시키고 나머지는 차단하는 HW와 SW의 조합&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc24.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Firewall 서비스&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Traffic monitoring​&lt;/li&gt;
  &lt;li&gt;Traffic control​&lt;/li&gt;
  &lt;li&gt;NAT – 내부 network 보호​&lt;/li&gt;
  &lt;li&gt;VPN – 내부 traffic 노출차단&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Firewalls을 쓰는 이유&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;서비스 거부 공격 방지:
    &lt;ul&gt;
      &lt;li&gt;SYN 플러딩: 공격자가 많은 가짜 TCP 연결을 설정하고 “실제” 연결을 위한 리소스가 남지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;내부 데이터의 불법적인 수정/접근을 방지한다
    &lt;ul&gt;
      &lt;li&gt;예: 공격자가 CIA의 홈페이지를 다른 것으로 교체&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;내부 네트워크(인증된 사용자/호스트 집합)에 대한 승인된 액세스만 허용&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Firewall types&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;Stateless packet filter​&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;지나는 packet에 대해 미리 정의된 규칙에 따라 pass/block 결정​&lt;/li&gt;
  &lt;li&gt;Packet의 다음 정보를 기반으로 결정​
    &lt;ul&gt;
      &lt;li&gt;source IP address, destination IP address​&lt;/li&gt;
      &lt;li&gt;TCP/UDP source and destination port numbers​&lt;/li&gt;
      &lt;li&gt;ICMP message type​&lt;/li&gt;
      &lt;li&gt;TCP SYN and ACK bits​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;example 1: block incoming and outgoing BitTorrent traffic source or dest port = 6881-6889​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;example 2: Block outbound Web access, port=80.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ACL: 규칙이 있는 테이블, 들어오는 패킷에 위에서 아래로 적용: (액션, 조건) pair&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;장점​
    &lt;ul&gt;
      &lt;li&gt;Simple : 동작방식이 직관적이며 간단, 구현용이​&lt;/li&gt;
      &lt;li&gt;Fast​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;application layer protocol의 취약점공격에 차단 불가능​&lt;/li&gt;
      &lt;li&gt;사용자/application 별 서비스 제공불가능 ​&lt;/li&gt;
      &lt;li&gt;필터링시 사용 정보가 제한되어서 정교한 필터링 불가능​&lt;/li&gt;
      &lt;li&gt;IP주소 위변조 여부 판단 불가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Statefull packet filter​&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;동일한 상태정보를 가지는 패킷들을(packet flow) 그룹으로 필터링​
    &lt;ul&gt;
      &lt;li&gt;상태정보: src IP/port, dst IP/port ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점​
    &lt;ul&gt;
      &lt;li&gt;정교한 필터링​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;상태정보 테이블 검사수행에 따른 성능저하​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Application gateway&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;애플리케이션 데이터 및 IP/TCP/UDP 필드에서 패킷을 필터링한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;장점​
    &lt;ul&gt;
      &lt;li&gt;Application layer protocol 공격 차단​&lt;/li&gt;
      &lt;li&gt;사용자 인증가능​&lt;/li&gt;
      &lt;li&gt;정교한 Log, audit 가능​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;응용 프로그램마다 다른 응용 프로그램 게이트웨이가 필요하다(텔넷, http, ftp, 이메일 …)&lt;/li&gt;
      &lt;li&gt;모든 데이터가 게이트웨이를 통과하기 때문에 성능이 저하됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;방화벽 및 게이트웨이의 한계&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;IP spoofing: 라우터는 데이터가 “실제로” 청구된 소스에서 오는지 알 수 없다&lt;/li&gt;
  &lt;li&gt;여러 앱의 경우. 특별한 대우가 필요하며 각각의 앱이 있다&lt;/li&gt;
  &lt;li&gt;클라이언트 소프트웨어는 게이트웨이에 접속하는 방법을 알아야 한다.
    &lt;ul&gt;
      &lt;li&gt;예를 들어, 웹 브라우저에서 프록시의 IP 주소를 설정해야 한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;내부 공격자 방어에 취약​&lt;/li&gt;
  &lt;li&gt;데이터 내용은 미확인 – 문서 등 내부에 심겨진 악성코드 방어 취약&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="security" /><summary type="html">방화벽</summary></entry><entry><title type="html">__침입탐지__</title><link href="https://lee989898.github.io/sc-16" rel="alternate" type="text/html" title="__침입탐지__" /><published>2021-11-24T01:06:00+09:00</published><updated>2021-11-24T01:06:00+09:00</updated><id>https://lee989898.github.io/sc-16</id><content type="html" xml:base="https://lee989898.github.io/sc-16">&lt;h3 id=&quot;침입탐지&quot;&gt;&lt;strong&gt;침입탐지&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;IDS(침입탐지 시스템)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;침입탐지시스템​&lt;/li&gt;
  &lt;li&gt;침입행위에 대한 탐지를 수행하고 탐지시 대응할 수 있도록 지원하는 일련의 시스템​&lt;/li&gt;
  &lt;li&gt;Intrusion?​
    &lt;ul&gt;
      &lt;li&gt;시스템에 허가되지 않은 방법으로 내부 자원에 접근​&lt;/li&gt;
      &lt;li&gt;Login 시도 (ID, PWD 추측)​&lt;/li&gt;
      &lt;li&gt;불법적으로 데이터 도용시도 (rootkit)​&lt;/li&gt;
      &lt;li&gt;Root/관리자 권한 획득시도​&lt;/li&gt;
      &lt;li&gt;메일발송 실행파일을 숨겨놓고 메일전송시도​&lt;/li&gt;
      &lt;li&gt;Backdoor 접근시도&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;패킷 필터링
    &lt;ul&gt;
      &lt;li&gt;오직 TCP/IP 헤더만 본다&lt;/li&gt;
      &lt;li&gt;패킷 간의 연관성을 알아 내기 어렵다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;IDS
    &lt;ul&gt;
      &lt;li&gt;depp packet inspection: 패킷 콘테츠 까지 검사한다&lt;/li&gt;
      &lt;li&gt;다수의 패킷을 검사한다
        &lt;ul&gt;
          &lt;li&gt;port scanning&lt;/li&gt;
          &lt;li&gt;network mapping&lt;/li&gt;
          &lt;li&gt;Dos attack&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Dectection 방법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;Signature-based dectection​
    &lt;ul&gt;
      &lt;li&gt;침입사건들을 패턴화(signature)​
    + Signature example​&lt;/li&gt;
      &lt;li&gt;실행 파일 첨부 메일 유형​&lt;/li&gt;
      &lt;li&gt;파일 읽기 시도 유형​&lt;/li&gt;
      &lt;li&gt;로그인 시도 유형​
    + 장점​&lt;/li&gt;
      &lt;li&gt;known attack에 대해 효율적​
    + 단점​&lt;/li&gt;
      &lt;li&gt;Unknown attack에 취약​&lt;/li&gt;
      &lt;li&gt;새로운 공격유형 발견때마다 signature 생성해야​&lt;/li&gt;
      &lt;li&gt;일반적으로 False negative rate 높음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Anomaly-based dectection​
    &lt;ul&gt;
      &lt;li&gt;정상범위를 벗어나는 사건을 탐지​
    + Anomaly example​&lt;/li&gt;
      &lt;li&gt;휴일에 traffic 량이 평소보다 20%증가​&lt;/li&gt;
      &lt;li&gt;일반사용자가 갑자기 1000통 메일발송​&lt;/li&gt;
      &lt;li&gt;특정 호스트에 단시간 주문요청 100%증가​&lt;/li&gt;
      &lt;li&gt;국내 사용자 카드가 해외에서 결재​
    + 장점​&lt;/li&gt;
      &lt;li&gt;Machine learning 처리​&lt;/li&gt;
      &lt;li&gt;Unknown attac에 대해 효율적​
    + 단점​&lt;/li&gt;
      &lt;li&gt;정상범위 정의 어려움​&lt;/li&gt;
      &lt;li&gt;비정상탐지까지 기다려야​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;IDS types&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;Network-based IDS​&lt;/li&gt;
  &lt;li&gt;Wireless IDS (wireless IDS)​&lt;/li&gt;
  &lt;li&gt;Host-based IDS​&lt;/li&gt;
  &lt;li&gt;Distributed Host-based IDS&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Network-based IDS​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Example​
    &lt;ul&gt;
      &lt;li&gt;Network 망에 곳곳에 traffic을 모니터, 분석하여 침입탐지​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Example​
    &lt;ul&gt;
      &lt;li&gt;Ddos, worm  ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점 ​
    &lt;ul&gt;
      &lt;li&gt;Host는 부하적음 (하나의  NIDS로 여러 host보호)​&lt;/li&gt;
      &lt;li&gt;조기 탐지가능​&lt;/li&gt;
      &lt;li&gt;취약한 부분의 packet 을 정밀분석하여 다양한 침입탐지 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;각 host 내부는 탐지제한​&lt;/li&gt;
      &lt;li&gt;전체 network 망에 부하&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Wireless IDS (wireless IDS)​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무선통신 WLAN network망의 traffic 분석​&lt;/li&gt;
  &lt;li&gt;장점​
    &lt;ul&gt;
      &lt;li&gt;무선통신의 취약성위협 탐지​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;Network 부하, 비용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Host-based IDS​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;특정 host 컴퓨터내부를 모니터링, 분석하여 탐지​&lt;/li&gt;
  &lt;li&gt;Example​
    &lt;ul&gt;
      &lt;li&gt;로그분석, 파일시스템 기록분석, 실행코드분석 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점​
    &lt;ul&gt;
      &lt;li&gt;악성sw 탐지용이​&lt;/li&gt;
      &lt;li&gt;내부공격자 탐지​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;각 host마다 다름​&lt;/li&gt;
      &lt;li&gt;Host 부하&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Distributed Host-based IDS&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;여러 HIDS들이 연계하여 전체적으로 host들을 분석하여 탐지 ​&lt;/li&gt;
  &lt;li&gt;장점​
    &lt;ul&gt;
      &lt;li&gt;효율적이고 정확성​&lt;/li&gt;
      &lt;li&gt;공격들의 연관관계 파악용이​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;HIDS보다 복잡, 부담&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Honey Pot&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;꿀단지​&lt;/li&gt;
  &lt;li&gt;의도적으로 해커의 침입을 유도하는 시스템​&lt;/li&gt;
  &lt;li&gt;해커 정보수집, 공격유형파악, 대응전략수립, 법적증거 ​&lt;/li&gt;
  &lt;li&gt;침입자 활동감시, 로그기록&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;IDS 평가 기준&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;False Positive rate​
    &lt;ul&gt;
      &lt;li&gt;정상을 침입으로 판단하는 확률​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;False Negative​
    &lt;ul&gt;
      &lt;li&gt;침입을 정상으로 판단하는 확률​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;True Positive rate​&lt;/li&gt;
  &lt;li&gt;True Negative rate​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;IPS (Intrusion Prevention System)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;침입방지시스템​&lt;/li&gt;
  &lt;li&gt;IDS+침입방지기능​&lt;/li&gt;
  &lt;li&gt;Example​
    &lt;ul&gt;
      &lt;li&gt;IDS로 침입탐지하고 계정, 연결 등 차단​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="security" /><summary type="html">침입탐지</summary></entry><entry><title type="html">분기 한정</title><link href="https://lee989898.github.io/algorithm-08" rel="alternate" type="text/html" title="분기 한정" /><published>2021-11-22T01:09:00+09:00</published><updated>2021-11-22T01:09:00+09:00</updated><id>https://lee989898.github.io/algorithm-08</id><content type="html" xml:base="https://lee989898.github.io/algorithm-08">&lt;h3 id=&quot;분기-한정&quot;&gt;&lt;strong&gt;분기 한정&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;분기 한정&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;안내 표지판과 같은 지표를 활용하여 최종 해를 찾는 기법&lt;/li&gt;
  &lt;li&gt;상태 공간 트리 이용&lt;/li&gt;
  &lt;li&gt;최적화 문제에만 적용 가능&lt;/li&gt;
  &lt;li&gt;최적 해를 구하기 위해 모든 해를 다 고려해야 하므로 트리의 노드를 순회하는 방법과 무관&lt;/li&gt;
  &lt;li&gt;하지만 최적의 해에 더 빨리 도달하기 위해 가장 좋은 한계값을 가진 노드를 먼저 탐색하는 최선 우선 탐색 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;분기 한정의 핵심 원리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;상태 공간 트리의 각 노드를 탐색할 때마다, 그 노드가 유망한 지를 알기 위해 한계값(그 노드로부터 확장하여 얻을 수 있는 실현    가능한 해의 한계)을 계산한다.&lt;/li&gt;
  &lt;li&gt;만약 그 한계값이 그 때까지 찾은 최고 해의 값보다 더 좋으면 그 노드는 유망하다고 판단하고 확장을 하면서 탐색을 계속한다. 그렇지 않으면 그 노드는 유망하지 않다고 판단하고 탐색을 멈춘다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;노드에서 탐색 중단 이유&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;노드의 한계값이 그 때까지 찾은 최고 해의 값보다 못하다&lt;/li&gt;
  &lt;li&gt;노드는 문제의 제약 사항들을 만족시키지 못하므로 실현 가능한 해가 될 수 없다&lt;/li&gt;
  &lt;li&gt;노드가 나타내는 실형 가능한 해들의 부분 집합이 더 이상의 추가 선택들을 할 수 없는 경우에 해당한다
    &lt;ul&gt;
      &lt;li&gt;세 번째 경우에 실현 가능한 해에 대한 목적 함수의​ 값이 그때까지 찾은 최고 해의 값보다 더 좋다면 ​최고 해의 값을 목적 함수의 값으로 갱신한다.​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;최선 우선 탐색&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;최적의 해에 더 빨리 도달하기 위한 전략&lt;/li&gt;
  &lt;li&gt;너비 우선 탐색 사용&lt;/li&gt;
  &lt;li&gt;한 유망한 노드의 모든 자식 노드들을 만든 후 남아 있는 유망하나 확장되지 않은 노드들 중에서 최고의 한계값을 가진 노드를먼저 확장&lt;/li&gt;
  &lt;li&gt;최고의 한계값을 가진 노드를 우선적으로 선택하기 위해서 우선 순위 대기열 사용&lt;/li&gt;
  &lt;li&gt;우선 순위 대기열은 힙을 사용하여 효과적으로 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;너비 우선 탐색&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;트리의 노드들을 다음과 같은 순서로 탐색&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;트리의 루트 노드를 먼저 탐색&lt;/li&gt;
  &lt;li&gt;다음으로 트리의 수준 1에 있는 모든 노드를 왼쪽에서 오른쪽으로 탐색&lt;/li&gt;
  &lt;li&gt;다음으로 수준 2에 있는 모든 노드들을 왼쪽에서 오른쪽으로 탐색&lt;/li&gt;
  &lt;li&gt;마지막 수준까지 이 과정을 반복&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;최선 우선 탐색 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;v,u : 트리의 노드&lt;/li&gt;
  &lt;li&gt;value(v): 노드 v에 대응되는 실현 가능한 해의 값&lt;/li&gt;
  &lt;li&gt;bound(v): 노드 v의 한계값&lt;/li&gt;
  &lt;li&gt;best: 현재까지 찾은 최고 해&lt;/li&gt;
  &lt;li&gt;PQ: 상태 공간 트리를 대신하는 우선 순위 대기열
    &lt;ul&gt;
      &lt;li&gt;PQ는 유망하나 확장되지 않은 노드들 포함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Best-First-Branch-and-Bound(state-space-tree T)​
// 입력: T – 상태 공간 트리​
// 출력: 최적 해의 값​
1  initialize(PQ) // PQ를 빈 대기열로 초기화​
2  v = T의 루트 노드​
3  best = value(v)​
4  insert(PQ, v)           // 노드 v를 PQ에 삽입​
5  while (not empty(PQ)) { // PQ에 노드들이 남아 있는지 확인​
6    v = remove(PQ) // PQ에서 최고 한계값을 가진 노드를 제거​
7    if (bound(v) &amp;gt; best) // 노드 v가 유망한지 확인​
8       for (each child u of v) {​
9           if (value(u) &amp;gt; best) best = value(u)​
10          if (bound(u) &amp;gt; best) insert(PQ, u)  }  }​
11  return best​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;배낭 채우기 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;N(&amp;gt;=1)개의 물건들 중에서 배낭의 용량 C를 초과하지 않고 배낭에 넣을 수 있는 물건들의 최대 가치를 구하라&lt;/li&gt;
  &lt;li&gt;각 물건은 배낭에 넣거나 넣지 않을 수 있더&lt;/li&gt;
  &lt;li&gt;$w_i$: 물건 i, 1&amp;lt;=i&amp;lt;=N,의 무게&lt;/li&gt;
  &lt;li&gt;$v_i$: 물건 i, 1&amp;lt;=i&amp;lt;=N, 의 가치&lt;/li&gt;
  &lt;li&gt;가정: 물건들이 단위 무게당 가치($v_i$ / $w_i$)의 내림차순으로 정렬되어 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;배낭 채우기 상태 공간 트리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;루트 노드: 배낭에 물건들을 넣기 전의 초기 상태&lt;/li&gt;
  &lt;li&gt;트리의 수준 i, 1&amp;lt;=i&amp;lt;=N, 에 있는 각 노드는 첫 번째 물건부터 i번째까지의 물건들 중에서 배낭에 포함된 물건들의 특정 선택을 나타낸다. 이 특정 선택은 루트 노드부터 그 노드까지의 경로에 의해 유일무이하게 결정된다&lt;/li&gt;
  &lt;li&gt;한 노드의 왼쪽에 있는 자식 노드는 다음 물건을 배낭에 넣는 경우를 나타내고 오른쪽에 있는 자식 노드는 다음 물건을 배낭에 넣지 않는 경우를 나타낸다. 이 선택의 총 무게 w와 총 가치 v를 해당 노드에 한계값과 같이 저장한다. 그 노드의 한계값은 이 선택 후 남은 물건들 중 일부를 포함시킴으로써 얻을 수 있는 배낭의 물건들의 가치에 대한 상한을 나타낸다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;노드의 한계값 계산 방법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;배낭에 이미 포함된 물건들의 총 가치 v에 배낭의 남은 용량(C - w)를 전부 다음 물건으로만 채운 경우의 가치를 더한다(w는 배낭에 이미 포함된 물건들의 총 무게). 즉, 트리의 수준 i, 0 &amp;lt;= i &amp;lt; N, 에 있는 노드의 한계값은 다음과 같이 계산된다&lt;/li&gt;
  &lt;li&gt;한계값 &amp;gt;= 실현 가능한 해의 값&lt;/li&gt;
  &lt;li&gt;트리의 수준 n에 있는 노드의 한계값 = v&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;최선 우선 탐색 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;상태 공간 트리의 각 노드에 다음 값들을 저장한다.​
    &lt;ul&gt;
      &lt;li&gt;level: 트리에서 노드의 수준​&lt;/li&gt;
      &lt;li&gt;weight: 이미 선택된 물건들의 총 무게​&lt;/li&gt;
      &lt;li&gt;value: 이미 선택된 물건들의 총 가치​&lt;/li&gt;
      &lt;li&gt;bound: 한계값​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;root: 루트 노드​&lt;/li&gt;
  &lt;li&gt;u, v:  노드 ​&lt;/li&gt;
  &lt;li&gt;maxValue: 지금까지 찾은 최고 해의 값​&lt;/li&gt;
  &lt;li&gt;PQ: 상태 공간 트리를 대신하는 우선 순위 대기열​
    &lt;ul&gt;
      &lt;li&gt;주: PQ는 유망하나 확장되지 않은 노드들 포함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;KnapsackBandB(N, Wt[0 . . N – 1], Val[0 . . N – 1], C)​
// 입력: N – 물건들의 수​
// Wt[0 . . N – 1]– 각 물건의 무게를 저장하는 배열​
// Val[0 . . N – 1] – 각 물건의 가치를 저장하는 배열​
// C – 배낭의 용량​
// 출력: 배낭에 넣을 수 있는 물건들의 최대 가치​
1  initialize(PQ) // PQ를 빈 대기열로 초기화​
2  maxValue = 0 // maxValue를 0으로 초기화​
3  root.level = 0​
4  root.weight = 0​
5  root.value = 0
6  root.bound = computeBound(root) // 루트 노드의 한계값 계산​
7  insert(PQ, root)          // root를 PQ에 삽입
8  while (not empty(PQ)) {          // PQ가 비어 있지 않은 동안 반복​
9    v = remove(PQ)          // PQ에서 최대 한계값을 가진 노드 v를 끄집어 낸다​
10   if (v.bound &amp;gt; maxValue) {          // 노드 v가 유망하면 확장​
11      u.level = v.level + 1          // 노드 u를 노드 v의 자식 노드로 만든다​
12      u.weight = v.weight + Wt[v.level] // u는 다음 물건을 넣는 경우​
13      u.value = v.value + Val[v.level];​
14      if (u.weight &amp;lt;= C and u.value &amp;gt; maxValue)​
15         maxValue = u.value                // maxValue를 더 나은 해의 값으로 바꾼다​
16      u.bound = computeBound(u) // 자식 노드의 한계값을 계산​
17      if (u.bound &amp;gt; maxValue)​
18         insert(PQ, u);  // u가 유망하므로 PQ에 삽입​
19      w.level = v.level + 1                 // 노드 w는 다음 물건을 넣지 않는 경우​
20      w.weight = v.weight  ​
21      w.value = v.value​
22      w.bound = computeBound(w) // 자식 노드의 한계값 계산​
23      if (w.bound &amp;gt; maxValue)​
24         insert(PQ, w);  // w가 유망하므로 PQ에 삽입​
     }}​
25  return maxValue 

computeBound(u) // 노드 u의 한계값을 계산
// 입력: u - 트리의 노드
// 출력: u의 한계값
1 if(u.weight &amp;gt;= C) return 0
2 else if(u.level &amp;lt; N)
            return u.value + (C - u.wight) x (Val[u.level]/Wt[u.leve])
3 else return u.value

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;시간 복잡도: O($2^n$)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;일 배정 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;N(&amp;gt;1) 명의 사람에게 N개의 일을 배정&lt;/li&gt;
  &lt;li&gt;한 사람에게 정확하게 하나의 일만 배정&lt;/li&gt;
  &lt;li&gt;모든 일은 정확하게 한 사람에게 배정&lt;/li&gt;
  &lt;li&gt;C[i,j], 1&amp;lt;= i, j&amp;lt;=N: 사람 i를 일 j에 배정하는 비용&lt;/li&gt;
  &lt;li&gt;총 배정 비용이 최소가 되도록 일을 배정&lt;/li&gt;
  &lt;li&gt;비용 행렬의 각 행에서 한 요소를 선택하는 문제와 같다&lt;/li&gt;
  &lt;li&gt;선택된 요소들은 다른 열에 있어야 하고 총 배정 비용이 가장 작아야 한다&lt;/li&gt;
  &lt;li&gt;가능한 해는 n-짝(n-tuple)($j_1$,$j_2$, … ,$j_n$)으로 나타낼 수 있다. $j_i$, 1 &amp;lt;=i &amp;lt;= n, 는 사람 i에게 배정된 일의 번호&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;완전 탐색 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;아이디어: 가능한 일 배정과 1부터 N사이의 정수들의 순열과 일대일 대응 관계가 있다는 사실을 이용&lt;/li&gt;
  &lt;li&gt;알고리즘: 1부터 N사이의 정수들의 모든 순열을 생성하고 각 순열에 대응하는 일 배정의 총 비용을 계산한 후 총 비용이 가장 작은 일 배정을 선택한다&lt;/li&gt;
  &lt;li&gt;시간 복잡도: 1부터 N사이의 정수들의 모든 순열의 수 = N!(&amp;gt;$2^n$)
    &lt;ul&gt;
      &lt;li&gt;O(N!)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;분기 한정 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;상태 공간 트리 = N항(N-ary) 트리​&lt;/li&gt;
  &lt;li&gt;해: 루트 노드로부터 잎까지의 경로​&lt;/li&gt;
  &lt;li&gt;살아 있는 노드: 아직 가지 치지 않은 유망한 잎​&lt;/li&gt;
  &lt;li&gt;현재 트리의 살아 있는 노드들중에서 가장 유망한 노드의 모든 자식 노드들을 생성 ​&lt;/li&gt;
  &lt;li&gt;가장 유망한 노드 = 한계값이 가장 작은 노드​&lt;/li&gt;
  &lt;li&gt;최선 우선 탐색 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;최선 우선 탐색 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;상태 공간 트리의 각 노드에 다음 값들을 저장한다
    &lt;ul&gt;
      &lt;li&gt;personNumber: 사람의 번호​&lt;/li&gt;
      &lt;li&gt;jobNumber: 일의 번호​&lt;/li&gt;
      &lt;li&gt;sumAssignedCost: 현재까지 배정된 일들의 비용들의 합​&lt;/li&gt;
      &lt;li&gt;bound: 한계값​&lt;/li&gt;
      &lt;li&gt;parent: 부모 노드​&lt;/li&gt;
      &lt;li&gt;assigned: 사람들에 일들의 배정 여부를 저장하는 배열&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;root: 루트 노드&lt;/li&gt;
  &lt;li&gt;child: 자식 노드&lt;/li&gt;
  &lt;li&gt;queue: 살아 있는 노드들을 포함하는 우선 순위 대기열&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;일 배정 분기 한정 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;JobAssignmentBandB(N, C[0 . . N – 1, 0 . . N – 1])​
// 입력: N – 사람들(일들)의 수​
//        C[0 . . N – 1, 0 . . N – 1]) – 특정 사람에게 특정 일을 배정하는 비용 배열​
// 출력: 일 배정 결과와 최소 배정 비용​
1  Initialize(queue) // queue를 빈 대기열로 초기화​
// 루트 노드의 값들을 초기화​
2  root.personNumber = -1​
3  root.jobNumber = -1​
4  root.sumAssignedCost = 0​
5  root.parent = null​
6  for (i = 0; i &amp;lt; N; i++) root.assigned[i] = false​
// 루트 노드의 한계값 계산​
7  root.bound = computeBound(-1, -1, root.assigned)​
// 루트 노드를 queue에 삽입​
8  queue.insert(root)
// queue가 비어 있지 않은 한 한계값이 최소인 살아 있는 노드를 ​
// 찾아서 그 노드의 자식 노드들을 queue에 추가​
9  while ( not queue.empty( )) {​
      // 최소 한계값을 가진 노드를 queue에서 끄집어 낸다​
10   minNode = queue.remove( )​
11   i = minNode.personNumber + 1  // i는 일을 배정할 다음 사람​
12   if (i = N) {​
13      모든 사람들에게 일들이 배정된 결과를 출력한다​
14      최소 배정 비용을 반환한다
      }
// 사람 i에 배정 가능한 일을 배정하는 모든 자식 노드를 만들어 queue에 추가​
15  for (j = 0; j &amp;lt; N; j++) {​
16      if ( not minNode.assigned[j] ) { // 일 j가 배정되지 않았는지 확인 ​
17         child.personNumber = i​
18         child.jobNumber = j​
19         for (k = 0; k &amp;lt; N; k++) child.assigned[k] = minNode.assigned[k]​
20         child.assigned[j] = true
21         child.parent = minNode​
            // 배정된 일들의 총 비용에 새로 배정된 일의 비용을 더한다​
22         child.sumAssignedCost = minNode.sumAssignedCost + C[i][j]​
            // 새 자식 노드의 한계값 계산​
23         child.bound = child.sumAssignedCost + computeBound(i, j, child.assigned)​
            // 새 자식 노드를 queue에 추가​
24        queue.insert(child)  }​
        }​
     }

computeBound(x,y,assigned)
// 입력: x - 방금 배정된 사람의 번호
//      y - 방금 배정된 일의 번호
//      assigned - 사람들에 일들의 배정 여부를 알려 주는 배열
// 출력: 남은 사람들에게 남은 일들을 배정하는 데 드는 총 비용의 하한
1 bound = 0
2 for (i = x + 1; i &amp;lt; N; i++){
3       minCost = $\infty$
4       minIndex = -1
5       for ( j = 0; j &amp;lt; N; j ++){ // 사람 i에 일을 배정하는 최소 비용을 찾는다
6           if(not assigned[j] and (j !=y) and C[i][j] &amp;lt; minCost){
7               minIndex = j
8               minCost = C[i][j]}}
            bound = bound + minCost // 다음 사람에게 배정 가능한 일의 최소 비용을
                                    // 더한다
            }
9 return bound

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;시간복잡도: O(N!)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="algorithm" /><summary type="html">분기 한정</summary></entry><entry><title type="html">Lambda Calculus​</title><link href="https://lee989898.github.io/pl-19" rel="alternate" type="text/html" title="Lambda Calculus​" /><published>2021-11-17T19:18:00+09:00</published><updated>2021-11-17T19:18:00+09:00</updated><id>https://lee989898.github.io/pl-19</id><content type="html" xml:base="https://lee989898.github.io/pl-19">&lt;h3 id=&quot;lambda-calculus&quot;&gt;&lt;strong&gt;Lambda Calculus​&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;__&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Why functional programming?​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;함수 프로그래밍이 왜 필요한가? ​
    &lt;ul&gt;
      &lt;li&gt;소프트웨어 제품이 신뢰성이 낮고, 관리하기 어려우며, 올바른지 증명하기 하기 어렵다. ​&lt;/li&gt;
      &lt;li&gt;그 이유는 다음과 같다. ​
        &lt;ul&gt;
          &lt;li&gt;소프트웨어를 새로 릴리즈할 때마다, 알려진 오류는 수정되나 새로운 오류가 발견된다. ​&lt;/li&gt;
          &lt;li&gt;소프트웨어의 정밀한 설계는 오랜 기간의 연구 개발을 필요로 하나, ​&lt;/li&gt;
          &lt;li&gt;현실적으로 시장 출시 압박이 우선한다. ​&lt;/li&gt;
          &lt;li&gt;하드웨어의 처리 능력이 증가함에 따라, ​&lt;/li&gt;
          &lt;li&gt;과거에 못하던 복잡한 어플리케이션을 자동화하느라, 소프트웨어의 복잡도가 증가한다. ​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이러한 현상을 극복하기 위해, 컴퓨터 과학자들은 두가지 중요한 문제를 풀어야 한다. ​
    &lt;ul&gt;
      &lt;li&gt;저비용으로 대규모 소프트웨어의 신뢰성과 사용자 편의성을 개선하는 방법 ​&lt;/li&gt;
      &lt;li&gt;저비용으로 처리 능력을 증가시키는 방법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이러한 문제에 대한 해결책으로, ​명령형 프로그래밍을 지지하는 측에서는, 소프트웨어 공학, 프로그램 증명 기법, 스펙을 프로그램으로 변환하는 기법, 새로운 (병렬) 컴퓨터 아키텍처 등을 연구해 왔다. ​&lt;/li&gt;
  &lt;li&gt;함수 프로그래밍을 지지하는 측에서는 프로그램으로서의 함수를 대안으로 연구해 왔다.  ​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Imperative and Functional programming style​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;계산 모델을 튜링 머신에 기반한 IPL은 기본 개념으로 ​메모리, 변수, 할당문, 반복처리(iteration)을 갖는다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;메모리는 프로그램과 데이터를 저장하고, ​&lt;/li&gt;
  &lt;li&gt;변수는 메모리 셀을 차지하고 있으며, 계산 결과의 변화에 따라 변경 가능한 값을 저장한다. ​&lt;/li&gt;
  &lt;li&gt;할당문은 계산 결과를 메모리에 저장하며, 이를 통해 변수의 값을 변경시킨다. ​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Iteration은 값이 변하는 변수를 통해 반복처리를 제어한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;명령형 프로그래밍의 장점은 실행 시스템의 구현이 단순하고 저비용 고효율이다. ​&lt;/li&gt;
  &lt;li&gt;명령형 프로그래밍의 단점은 ​
    &lt;ul&gt;
      &lt;li&gt;Goto는 아무런 조건없이 점프만하기 때문에, ​프로그램의 올바름을 판단하기 어렵게 만든다. ​&lt;/li&gt;
      &lt;li&gt;난로컬 변수와 할당문으로 인해 부작용이 발생하며, ​이로 인해 프로그램의 올바름을 판단하기 어렵게 만든다. ​&lt;/li&gt;
      &lt;li&gt;알고리듬의 어느 부분이 동시 처리 가능한지, ​동시처리하면 안되는지 탐지하기 어려워서, ​알고리듬이 필요 이상으로 순차적이다. ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최근 들어 많은 연구자들은 소프트웨어 위기와 속도 문제가 ​명령형 언어와 튜링 머신의 계산 모델에 기인한다고 추측하고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;함수 프로그램에서는, ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;함수 파라미터의 실제 ‘값’이 함수 호출의 결과를 유일하게 결정한다. ​&lt;/li&gt;
  &lt;li&gt;할당문이 없어서 함수의 부작용이 발생할 수 없다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FUNCTION increment (INTEGER value) : INTEGER;​
BEGIN​
value + 1​
END;​
:​
print(increment (41));​ 
print(increment (41));​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;함수의 결과는 파라미터의 값에 의해서만 결정되므로, ​어떠한 조건 하에서도 그 결과는 같다. ​이것을 referential transparenc라고 한다. ​이러한 이유로, 함수 increment의 결과 값은 둘다 42이다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;함수 프로그래밍 언어에서는 함수를 ‘일등 시민’으로 취급한다. ​&lt;/li&gt;
  &lt;li&gt;따라서 함수를 파라미터로 주고 받을 수 있다. ​&lt;/li&gt;
  &lt;li&gt;명령형 프로그래밍 언어에서는 함수를 파라미터로 주고 받을 수 없다. ​&lt;/li&gt;
  &lt;li&gt;함수 프로그래밍 언어는 함수의 일반적인 사용(합성 함수 f(g(x)) 등)을 지원한다. ​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이것은 종래의 명령형 언어에서 허용되지 않는다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;함수 프로그래밍 언어는 계산 모형을 람다 계산학에 기반하고 있으며, ​기본 개념으로 표현식(expression), 리커젼, 평가, 변수가 있다. ​&lt;/li&gt;
  &lt;li&gt;표현식은 수학식을 의미하며, ​리커젼은 재귀 함수에 의한 반복처리로서, iteration과 다르다. ​&lt;/li&gt;
  &lt;li&gt;평가는 함수의 실행을 의미하지만, 아무 것도 수정하지 않는다. ​&lt;/li&gt;
  &lt;li&gt;변수는 수학적 의미의 변수로서 알려지지 않은 값을 가지며, ​구체적인 값의 추상화일 뿐, 메모리를 차지하지 않는다. ​&lt;/li&gt;
  &lt;li&gt;따라서 값의 placeholder 역할을 하며, 수정 불가능하다. ​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;FPL에서는 명령형 언어적 의미의 변수가 없으므로, ​iteration이 불가능하며, ​대신에 반복처리를 위한 리커젼이 있다.​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;FPL의 장점은 ​
    &lt;ul&gt;
      &lt;li&gt;IPL의 기본 개념이 없어서, 소프트웨어 신뢰성을 높인다. ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로그래머는 함수를 정의하기만 하고, 인터프리터(실행 시스템)가 계산한다. ​&lt;/li&gt;
  &lt;li&gt;할당문이 없고, 변수의 개념이 IPL의 변수와 다르고, 부작용이 없다. ​
    &lt;ul&gt;
      &lt;li&gt;변수는 ‘아직 알려지지 않은 값’을 명명하고 언급한다. ​&lt;/li&gt;
      &lt;li&gt;부작용이 없어서, 올바름 증명이 쉽고, 함수의 평가는 순서에 무관하다. ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;따라서 FPL은 병렬 처리에 적합하다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;FPL의 단점은, ​우선, 실행 속도가 매우 느려서 비효율적이다. ​&lt;/li&gt;
  &lt;li&gt;그 이유는 다음과 같다. ​
    &lt;ul&gt;
      &lt;li&gt;머신 아키텍처가 함수 언어에 적합하게 설계되지 않았다. ​&lt;/li&gt;
      &lt;li&gt;함수 호출 비용이 비싸다. 특히 지연 평가시에… ​&lt;/li&gt;
      &lt;li&gt;파괴적 갱신(갱신되면 먼저 값이 없어짐)에 적합하므로, ​효율적인 컴파일 방법을 찾기 어렵고, ​
어떤 알고리듬에 대해, 시간 및 공간 복잡도가 너무 높다. ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이러한 경우에 효율을 위해 프로그램 변환이 필요하다. ​&lt;/li&gt;
  &lt;li&gt;아직 효율적인 컴파일 방법이 널리 사용 가능하지 않다. ​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;많은 경우에 함수 프로그램의 효율이 받아 들일 수 있는 수준에 있지만, ​컴파일 방법이 매우 복잡하고 연구 수준에 머물어 있다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;둘째, 명령형 프로그램의 특성이 강한 어플리케이션에 아직 부적합하다. ​
    &lt;ul&gt;
      &lt;li&gt;상호 작용이 강한 어플리케이션을 함수 프로그래밍 스타일로 표현하는 능력이 아직은 부족하다. ​&lt;/li&gt;
      &lt;li&gt;이들 어플리케이션으로는 상호적 프로그램, DBMS, OS, 프로세스 컨트롤 등이다. ​&lt;/li&gt;
      &lt;li&gt;함수 프로그래밍 기술 개발이 필요하다. ​&lt;/li&gt;
      &lt;li&gt;함수 스타일로 표현하기 어려운 어플리케이션을 함수 스타일로 표현하는 방법을 개발하는 것이 필요하다.  ​&lt;/li&gt;
      &lt;li&gt;현재, 윈도우, 다이알로그, 메뉴 등을 사용하는 상호적 프로그램을 함수 언어로 명세화하는 방법이 알려져 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Functions as programs ​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;함수가 프로그램인가? 이 문제에 대해 살펴 봅시다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;팩토리알을 구하는 함수는 프로그램이라고 간주해도 문제가 없다. ​프로그램의 종료 확인 함수(Halting)는 계산 가능하지 않고, 따라서 원하는 결과를 생산하지 못한다.  ​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;함수가 임의의 프로그램에 대해 halting 함수를 계산한다고 하자. ​만일 파라미터 프로그램이 종료되지 않는다면 ​Halting 함수는 종료되지 않을 것이고, ​Result 0이 절대로 생산되지 않는다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;이들 예에서 함수는 람다 계산학에 기반한 계산 모델을 사용하여 평가된다. ​&lt;/li&gt;
  &lt;li&gt;평가는 IPL의 실행과 유사하지만, IPL의 파괴적 갱신이 없다는 면에서 다르다.​&lt;/li&gt;
  &lt;li&gt;람다 계산학은 함수 정의 방식과 변수 대체 규칙(substitution)으로 구성된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Functional programs​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;FPL로 작성된 프로그램은 함수의 모음과 초기 표현식으로 구성된다. ​&lt;/li&gt;
  &lt;li&gt;초기 표현식이란 모든 파라미터가 상수인 (또는 상수로 대체된) 표현식을 말하는데, ​&lt;/li&gt;
  &lt;li&gt;이 식은 평가되어야 한다. -&amp;gt; reduce​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​+ 함수 정의는 표현식 내에서 다음 형태로 구성된다. ​(여기서는 scheme 문법을 차용함) ​
define (함수명 파라미터1 … 파라미터n) 표현식) ​
이와 같이 함수 프로그램을 정의하는 것은 recursive하다. ​
표현식은 함수 결과를 명세화하며, 값, 파라미터, 함수 적용(application)을 나타낸다. ​&lt;/p&gt;

&lt;p&gt;​+ 함수 적용(application), (f a)는 함수 f를 a에 적용하라는 뜻이다. ​
초기 표현식은 (+ 2 3), (squareinc 5)과 같이 계산될 수 있는 표현식이다.  ​
함수 프로그램의 예를 들어 보자. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Evaluation of functional programs​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;함수 프로그램의 평가는 실행이나 계산을 의미하는데,  이것은 초기 표현식의 평가와 리덕션(표현식의 축소화)에 의한다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;초기 표현식의 평가는 인터프리터가 수행하며, ​반복적으로 리덕션(또는 rewriting)을 수행한다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;예를 들어, ​&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(ident 42) → 42​
(square (+ 1 2)) → (square 3) → (* 3 3) → 9​
(squareinc 7) → (square (inc 7) → (square (+ 7 1)) → (square 8) → (*8 8) → 64​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;각 리덕션 단계에서(화살표로 표시)  ​&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;함수 적용은 함수의 파라미터를 대응하는 함수 body로 교체하는 것이다.  ​
리덕션 가능한 표현식(redex)은 함수 정의에 따라 rewrite 될 수 있는 서브 표현식을 말한다. ​&lt;/li&gt;
  &lt;li&gt;다음 상황에서 리덕션 과정이 끝난다.​
    &lt;ul&gt;
      &lt;li&gt;더 이상 redex가 남아 있지 않고,  ​(즉, 더 이상 어떠한 함수 정의라도 적용할 수 없을 때)​&lt;/li&gt;
      &lt;li&gt;초기 표현식이 가장 단순한 형태(normal form; 상수만 있는 축소화된 표현식)에 있을 때, ​결과를 프린트하고 종료한다.   ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Order of Evaluation&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;부작용이 없어서, 평가 순서는 무관하다. ​&lt;/li&gt;
  &lt;li&gt;리덕션 가능한 표현식이 다 없어진 후에, ​계산 결과는 항상 같고, 유일하다. ​&lt;/li&gt;
  &lt;li&gt;그러나 순서가 완전히 무관한 것은 아니다. ​경우에 따라 리덕션 순서는 결과를 생산하지 못할 뿐더러 종료되지 않을 수 있다. ​
    &lt;ul&gt;
      &lt;li&gt;종료 못하는 리덕션 순서의 예: ​&lt;/li&gt;
      &lt;li&gt;리커젼 함수의 정의가  ​(define (inf x) (inf x)) (define (alwaysseven x) 7)  일 때, ​만일 앞의 것을 먼저 계산하면, ​(alwaysseven (inf 2)) → (alwaysseven (inf 2)) → … 종료되지 않는다. ​&lt;/li&gt;
      &lt;li&gt;그러나 뒤의 것을 먼저 계산하면, ​(alwaysseven (inf 2)) → 7로 종료된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;리덕션 전략에는 call by value, call by name이 있다. ​&lt;/li&gt;
  &lt;li&gt;먼저 리슾, 스킴, 엠엘 등에서 사용되는 call by value를 살펴 보자. ​
    &lt;ul&gt;
      &lt;li&gt;Eager, strict evaluation이라고 한다. ​&lt;/li&gt;
      &lt;li&gt;리덕션 절차에 의해 함수 적용 그 자체가 리덕션 가능한 표현식이라고 간주(확인)되기 전에, ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;함수의 파라미터를 항상 리덕션한다. (그것이 초기 표현식일 때) ​
    &lt;ul&gt;
      &lt;li&gt;파리미터에 대한 함수 적용은 그 파라미터가 값일때만, 리덕션 가능한 표현식이 된다. ​&lt;/li&gt;
      &lt;li&gt;조건 연산자 if의 적용 후에, if의 파라미터를 평가한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;하스켈에서 사용되는 Call by name를 살펴 보자. ​
    &lt;ul&gt;
      &lt;li&gt;lazy evaluation이라고 한다. ​&lt;/li&gt;
      &lt;li&gt;값이 알려져서 초기 표현식이 되고 값을 반환해야 할 때가 되면,  ​비로소 리덕션 가능한 서브 표현식의 값이 계산된다. ​&lt;/li&gt;
      &lt;li&gt;조건 함수의 call by name은 ​첫째 파라미터(if 다음의 부울식)의 평가를 요구한다.  ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정리하면, ​Eager는 초기 표현식이 만들어지면 바로 계산하여 리덕션(축소화)하지만, ​
Lazy는 초기 표현식이 만들어지더라도 그 식의 값이 필요할(반환해야 할) 때 계산한다. ​
표현식에 조건함수가 있다면, if 다음의 부울식을 계산해 가면서 표현식을 펼쳐 가면서 리덕션한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Recursion ​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;리커젼은 순환적으로 정의된 데이터에 대한 함수 정의에 자연스럽게 적용되는 절차이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Higher-order functions​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;FPL은 함수의 개념에 대해 일반적인 관점을 갖는다. ​&lt;/li&gt;
  &lt;li&gt;함수는 ‘일등 시민’으로 (객체처럼) 취급된다. ​&lt;/li&gt;
  &lt;li&gt;함수는 파라미터와 결과로서 함수를 가질(사용할) 수 있다. ​&lt;/li&gt;
  &lt;li&gt;고차 함수는 파라미터로 함수를 갖거나 결과로서 함수를 생산한다. ​&lt;/li&gt;
  &lt;li&gt;일차 함수는 파라미터와 결과로서 함수가 아닌 값을 갖는다. ​&lt;/li&gt;
  &lt;li&gt;예에서 파라미터로서 함수 f를 갖는다. ​&lt;/li&gt;
  &lt;li&gt;이때 f는 목적에 따라 inc, square, ident 등이 된다. ​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이와 같이 파라미터로서 함수를 쓰는 것은 ​동일한 함수를 다른 경우에 적용하는데 유용하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;자연수 n을 인풋으로 받아서 ​sum, product를 구하는 프로그램을 짠다고 하면, ​
위의 슬라이드와 같다. ​&lt;/li&gt;
  &lt;li&gt;왼쪽은 함수 파라미터가 없이 ​미리 정의된 함수 G만을 사용하여 계산하는 경우이고, ​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;오른쪽은 함수 파라미터를 갖고 있어서, ​목적에 따라 다양한 함수를 사용하여 계산할 수 있는 경우이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;파라미터와 결과로서 함수를 갖는 함수의 예로 함수 합성을 들 수 있다. ​&lt;/li&gt;
  &lt;li&gt;함수의 합성은 두개의 함수를 인풋으로 받아서, 합성 함수를 반환한다. ​&lt;/li&gt;
  &lt;li&gt;합성 함수를 정의하려면, 함수를 나타내는 표현식을 함수명 없이 쓸 수 있어야 한다. ​&lt;/li&gt;
  &lt;li&gt;이와 같은 함수를 익명 함수라고 부르며, 그 신택스는 다음과 같다. ​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(lambda (파라미터1, … 파라미터n)  body)​ 이것을 이용하여 합성 함수를 정의하면, ​(define (compose f g) (lambda (x) (f (g x))))가 된다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;파라미터로 주어진 함수와 동일한 유형의 함수와 ​&lt;/li&gt;
  &lt;li&gt;n일 때 갱신된 새로운 값을 반환하는 ​&lt;/li&gt;
  &lt;li&gt;고차 함수의 정의는 다음과 같다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(define (change-value-at-n  f  n  new-value)​
        (lambda (x)​
            (if (= x n)​
                new-value​
                (f x))))​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;여기서 람다가 들어가는 이유는 이것이 새로운 함수이기 때문이다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;표현식을 정의하는 신택스는 (define name expr)이다. ​&lt;/li&gt;
  &lt;li&gt;표현식의 예는 (define a (+ 3 4)) (* a 2)  결과는 14이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Data structures​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;FPL의 데이터 구조는 read-only이다. ​&lt;/li&gt;
  &lt;li&gt;Overwrite할 수 없고, 글로벌하게 사용하지 못하지만, ​파라미터로서 함수에 패스된다. ​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리스트는 FPL에서 미리 정의된 자료구조로, recursive하다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;리스트를 구성하는 데 필요한 데이터 컨스트럭터는 다음과 같다. ​
    &lt;ul&gt;
      &lt;li&gt;empty: 엠티 리스트를 나타낸다. ​&lt;/li&gt;
      &lt;li&gt;cons: 값과 리스트를 인풋으로 받아서 v를 첫째 요소로 하는 새로운 리스트를 반환한다. ​&lt;/li&gt;
      &lt;li&gt;여러 값을 리스트로 만들어야 할 때 cons 대신에 list 함수를 사용한다. ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;리스트의 조작을 위해 미리 정의된 셀렉터는 다음과 같다. ​
    &lt;ul&gt;
      &lt;li&gt;car: 리스트를 인풋으로 받아서 첫째 요소를 반환한다.    ​&lt;/li&gt;
      &lt;li&gt;cdr: 리스트를 인풋으로 받아서 첫째 요소를 제외한 나머지를 반환한다.    ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(define Pamuk (list #t 2 #f))에서, ​
(car Pamuk)은 #t을 반환하고,​
(cdr Pamuk)은 (2 #f)를 반환한다. ​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Definition of Lambda calculus ​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Free and bound variables ​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Substitution as a computation ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;람다 계산학은 FPL의 계산 모델이다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;람다 계산학은 하나의 변환 규칙과 하나의 함수 정의 방식(스킴)으로 구성된다.​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;변환 규칙은 변수 대체로서, 베타 변환이라고도 한다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;표현식은 이름이거나 함수이다. ​&lt;/li&gt;
  &lt;li&gt;이름은 값을 담고 있는 것의 식별자이고, ​함수는 파라미터의 이름을 표시하기 위해, ​
그리스 문자 람다를 사용한다. ​&lt;/li&gt;
  &lt;li&gt;함수의 body는 λ&lt;파라미터&gt;의 뒤에 나오는 표현식으로, ​파라미터를 어떻게 재구성할 것인지 명세화한다. ​&lt;/파라미터&gt;&lt;/li&gt;
  &lt;li&gt;표현식의 (순환적) 정의는 다음 3개의 규칙에 의한다. ​
    &lt;ul&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;&amp;lt; expression &amp;gt; := &amp;lt; name &amp;gt;&lt;/td&gt;
              &lt;td&gt;&amp;lt; function &amp;gt;&lt;/td&gt;
              &lt;td&gt;&amp;lt; application &amp;gt; ​&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;&amp;lt; function &amp;gt; := λ &amp;lt; name &amp;gt; . &amp;lt; expression &amp;gt; ​&lt;/li&gt;
      &lt;li&gt;&amp;lt; application &amp;gt; := &amp;lt; expression &amp;gt;&amp;lt; expression &amp;gt; ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;여기서 name은 파라미터명을, application은 함수의 적용을 나타낸다. ​&lt;/li&gt;
  &lt;li&gt;함수의 적용은 name과 function이 나열될 수 있다. 앞에서 나온 f a처럼 함수의 body는 &lt;expression&gt; 이다. ​&lt;/expression&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​+ 합성 표현식은 지속적인 표현식을 적용하여 합성 표현식을 평가한다.  ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;즉, E1E2E3 . . . En ≡  (. . . ((E1E2)E3) . . . En)이다. ​&lt;/li&gt;
  &lt;li&gt;여기서 ≡는 동동성(equivalence)를 나타낸다. ​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모호함을 줄이기 위해, λx.x ≡ (λx.x)와 같이 괄호를 사용한다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;함수는 표현식에 적용될 수 있다. ​
    &lt;ul&gt;
      &lt;li&gt;이러한 경우에 해당되는 단순한 예로, (λx.x)y을 들 수 있다. ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이것은 y에 identity 함수를 적용하는 것이다. ​
    &lt;ul&gt;
      &lt;li&gt;이때, 표현식이 모호해 질 수 있으며, 괄호를 써서 모호성을 피한다.  ​&lt;/li&gt;
      &lt;li&gt;함수 적용의 평가는 파라미터를 함수 정의의 body로 대체하는 것이다.​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;위의 예에서, X를 y로 대체하는 것이 함수 적용의 평가이다. ​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;맨 아랫줄의 [y/x]는 x를 y로 대체하는 것을 나타낸다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;대체하는 것을 베타 리덕션이라고도 한다. ​&lt;/li&gt;
  &lt;li&gt;이것을 자세히 들여다 보면, 두 단계로 이루어짐을 알 수 있다. ​&lt;/li&gt;
  &lt;li&gt;파라미터가 표현식을 받아들인다(take in). 이후 표현식으로 body의 파라미터를 교체한다. ​&lt;/li&gt;
  &lt;li&gt;그림은 이 과정을 보여준다. ​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리덕션(축소화)은 함수 적용을 통해 ​표현식에 포함된 함수 정의를 줄여 나가는(축소하는) 과정이다.  ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;변수는 자유 변수와 속박 변수로 구분된다. ​
    &lt;ul&gt;
      &lt;li&gt;모든 name(변수)는 함수 정의 내에서 로컬이다. ​&lt;/li&gt;
      &lt;li&gt;함수 λx.x에서 body 내의 x는 그 앞에 λx가 있기때문에 속박 변수이다. ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자유 변수는 name 앞에 λ가 없다. ​
    &lt;ul&gt;
      &lt;li&gt;표현식 (λx.x)(λy.yx)에서, 첫째 표현식의 body에 있는 x는 첫째 λ에 속박되어 있다.  ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;두번째 표현식의 body에 있는 y는 두번째 λ에 속박되어 있다. ​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;두번째 표현식의 body에 있는 x는 자유변수이며, 첫번째 표현식의 x와 전적으로 독립적이다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;이 슬라이드는 표현식 (λx.x)(λy.yx)의 베타 리덕션을 보여준다. ​&lt;/li&gt;
  &lt;li&gt;앞 표현식의 x가 두번째 표현식을 받아 들여서 ​앞 표현식의 body의 x를 두번째 표현식으로 교체한다. ​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이와 같이 함수 적용을 통해, 표현식의 함수 정의를 제거함으로써, ​표현식을 축소해 나간다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;베타 리덕션의 조금 복잡한 사례를 살펴 보자 ​&lt;/li&gt;
  &lt;li&gt;표현식이 (λx.(λy.xy))y 라고 하자. ​&lt;/li&gt;
  &lt;li&gt;대체할 때, 자유 변수와 속박 변수를 혼동하지 않도록 조심해야 한다. ​&lt;/li&gt;
  &lt;li&gt;왼쪽의 함수는 속박변수 y를 포함한다. ​&lt;/li&gt;
  &lt;li&gt;오른쪽 표현식의 y는 괄호 밖에 있으며, 따라서 자유 변수이다. ​&lt;/li&gt;
  &lt;li&gt;변수 y는 왼쪽에서는 속박 변수, 오른쪽에서는 자유 변수이다. ​&lt;/li&gt;
  &lt;li&gt;이때 이들을 혼동하면 (λy.yy) 로 잘못 리덕션된다. ​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;혼동을 피하려면, 속박 변수 y를 t로 재명명(rename)하면 된다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;정리해 보면,…​&lt;/li&gt;
  &lt;li&gt;교체했다고 가정하고, ​&lt;/li&gt;
  &lt;li&gt;새로 교체한 변수가 이후의 표현식에서 기존의 바운드 변수로 사용되었다면, ​&lt;/li&gt;
  &lt;li&gt;전혀 다른 두 변수가 동일한 이름을 쓰게 되기 때문에, ​새로 교체한 변수와 기존의 바운드 변수를 구분할 필요가 있다. ​&lt;/li&gt;
  &lt;li&gt;이를 위해 기존의 바운드 변수를 재명명(rename)한다. ​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그러나 (λx.(λt.xt))y 와 같이 끝의 y는 free이므로 rename하지 않는다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;이 슬라이드의 윗 부분은 앞 슬라이드의 ‘정리하면’의 부분이다. ​&lt;/li&gt;
  &lt;li&gt;끝으로 조금 더 복잡한 예를 들어 보자. ​&lt;/li&gt;
  &lt;li&gt;앞쪽 함수는 변수 y에 적용하면, ​&lt;/li&gt;
  &lt;li&gt;오른쪽 표현식의 자유변수 y(빨간)와 앞의 함수의 body, ​&lt;/li&gt;
  &lt;li&gt;또 다시 body의 속박변수 y(파란)와 혼동된다(구별되지 않는다). ​&lt;/li&gt;
  &lt;li&gt;혼동을 피하고 이들을 구별하려면, 속박변수 y를 t로 재명명한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Arithmetic functions​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Successor 함수를 이와 같이 정의하자.  ​
여기서 n은 a의 개수이다. ​
앞에서 정의한 0, 1, 2, 3을 참고하자. ​&lt;/p&gt;

&lt;p&gt;그렇다면 Addition과 Multiplication 함수는 ​
Successor 함수를 이용하여 다음과 같이 정의할 수 있다. ​
2+3은 2S3으로, (λsz.s(sz)))S3 로 정의할 수 있고, 이것을 리덕션하면, ​
→S(S3) → · · · → 5 가 된다. ​
3*3은 (λxya.x(ya))33 → (λa.3(3a)) 으로 정의되며, ​
이것을 리덕션하면 9가 된다. ​&lt;/p&gt;

&lt;p&gt;—​&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Recursion&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;함수 Y를 이와 같이 정의한다. ​
Y를 함수 R에 적용하면, YR은 이와 같다. ​
이것을 리덕션하면, YR -&amp;gt; R(YR)가 된다. ​
람다 계산학에서 리커젼은 이와 같이 표현되며, ​
R의 평가(계산)은 YR의 순환 호출을 사용한다. ​&lt;/p&gt;

&lt;p&gt;이것으로 함수 프로그램과 람다 계산학의 소개를 마칩니다.&lt;/p&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="pl" /><summary type="html">Lambda Calculus​ __</summary></entry><entry><title type="html">__Diffie-Hellman__</title><link href="https://lee989898.github.io/sc-14" rel="alternate" type="text/html" title="__Diffie-Hellman__" /><published>2021-11-17T01:06:00+09:00</published><updated>2021-11-17T01:06:00+09:00</updated><id>https://lee989898.github.io/sc-14</id><content type="html" xml:base="https://lee989898.github.io/sc-14">&lt;h3 id=&quot;diffie-hellman&quot;&gt;&lt;strong&gt;Diffie-Hellman&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Diffie-Hellman&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;보안성 없는 매체를 통한 Symmetric key 공유&lt;/li&gt;
  &lt;li&gt;송/수신자를 위한 일회용 Secret/shared session key agreement protocol&lt;/li&gt;
  &lt;li&gt;이산대수문제&lt;/li&gt;
  &lt;li&gt;IPSEC, 상용sw에 자주 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Steps&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;p,g: 큰 정수, 1 &amp;lt; q &amp;lt; p, 모든 사용자에 공개&lt;/li&gt;
  &lt;li&gt;Alice는 임의로 a 생성, A = $g^a$ mod p 계산&lt;/li&gt;
  &lt;li&gt;Bob은 임의로 b 생성, B = $g^b$ mod p 계산&lt;/li&gt;
  &lt;li&gt;A,B를 서로 교환&lt;/li&gt;
  &lt;li&gt;Alice와 Bob은 K=$g^{ab}$ mod p&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Deiffie-Hellman의 취약성: 중간자 공격&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Man in the middle attack: Trudy poses as Alice and as Bob
    &lt;ul&gt;
      &lt;li&gt;Diffe-Hellman은 매우 복잡한 프로토콜이지만, 제 3자가 x 또는 y 값을 알아내지 않아도 되기 때문에 중간에서 밥과 앨리스를 속이는 것이 가능하다.​&lt;/li&gt;
      &lt;li&gt;중간자 공격 절차​
        &lt;ol&gt;
          &lt;li&gt;앨리스가 x를 선택한 후 R1=Gx를 계산하여 R1을 밥에게 전송​&lt;/li&gt;
          &lt;li&gt;제 3자가 R1을 가로챈 후, z를 선택한 다음 R2=Gz mod N을 계산하여 R2를 앨리스와 밥에게 전송​&lt;/li&gt;
          &lt;li&gt;밥이 y를 선택한 다음 R3=Gy mod N을 계산해서 R3을 앨리스에게 전송, R3을 제 3자가 가로챔​&lt;/li&gt;
          &lt;li&gt;앨리스와 제 3자가 공유한 키 K1=Gxz mod N을 계산​&lt;/li&gt;
          &lt;li&gt;제 3자와 밥은 공유한 키 K2=Gzy mod N을 계산​&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;경우 앨리스와 밥은 제 3자와 공유한 키를 서로간의 공유한 키로 생각​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자 인증을 하지 않아서 발생하는 문제 -&amp;gt; 전자서명, 인증서&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="security" /><summary type="html">Diffie-Hellman</summary></entry><entry><title type="html">__DRM(Digital Right Managemment__</title><link href="https://lee989898.github.io/sc-15" rel="alternate" type="text/html" title="__DRM(Digital Right Managemment__" /><published>2021-11-17T01:06:00+09:00</published><updated>2021-11-17T01:06:00+09:00</updated><id>https://lee989898.github.io/sc-15</id><content type="html" xml:base="https://lee989898.github.io/sc-15">&lt;h3 id=&quot;drmdigital-right-managemment&quot;&gt;&lt;strong&gt;DRM(Digital Right Managemment&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;DRM&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;digital 저작권 관리&lt;/li&gt;
  &lt;li&gt;Digital contents의 불법 사용을 제한/방지하고, 저작권을 보고하기 위한 기술 및 서비스&lt;/li&gt;
  &lt;li&gt;Digital contents
    &lt;ul&gt;
      &lt;li&gt;audio,video,image,text,multimedia,sw 등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;저작권이란&lt;/li&gt;
  &lt;li&gt;Copyright​&lt;/li&gt;
  &lt;li&gt;저작자가 자신이 창작한 저작물에 대해 갖는 권리(저작권법)​
    &lt;ol&gt;
      &lt;li&gt;복제권: 저작자는 저작물을 복제할 권리를 갖는다​&lt;/li&gt;
      &lt;li&gt;공연권​&lt;/li&gt;
      &lt;li&gt;공중송신권​&lt;/li&gt;
      &lt;li&gt;전시권: 원본이나 복제물을 전시할 권리​&lt;/li&gt;
      &lt;li&gt;배포권: 원본이나 복제물을 배포. 다만, 저작자의 허락을 받아 판매등의 방법으로 거래에 제공된 경우는 제외​&lt;/li&gt;
      &lt;li&gt;대여권: 영리를 목적으로 대여할 권리​&lt;/li&gt;
      &lt;li&gt;2차적 저작물작성권: 원저작물로 하는 2차적저작물을 작성하여 이용할 권리​&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Common DRM business model&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Provider​
    &lt;ul&gt;
      &lt;li&gt;저자물(권) 소유​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Distributor​
    &lt;ul&gt;
      &lt;li&gt;유통을 담당하는 배급자​&lt;/li&gt;
      &lt;li&gt;합법적인 소비자에게만 제공해야​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Clearinghouse​
    &lt;ul&gt;
      &lt;li&gt;디지털 상품에 대한 권리발급​&lt;/li&gt;
      &lt;li&gt;배급료, 사용료 처리 (Log기록)​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Consumer​
    &lt;ul&gt;
      &lt;li&gt;Clearinghouse에 사용료지급하고  distributor로부터 컨텐츠제공받음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;주요기술 1: Stegano graphy(숨겨진 글)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;평범해 보이는 미디어에 내용을 아는 수신자만 알아볼 수 있도록 은밀히 정보를 숨기는 기술​&lt;/li&gt;
  &lt;li&gt;암호화알고리즘이 안전하지 않을 때 유용&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;주요기술 2: Watermark&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;빛을 비출때나 반사될 때 더 밝게 보이는, 인지할 수 있는 종이의 무늬나 그림​&lt;/li&gt;
  &lt;li&gt;지폐, 상표, 문서 등의 위조 방지에 많이 사용된다&lt;/li&gt;
  &lt;li&gt;Digital watermarking​
    &lt;ul&gt;
      &lt;li&gt;Text, image, video, audio 등의 원본 데이터에 본래 소유주만이 아는 mark를 사람의 감각으로 식별할 수 없게 삽입하는 기술​&lt;/li&gt;
      &lt;li&gt;일부 digital data가 손상되더라도 인간은 감지할 수 없음​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;복제방지, 원본여부, 재생횟수제한, 유효기간설정, 시간제한 등에 활용&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="security" /><summary type="html">DRM(Digital Right Managemment</summary></entry><entry><title type="html">프로세스통신-socket</title><link href="https://lee989898.github.io/st-09" rel="alternate" type="text/html" title="프로세스통신-socket" /><published>2021-11-16T01:06:00+09:00</published><updated>2021-11-16T01:06:00+09:00</updated><id>https://lee989898.github.io/st-09</id><content type="html" xml:base="https://lee989898.github.io/st-09">&lt;h3 id=&quot;프로세스통신-socket&quot;&gt;&lt;strong&gt;프로세스통신-socket&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Socket&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Pipe는 통신하는 프로세스들을 하나의 시스템 내부로 한정 ​&lt;/li&gt;
  &lt;li&gt;Socket은 같은 시스템에 속한 프로세스들 뿐만 아니라, 서로 다른 시스템들에 속한 프로세스들 간의 통신을 가능케 함​
    &lt;ul&gt;
      &lt;li&gt;socket() 시스템 호출에 의해 만들어 짐 ​&lt;/li&gt;
      &lt;li&gt;응용 프로그램의 관점에서는 pipe와 마찬가지로 파일 디스크립터를 통해 접근(read, write, 등) 가능​&lt;/li&gt;
      &lt;li&gt;Kernel의 관점에서 socket은 IPC를 위한 통신의 끝점(또는 출입구)에 해당함​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;전혀 관계없는 프로세스간에 통신을 위해 socket을 식별할 목적으로 이름을 붙임​
    &lt;ul&gt;
      &lt;li&gt;파일 이름 또는 번호​&lt;/li&gt;
      &lt;li&gt;bind() 시스템 호출 사용​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;이름 붙이기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Linux 도메인에서는 socket 이름으로 파일 이름 사용 (경로명 포함)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;INET(Internet) 도메인에서는 socket 이름으로 포트번호 사용​&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;Well-known port: ftp는 21번, telnet은 23번, 등등. ​&lt;/li&gt;
      &lt;li&gt;통신 상대 프로세스가 속한 컴퓨터 시스템 이름(IP address) + 
  포트 번호&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st21.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Stream Socket을 이용한 IPC&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Virtual circuit​
    &lt;ul&gt;
      &lt;li&gt;통신 대상에 연결(논리적 접속)을 설정​&lt;/li&gt;
      &lt;li&gt;그 연결을 통하여 데이터를 송수신​&lt;/li&gt;
      &lt;li&gt;송수신이 끝나면 연결 해제​&lt;/li&gt;
      &lt;li&gt;연결형 통신이라고 부름 : 전화에 비유​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Stream socket​
    &lt;ul&gt;
      &lt;li&gt;Virtual circuit 기능을 이용하여 구현한 socket​&lt;/li&gt;
      &lt;li&gt;프로세스간에 대량의 데이터를 송수신하는 경우 이용 ​&lt;/li&gt;
      &lt;li&gt;통신의 신뢰성 보증​&lt;/li&gt;
      &lt;li&gt;송신한 정보가 없어지거나 바뀌지 않음​&lt;/li&gt;
      &lt;li&gt;올바른 순서로 수신됨​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;연결형 프로토콜의 예 : TCP (Transmission Control Protocol)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Client :​
    &lt;ul&gt;
      &lt;li&gt;Socket 작성 : socket() 시스템 호출​&lt;/li&gt;
      &lt;li&gt;Socket에 이름 붙임 : bind()  생략 가능​&lt;/li&gt;
      &lt;li&gt;Server에 접속 요구 : connect()​&lt;/li&gt;
      &lt;li&gt;데이터 송수신 : read()/write()  socket이 파일 디스크립터로 접근 가능하므로​&lt;/li&gt;
      &lt;li&gt;Socket 제거 : close()​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Server : ​
    &lt;ul&gt;
      &lt;li&gt;Socket 작성 : socket() 시스템 호출​&lt;/li&gt;
      &lt;li&gt;Socket에 이름 붙임 : bind()​&lt;/li&gt;
      &lt;li&gt;Client의 접속 요구 받을 준비 : listen()​&lt;/li&gt;
      &lt;li&gt;접속 요구 허가 : accept()​&lt;/li&gt;
      &lt;li&gt;데이터 송수신 : read()/write()​&lt;/li&gt;
      &lt;li&gt;Socket 제거 : close()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st22.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Datagram Socket을 이용한 IPC&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Datagram​
    &lt;ul&gt;
      &lt;li&gt;통신 대상에 연결(논리적 접속)을 설정할 필요 없음​&lt;/li&gt;
      &lt;li&gt;개개의 데이터를 그때 그때 상대방에게 보냄​&lt;/li&gt;
      &lt;li&gt;비 연결형 통신이라고 부름 : 편지에 비유​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Datagram socket​
    &lt;ul&gt;
      &lt;li&gt;Datagram 기능을 이용하여 구현한 socket​&lt;/li&gt;
      &lt;li&gt;프로세스간에 작은 데이터를 계속해서 보내는 통신​&lt;/li&gt;
      &lt;li&gt;매번 데이터를 보낼 때마다 상대방을 지정 ​&lt;/li&gt;
      &lt;li&gt;전송 데이터의 신뢰성이 보증되지 않음 : 시간, 순서, 등​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;비 연결형 프로토콜의 예 : UDP (User Datagram Protocol)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Client :​
    &lt;ul&gt;
      &lt;li&gt;Socket 작성 : socket() 시스템 호출​&lt;/li&gt;
      &lt;li&gt;Socket에 이름 붙임 : bind()  생략 가능​&lt;/li&gt;
      &lt;li&gt;데이터 송신 : sendto() ​&lt;/li&gt;
      &lt;li&gt;데이터 수신 : recvfrom()​&lt;/li&gt;
      &lt;li&gt;Socket 제거 : close()​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Server : ​
    &lt;ul&gt;
      &lt;li&gt;Socket 작성 : socket() 시스템 호출​&lt;/li&gt;
      &lt;li&gt;Socket에 이름 붙임 : bind()​&lt;/li&gt;
      &lt;li&gt;데이터 수신 : recvfrom()​&lt;/li&gt;
      &lt;li&gt;데이터 송신 : sendto()​&lt;/li&gt;
      &lt;li&gt;Socket 제거 : close()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;socket() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int socket(int domain, int type, int protocol)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;소켓을 생성​
    &lt;ul&gt;
      &lt;li&gt;int domain :  사용하는 도메인의 종류​&lt;/li&gt;
      &lt;li&gt;int type :      사용하는 소켓 타입​&lt;/li&gt;
      &lt;li&gt;int protocol : 사용하는 프로토콜의 종류​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정상 종료시 생성된 소켓에 대한 파일 디스크립터 반환, 에러시 -1 반환&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Domain의 종류 ​
    &lt;ul&gt;
      &lt;li&gt;PF_UNIX : unix domain ​&lt;/li&gt;
      &lt;li&gt;PF_INET : inet domain​&lt;/li&gt;
      &lt;li&gt;그 이외​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Socket type의 종류​
    &lt;ul&gt;
      &lt;li&gt;Sock_stream : stream socket​&lt;/li&gt;
      &lt;li&gt;Sock_dgram : datagram socket​&lt;/li&gt;
      &lt;li&gt;그 이외​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용되는 고유의 protocol 지정. 대부분 0을 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;bind() system call​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int bind(int sockfd, struct sockaddr *my_addr, int len)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;int sockfd : socket() 시스템 호출에서 돌려 받은 socket 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;struct sockaddr *my_addr : 이름을 붙일 구조체​
    &lt;ul&gt;
      &lt;li&gt;struct sockaddr *my_addr 에는 다음을 지정​
        &lt;ul&gt;
          &lt;li&gt;Unix domain 또는 Inet domain 중 어느 쪽을 사용할 지​&lt;/li&gt;
          &lt;li&gt;Socket 이름​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;int len :  이름이 붙여진 구조체(*my_addr)의 길이​&lt;/li&gt;
  &lt;li&gt;Unix Domain에서 socket의 주소 정보는 socketaddr_un 구조체에서 정의​
```
#include &amp;lt;sys/un.h&amp;gt;​
#define UNIX_PATH_MAX 108​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;struct sockaddr_un {​
    sa_family_t   sun_family;     /* sa_family_t는 short과 같은 타입&lt;em&gt;/​
     /&lt;/em&gt; PF_UNIX 설정 &lt;em&gt;/​
    char sun_path[UNIX_PATH_MAX];   /&lt;/em&gt; 경로명 */​&lt;/p&gt;

&lt;p&gt;};&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ Inet Domain에서 socket의 주소 정보는 socketaddr_in 구조체에서 정의​

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;#include &amp;lt;netinet/in.h&amp;gt;​&lt;/p&gt;

&lt;p&gt;struct sockaddr_in {​
    sa_family_t     sin_family;   /* PF_INET 설정 &lt;em&gt;/
    u_int16_t        sin_port;      /&lt;/em&gt; 포트 번호 &lt;em&gt;/​
    struct in_addr   sin_addr;    /&lt;/em&gt; IP 주소 */​&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;}; ​ struct in_addr { u_int32_t  s_addr; };  /* IP 주소 */ ```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;connect() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;netinet/in.h&amp;gt;​
#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int connect(int sockfd, const struct socketaddr *serv_addr, socklen_t addr_len)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;스트림 소켓 이용시 client에서 호출 (서버에 접속 요청)​&lt;/li&gt;
  &lt;li&gt;정상 종료시 0을 반환, 에러시 -1 반환​
    &lt;ul&gt;
      &lt;li&gt;int sockfd : socket 파일 디스크립터를 지정​&lt;/li&gt;
      &lt;li&gt;struct sockaddr *serv_addr : 접속하고 싶은 서버의 소켓 주소 정보 ​&lt;/li&gt;
      &lt;li&gt;socklen_t addr_len : 서버의 소켓 주소 정보 구조체의 길이​
​
        &lt;blockquote&gt;
          &lt;p&gt;listen() system call&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/socket.h&amp;gt;​

int listen(int sockfd, int backlog)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;스트림 소켓 이용시 server에서 호출 정상 종료시 0을 반환, 에러시 -1 반환​&lt;/li&gt;
  &lt;li&gt;int sockfd : socket 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;int backlog : 연결 요청에 대한 대기열의 최대 길이(대개 5)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;accept() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int accept(int sockfd, struct sockaddr *client_addr, socklen_t *addrlen)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;스트림 소켓 이용시 server에서 호출​&lt;/li&gt;
  &lt;li&gt;정상 종료시 소켓에 대한 새로운 파일 디스크립터를 반환, 에러시 -1 반환​&lt;/li&gt;
  &lt;li&gt;int sockfd : socket 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;struct sockaddr *client_addr : client의 socket 주소 정보 구조체를 가리키는 포인터​&lt;/li&gt;
  &lt;li&gt;socklen_t *addrlen : client의 socket 주소 정보 구조체의 길이&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;send() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int send(int sockfd, const void *buf, size_t len, int flags)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Send() : 소켓으로 데이터 보냄&lt;/li&gt;
  &lt;li&gt;정상 종료시 실제 보낸 바이트 수를 반환, 에러시 -1 반환​&lt;/li&gt;
  &lt;li&gt;int sockfd : accept로 반환된 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;const void *buf : 송신 버퍼의 시작 주소​&lt;/li&gt;
  &lt;li&gt;size_t len : 송신 데이터의 길이​&lt;/li&gt;
  &lt;li&gt;int flags : 송신 옵션&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;recv() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int recv(int sockfd, void *buf, size_t len, int flags)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Recv() : 소켓으로부터 데이터 받음&lt;/li&gt;
  &lt;li&gt;정상 종료시 실제 받은 바이트 수를 반환, 에러시 -1 반환​&lt;/li&gt;
  &lt;li&gt;int sockfd : accept로 반환된 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;void *buf : 수신 버퍼의 시작 주소​&lt;/li&gt;
  &lt;li&gt;size_t len : 수신 데이터의 길이​&lt;/li&gt;
  &lt;li&gt;int flags : 수신 옵션&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;sendto() system call​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;​

int sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *to, socklen_t tolen)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Sendto() : 데이터그램 소켓으로 데이터 보냄​&lt;/li&gt;
  &lt;li&gt;정상 종료시 실제 보낸 바이트 수를 반환, 에러시 -1 반환​&lt;/li&gt;
  &lt;li&gt;int sockfd : 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;const void *buf : 송신 버퍼의 시작 주소​&lt;/li&gt;
  &lt;li&gt;size_t len : 송신 데이터의 길이​&lt;/li&gt;
  &lt;li&gt;int flags : 송신 옵션 ​&lt;/li&gt;
  &lt;li&gt;const struct sockaddr *to : 받을 곳의 소켓 주소 정보 구조체를 가리키는 포인터​&lt;/li&gt;
  &lt;li&gt;socklen_t tolen : 받을 곳의 소켓 주소 정보 구조체의 길이​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;recvfrom() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlen)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;Recvfrom() : 데이터그램 소켓에서 데이터 받음​&lt;/li&gt;
  &lt;li&gt;정상 종료시 실제 받은 바이트 수를 반환, 에러시 -1 반환​&lt;/li&gt;
  &lt;li&gt;int sockfd : 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;void *buf : 수신 버퍼의 시작 주소​&lt;/li&gt;
  &lt;li&gt;size_t len : 수신 데이터의 길이​&lt;/li&gt;
  &lt;li&gt;int flags : 수신 옵션​&lt;/li&gt;
  &lt;li&gt;struct sockaddr *from : 보내는 곳의 소켓 주소 정보 구조체를 가리키는 포인터​&lt;/li&gt;
  &lt;li&gt;socklen_t tolen : 보내는 곳의 소켓 주소 정보 구조체의 길이&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;System V IPC​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;Semaphores​&lt;/li&gt;
  &lt;li&gt;Shared memory​&lt;/li&gt;
  &lt;li&gt;Message queues​&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Semaphores&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;여러 프로세스에 대한 공유 데이터 개체에 대한 액세스를 제공하는 카운터&lt;/li&gt;
  &lt;li&gt;공유 리소스를 얻으려면
    &lt;ul&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;Test semaphore controlling resource​
            &lt;ul&gt;
              &lt;li&gt;1-1 If value &amp;gt; 0, value –, grant use​&lt;/li&gt;
              &lt;li&gt;1-2 If value == 0, sleep until value &amp;gt; 0​&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;Release resource, value ++​&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Steps 1-1, 1-2 atomic 연산이어야 한다&lt;/li&gt;
  &lt;li&gt;세마포어는 하나 이상의 세마포어 값의 집합으로 정의되다
    &lt;ul&gt;
      &lt;li&gt;세마포어가 생성될 때 집합에 값의 개수도 지정된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st23.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Functions&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/sem.h&amp;gt;​

int semget(key_t key, int num_sems, int sem_flags);​
int semctl(int sem_id, int sem_num, int command, …);​
int semop(int sem_id, struct sembuf *sem_ops, size_t num_sem_ops);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;semget : 세마포어 생성 또는 세마포어 키 반환
    &lt;ul&gt;
      &lt;li&gt;Key : 동일한 세마포어에 액세스하기 위한 10진수 값&lt;/li&gt;
      &lt;li&gt;num_sems : 세마포어의 수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;semctl : 세마포어 정보 제어
    &lt;ul&gt;
      &lt;li&gt;sem_id : 세마포어 ID​&lt;/li&gt;
      &lt;li&gt;sem_num : 세마포어의 수&lt;/li&gt;
      &lt;li&gt;command : 세마포어 명령&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;semop : 세마포어 값 변경&lt;/li&gt;
  &lt;li&gt;생성(semget)은 초기화(semctl)와 무관하다​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shared memory&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;가장 빠른 형태의 IPC: 프로세스 간 데이터 복사 불필요&lt;/li&gt;
  &lt;li&gt;공유 메모리 세그먼트에 대한 액세스를 동기화해야 함 -&amp;gt; 세마포어가 사용됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st24.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Functions&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt; ​
#include &amp;lt;sys/ipc.h&amp;gt; ​
#include &amp;lt;sys/shm.h&amp;gt; ​

int shmget(key_t key, int size, int flag); ​
        Returns: shared memory ID if OK, -1 on error
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;공유 메모리 식별자 얻기&lt;/li&gt;
  &lt;li&gt;Size : 공유 메모리 세그먼트의 크기&lt;/li&gt;
  &lt;li&gt;Flag : ipc_perm.mode​&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt; ​
#include &amp;lt;sys/ipc.h&amp;gt; ​
#include &amp;lt;sys/shm.h&amp;gt; ​

int shmctl(int shmid, int cmd, struct shmid_ds *buf);​
        Returns: 0 if OK, -1 on error
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;다양한 공유 메모리 작업​&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt; ​
#include &amp;lt;sys/ipc.h&amp;gt; ​
#include &amp;lt;sys/shm.h&amp;gt; ​

void *shmat (int shmid, void *addr, int flag); ​
        Returns: pointer to shared memory segment if OK, -1 on error
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;주소에 공유 메모리 첨부&lt;/li&gt;
  &lt;li&gt;flag ​
    &lt;ul&gt;
      &lt;li&gt;SHM_RDONLY : 세그먼트가 읽기 전용이다​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;addr==0: 커널이 선택한 첫 번째 주소에서
    &lt;ul&gt;
      &lt;li&gt;recommended​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;addr!=0 &amp;amp;&amp;amp; SHM_RND is not specified:​
    &lt;ul&gt;
      &lt;li&gt;addr이 제공한 주소에서&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;addr!=0 &amp;amp;&amp;amp; SHM_RND is specified:​
    &lt;ul&gt;
      &lt;li&gt;주어진 주소에서 (addr – (addr modulus SHMLBA))​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt; ​
#include &amp;lt;sys/ipc.h&amp;gt; ​
#include &amp;lt;sys/shm.h&amp;gt; ​

void shmdt (void *addr); ​
        Returns: 0 if OK, -1 on error
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;공유 메모리 세그먼트 분리&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Message queues&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;메시지의 연결 목록
    &lt;ul&gt;
      &lt;li&gt;커널에 저장&lt;/li&gt;
      &lt;li&gt;메시지 대기열 식별자로 식별&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;msgget: 새 대기열 생성 또는 기존 대기열 열기&lt;/li&gt;
  &lt;li&gt;msgsnd: 대기열에 새 메시지 추가&lt;/li&gt;
  &lt;li&gt;msgrcv: 대기열에서 메시지 수신&lt;/li&gt;
  &lt;li&gt;Fetching order: based on type&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt; ​
#include &amp;lt;sys/ipc.h&amp;gt; ​
#include &amp;lt;sys/msg.h&amp;gt; ​

int msgget(key_t key, int flag); ​
        Returns: msg queue ID if OK, -1 on error
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;새 대기열 생성 또는 기존 대기열 열기&lt;/li&gt;
  &lt;li&gt;Flag : ipc_perm.mode​&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt; ​
#include &amp;lt;sys/ipc.h&amp;gt; ​
#include &amp;lt;sys/msg.h&amp;gt; ​
​
int msgsnd(int msqid, const void *ptr, size_t nbytes, int flag); ​
        Returns: 0 if OK, -1 on error

struct mymesg {​
  long mtype;         /* positive message type */​
  char mtext[512];    /* message data, of length nbytes */​
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;큐의 끝에 메시지 배치&lt;/li&gt;
  &lt;li&gt;ptr은 메시지를 가리킨다&lt;/li&gt;
  &lt;li&gt;nbytes : 메시지 데이터의 길이&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt; ​
#include &amp;lt;sys/ipc.h&amp;gt; ​
#include &amp;lt;sys/msg.h&amp;gt; ​

int msgrcv(int msqid, void *ptr, size_t nbytes, long type, int flag); ​
        Returns: data size in message if OK, -1 on error
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;대기열에서 메시지 검색&lt;/li&gt;
  &lt;li&gt;type == 0 : 큐의 첫 번째 메시지가 반환된다&lt;/li&gt;
  &lt;li&gt;type &amp;gt; 0 : 메시지 유형이 유형과 동일한 큐의 첫 번째 메시지가 반환된다&lt;/li&gt;
  &lt;li&gt;type &amp;lt; 0 : 메시지 유형이 유형의 절대값보다 작거나 같은 가장 낮은 값인 큐의 첫 번째 메시지가 반환된다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content><author><name>lee989898</name></author><category term="system" /><summary type="html">프로세스통신-socket</summary></entry></feed>