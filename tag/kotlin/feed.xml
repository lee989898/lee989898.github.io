<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://lee989898.github.io/tag/kotlin/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://lee989898.github.io/" rel="alternate" type="text/html" />
  <updated>2021-11-25T14:23:12+09:00</updated>
  <id>https://lee989898.github.io/tag/kotlin/feed.xml</id>

  
  
  

  
    <title type="html">LEE | </title>
  

  
    <subtitle>공부 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">애노테이션과 리플렉션</title>
      <link href="https://lee989898.github.io/kotlin-09" rel="alternate" type="text/html" title="애노테이션과 리플렉션" />
      <published>2021-08-09T01:07:00+09:00</published>
      <updated>2021-08-09T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-09</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-09">&lt;h3 id=&quot;애노테이션과-리플렉션&quot;&gt;&lt;strong&gt;애노테이션과 리플렉션&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">애노테이션과 리플렉션</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">제네릭스</title>
      <link href="https://lee989898.github.io/kotlin-08" rel="alternate" type="text/html" title="제네릭스" />
      <published>2021-08-09T01:07:00+09:00</published>
      <updated>2021-08-09T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-08</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-08">&lt;h3 id=&quot;제네릭스&quot;&gt;&lt;strong&gt;제네릭스&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">제네릭스</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">DSL 만들기</title>
      <link href="https://lee989898.github.io/kotlin-10" rel="alternate" type="text/html" title="DSL 만들기" />
      <published>2021-08-09T01:07:00+09:00</published>
      <updated>2021-08-09T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-10</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-10">&lt;h3 id=&quot;dsl-만들기&quot;&gt;&lt;strong&gt;DSL 만들기&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">DSL 만들기</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">고차 함수, 파라미터와 반환 값으로 람다 사용</title>
      <link href="https://lee989898.github.io/kotlin-07" rel="alternate" type="text/html" title="고차 함수, 파라미터와 반환 값으로 람다 사용" />
      <published>2021-08-08T01:07:00+09:00</published>
      <updated>2021-08-08T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-07</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-07">&lt;h3 id=&quot;고차-함수-파라미터와-반환-값으로-람다-사용&quot;&gt;&lt;strong&gt;고차 함수, 파라미터와 반환 값으로 람다 사용&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;흐름을 제어하는 키워드&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;break: 반복문 내의 구문이 실행되는 중간에 즉시 반복문을 종료하고 다음 구문으로 넘어가는 역할을 한다.&lt;/li&gt;
  &lt;li&gt;continue: 다음 반복조건으로 즉시 넘어가는 역할을 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;noscript&gt;&lt;pre&gt;fun main(){
    
   for(i in 1..10){
       if(i == 3) break
       print(i)
   }
   
   for(j in 1..10){
       if(j == 3) continue
       print(j)
   }
    
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/lee989898/c45e3e7ff56735d5f8c1bccaed1d11f8.js&quot;&gt; &lt;/script&gt;

&lt;hr /&gt;

&lt;p&gt;코틀린은 다중 반복문에서 break나 continue가 적용되는 반복문을 label을 통해 지정할 수 있는 기능이 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;noscript&gt;&lt;pre&gt;fun main(){
    
   loop@for(i in 1..10){
       for(j in 1..10){
           if(i == 1 &amp;amp;&amp;amp; j == 2) break@loop
           println(&amp;quot;i : $i, j : $j&amp;quot;)
       }
   }
    
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/lee989898/4d8365d4a8e0296984e9039064fbcf07.js&quot;&gt; &lt;/script&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;논리연산자&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;논리 값을 연산하여 새로운 논리값을 도출할 떄 쓰는 연산자입니다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&amp;amp;&amp;amp; : 둘다 true인 경우 결과값이 true입니다.&lt;/li&gt;
  &lt;li&gt;|| : 하나라도 true이면 결과값이 true입니다.&lt;/li&gt;
  &lt;li&gt;! : 뒤에 붙는 값을 반전시킵니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;noscript&gt;&lt;pre&gt;fun main(){
    
    println(true &amp;amp;&amp;amp; false)
    println(true || false)
    println(!false)
    println(!true)
    
    var a = 6
    var b = 4
    
    println(a &amp;gt; 5 &amp;amp;&amp;amp; b &amp;gt; 5) 
    
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/lee989898/7c772edd91c61e2b32dbb811c42403de.js&quot;&gt; &lt;/script&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">고차 함수, 파라미터와 반환 값으로 람다 사용</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">연산자 오버로딩과 기타 관례</title>
      <link href="https://lee989898.github.io/kotlin-06" rel="alternate" type="text/html" title="연산자 오버로딩과 기타 관례" />
      <published>2021-08-08T01:07:00+09:00</published>
      <updated>2021-08-08T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-06</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-06">&lt;h3 id=&quot;연산자-오버로딩과-기타-관례&quot;&gt;&lt;strong&gt;연산자 오버로딩과 기타 관례&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">연산자 오버로딩과 기타 관례</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">코틀린 타입 시스템</title>
      <link href="https://lee989898.github.io/kotlin-05" rel="alternate" type="text/html" title="코틀린 타입 시스템" />
      <published>2021-08-08T01:07:00+09:00</published>
      <updated>2021-08-08T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-05</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-05">&lt;h3 id=&quot;코틀린-타입-시스템&quot;&gt;&lt;strong&gt;코틀린 타입 시스템&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">코틀린 타입 시스템</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">람다로 프로그래밍</title>
      <link href="https://lee989898.github.io/kotlin-04" rel="alternate" type="text/html" title="람다로 프로그래밍" />
      <published>2021-08-06T01:07:00+09:00</published>
      <updated>2021-08-06T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-04</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-04">&lt;h1 id=&quot;람다로-프로그래밍&quot;&gt;&lt;strong&gt;람다로 프로그래밍&lt;/strong&gt;&lt;/h1&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">람다로 프로그래밍</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">클래스, 객체, 인터페이스</title>
      <link href="https://lee989898.github.io/kotlin-03" rel="alternate" type="text/html" title="클래스, 객체, 인터페이스" />
      <published>2021-08-05T01:07:00+09:00</published>
      <updated>2021-08-05T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-03</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-03">&lt;h1 id=&quot;클래스-객체-인터페이스&quot;&gt;&lt;strong&gt;클래스, 객체, 인터페이스&lt;/strong&gt;&lt;/h1&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">클래스, 객체, 인터페이스</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">함수 정의와 호출</title>
      <link href="https://lee989898.github.io/kotlin-02" rel="alternate" type="text/html" title="함수 정의와 호출" />
      <published>2021-08-02T01:07:00+09:00</published>
      <updated>2021-08-02T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-02</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-02">&lt;h1 id=&quot;함수-정의와-호출&quot;&gt;&lt;strong&gt;함수 정의와 호출&lt;/strong&gt;&lt;/h1&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">함수 정의와 호출</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">코틀린 기초</title>
      <link href="https://lee989898.github.io/kotlin-01" rel="alternate" type="text/html" title="코틀린 기초" />
      <published>2021-08-02T01:05:00+09:00</published>
      <updated>2021-08-02T01:05:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-01</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-01">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;코틀린 테이블&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-01&quot;&gt;코틀린 기초&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-02&quot;&gt;함수 정의와 호출&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-03&quot;&gt;클래스, 객체, 인터페이스&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-04&quot;&gt;람다로 프로그래밍&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-05&quot;&gt;코틀린 타입 시스템&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-06&quot;&gt;연산자 오버로딩과 기타 관례&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-07&quot;&gt;고차 함수: 파라미터와 반환 값으로 람다 사용&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-08&quot;&gt;제네릭스&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-09&quot;&gt;애노테이션과 리플렉션&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-10&quot;&gt;DSL 만들기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;코틀린-기초&quot;&gt;코틀린 기초&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#함수와-변수&quot;&gt;함수와 변수&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#클래스와-프로퍼티&quot;&gt;클래스와 프로퍼티&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#enum과-when&quot;&gt;enum과 when&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#while과-for-루프&quot;&gt;while과 for 루프&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#코틀린의-예외-처리&quot;&gt;코틀린의 예외 처리&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;함수와-변수&quot;&gt;함수와 변수&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun main(args: String&amp;lt;String&amp;gt;){
    println(&quot;Hello, world!&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 함수에서 알 수 있는 것들&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;함수를 선언할 때 fun 키워드를 사용한다&lt;/li&gt;
  &lt;li&gt;파라미터 이름 뒤에 그 파라미터의 타입을 쓴다&lt;/li&gt;
  &lt;li&gt;함수를 최상위 수준에 정의할 수 있다. 클래스 안에 함수를 넣어야 할 필요가 없다&lt;/li&gt;
  &lt;li&gt;배열도 일반적인 클래스와 마찬가지다. 배열 처리를 위한 문법이 따로 존재하지 않는다&lt;/li&gt;
  &lt;li&gt;함수를 간결하게 사용할 수 있게 감싼 래퍼를 제공하여 println을 사용한다&lt;/li&gt;
  &lt;li&gt;줄 끝에 세미콜론을 붙이지 않아도 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;함수&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun max(a: Int, b: Int): Int{
    return if (a &amp;gt; b) a else b
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;함수 이름 뒤에는 괄호 안에 파라미터 목록이 온다&lt;/li&gt;
  &lt;li&gt;함수의 반환 타입은 파라미터 목록의 닫는 괄호 다음에 온다. 콜론으로 구분해야 한다&lt;/li&gt;
  &lt;li&gt;코틀린 if는 문장이 아니고 결과를 만드는 식이다&lt;/li&gt;
  &lt;li&gt;식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있는 반면 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 못한다&lt;/li&gt;
  &lt;li&gt;코틀린 대부분 제어 구조는 식이다. 반면 자바와 달리 대입문은 코틀린에서 문이다.&lt;/li&gt;
  &lt;li&gt;(fun max(a: Int, b: Int): Int = if(a &amp;gt; b) a else b) 처럼 간결하게 표현할 수 있다. (식이 본문인 함수, 블록이 본문인 함수)&lt;/li&gt;
  &lt;li&gt;반환 타입을 생략할 수 도 있다. 컴파일러가 타입을 분석해 프로그래머 대신 프로그램 구성 요소의 타입을 정해주는 타입추론 기능이 있기 때문이다&lt;/li&gt;
  &lt;li&gt;식이 본문인 함수의 반환 타입만 생략 가능하다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;변수&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val question = &quot;삶, 우주, 그리고 모든 것에 대한 궁극적인 질문&quot;
val answer: 42
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;코틀린에서는 키워드로 변수 선언을 시작하는 대신 변수 이름 뒤에 타입을 명시하거나 생략하게 허용한다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val answer: Int
answer = 42
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시해야한다&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;초기화 식이 없다면 변수에 저장될 값에 대해 아무 정보가 없기 때문에 컴파일러가 타입을 추론할 수 없다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;변수 선언 시 사용하는 키워드는 2가지가 있다
    &lt;ul&gt;
      &lt;li&gt;val - 변경 불가능한 참조를 저장하는 변수다. val로 선언된 변수는 일단 초기화하고 나면 재대입이 불가능하다&lt;/li&gt;
      &lt;li&gt;var - 변경 가능한 참조다. 변수의 값은 바뀔 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기본적으로 모든 변수를 val 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때에만 var로 변경하는게 좋다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val message: String
if(canPerformOperation()){
    message = &quot;Success&quot;
}
else {
    message = &quot;Failed&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;조건에 따라 val 값을 다른 여러 값으로 초기화 할 수 있다
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val languages = arrayListOf(&quot;Java&quot;)
languages.add(&quot;Kotlin&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;val 참조 객체는 불변일지라도 그 참조가 가리키는 객체의 배부 값은 변경될 수 있다
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var answer = 42
answer = &quot;no answer&quot; // 컴파일 오류 발생
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;var 키워드를 사용하면 변수의 값을 변경할 수 있지만 변수의 타입은 고정돼 바뀌지 않는다&lt;/li&gt;
  &lt;li&gt;어떤 타입의 변수에 다른 타입의 값을 저장하고 싶다면 변환 함수를 써서 값을 변수의 타입으로 변환하거나, 값을 변수에 대입할 수 있는 타입으로 강제 형 변환해야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;문자열 템플릿&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun main(args: Array&amp;lt;String&amp;gt;){
    val name = if (args.size &amp;gt; 0) args[0] else &quot;Kotlin&quot;
    println(&quot;Hello, $name!&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;변수를 문자열 안에 사용할 수 있다&lt;/li&gt;
  &lt;li&gt;문자열 리터럴의 필요한 곳에 변수를 넣되 변수 앞에 $를 추가해야 한다&lt;/li&gt;
  &lt;li&gt;$ 문자를 문자열에 넣고 싶으면 $를 이스케이프 시켜야 한다
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun main(args: Array&amp;lt;String&amp;gt;){
  if(args.size &amp;gt; 0){
      println(&quot;Hello, ${args[0]}!&quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;복잡한 식도 중괄호로 둘러싸서 문자열 템플릿 안에 넣을 수 있다&lt;/li&gt;
  &lt;li&gt;문자열 템플릿 안에서 변수 이름만 사용하는 경우라도 ${name}처럼 중괄호로 변수명을 감싸는 습관을 들이면 더 좋다
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun main(args: Array&amp;lt;String&amp;gt;){
  println(&quot;Hello, ${if (args.size &amp;gt; 0) args[0] else &quot;someone&quot;}!&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;중괄호로 둘러싼 식 안에서 큰 타옴표를 사용할 수도 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;클래스와-프로퍼티&quot;&gt;클래스와 프로퍼티&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Person(val name: String)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;이런 유형의 클래스를 값 객체라 부른다&lt;/li&gt;
  &lt;li&gt;코틀린의 기본 가시성은 public이므로 이런 경우 변경자를 생략해도 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로피터&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Person(
    val name: String       // (비공개)필드, (공개) 게터를 만들어 낸다
    var isMarried: Boolean // (비공개)필드, (공개) 게터, (공개) 세터를 만들어 낸다
)

&amp;gt;&amp;gt;&amp;gt; val person = Person(&quot;Bob&quot;, true)
&amp;gt;&amp;gt;&amp;gt; println(person.name) // 프로퍼티 이름을 직접 사용해도 코틀린이 자동으로 게터를 호출해준다
Bob
&amp;gt;&amp;gt;&amp;gt; println(person.isMarried) // 프로퍼티 이름을 직접 사용해도 코틀린이 자동으로 게터를 호출해준다
true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;코틀린 프로퍼티는 자바의 필드와 접근자 메소드를 대신한다&lt;/li&gt;
  &lt;li&gt;클래스에서 프로퍼티를 선언할 때는 val이나 var를 사용한다
    &lt;ul&gt;
      &lt;li&gt;val로 선언한 프로퍼티는 읽기 전용이며, var로 선언한 프로퍼티는 변경 가능하다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;커스텀 접근자&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Rectangle(val height: Int, val width: Int){
    val isSquare: Boolean
        get(){
            return height == width
        }
}

&amp;gt;&amp;gt;&amp;gt; val rectangle = Rectangle(41, 43)
&amp;gt;&amp;gt;&amp;gt; println(rectangle.isSquare)
false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;isSqaure 프로퍼티에는 자체 값을 저장하는 필드가 필요없다. 이 프로퍼티에는 자체 구현을 제공하는 게터만 제공한다&lt;/li&gt;
  &lt;li&gt;클라이언트가 프로퍼티에 접근할 때마다 게터가 프로퍼티 값을 매번 다시 계산한다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;디렉터리와 패키지&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package gemotry.shapes

import java.util.Random

class Rectangle(val height: Int, val width: Int){
    val isSquare: Boolean
        get(){
            return height == width
        }
}

fun createRandomRectangle(): Rectangle{
    val random = Random()
    return Rectangle(random.nextInt(), random.nextInt())
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;모든 코틀린 맨 앞에 package문을 넣을 수 있다. 그러면 그파일 안에 있는 모든 선언이 해당 패키지에 들어간다&lt;/li&gt;
  &lt;li&gt;다른 패키지에 정의한 선언을 사용하려면 임포트를 통해 선언을 불러와야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package gemotry.example

import geometry.shapes.createRandomRectangle    // 이름으로 함수 임포트하기

fun main(args: Array&amp;lt;String&amp;gt;){
    println(createRandomRectangle().isSquare)   // &quot;true&quot;가 아주 드물게 출력된다
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;클래스 임포트와 함수 임포트에 차이가 없다&lt;/li&gt;
  &lt;li&gt;최상위 함수는 그 이름을 써서 임포트 할 수 있다&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;패키지 이름 뒤에 .*를 추가하면 패키지 안의 모든 선언을 임포트 할 수 있다. 모든 클래스뿐 아니라 최상위에 정의된 함수나 프로퍼티까지 모두 불러온다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;코틀린에서는 여러 클래스를 한 파일에 넣을 수 있고, 파일의 이름도 마음대로 정할 수 있다. 코틀린에서는 디스크상의 어느 디렉터리에 소스코드 파일을 위치시키든 관계없다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;enum과-when&quot;&gt;enum과 when&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;enum 클래스 정의&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;enum class Color{
    RED, ORANCE, YELLOW, GREEN, BLUE, INDIGO, VIOLET
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;enum은 소프트 키워드이다&lt;/li&gt;
  &lt;li&gt;enum 클래스 안에도 프로퍼티나 메소드를 정의할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;enum class Color(
    val r: Int, val g: Int, var b: Int
){
    RED(255,0,0), ORANGE(255,165,0), YELLOW(255,255,0), GREEN(0,255,0), BLUE(0,0,255),
    INDIGO(75,0,130), VIOLET(238,130,238);
    
    fun rgb() = (r * 256 + g) * 256 + b
}

&amp;gt;&amp;gt;&amp;gt; println(Color.BLUE.rgb())
255
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;각 enum 상수를 정의할 때는 그 상수에 해당하는 프로퍼티 값을 지정해야만 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;when으로 enum 클래스 다루기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun getMnemonic(color: Color)=
    when(color){
        Color.RED -&amp;gt; &quot;Richard&quot;
        Color.ORANGE -&amp;gt; &quot;Of&quot;
        Color.YELLOW -&amp;gt; &quot;York&quot;
        Color.GREEN -&amp;gt; &quot;Gave&quot;
        Color.BLUE -&amp;gt; &quot;Battle&quot;
        Color.INDIGO -&amp;gt; &quot;In&quot;
        Color.VIOLET -&amp;gt; &quot;Vain&quot;
    }

&amp;gt;&amp;gt;&amp;gt; println(getMneminic(Color.BLUE))
Battle
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;각 분기의 끝에 break를 넣지 않아도 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun getWarmth(color: Color) = when(color){
    Color.RED, Color.ORANGE, Color.YELLOW -&amp;gt; &quot;warm&quot;
    Color.GREEN -&amp;gt; &quot;neutral&quot;
    Color.BLUE, Color.INDIGO, Color.VIOLET -&amp;gt; &quot;cold&quot;
}

&amp;gt;&amp;gt;&amp;gt; println(getWarmth(Color.ORANGE))
warm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;한 분기 안에서 여러 값을 매치 패턴으로 사용할 수도 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import ch02.colors.Color   // 다른 패키지에서 정의한 Color 클래스를 임포트한다
import ch02.colors.Color.* //짧은 이름으로 사용하기 위해 enum 상수를 모두 임포트한다

fun getWarmth(color: Color) = when(color){
    RED,ORANGE,YELLOW -&amp;gt; &quot;warm&quot;
    GREEN -&amp;gt; &quot;neutral&quot;
    BLUE, INDIGO, VIOLET -&amp;gt; &quot;cold&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;상수 값을 임포트 하면 코드를 더 간단하게 만들 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;when과 임의의 객체를 함께 사용&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun mix(c1: Color, c2: Color) = when(setOf(c1,c2)){
    setOf(RED, YELLOW) -&amp;gt; ORANGE
    setOf(YELLOW, BLUE) -&amp;gt; GREEN
    setOf(BLUE, VIOLET) -&amp;gt; INDIGO
    else -&amp;gt; throw Exception(&quot;Dirty color&quot;)
}

&amp;gt;&amp;gt;&amp;gt; println(mix(BLUE, YELLOW))
GREEN
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;when의 분기 조건은 임의의 객체를 허용한다&lt;/li&gt;
  &lt;li&gt;when의 분기 조건 부분에 식을 넣을 수 있기 때문에 많은 경우 코드를 더 간결하고 아름답게 작성할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;인자 없는 when 사용&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun mixOptimized(c1: Color, c2: Color) =
    when{
        (c1 == RED &amp;amp;&amp;amp; c2 == YELLOW) ||
        (c1 == YELLOW &amp;amp;&amp;amp; c2 == RED) -&amp;gt;
            ORANGE
        (c1 == YELLOW &amp;amp;&amp;amp; c2 == BLUE) ||
        (c1 == BLUE &amp;amp;&amp;amp; c2 == YELLOW) -&amp;gt;
            GREEN
        (c1 == BLUE &amp;amp;&amp;amp; c2 == VIOLET) ||
        (c1 == VIOLET &amp;amp;&amp;amp; c2 == BLUE) -&amp;gt;
            INDIGO
        else -&amp;gt; throw Exception(&quot;Dirty color&quot;)
    }

&amp;gt;&amp;gt;&amp;gt; println(mixOptimized(BLUE, YELLOW))
GREEN
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;인자가 없는 when식을 사용하면 불필요한 객체 생성을 막을 수 있다&lt;/li&gt;
  &lt;li&gt;코드는 약간 읽기 어려워지지만 성능이 향상된다&lt;/li&gt;
  &lt;li&gt;when에 아무 인자가 없으려면 각 분기의 조건이 불리언 결과를 계산하는 식이어야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;스마트 캐스트: 타입 검사와 타입 캐스트를 조합&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface Expr
class Num(val value: Int): Expr
class Sum(val left: Expr, val right: Expr): Expr

fun eval (e: Expr): Int{
    if (e is Num){
        val n = e as Num
        return n.value
    }
    if (e is Sum){
        return eval(e.right) + eval(e.left)
    }
    throw IllegalArgumentException(&quot;Unknown expression&quot;)
}

&amp;gt;&amp;gt;&amp;gt; println(eval(Sum(Sum(Num(1),Num(2)), Num(4))))
7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;is를 사용해 변수 타입을 검사한다. 컴파일러가 대신 캐스팅을 해준다. 이를 스마트 캐스트라고 부른다&lt;/li&gt;
  &lt;li&gt;원하는 타입으로 명시적으로 타입 캐스팅하려면 as 키워드를 사용한다&lt;/li&gt;
  &lt;li&gt;스마트 캐스트는 is로 변수에 든 값의 타입을 검사한 다음에 그 값이 바뀔 수 없는 경우에만 작동한다&lt;/li&gt;
  &lt;li&gt;스마트 캐스트를 사용한다면 그 프로퍼티는 반드시 val이어야 하며 커스텀 접근자를 사용한 것이어도 안 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;리펙토리: if를 when으로 변경&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun eval (e: Expr): Int =
    if (e is Num){
        e.value
    } else if (e is Sum){
        eval(e.right) + eval(e.left)
    } else {}
    throw IllegalArgumentException(&quot;Unknown expression&quot;)
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;return문과 중괄호를 없애고 if식을 본문으로 사용해 더 간단하게 만들 수 있다&lt;/li&gt;
  &lt;li&gt;if의 분기에 식이 하나밖에 없다면 중괄호를 생략해도 된다&lt;/li&gt;
  &lt;li&gt;if 분기에 블록을 사용하는 경우 그 블록의 마지막 식이 그 분기의 결과 값이다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun eval (e: Expr): Int =
    when(e){
        is Num -&amp;gt;
            e.value
        is Sum -&amp;gt;
            eval(e.right) + eval(e.left)
        else -&amp;gt;
            throw IllegalArgumentException(&quot;Unknown expression&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;when을 사용해 더 다듬을 수도 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;if와 when의 분기에서 블록 사용&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun evalWithLogging (e: Expr): Int =
    when(e){
        is Num -&amp;gt;{
            println(&quot;num: ${e.value}&quot;)
            e.value
        }
        is Sum -&amp;gt;{
            val left = evalWithLogging(e.left)
            val right = evalWithLogging(e.right)
            println(&quot;sum: $left + $right&quot;)
            left + right
        }
        else -&amp;gt; throw IllegalArgumentException(&quot;Unknown expression&quot;)
}

&amp;gt;&amp;gt;&amp;gt; println(evalWithLogging(Sum(Sum(Num(1),Num(2)), Num(4))))
num: 1
num: 2
sum: 1 + 2
num: 4
sum: 3 + 4
7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;if나 when 모두 분기에 블록을 사용할 수 있다. 그런 경우 블록의 마지막 문장이 블록 전체의 결과가 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;while과-for-루프&quot;&gt;while과 for 루프&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;대상을 이터레이션: while과 for 루프&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;while 루프&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while(조건){
    /* ... */
}
do {
    /* ... */
} while(조건)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;자바와 동일하다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;수에 대한 이터레이션: 범위와 수열&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val oneToTen = 1..10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;코틀린의 범위는 폐구간 또는 양끝을 포함하는 구간이다&lt;/li&gt;
  &lt;li&gt;이런 식으로 어떤 범위에 속한 값을 일정한 순서로 이터레이션 하는 경우를 수열이라고 부른다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun fizzBuzz(i: Int) = when{
    i % 15 == 0 -&amp;gt; &quot;FizzBuzz&quot;
    i % 3 == 0 -&amp;gt; &quot;Fizz&quot;
    i % 5 == 0 -&amp;gt; &quot;Buzz&quot;
    else -&amp;gt; &quot;$i&quot;
}

&amp;gt;&amp;gt;&amp;gt; for(i in 1..100){
    print(fizzBuzz(i))
    }

1 2 Fizz 4 Buzz Fizz 7 ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;for &lt;아이템&gt; in &lt;원소들&gt;&lt;/원소들&gt;&lt;/아이템&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; for(i in 100 downTo 1 step 2){
    print(fizzBuzz(i))
}

Buzz 98 Fizz 94 92 FizzBuzz 88 ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;100부터 거꾸로 세되 짝수만 나오게 하기&lt;/li&gt;
  &lt;li&gt;증가 값을 음수로 만들면 정방향 수열이 아닌 역방향 수열을 만들 수 있다&lt;/li&gt;
  &lt;li&gt;증가 값을 사용하면 수를 건너 뛸 수 있다&lt;/li&gt;
  &lt;li&gt;끝 값을 포함하지 않는 반만 닫힌 범위를 원하면 until 함수를 사용하자&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;맵에 대한 이터레이션&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val binaryReps = TreeMap&amp;lt;Char, String&amp;gt;()

for(c in 'A'..'F'){
    val binary = Integer.toBinaryString(c.toInt())
    binaryResps[c] = binary
}

for((letter, binary) in binaryReps){
    println(&quot;$letter = $binary&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;.. 연산자를 숫자 타입의 값뿐 아니라 문자 타입의 값에도 적용할 수 있다&lt;/li&gt;
  &lt;li&gt;binaryReps[c] = binary 라는 코드는 binaryReps.put(c, binary)라는 자바 코드와 같다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val list = arrayListOf(&quot;10&quot;, &quot;11&quot;, &quot;1001&quot;)
for((index, element) in list.withIndex()){
    println(&quot;$index: $element)
}

0: 10
1: 11
2: 1001
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;맵에 사용했던 구조 분해 구문을 맵이 아닌 컬렉션에도 활용할 수 있다&lt;/li&gt;
  &lt;li&gt;구조 분해 구문을 사용하면 원소의 현재 인덱스를 유지하면서 컬렉션을 이터레이션 할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;in으로 컬렉션이나 범위의 원소 검사&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun isLetter(c: Char) = c in 'a'..'z' || c in 'A'..'Z'
fun isNotDigit(c: Char) = c! in '0'..'9'

&amp;gt;&amp;gt;&amp;gt; println(isLetter('q'))
true
&amp;gt;&amp;gt;&amp;gt; println(isNotDigit('x'))
true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;in 연산자를 사용해 어떤 값이 범위에 속하는지 검사할 수 있다&lt;/li&gt;
  &lt;li&gt;!in을 사용하면 어떤 값이 범위에 속하지 않는지 검사할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun recognize(c: Char) = when(c){
    in '0'..'9' -&amp;gt; &quot;It's a digit!&quot;
    in 'a'..'z', in 'A'..'Z' -&amp;gt; &quot;It's a letter!&quot;
    ele -&amp;gt; &quot;I dont know..&quot;
}

&amp;gt;&amp;gt;&amp;gt; println(recognize('8'))
It's a digit!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;in과 !in 연산자를 when 식에서 사용할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; println(&quot;Kotlin&quot; in &quot;java&quot;..&quot;Scala&quot;)
true
&amp;gt;&amp;gt;&amp;gt; println(&quot;Kotlin&quot; in setOf(&quot;Java&quot;, &quot;Scala&quot;))
false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;범위는 문자에만 국한하지 않고 비교가 가능한 클래스라면 그 클래스의 인스턴스 객체를 사용해 범위를 만들 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;코틀린의-예외-처리&quot;&gt;코틀린의 예외 처리&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val percentage =
    if(number in 0..100)
        number
    else
        throw IllegalArgumentException(
            &quot;A precentage value must be between 0 and 100: $number&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;함수는 정상적으로 종료할 수 있지만 오류가 발생하면 예외를 던질수 있다&lt;/li&gt;
  &lt;li&gt;함수를 호출하는 쪽에서는 그 예외를 잡아 처리할 수 있다&lt;/li&gt;
  &lt;li&gt;throw는 식이므로 다른 식에 포함될 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;try, catch, finally&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun readNumber(reader: BufferedReader): Int?{
    try{
        val line = reader.readLine()
        return Integer.parseInt(line)
    }
    catch(e: NumberFormatException){
        return null
    }
    finally{
        reader.close()
    }
}

&amp;gt;&amp;gt;&amp;gt; val reader = BufferReader(StringReader(&quot;239&quot;))
&amp;gt;&amp;gt;&amp;gt; println(readNumber(reader))
239
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;코틀린은 체크 예외와 언체크 예외를 구별하지 않는다&lt;/li&gt;
  &lt;li&gt;함수가 던지는 예외를 지정하지 않고 발생한 예외를 잡아내도 되고 잡아내지 않아도 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;try를 식으로 사용&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun readNumber(reader: BufferedReader){
    val number = try{
        Integer.parseInt(reader.readLine())
    } catch(e: NumberFormatException){
        return
    }
    println(number)
}

&amp;gt;&amp;gt;&amp;gt; val reader = BufferedReader(StringReader(&quot;not a number&quot;))
&amp;gt;&amp;gt;&amp;gt; readNumber(reader)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;try 키워드는 if나 when과 마찬가지로 식이다&lt;/li&gt;
  &lt;li&gt;try 본문을 반드시 중괄호로 둘러싸야 한다&lt;/li&gt;
  &lt;li&gt;try도 마지막 식의 값이 전체 결과 값이다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun readNumber(reader: BufferedReader){
    val number = try{
        Integer.parseInt(reader.readLine())
    } catch(e: NumberFormatException){
        null
    }
    println(number)
}

&amp;gt;&amp;gt;&amp;gt; val reader = BufferedReader(StringReader(&quot;not a number&quot;))
&amp;gt;&amp;gt;&amp;gt; readNumber(reader)
null
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;catch에서 값 반환하기&lt;/li&gt;
  &lt;li&gt;try 코드 블럭의 실행이 정상적으로 끝나면 그 블록의 마지막 식의 값이 결과다&lt;/li&gt;
  &lt;li&gt;예외가 발생하고 잡히면 그 예외에 해당하는 catch 블록의 값이 결과다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">코틀린 테이블 코틀린 기초 함수 정의와 호출 클래스, 객체, 인터페이스 람다로 프로그래밍 코틀린 타입 시스템 연산자 오버로딩과 기타 관례 고차 함수: 파라미터와 반환 값으로 람다 사용 제네릭스 애노테이션과 리플렉션 DSL 만들기</summary>
      

      
      
    </entry>
  
</feed>
