<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://lee989898.github.io/tag/kotlin/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://lee989898.github.io/" rel="alternate" type="text/html" />
  <updated>2021-11-30T10:42:36+09:00</updated>
  <id>https://lee989898.github.io/tag/kotlin/feed.xml</id>

  
  
  

  
    <title type="html">LEE | </title>
  

  
    <subtitle>공부 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">애노테이션과 리플렉션</title>
      <link href="https://lee989898.github.io/kotlin-09" rel="alternate" type="text/html" title="애노테이션과 리플렉션" />
      <published>2021-08-09T01:07:00+09:00</published>
      <updated>2021-08-09T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-09</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-09">&lt;h3 id=&quot;애노테이션과-리플렉션&quot;&gt;&lt;strong&gt;애노테이션과 리플렉션&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">애노테이션과 리플렉션</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">제네릭스</title>
      <link href="https://lee989898.github.io/kotlin-08" rel="alternate" type="text/html" title="제네릭스" />
      <published>2021-08-09T01:07:00+09:00</published>
      <updated>2021-08-09T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-08</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-08">&lt;h3 id=&quot;제네릭스&quot;&gt;&lt;strong&gt;제네릭스&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">제네릭스</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">DSL 만들기</title>
      <link href="https://lee989898.github.io/kotlin-10" rel="alternate" type="text/html" title="DSL 만들기" />
      <published>2021-08-09T01:07:00+09:00</published>
      <updated>2021-08-09T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-10</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-10">&lt;h3 id=&quot;dsl-만들기&quot;&gt;&lt;strong&gt;DSL 만들기&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">DSL 만들기</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">고차 함수, 파라미터와 반환 값으로 람다 사용</title>
      <link href="https://lee989898.github.io/kotlin-07" rel="alternate" type="text/html" title="고차 함수, 파라미터와 반환 값으로 람다 사용" />
      <published>2021-08-08T01:07:00+09:00</published>
      <updated>2021-08-08T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-07</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-07">&lt;h3 id=&quot;고차-함수-파라미터와-반환-값으로-람다-사용&quot;&gt;&lt;strong&gt;고차 함수, 파라미터와 반환 값으로 람다 사용&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;흐름을 제어하는 키워드&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;break: 반복문 내의 구문이 실행되는 중간에 즉시 반복문을 종료하고 다음 구문으로 넘어가는 역할을 한다.&lt;/li&gt;
  &lt;li&gt;continue: 다음 반복조건으로 즉시 넘어가는 역할을 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;noscript&gt;&lt;pre&gt;fun main(){
    
   for(i in 1..10){
       if(i == 3) break
       print(i)
   }
   
   for(j in 1..10){
       if(j == 3) continue
       print(j)
   }
    
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/lee989898/c45e3e7ff56735d5f8c1bccaed1d11f8.js&quot;&gt; &lt;/script&gt;

&lt;hr /&gt;

&lt;p&gt;코틀린은 다중 반복문에서 break나 continue가 적용되는 반복문을 label을 통해 지정할 수 있는 기능이 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;noscript&gt;&lt;pre&gt;fun main(){
    
   loop@for(i in 1..10){
       for(j in 1..10){
           if(i == 1 &amp;amp;&amp;amp; j == 2) break@loop
           println(&amp;quot;i : $i, j : $j&amp;quot;)
       }
   }
    
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/lee989898/4d8365d4a8e0296984e9039064fbcf07.js&quot;&gt; &lt;/script&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;논리연산자&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;논리 값을 연산하여 새로운 논리값을 도출할 떄 쓰는 연산자입니다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&amp;amp;&amp;amp; : 둘다 true인 경우 결과값이 true입니다.&lt;/li&gt;
  &lt;li&gt;|| : 하나라도 true이면 결과값이 true입니다.&lt;/li&gt;
  &lt;li&gt;! : 뒤에 붙는 값을 반전시킵니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;noscript&gt;&lt;pre&gt;fun main(){
    
    println(true &amp;amp;&amp;amp; false)
    println(true || false)
    println(!false)
    println(!true)
    
    var a = 6
    var b = 4
    
    println(a &amp;gt; 5 &amp;amp;&amp;amp; b &amp;gt; 5) 
    
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/lee989898/7c772edd91c61e2b32dbb811c42403de.js&quot;&gt; &lt;/script&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">고차 함수, 파라미터와 반환 값으로 람다 사용</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">연산자 오버로딩과 기타 관례</title>
      <link href="https://lee989898.github.io/kotlin-06" rel="alternate" type="text/html" title="연산자 오버로딩과 기타 관례" />
      <published>2021-08-08T01:07:00+09:00</published>
      <updated>2021-08-08T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-06</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-06">&lt;h3 id=&quot;연산자-오버로딩과-기타-관례&quot;&gt;&lt;strong&gt;연산자 오버로딩과 기타 관례&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">연산자 오버로딩과 기타 관례</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">코틀린 타입 시스템</title>
      <link href="https://lee989898.github.io/kotlin-05" rel="alternate" type="text/html" title="코틀린 타입 시스템" />
      <published>2021-08-08T01:07:00+09:00</published>
      <updated>2021-08-08T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-05</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-05">&lt;h3 id=&quot;코틀린-타입-시스템&quot;&gt;&lt;strong&gt;코틀린 타입 시스템&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">코틀린 타입 시스템</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">람다로 프로그래밍</title>
      <link href="https://lee989898.github.io/kotlin-04" rel="alternate" type="text/html" title="람다로 프로그래밍" />
      <published>2021-08-06T01:07:00+09:00</published>
      <updated>2021-08-06T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-04</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-04">&lt;h1 id=&quot;람다로-프로그래밍&quot;&gt;&lt;strong&gt;람다로 프로그래밍&lt;/strong&gt;&lt;/h1&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">람다로 프로그래밍</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">클래스, 객체, 인터페이스</title>
      <link href="https://lee989898.github.io/kotlin-03" rel="alternate" type="text/html" title="클래스, 객체, 인터페이스" />
      <published>2021-08-05T01:07:00+09:00</published>
      <updated>2021-08-05T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-03</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-03">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;코틀린 테이블&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-01&quot;&gt;코틀린 기초&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-02&quot;&gt;함수 정의와 호출&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-03&quot;&gt;클래스, 객체, 인터페이스&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-04&quot;&gt;람다로 프로그래밍&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-05&quot;&gt;코틀린 타입 시스템&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-06&quot;&gt;연산자 오버로딩과 기타 관례&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-07&quot;&gt;고차 함수: 파라미터와 반환 값으로 람다 사용&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-08&quot;&gt;제네릭스&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-09&quot;&gt;애노테이션과 리플렉션&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-10&quot;&gt;DSL 만들기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;클래스-객체-인터페이스&quot;&gt;클래스, 객체, 인터페이스&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#클래스-계층-정의&quot;&gt;클래스 계층 정의&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#뻔하지-않은-생성자와-프로퍼티를-갖는-클래스-선언&quot;&gt;뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#컴파일러가-생성한-메서드-데이터-클래스와-클래스-위임&quot;&gt;컴파일러가 생성한 메서드: 데이터 클래스와 클래스 위임&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#object-키워드-클래스-선언과-인스턴스-생성&quot;&gt;object 키워드: 클래스 선언과 인스턴스 생성&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;클래스-계층-정의&quot;&gt;클래스 계층 정의&lt;/h2&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;뻔하지-않은-생성자와-프로퍼티를-갖는-클래스-선언&quot;&gt;뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언&lt;/h2&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;컴파일러가-생성한-메서드-데이터-클래스와-클래스-위임&quot;&gt;컴파일러가 생성한 메서드: 데이터 클래스와 클래스 위임&lt;/h2&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;object-키워드-클래스-선언과-인스턴스-생성&quot;&gt;object 키워드: 클래스 선언과 인스턴스 생성&lt;/h2&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">코틀린 테이블 코틀린 기초 함수 정의와 호출 클래스, 객체, 인터페이스 람다로 프로그래밍 코틀린 타입 시스템 연산자 오버로딩과 기타 관례 고차 함수: 파라미터와 반환 값으로 람다 사용 제네릭스 애노테이션과 리플렉션 DSL 만들기</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">함수 정의와 호출</title>
      <link href="https://lee989898.github.io/kotlin-02" rel="alternate" type="text/html" title="함수 정의와 호출" />
      <published>2021-08-02T01:07:00+09:00</published>
      <updated>2021-08-02T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-02</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-02">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;코틀린 테이블&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-01&quot;&gt;코틀린 기초&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-02&quot;&gt;함수 정의와 호출&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-03&quot;&gt;클래스, 객체, 인터페이스&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-04&quot;&gt;람다로 프로그래밍&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-05&quot;&gt;코틀린 타입 시스템&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-06&quot;&gt;연산자 오버로딩과 기타 관례&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-07&quot;&gt;고차 함수: 파라미터와 반환 값으로 람다 사용&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-08&quot;&gt;제네릭스&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-09&quot;&gt;애노테이션과 리플렉션&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-10&quot;&gt;DSL 만들기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;함수-정의와-호출&quot;&gt;함수 정의와 호출&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#코틀린에서-컬렉션-만들기&quot;&gt;코틀린에서 컬렉션 만들기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#함수를-호출하기-쉽게-만들기&quot;&gt;함수를 호출하기 쉽게 만들기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#메서드를-다른-클래스에-추가-확장-함수와-확장-프로퍼티&quot;&gt;메서드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#컬렌션-처리-가변-길이-인자와-중위-함수-호출과-라이브러리-지원&quot;&gt;컬렌션 처리: 가변 길이 인자와 중위 함수 호출과 라이브러리 지원&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#문자열과-정규식-다루기&quot;&gt;문자열과 정규식 다루기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#코드-다듬기-로컬-함수와-확장&quot;&gt;코드 다듬기: 로컬 함수와 확장&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;코틀린에서-컬렉션-만들기&quot;&gt;코틀린에서 컬렉션 만들기&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val set hashSetOf(1, 7, 53)
val list = arrayListOf(1 ,7, 53)
val map = hashMapOf(1 to &quot;one&quot;, 7 to &quot;seven&quot;)

&amp;gt;&amp;gt;&amp;gt; println(set.javaClass)
class java.util.HashSet
&amp;gt;&amp;gt;&amp;gt; println(list.javaClass)
class java.util.ArrayList
&amp;gt;&amp;gt;&amp;gt; println(map.javaClass)
class java.util.HashMap
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;코틀린이 자신만의 컬렉션 기능을 제공하지 않는다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; val strings = listOf(&quot;first&quot;, &quot;second&quot;, &quot;fourteenth&quot;)
&amp;gt;&amp;gt;&amp;gt; println(strings.last())
fourteenth
&amp;gt;&amp;gt;&amp;gt; val numbers = setOf(1, 14, 2)
&amp;gt;&amp;gt;&amp;gt; println(numbets.max())
14
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;코틀린에서는 자바보다 더 많은 기능을 쓸 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;함수를-호출하기-쉽게-만들기&quot;&gt;함수를 호출하기 쉽게 만들기&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; val list = listOf(1,2,3)
&amp;gt;&amp;gt;&amp;gt; println(list)
[1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;자바 컬렉션에는 디폴트 toString 구현이 들어있다.그러나 우리에게 필요한 형식이 아닐 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun &amp;lt;T&amp;gt; joinToString(
    collection: Collection&amp;lt;T&amp;gt;,
    separator: String,
    prefix: String,
    postfix: String
): String {
    val result = StringBuilder(prefix)
    for((index, element) in collection.withIndex()){
        if(index &amp;gt; 0) result.append(separator)
        result.append(element)
    }
    result.append(postfix)
    return result.toString()
}

&amp;gt;&amp;gt;&amp;gt; val list = listOf(1, 2, 3)
&amp;gt;&amp;gt;&amp;gt; println(joinToString(list, &quot;; &quot;, &quot;, &quot;(&quot;, &quot;)&quot;))
(1; 2; 3)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위 함수는 어떤 타입의 값을 원소로 하는 컬렉션이든 처리할 수 있다 그러나 함수를 호출하는 문장이 번잡하다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;이름 붙인 인자&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;joinToString(collection, separator = &quot; &quot;, prefix = &quot; &quot;, postfix = &quot;.&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;코틀린으로 작성한 함수를 호출할 때는 함수에 전달하는 인자 중 일부의 이름을 명시할 수 있다&lt;/li&gt;
  &lt;li&gt;호출 시 인자 중 어느 하나라도 이름을 명시하고 나면 혼동을 막기 위해 그 뒤에 오는 모든 인자는 이름을 꼭 명시해야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;디폴트 파라미터 값&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun &amp;lt;T&amp;gt; joinToString(
    collection: Collection&amp;lt;T&amp;gt;,
    separator: String = &quot;, &quot;,
    prefix: String = &quot;&quot;,
    postfix: String = &quot;&quot; 
): String {
    val result = StringBuilder(prefix)
    for((index, element) in collection.withIndex()){
        if(index &amp;gt; 0) result.append(separator)
        result.append(element)
    }
    result.append(postfix)
    return result.toString()
}

&amp;gt;&amp;gt;&amp;gt; joinToString(list, &quot;, &quot;, &quot;&quot;, &quot;&quot;)
1, 2, 3
&amp;gt;&amp;gt;&amp;gt; joinToString(list)
1, 2, 3
&amp;gt;&amp;gt;&amp;gt; joinToString(list, &quot;; &quot;)
1; 2; 3;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;함수를 호출할 때 모든 인자를 쓸 수도 있고, 일부를 생략할 수도 있다&lt;/li&gt;
  &lt;li&gt;일반 호출 문법을 사용하려면 함수를 선언할 때와 같은 순서로 인자를 지정해야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; joinToString(list, postfix = &quot;;&quot;, prefix = &quot;# &quot;)
# 1, 2, 3;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이름 붙인 인자를 사용하는 경우에는 인자 목록의 중간에 있는 인자를 생략하고, 지정하고 싶은 인자를 이름을 붙여 순서와 관계없이 지정할 수 있다&lt;/li&gt;
  &lt;li&gt;함수의 디폴트 파라미터 값은 함수를 호출하는 쪽이 아니라 함수 선언 쪽에서 지정된다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;정적인 유틸리티 클래스 없애기: 최상위 함수와 프로피터&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package strings // 코틀린 join.kt

fun joinToString(...): String {...} 

package strings // join.kt를 컴파일한 결과와 같은 클래스를 자바 코드

public class JoinKt{
    public static String joinToString(...) { ... } 
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;다른 패기지에서 그 함수를 사용하고 싶을때는 그 함수가 정의된 패키지를 임포트 해야한다&lt;/li&gt;
  &lt;li&gt;임포트 시 유틸리티 클래스 이름이 추가로 들어갈 필요가 없다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;최상위 프로퍼티&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var opCount = 0

fun performOperation(){
    opCount++
    //...
}

fun reporstOperationCount(){
    println(&quot;Operation performed $opCount times&quot;)
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;함수와 마찬지로 프로퍼티도 파일의 최상위 수준에 놓을 수 있다&lt;/li&gt;
  &lt;li&gt;이런 프로퍼티의 값은 정적 필드에 저장된다&lt;/li&gt;
  &lt;li&gt;최상위 프로퍼티를 활용해 코드에 상수를 추가할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val UNIX_LINE_SEOARATIR = &quot;\n&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;최상위 프로퍼티도 다른 모든 프로퍼티처럼 접근자 메소드를 통해 자바 코드에 노출된다&lt;/li&gt;
  &lt;li&gt;겉으론 상수처럼 보이는데 실제로는 게터를 사용해야 한다면 자연스럽지 못하다&lt;/li&gt;
  &lt;li&gt;const 변경자를 추가하면 프로퍼티를 public static final 필드로 컴파일하게 만들 수 있다&lt;/li&gt;
  &lt;li&gt;원시 타입과 String 타입의 프로퍼티만 const로 지정할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;메서드를-다른-클래스에-추가-확장-함수와-확장-프로퍼티&quot;&gt;메서드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package strings

fun String.lastChar(): Char = this.get(this.length - 1) // 수신 객체 멤버에 this없이도 접근할 수 있다

&amp;gt;&amp;gt;&amp;gt; println(&quot;Kotlin&quot;.lastChar())
n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;확장 함수는 어떤 클래스의 멤버 메서드인 것처럼 호출할 수 있지만 그 클래스의 밖에 선언된 함수다&lt;/li&gt;
  &lt;li&gt;확장 함수를 만드려면 추가하려는 함수 이름 앞에 그 함수가 확장할 클래스의 이름을 덧붙이기만 하면 된다&lt;/li&gt;
  &lt;li&gt;클래스 이름을 수신 객체 타입, 확장 함수가 호출 되는 대상이 되는 값을 수신 객체라고 부른다&lt;/li&gt;
  &lt;li&gt;위 예제에서는 String이 수신 객체 타입이고 “kotlin”이 수신 객체다&lt;/li&gt;
  &lt;li&gt;확장 함수 내부에서는 수신 객체의 메소드나 프로퍼티를 바로 사용할 수 있다. 그러나 클래스 내부에서만 사용할 수 있는 비공개 멤버나 보호된 멤버를 사용할 수 없다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;임포트와 확장 함수&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import strings.lastChar

val c = &quot;Kotlin&quot;.lastChar()

import strings.lastChar as last

val c = &quot;Kotlin&quot;.lats()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;확장 함수를 정의했다고 해도 자동으로 프로젝트 안의 모든 소스코드에서 그 함수를 사용할 수 있지는 않다&lt;/li&gt;
  &lt;li&gt;다른 클래스나 함수와 마찬가지로 임포트해야 한다&lt;/li&gt;
  &lt;li&gt;as 키워드를 사용하면 임포트한 클래스나 함수를 다른 이름으로 부를 수 있다&lt;/li&gt;
  &lt;li&gt;한 파일 안에서 다른 여러 패키지에 속해있는 이름이 같은 함수를 가져와 사용해야 하는 경우 이름을 바꿔서 임포트하면 이름 충돌을 막을 수 있다&lt;/li&gt;
  &lt;li&gt;코틀린 문법상 확장 함수는 반드시 짧은 이름을 써야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;확장 함수로 유틸리티 함수 정의&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun &amp;lt;T&amp;gt; Collection&amp;lt;T&amp;gt;.joinToString(
    separator: String = &quot;, &quot;,
    prefix: String = &quot;&quot;,
    postfix: String = &quot;&quot; 
): String {
    val result = StringBuilder(prefix)
    for((index, element) in this.withIndex()){
        if(index &amp;gt; 0) result.append(separator)
        result.append(element)
    }
    result.append(postfix)
    return result.toString()
}

&amp;gt;&amp;gt;&amp;gt; val list = listOf(1, 2, 3)
&amp;gt;&amp;gt;&amp;gt; println(list.joinToString(separator = &quot;; &quot;, prefix = &quot;(&quot;,postfix = &quot;)&quot;))
(1; 2; 3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이제 joinToString을 마치 클래스의 멤버인 것처럼 호출할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;확장 함수는 오바리이드 할 수 없다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;open class View{
    open fun click() = println(&quot;View Clicked&quot;)
}

class Button: View{
    override fun click() = println(&quot;Button clicked&quot;)
}

&amp;gt;&amp;gt;&amp;gt; val view: View = Button()
&amp;gt;&amp;gt;&amp;gt; view.click()
Button clicked
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;확장 함수는 오버라이드 할 수 없다&lt;/li&gt;
  &lt;li&gt;확장 함수는 클래스의 일부가 아니다&lt;/li&gt;
  &lt;li&gt;확장 함수는 클래스 밖에 선언된다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun View.showOff() = println(&quot;I'm a view!&quot;)
fun Button.showOff() = println(&quot;I'm a button!&quot;)
&amp;gt;&amp;gt;&amp;gt; val view: View = Button()
&amp;gt;&amp;gt;&amp;gt; view.showOff()
I'm a view!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;view가 가리키는 객체의 실제 타입은 Button이지만, 이 경우 view의 타입이 View이기 때문에 무조건 View의 확장 함수가 호출된다&lt;/li&gt;
  &lt;li&gt;클래스를 확장한 함수와 클래스의 멤버 함수의 이름과 시그니처가 같다면 확장 함수가 아니라 멤버 함수가 호출된다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;확장 프로퍼티&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val String.lastChar: Char
    get() = get(length - 1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;실제로 확장 프로퍼티는 아무 상태도 가질 수 없다&lt;/li&gt;
  &lt;li&gt;확장 함수의 경우와 마찬가지로 확장 프로퍼티도 일반적인 프로퍼티와 같은데, 단지 수신 객체 클래스가 추가된 것이다&lt;/li&gt;
  &lt;li&gt;뒷받침하는 필드가 없어서 기본 게터 구현을 제공할 수 없으므로 게터는 꼭 정의를 해야한다&lt;/li&gt;
  &lt;li&gt;초기와 코드도 쓸 수 없다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var StringBuilder.lastChar: Char
    get() = get(length - 1)
    set(value: Char){
        this.setCharAt(length -1, value)
    }

&amp;gt;&amp;gt;&amp;gt; println(&quot;Kotlin&quot;.lastChar)
n
&amp;gt;&amp;gt;&amp;gt; val sb = StringBuilder(&quot;Kotlin?&quot;)
&amp;gt;&amp;gt;&amp;gt; sb.lastChar = '!'
&amp;gt;&amp;gt;&amp;gt; println(sb)
Kotlin!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;컬렌션-처리-가변-길이-인자와-중위-함수-호출과-라이브러리-지원&quot;&gt;컬렌션 처리: 가변 길이 인자와 중위 함수 호출과 라이브러리 지원&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;vararg 키워드를 사용하면 호출 시 인자 개수가 달라질 수 있는 함수를 정의할 수 있다&lt;/li&gt;
  &lt;li&gt;중위 함수 호출 구문을 사용하면 인자가 하나뿐인 메소드를 간편하게 호출할 수 있다&lt;/li&gt;
  &lt;li&gt;구조 분해 선언을 사용하면 복합적인 값을 분해해서 여러 번 수에 나눠 담을 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;자바 컬렉션 API 확장&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val strings: List&amp;lt;String&amp;gt; = listOf(&quot;first&quot;,&quot;second&quot;, &quot;fourteenth&quot;)
&amp;gt;&amp;gt;&amp;gt; strings.last()
fourteenth
&amp;gt;&amp;gt;&amp;gt; val numbers: Collection&amp;lt;Int&amp;gt; = setOf(1, 14, 2)
&amp;gt;&amp;gt;&amp;gt; numbers.max()
14

fun&amp;lt;T&amp;gt;List&amp;lt;T&amp;gt;.last(): T{ 마지막 원소를 반환함}
fun Collection&amp;lt;Int&amp;gt;.max(): Int{ 컬렉션의 최댓값을 찾음}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;last와 max는 모두 확장 함수였던 것이다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;가변 인자 함수: 인자의 개수가 달라질 수 있는 함수 정의&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun listOf&amp;lt;T&amp;gt;(vararg values: T): List&amp;lt;T&amp;gt; { ... }

fun main(args: Array&amp;lt;String&amp;gt;){
    val list = listOf(&quot;args: &quot;, *args) // 스프레드 연산자가 배열의 내용을 펼쳐준다
    println(list)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;가변 길이 인자는 메소드를 호출할 때 원하는 개수만큼 값을 인자로 넘기면 자바 컴파일러가 배열에 그 값들을 넣어 주는 기능이다&lt;/li&gt;
  &lt;li&gt;타입 뒤에 …를 붇이는 대신 vararg 변경자를 붙인다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;값의 쌍 다루기: 중위 호출과 구조 분해 선언&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val map = mapOf(1 to &quot;one&quot;, 7 to &quot;seven&quot;, 53 to &quot;fifty-three&quot;)

1.to(&quot;one&quot;) // &quot;to&quot; 메소드를 일반적인 방식으로 호출함
1 to &quot;one&quot; // &quot;to&quot; 메소드를 중위 호출 방식으로 호출함

infix fun Any.to(other: Any) = Pair(this, other)

val (number, name) = 1 to &quot;one&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;맵을 만들려면 mapOf 함수를 사용한다&lt;/li&gt;
  &lt;li&gt;to라는 단어는 중위 호출이라는 특별한 방식으로 to라는 일반 메소드를 호출한 것이다&lt;/li&gt;
  &lt;li&gt;인자가 하나뿐인 일반 메소드나 인자가 하나뿐인 확장 함수에 중위 호출을 사용할 수 있다&lt;/li&gt;
  &lt;li&gt;함수를 중위 호출에 사용하게 허용하고 싶으면 infix 변경자를 함수 선언 앞에 추가해야 한다&lt;/li&gt;
  &lt;li&gt;이런 기능을 구조 분해 선언이라고 한다&lt;/li&gt;
  &lt;li&gt;to를 사용하면 타입과 관계없이 임의의 순서쌍을 만들 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;문자열과-정규식-다루기&quot;&gt;문자열과 정규식 다루기&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;문자열 나누기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; println(&quot;12.345-6.A&quot;.split(&quot;\\.|-&quot;.toRegex()))
[12, 345, 6 ,A]

&amp;gt;&amp;gt;&amp;gt; println(12.345-6.A&quot;.split(&quot;.&quot;,&quot;-&quot;))
[12, 345, 6, A]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;정규식을 파라미터로 받는 함수는 String이 아닌 Regex타입의 값을 받는다&lt;/li&gt;
  &lt;li&gt;간단한 경우네는 꼭 정규식을 쓸 필요가 없다. split 확장 함수를 오버로딩한 버전 중에는 구분 문자열을 하나 이상 인자로 받는 함수가 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;정규식과 3중 따움표로 묶은 문자열&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun parsePath(path: String){
    val directory = path.substringBeforeLast(&quot;/&quot;)
    val fullName = path.substringAfterLast(&quot;/&quot;)
    val fileName = fullName.substringBeforeLast(&quot;.&quot;)
    val extenstion = fullName.substringAfterLast(&quot;.&quot;)
    println(&quot;dir: $directory, name: $fileName, ext: $extension&quot;)
}
&amp;gt;&amp;gt;&amp;gt; parsePath(/users/yole/kotlin-book/chapter.aboc)
dir: /users/yole/kotlin-book, name: chapter, ext: aboc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;String을 확장한 함수를 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun parsePath(path: String){
    val regax = &quot;&quot;&quot;(.+)/(.+)\(.+)&quot;&quot;&quot;.toRegax()
    val matchResult = regax.matchEntire(path)
    if(matchResult != null){
        val(directory, filename, extension) = matchResult.destructured
        println(&quot;dir: $directory, name: $filename, ext: $extension&quot;)
    }    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;정규식을 사용&lt;/li&gt;
  &lt;li&gt;3중 따옴표 문자열에서는 역슬래시를 포함한 어떤 문자도 이스케이프할 필요가 없다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;여러 줄 3중 따옴표 문자열&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;3중 따옴표 문자열에서는 줄 바꿈을 표현하는 아무 문자열이나 그대로 들어간다&lt;/li&gt;
  &lt;li&gt;3중 따옴표 안에 문자열 템플릿을 사용할 수 있다 ‘$’ 문자를 넣어야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;코드-다듬기-로컬-함수와-확장&quot;&gt;코드 다듬기: 로컬 함수와 확장&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class User(val id: Int, val name: String, val address: String)

fun saveUser(user: User){
    if(user.name.isEmpty()){
        throws IllegalArgumentException(
            &quot;Can't save user $(user.id): empty Name&quot;)
        )
    }
    if(user.address.isEmpty()){
        throws IllegalArgumentException(
            &quot;Can't save user $(user.id): empty Address&quot;)
        )
    }
}

&amp;gt;&amp;gt;&amp;gt; saveUser(User(1,&quot;&quot;,&quot;&quot;))
java.lang.IllegalArgumentException: Can't save user 1: empty Name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;코틀린에서는 함수에서 추출한 함수를 원 함수 내부에 중첩시킬 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class User(val id: Int, val name: String, val address: String)

fun saveUser(user: User){
    fun vaildate(user: USer,
                value: String,
                fieldName: String){
            if(value.isEmpty()){
        throws IllegalArgumentException(
            &quot;Can't save user $(user.id): empty $fileName&quot;)
        }
    }
    validate(user, user.name, &quot;Name&quot;)
    validate(user, user.address, &quot;Address&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;검증 로직 중복이 사라졌다&lt;/li&gt;
  &lt;li&gt;불필요한 User 파라미터도 없애보자&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class User(val id: Int, val name: String, val address: String)

fun saveUser(user: User){
    fun vaildate(value: String,fieldName: String){
            if(value.isEmpty()){
        throws IllegalArgumentException(
            &quot;Can't save user $(user.id): &quot; + &quot;empty $fileName&quot;)
        }
    }
    validate(user.name, &quot;Name&quot;)
    validate(user.address, &quot;Address&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이 것을 더 개선하고 싶다면 User클래스를 확장한 함수로 만들 수도 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">코틀린 테이블 코틀린 기초 함수 정의와 호출 클래스, 객체, 인터페이스 람다로 프로그래밍 코틀린 타입 시스템 연산자 오버로딩과 기타 관례 고차 함수: 파라미터와 반환 값으로 람다 사용 제네릭스 애노테이션과 리플렉션 DSL 만들기</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">코틀린 기초</title>
      <link href="https://lee989898.github.io/kotlin-01" rel="alternate" type="text/html" title="코틀린 기초" />
      <published>2021-08-02T01:05:00+09:00</published>
      <updated>2021-08-02T01:05:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-01</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-01">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;코틀린 테이블&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-01&quot;&gt;코틀린 기초&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-02&quot;&gt;함수 정의와 호출&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-03&quot;&gt;클래스, 객체, 인터페이스&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-04&quot;&gt;람다로 프로그래밍&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-05&quot;&gt;코틀린 타입 시스템&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-06&quot;&gt;연산자 오버로딩과 기타 관례&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-07&quot;&gt;고차 함수: 파라미터와 반환 값으로 람다 사용&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-08&quot;&gt;제네릭스&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-09&quot;&gt;애노테이션과 리플렉션&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./kotlin-10&quot;&gt;DSL 만들기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;코틀린-기초&quot;&gt;코틀린 기초&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#기본요소-함수와-변수&quot;&gt;기본요소: 함수와 변수&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#클래스와-프로퍼티&quot;&gt;클래스와 프로퍼티&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#선택-표현과-처리-enum과-when&quot;&gt;선택 표현과 처리: enum과 when&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#대상을-이터레이션-while과-for-루프&quot;&gt;대상을 이터레이션: while과 for 루프&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#코틀린의-예외-처리&quot;&gt;코틀린의 예외 처리&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;기본요소-함수와-변수&quot;&gt;기본요소: 함수와 변수&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun main(args: String&amp;lt;String&amp;gt;){
    println(&quot;Hello, world!&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 함수에서 알 수 있는 것들&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;함수를 선언할 때 fun 키워드를 사용한다&lt;/li&gt;
  &lt;li&gt;파라미터 이름 뒤에 그 파라미터의 타입을 쓴다&lt;/li&gt;
  &lt;li&gt;함수를 최상위 수준에 정의할 수 있다. 클래스 안에 함수를 넣어야 할 필요가 없다&lt;/li&gt;
  &lt;li&gt;배열도 일반적인 클래스와 마찬가지다. 배열 처리를 위한 문법이 따로 존재하지 않는다&lt;/li&gt;
  &lt;li&gt;함수를 간결하게 사용할 수 있게 감싼 래퍼를 제공하여 println을 사용한다&lt;/li&gt;
  &lt;li&gt;줄 끝에 세미콜론을 붙이지 않아도 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;함수&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun max(a: Int, b: Int): Int{
    return if (a &amp;gt; b) a else b
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;함수 이름 뒤에는 괄호 안에 파라미터 목록이 온다&lt;/li&gt;
  &lt;li&gt;함수의 반환 타입은 파라미터 목록의 닫는 괄호 다음에 온다. 콜론으로 구분해야 한다&lt;/li&gt;
  &lt;li&gt;코틀린 if는 문장이 아니고 결과를 만드는 식이다&lt;/li&gt;
  &lt;li&gt;식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있는 반면 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 못한다&lt;/li&gt;
  &lt;li&gt;코틀린 대부분 제어 구조는 식이다. 반면 자바와 달리 대입문은 코틀린에서 문이다.&lt;/li&gt;
  &lt;li&gt;(fun max(a: Int, b: Int): Int = if(a &amp;gt; b) a else b) 처럼 간결하게 표현할 수 있다. (식이 본문인 함수, 블록이 본문인 함수)&lt;/li&gt;
  &lt;li&gt;반환 타입을 생략할 수 도 있다. 컴파일러가 타입을 분석해 프로그래머 대신 프로그램 구성 요소의 타입을 정해주는 타입추론 기능이 있기 때문이다&lt;/li&gt;
  &lt;li&gt;식이 본문인 함수의 반환 타입만 생략 가능하다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;변수&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val question = &quot;삶, 우주, 그리고 모든 것에 대한 궁극적인 질문&quot;
val answer: 42
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;코틀린에서는 키워드로 변수 선언을 시작하는 대신 변수 이름 뒤에 타입을 명시하거나 생략하게 허용한다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val answer: Int
answer = 42
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시해야한다&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;초기화 식이 없다면 변수에 저장될 값에 대해 아무 정보가 없기 때문에 컴파일러가 타입을 추론할 수 없다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;변수 선언 시 사용하는 키워드는 2가지가 있다
    &lt;ul&gt;
      &lt;li&gt;val - 변경 불가능한 참조를 저장하는 변수다. val로 선언된 변수는 일단 초기화하고 나면 재대입이 불가능하다&lt;/li&gt;
      &lt;li&gt;var - 변경 가능한 참조다. 변수의 값은 바뀔 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기본적으로 모든 변수를 val 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때에만 var로 변경하는게 좋다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val message: String
if(canPerformOperation()){
    message = &quot;Success&quot;
}
else {
    message = &quot;Failed&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;조건에 따라 val 값을 다른 여러 값으로 초기화 할 수 있다
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val languages = arrayListOf(&quot;Java&quot;)
languages.add(&quot;Kotlin&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;val 참조 객체는 불변일지라도 그 참조가 가리키는 객체의 배부 값은 변경될 수 있다
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var answer = 42
answer = &quot;no answer&quot; // 컴파일 오류 발생
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;var 키워드를 사용하면 변수의 값을 변경할 수 있지만 변수의 타입은 고정돼 바뀌지 않는다&lt;/li&gt;
  &lt;li&gt;어떤 타입의 변수에 다른 타입의 값을 저장하고 싶다면 변환 함수를 써서 값을 변수의 타입으로 변환하거나, 값을 변수에 대입할 수 있는 타입으로 강제 형 변환해야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;문자열 템플릿&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun main(args: Array&amp;lt;String&amp;gt;){
    val name = if (args.size &amp;gt; 0) args[0] else &quot;Kotlin&quot;
    println(&quot;Hello, $name!&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;변수를 문자열 안에 사용할 수 있다&lt;/li&gt;
  &lt;li&gt;문자열 리터럴의 필요한 곳에 변수를 넣되 변수 앞에 $를 추가해야 한다&lt;/li&gt;
  &lt;li&gt;$ 문자를 문자열에 넣고 싶으면 $를 이스케이프 시켜야 한다
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun main(args: Array&amp;lt;String&amp;gt;){
  if(args.size &amp;gt; 0){
      println(&quot;Hello, ${args[0]}!&quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;복잡한 식도 중괄호로 둘러싸서 문자열 템플릿 안에 넣을 수 있다&lt;/li&gt;
  &lt;li&gt;문자열 템플릿 안에서 변수 이름만 사용하는 경우라도 ${name}처럼 중괄호로 변수명을 감싸는 습관을 들이면 더 좋다
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun main(args: Array&amp;lt;String&amp;gt;){
  println(&quot;Hello, ${if (args.size &amp;gt; 0) args[0] else &quot;someone&quot;}!&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;중괄호로 둘러싼 식 안에서 큰 타옴표를 사용할 수도 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;클래스와-프로퍼티&quot;&gt;클래스와 프로퍼티&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Person(val name: String)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;이런 유형의 클래스를 값 객체라 부른다&lt;/li&gt;
  &lt;li&gt;코틀린의 기본 가시성은 public이므로 이런 경우 변경자를 생략해도 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로피터&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Person(
    val name: String       // (비공개)필드, (공개) 게터를 만들어 낸다
    var isMarried: Boolean // (비공개)필드, (공개) 게터, (공개) 세터를 만들어 낸다
)

&amp;gt;&amp;gt;&amp;gt; val person = Person(&quot;Bob&quot;, true)
&amp;gt;&amp;gt;&amp;gt; println(person.name) // 프로퍼티 이름을 직접 사용해도 코틀린이 자동으로 게터를 호출해준다
Bob
&amp;gt;&amp;gt;&amp;gt; println(person.isMarried) // 프로퍼티 이름을 직접 사용해도 코틀린이 자동으로 게터를 호출해준다
true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;코틀린 프로퍼티는 자바의 필드와 접근자 메소드를 대신한다&lt;/li&gt;
  &lt;li&gt;클래스에서 프로퍼티를 선언할 때는 val이나 var를 사용한다
    &lt;ul&gt;
      &lt;li&gt;val로 선언한 프로퍼티는 읽기 전용이며, var로 선언한 프로퍼티는 변경 가능하다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;커스텀 접근자&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Rectangle(val height: Int, val width: Int){
    val isSquare: Boolean
        get(){
            return height == width
        }
}

&amp;gt;&amp;gt;&amp;gt; val rectangle = Rectangle(41, 43)
&amp;gt;&amp;gt;&amp;gt; println(rectangle.isSquare)
false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;isSqaure 프로퍼티에는 자체 값을 저장하는 필드가 필요없다. 이 프로퍼티에는 자체 구현을 제공하는 게터만 제공한다&lt;/li&gt;
  &lt;li&gt;클라이언트가 프로퍼티에 접근할 때마다 게터가 프로퍼티 값을 매번 다시 계산한다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;디렉터리와 패키지&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package gemotry.shapes

import java.util.Random

class Rectangle(val height: Int, val width: Int){
    val isSquare: Boolean
        get(){
            return height == width
        }
}

fun createRandomRectangle(): Rectangle{
    val random = Random()
    return Rectangle(random.nextInt(), random.nextInt())
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;모든 코틀린 맨 앞에 package문을 넣을 수 있다. 그러면 그파일 안에 있는 모든 선언이 해당 패키지에 들어간다&lt;/li&gt;
  &lt;li&gt;다른 패키지에 정의한 선언을 사용하려면 임포트를 통해 선언을 불러와야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package gemotry.example

import geometry.shapes.createRandomRectangle    // 이름으로 함수 임포트하기

fun main(args: Array&amp;lt;String&amp;gt;){
    println(createRandomRectangle().isSquare)   // &quot;true&quot;가 아주 드물게 출력된다
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;클래스 임포트와 함수 임포트에 차이가 없다&lt;/li&gt;
  &lt;li&gt;최상위 함수는 그 이름을 써서 임포트 할 수 있다&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;패키지 이름 뒤에 .*를 추가하면 패키지 안의 모든 선언을 임포트 할 수 있다. 모든 클래스뿐 아니라 최상위에 정의된 함수나 프로퍼티까지 모두 불러온다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;코틀린에서는 여러 클래스를 한 파일에 넣을 수 있고, 파일의 이름도 마음대로 정할 수 있다. 코틀린에서는 디스크상의 어느 디렉터리에 소스코드 파일을 위치시키든 관계없다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;선택-표현과-처리-enum과-when&quot;&gt;선택 표현과 처리: enum과 when&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;enum 클래스 정의&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;enum class Color{
    RED, ORANCE, YELLOW, GREEN, BLUE, INDIGO, VIOLET
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;enum은 소프트 키워드이다&lt;/li&gt;
  &lt;li&gt;enum 클래스 안에도 프로퍼티나 메소드를 정의할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;enum class Color(
    val r: Int, val g: Int, var b: Int
){
    RED(255,0,0), ORANGE(255,165,0), YELLOW(255,255,0), GREEN(0,255,0), BLUE(0,0,255),
    INDIGO(75,0,130), VIOLET(238,130,238);
    
    fun rgb() = (r * 256 + g) * 256 + b
}

&amp;gt;&amp;gt;&amp;gt; println(Color.BLUE.rgb())
255
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;각 enum 상수를 정의할 때는 그 상수에 해당하는 프로퍼티 값을 지정해야만 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;when으로 enum 클래스 다루기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun getMnemonic(color: Color)=
    when(color){
        Color.RED -&amp;gt; &quot;Richard&quot;
        Color.ORANGE -&amp;gt; &quot;Of&quot;
        Color.YELLOW -&amp;gt; &quot;York&quot;
        Color.GREEN -&amp;gt; &quot;Gave&quot;
        Color.BLUE -&amp;gt; &quot;Battle&quot;
        Color.INDIGO -&amp;gt; &quot;In&quot;
        Color.VIOLET -&amp;gt; &quot;Vain&quot;
    }

&amp;gt;&amp;gt;&amp;gt; println(getMneminic(Color.BLUE))
Battle
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;각 분기의 끝에 break를 넣지 않아도 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun getWarmth(color: Color) = when(color){
    Color.RED, Color.ORANGE, Color.YELLOW -&amp;gt; &quot;warm&quot;
    Color.GREEN -&amp;gt; &quot;neutral&quot;
    Color.BLUE, Color.INDIGO, Color.VIOLET -&amp;gt; &quot;cold&quot;
}

&amp;gt;&amp;gt;&amp;gt; println(getWarmth(Color.ORANGE))
warm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;한 분기 안에서 여러 값을 매치 패턴으로 사용할 수도 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import ch02.colors.Color   // 다른 패키지에서 정의한 Color 클래스를 임포트한다
import ch02.colors.Color.* //짧은 이름으로 사용하기 위해 enum 상수를 모두 임포트한다

fun getWarmth(color: Color) = when(color){
    RED,ORANGE,YELLOW -&amp;gt; &quot;warm&quot;
    GREEN -&amp;gt; &quot;neutral&quot;
    BLUE, INDIGO, VIOLET -&amp;gt; &quot;cold&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;상수 값을 임포트 하면 코드를 더 간단하게 만들 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;when과 임의의 객체를 함께 사용&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun mix(c1: Color, c2: Color) = when(setOf(c1,c2)){
    setOf(RED, YELLOW) -&amp;gt; ORANGE
    setOf(YELLOW, BLUE) -&amp;gt; GREEN
    setOf(BLUE, VIOLET) -&amp;gt; INDIGO
    else -&amp;gt; throw Exception(&quot;Dirty color&quot;)
}

&amp;gt;&amp;gt;&amp;gt; println(mix(BLUE, YELLOW))
GREEN
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;when의 분기 조건은 임의의 객체를 허용한다&lt;/li&gt;
  &lt;li&gt;when의 분기 조건 부분에 식을 넣을 수 있기 때문에 많은 경우 코드를 더 간결하고 아름답게 작성할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;인자 없는 when 사용&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun mixOptimized(c1: Color, c2: Color) =
    when{
        (c1 == RED &amp;amp;&amp;amp; c2 == YELLOW) ||
        (c1 == YELLOW &amp;amp;&amp;amp; c2 == RED) -&amp;gt;
            ORANGE
        (c1 == YELLOW &amp;amp;&amp;amp; c2 == BLUE) ||
        (c1 == BLUE &amp;amp;&amp;amp; c2 == YELLOW) -&amp;gt;
            GREEN
        (c1 == BLUE &amp;amp;&amp;amp; c2 == VIOLET) ||
        (c1 == VIOLET &amp;amp;&amp;amp; c2 == BLUE) -&amp;gt;
            INDIGO
        else -&amp;gt; throw Exception(&quot;Dirty color&quot;)
    }

&amp;gt;&amp;gt;&amp;gt; println(mixOptimized(BLUE, YELLOW))
GREEN
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;인자가 없는 when식을 사용하면 불필요한 객체 생성을 막을 수 있다&lt;/li&gt;
  &lt;li&gt;코드는 약간 읽기 어려워지지만 성능이 향상된다&lt;/li&gt;
  &lt;li&gt;when에 아무 인자가 없으려면 각 분기의 조건이 불리언 결과를 계산하는 식이어야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;스마트 캐스트: 타입 검사와 타입 캐스트를 조합&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface Expr
class Num(val value: Int): Expr
class Sum(val left: Expr, val right: Expr): Expr

fun eval (e: Expr): Int{
    if (e is Num){
        val n = e as Num
        return n.value
    }
    if (e is Sum){
        return eval(e.right) + eval(e.left)
    }
    throw IllegalArgumentException(&quot;Unknown expression&quot;)
}

&amp;gt;&amp;gt;&amp;gt; println(eval(Sum(Sum(Num(1),Num(2)), Num(4))))
7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;is를 사용해 변수 타입을 검사한다. 컴파일러가 대신 캐스팅을 해준다. 이를 스마트 캐스트라고 부른다&lt;/li&gt;
  &lt;li&gt;원하는 타입으로 명시적으로 타입 캐스팅하려면 as 키워드를 사용한다&lt;/li&gt;
  &lt;li&gt;스마트 캐스트는 is로 변수에 든 값의 타입을 검사한 다음에 그 값이 바뀔 수 없는 경우에만 작동한다&lt;/li&gt;
  &lt;li&gt;스마트 캐스트를 사용한다면 그 프로퍼티는 반드시 val이어야 하며 커스텀 접근자를 사용한 것이어도 안 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;리펙토리: if를 when으로 변경&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun eval (e: Expr): Int =
    if (e is Num){
        e.value
    } else if (e is Sum){
        eval(e.right) + eval(e.left)
    } else {}
    throw IllegalArgumentException(&quot;Unknown expression&quot;)
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;return문과 중괄호를 없애고 if식을 본문으로 사용해 더 간단하게 만들 수 있다&lt;/li&gt;
  &lt;li&gt;if의 분기에 식이 하나밖에 없다면 중괄호를 생략해도 된다&lt;/li&gt;
  &lt;li&gt;if 분기에 블록을 사용하는 경우 그 블록의 마지막 식이 그 분기의 결과 값이다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun eval (e: Expr): Int =
    when(e){
        is Num -&amp;gt;
            e.value
        is Sum -&amp;gt;
            eval(e.right) + eval(e.left)
        else -&amp;gt;
            throw IllegalArgumentException(&quot;Unknown expression&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;when을 사용해 더 다듬을 수도 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;if와 when의 분기에서 블록 사용&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun evalWithLogging (e: Expr): Int =
    when(e){
        is Num -&amp;gt;{
            println(&quot;num: ${e.value}&quot;)
            e.value
        }
        is Sum -&amp;gt;{
            val left = evalWithLogging(e.left)
            val right = evalWithLogging(e.right)
            println(&quot;sum: $left + $right&quot;)
            left + right
        }
        else -&amp;gt; throw IllegalArgumentException(&quot;Unknown expression&quot;)
}

&amp;gt;&amp;gt;&amp;gt; println(evalWithLogging(Sum(Sum(Num(1),Num(2)), Num(4))))
num: 1
num: 2
sum: 1 + 2
num: 4
sum: 3 + 4
7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;if나 when 모두 분기에 블록을 사용할 수 있다. 그런 경우 블록의 마지막 문장이 블록 전체의 결과가 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;while과-for-루프&quot;&gt;while과 for 루프&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;대상을 이터레이션: while과 for 루프&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;while 루프&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while(조건){
    /* ... */
}
do {
    /* ... */
} while(조건)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;자바와 동일하다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;수에 대한 이터레이션: 범위와 수열&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val oneToTen = 1..10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;코틀린의 범위는 폐구간 또는 양끝을 포함하는 구간이다&lt;/li&gt;
  &lt;li&gt;이런 식으로 어떤 범위에 속한 값을 일정한 순서로 이터레이션 하는 경우를 수열이라고 부른다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun fizzBuzz(i: Int) = when{
    i % 15 == 0 -&amp;gt; &quot;FizzBuzz&quot;
    i % 3 == 0 -&amp;gt; &quot;Fizz&quot;
    i % 5 == 0 -&amp;gt; &quot;Buzz&quot;
    else -&amp;gt; &quot;$i&quot;
}

&amp;gt;&amp;gt;&amp;gt; for(i in 1..100){
    print(fizzBuzz(i))
    }

1 2 Fizz 4 Buzz Fizz 7 ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;for &lt;아이템&gt; in &lt;원소들&gt;&lt;/원소들&gt;&lt;/아이템&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; for(i in 100 downTo 1 step 2){
    print(fizzBuzz(i))
}

Buzz 98 Fizz 94 92 FizzBuzz 88 ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;100부터 거꾸로 세되 짝수만 나오게 하기&lt;/li&gt;
  &lt;li&gt;증가 값을 음수로 만들면 정방향 수열이 아닌 역방향 수열을 만들 수 있다&lt;/li&gt;
  &lt;li&gt;증가 값을 사용하면 수를 건너 뛸 수 있다&lt;/li&gt;
  &lt;li&gt;끝 값을 포함하지 않는 반만 닫힌 범위를 원하면 until 함수를 사용하자&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;맵에 대한 이터레이션&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val binaryReps = TreeMap&amp;lt;Char, String&amp;gt;()

for(c in 'A'..'F'){
    val binary = Integer.toBinaryString(c.toInt())
    binaryResps[c] = binary
}

for((letter, binary) in binaryReps){
    println(&quot;$letter = $binary&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;.. 연산자를 숫자 타입의 값뿐 아니라 문자 타입의 값에도 적용할 수 있다&lt;/li&gt;
  &lt;li&gt;binaryReps[c] = binary 라는 코드는 binaryReps.put(c, binary)라는 자바 코드와 같다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val list = arrayListOf(&quot;10&quot;, &quot;11&quot;, &quot;1001&quot;)
for((index, element) in list.withIndex()){
    println(&quot;$index: $element)
}

0: 10
1: 11
2: 1001
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;맵에 사용했던 구조 분해 구문을 맵이 아닌 컬렉션에도 활용할 수 있다&lt;/li&gt;
  &lt;li&gt;구조 분해 구문을 사용하면 원소의 현재 인덱스를 유지하면서 컬렉션을 이터레이션 할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;in으로 컬렉션이나 범위의 원소 검사&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun isLetter(c: Char) = c in 'a'..'z' || c in 'A'..'Z'
fun isNotDigit(c: Char) = c! in '0'..'9'

&amp;gt;&amp;gt;&amp;gt; println(isLetter('q'))
true
&amp;gt;&amp;gt;&amp;gt; println(isNotDigit('x'))
true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;in 연산자를 사용해 어떤 값이 범위에 속하는지 검사할 수 있다&lt;/li&gt;
  &lt;li&gt;!in을 사용하면 어떤 값이 범위에 속하지 않는지 검사할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun recognize(c: Char) = when(c){
    in '0'..'9' -&amp;gt; &quot;It's a digit!&quot;
    in 'a'..'z', in 'A'..'Z' -&amp;gt; &quot;It's a letter!&quot;
    ele -&amp;gt; &quot;I dont know..&quot;
}

&amp;gt;&amp;gt;&amp;gt; println(recognize('8'))
It's a digit!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;in과 !in 연산자를 when 식에서 사용할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; println(&quot;Kotlin&quot; in &quot;java&quot;..&quot;Scala&quot;)
true
&amp;gt;&amp;gt;&amp;gt; println(&quot;Kotlin&quot; in setOf(&quot;Java&quot;, &quot;Scala&quot;))
false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;범위는 문자에만 국한하지 않고 비교가 가능한 클래스라면 그 클래스의 인스턴스 객체를 사용해 범위를 만들 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;코틀린의-예외-처리&quot;&gt;코틀린의 예외 처리&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val percentage =
    if(number in 0..100)
        number
    else
        throw IllegalArgumentException(
            &quot;A precentage value must be between 0 and 100: $number&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;함수는 정상적으로 종료할 수 있지만 오류가 발생하면 예외를 던질수 있다&lt;/li&gt;
  &lt;li&gt;함수를 호출하는 쪽에서는 그 예외를 잡아 처리할 수 있다&lt;/li&gt;
  &lt;li&gt;throw는 식이므로 다른 식에 포함될 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;try, catch, finally&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun readNumber(reader: BufferedReader): Int?{
    try{
        val line = reader.readLine()
        return Integer.parseInt(line)
    }
    catch(e: NumberFormatException){
        return null
    }
    finally{
        reader.close()
    }
}

&amp;gt;&amp;gt;&amp;gt; val reader = BufferReader(StringReader(&quot;239&quot;))
&amp;gt;&amp;gt;&amp;gt; println(readNumber(reader))
239
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;코틀린은 체크 예외와 언체크 예외를 구별하지 않는다&lt;/li&gt;
  &lt;li&gt;함수가 던지는 예외를 지정하지 않고 발생한 예외를 잡아내도 되고 잡아내지 않아도 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;try를 식으로 사용&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun readNumber(reader: BufferedReader){
    val number = try{
        Integer.parseInt(reader.readLine())
    } catch(e: NumberFormatException){
        return
    }
    println(number)
}

&amp;gt;&amp;gt;&amp;gt; val reader = BufferedReader(StringReader(&quot;not a number&quot;))
&amp;gt;&amp;gt;&amp;gt; readNumber(reader)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;try 키워드는 if나 when과 마찬가지로 식이다&lt;/li&gt;
  &lt;li&gt;try 본문을 반드시 중괄호로 둘러싸야 한다&lt;/li&gt;
  &lt;li&gt;try도 마지막 식의 값이 전체 결과 값이다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fun readNumber(reader: BufferedReader){
    val number = try{
        Integer.parseInt(reader.readLine())
    } catch(e: NumberFormatException){
        null
    }
    println(number)
}

&amp;gt;&amp;gt;&amp;gt; val reader = BufferedReader(StringReader(&quot;not a number&quot;))
&amp;gt;&amp;gt;&amp;gt; readNumber(reader)
null
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;catch에서 값 반환하기&lt;/li&gt;
  &lt;li&gt;try 코드 블럭의 실행이 정상적으로 끝나면 그 블록의 마지막 식의 값이 결과다&lt;/li&gt;
  &lt;li&gt;예외가 발생하고 잡히면 그 예외에 해당하는 catch 블록의 값이 결과다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">코틀린 테이블 코틀린 기초 함수 정의와 호출 클래스, 객체, 인터페이스 람다로 프로그래밍 코틀린 타입 시스템 연산자 오버로딩과 기타 관례 고차 함수: 파라미터와 반환 값으로 람다 사용 제네릭스 애노테이션과 리플렉션 DSL 만들기</summary>
      

      
      
    </entry>
  
</feed>
