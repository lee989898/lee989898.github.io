<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://lee989898.github.io/tag/algorithm/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://lee989898.github.io/" rel="alternate" type="text/html" />
  <updated>2021-11-09T21:31:37+09:00</updated>
  <id>https://lee989898.github.io/tag/algorithm/feed.xml</id>

  
  
  

  
    <title type="html">LEE | </title>
  

  
    <subtitle>공부 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">NP-완전</title>
      <link href="https://lee989898.github.io/algorithm-06" rel="alternate" type="text/html" title="NP-완전" />
      <published>2021-11-09T01:09:00+09:00</published>
      <updated>2021-11-09T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-06</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-06">&lt;h3 id=&quot;np-완전&quot;&gt;&lt;strong&gt;NP-완전&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;문제의 분류&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;풀 수 있는(solvable) 문제​
    &lt;ul&gt;
      &lt;li&gt;P 문제: 다항 시간 내에 풀 수 있는 문제 ​&lt;/li&gt;
      &lt;li&gt;NP 문제: 다항 시간 내에 풀 수 없는 문제​
        &lt;ul&gt;
          &lt;li&gt;비결정론적 다항 시간 알고리즘으로 해결할 수 있는 문제​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;NP-완전 문제: 지수 시간 내에 풀 수 있는 문제​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;풀 수 없는(unsolvable) 문제​
    &lt;ul&gt;
      &lt;li&gt;예: 정지 문제(Halting Problem)​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag14.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;결정 문제​
    &lt;ul&gt;
      &lt;li&gt;Yes 혹은 No의 해를 요구하는 문제​&lt;/li&gt;
      &lt;li&gt;예: 무방향그래프의 정점 s 에서 정점 f 까지 가는 경로의 거리가 K(상수) 이하인 경로가 있는가?​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최적화 문제​
    &lt;ul&gt;
      &lt;li&gt;최적의 해를 요구하는 문제​&lt;/li&gt;
      &lt;li&gt;예: 무방향그래프의 정점 s 에서 정점 f 까지 가는 최단 경로의 거리는 얼마인가?​&lt;/li&gt;
      &lt;li&gt;최적화 문제는 모두 대응하는 결정 문제로 바꾼 다음 해결한다.​&lt;/li&gt;
      &lt;li&gt;최적화 문제는 대응하는 결정 문제보다 풀기가 쉽지 않다. ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;비결정론적 다항 시간 알고리즘에 의해 해결할 수 있는 결정 문제들의 집합​&lt;/li&gt;
  &lt;li&gt;비결정론적 다항 시간 알고리즘이란?​
    &lt;ul&gt;
      &lt;li&gt;한 결정 문제의 사례 I를 입력으로 받아 다음을 수행하는 2 단계 알고리즘​&lt;/li&gt;
      &lt;li&gt;비결정론적 ‘추측’ 단계: 주어진 사례 I에 대한 해 S를 ‘추측’한다.​&lt;/li&gt;
      &lt;li&gt;결정론적 ‘확인’ 단계: 사례 I와 해 S를 입력으로 받아 S가 I에  대한 해임을 결정론적 다항 시간에 확인하고 그 해가 맞으면 ‘Yes’ 라고 답하고 해가 아니라면 ‘No’ 라고 답하거나 알고리즘이 종료되지 않게 한다. ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;NP 문제는 해가 Yes 라는 근거가 주어졌을 때 그 해가 옳은 근거임을 다항 시간에 확인해 줄 수 있다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-완전 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;NP에 속하는 문제​&lt;/li&gt;
  &lt;li&gt;어떤 NP-완전 문제를 다항 시간 알고리즘에 의해 풀 수 있다면 나머지 모든 NP-완전 문제들도 다항 시간 알고리즘에 의해 풀 수 있다.​&lt;/li&gt;
  &lt;li&gt;NP-완전 문제는 결정 문제만으로 국한한다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-완전 문제의 핵심 원리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;결정 문제의 변환을 이용한 해결 과정​
    &lt;ul&gt;
      &lt;li&gt;결정 문제 A를 다항 시간에 해결할 수 있는지 알고 싶다.​&lt;/li&gt;
      &lt;li&gt;가정​
        &lt;ul&gt;
          &lt;li&gt;다항 시간에 해결 가능한 결정 문제 B를 이미 알고 있다.​&lt;/li&gt;
          &lt;li&gt;문제 A를 다항 시간에 문제 B로 변환할 수 있고 문제 B의 해(Yes 혹은 No)가 문제 A의 해와 항상 일치한다.​
            &lt;ol&gt;
              &lt;li&gt;문제 A의 사례를 문제 B의 사례로 변환한다. ​&lt;/li&gt;
              &lt;li&gt;변환된 문제 B의 사례를 문제 B의 알고리즘을 이용하여 해결한다.&lt;br /&gt;
주: 문제 A도 다항 시간에 해결할 수 있다.​&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다항 시간에 해결할 수 있는 결정 문제가 아직까지 발견되지   않았다. 따라서 문제 A를 다항 시간에 해결할 수 있는지는 알 수 없다. ​&lt;/li&gt;
  &lt;li&gt;NP-완전 문제들은 서로 다항 시간에 변환 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-완전 정의&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;결정 문제 D는 다음 조건들을 만족시켜야 한다. ​
    &lt;ol&gt;
      &lt;li&gt;문제 D는 NP에 속한다.​&lt;/li&gt;
      &lt;li&gt;NP에 속한 모든 문제는 다항 시간에 문제 D로  변환 가능하다.​&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-hard&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;NP-완전보다 넓은 범위의 문제를 포함한다. ​&lt;/li&gt;
  &lt;li&gt;문제 A가 다음 조건을 만족하면 NP-hard이다.​
    &lt;ul&gt;
      &lt;li&gt;NP에 속한 모든 문제는 다항 시간에 문제 A로 변환 가능하다. ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;NP-완전 문제는 NP-hard에 속한다. ​&lt;/li&gt;
  &lt;li&gt;NP-hard 문제는 반드시 NP 문제일 필요는 없다.​&lt;/li&gt;
  &lt;li&gt;NP-hard는 최적화 문제도 포함한다.​&lt;/li&gt;
  &lt;li&gt;문제 A가 다음 조건들을 만족하면 NP-완전이다. ​
    &lt;ol&gt;
      &lt;li&gt;A는 NP에 속한다.​&lt;/li&gt;
      &lt;li&gt;A는 NP-hard이다. ​&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag15.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;한 문제가 NP-hard에 속한다는 것을 증명하는 것은 매우 어렵다. 왜냐하면 NP에 속한 모든 문제를 다항 시간에 그 문제로 변환 가능함을 보여야 하기 때문이다. ​&lt;/li&gt;
  &lt;li&gt;정리: 한 NP-hard 문제를 다항 시간에 주어진 문제로 변환 가능하다면 그 문제는 NP-hard에 속한다. ​&lt;/li&gt;
  &lt;li&gt;한 문제가 NP-hard에 속한다는 증명은 이 정리를 이용한다.​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;문제 A의 NP-완전 증명 방법​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;문제 A가 NP에 속함을 보인다.​&lt;/li&gt;
  &lt;li&gt;한 NP-hard 문제 C의 사례를 다항 시간에 문제 A의 사례로 변환하는 알고리즘을 작성한다.​&lt;/li&gt;
  &lt;li&gt;2의 알고리즘을 수행하여 얻은 결과 사례 C와 사례 A의 Yes/No 해가 일치함을 보인다.​&lt;br /&gt;
주: 어떤 문제가 NP-완전 문제임을 증명하는 것은 쉽지 않다. ​&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-완전 문제​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;논리곱 정규형-만족​&lt;/li&gt;
  &lt;li&gt;완전 부분 그래프​&lt;/li&gt;
  &lt;li&gt;정점 커버​&lt;/li&gt;
  &lt;li&gt;부분 집합의 합​&lt;/li&gt;
  &lt;li&gt;그래프 색칠하기​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;논리곱 정규형-만족 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;부울 연산식은 논리곱 정규형으로 표현될 수 있다.&lt;/li&gt;
  &lt;li&gt;문제: 논리곱 정규형의 주어진 부울 연산식의 값이 true가 되도록 부울 연산식의 변수들에 true나 false 값을 할당할 수 있는가?&lt;/li&gt;
  &lt;li&gt;예: a,b,c -부울 변수,$\bar{a}$, $\bar{b}$ , $\bar{c}$ : a,b,c의 역&lt;br /&gt;
부울 연산삭: ($\bar{a}$ $\lor$ $\bar{b}$ $\lor$ c) $\land$ ($\bar{a}$ $\lor$ b) $\land$ (a $\lor$ $\bar{b}$ $\lor$ $\bar{c}$ )
해: a = true, b = true, c = true&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;완전 부분 그래프​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무방향 그래프 내에 있는 최대 크기의 완전 부분 그래프를 찾아라&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/ag/ag16.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;정점 커버​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무방향 그래프 내에 있는 최소 크기의 정점 커버를 찾아라&lt;/li&gt;
  &lt;li&gt;정점 커버: 무방향 그래프에서 각 간선의 양쪽 끝의 두 정점들 중에서 적어도 1개의 정점을 포함하는 정점들의 집합&lt;/li&gt;
  &lt;li&gt;예: 아래 그래프에서 최소 크기의 정점 커버 C = {a,c,e}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/ag/ag17.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;부분 집합의 합 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;정수들의 집합 S의 요소들의 합이 K가 되는 S의 부분 집합을 찾아라.&lt;/li&gt;
  &lt;li&gt;예: S = {10,20,40,70,80}, K = 160
    &lt;ul&gt;
      &lt;li&gt;부분 집합{10,70,80}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;그래프 색칠하기 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무방향 그래프에서 인접한 정점들을 서로 다른색으로 가장 적은 수의 색을 사용하여 색칠하라&lt;/li&gt;
  &lt;li&gt;예: 아래 그래프에서 a,c: 빨강, b,d: 초록, e: 파랑&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/ag/ag18.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">NP-완전</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">탐욕 기법</title>
      <link href="https://lee989898.github.io/algorithm-05" rel="alternate" type="text/html" title="탐욕 기법" />
      <published>2021-10-26T01:09:00+09:00</published>
      <updated>2021-10-26T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-05</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-05">&lt;h3 id=&quot;탐욕-기법&quot;&gt;&lt;strong&gt;탐욕 기법&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;탐욕 기법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;매 번 선택할 때 마다 그 순간에 좋은 선택을 함으로써 최종적인 해에 도달한다.&lt;/li&gt;
  &lt;li&gt;최적인 해들을 모아서 최종 해를 만들었다고 해서, 그 해가 궁극 적으로 최적이라는 보장이 없다.&lt;/li&gt;
  &lt;li&gt;따라서 탐욕 기법은 항상 최적의 해를 만들어내는 지를 반드시 검증해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;선택 기준&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;선택이 실현 가능해야 한다.&lt;/li&gt;
  &lt;li&gt;모든 선택들 중에서 최적이라고 여겨지는 선택을 해야 한다.&lt;/li&gt;
  &lt;li&gt;한 번 선택하면 나중에 되돌릴 수 없다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;설계 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;비어 있는 해 모음으로 시작한다.&lt;/li&gt;
  &lt;li&gt;탐욕적인 기준에 따라 해 모음에 추가할 다음 해를 선택한다.&lt;/li&gt;
  &lt;li&gt;새 해 모음이 실형 가능한지를 확인한다.
실현 가능하다면 새 해 모음을 확정하고 아니면 선택한 해를 버린다.&lt;/li&gt;
  &lt;li&gt;새 해 모음이 최종 해라면 종료한다. 아니면 2번으로 간다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;거스름돈 주기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;거스름돈을 동전들의 수가 최소가 되도록 주어야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;액면가가 다른 m(&amp;gt;=1)개의 동전들이 있다.&lt;/li&gt;
  &lt;li&gt;동전 i,1&amp;lt;=i&amp;lt;=m,의 액면가는 $d_i$ 이고 $d_1$ &amp;gt; 
$d_2$ &amp;gt; … &amp;gt; $d_m$ = 1이다.&lt;/li&gt;
  &lt;li&gt;액면가가 같은 동전들의 개수는 무한히 많이 있다.&lt;/li&gt;
  &lt;li&gt;거스름돈 n(&amp;gt;=1)을 최소 개수의 동전들을 사용하여 주어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;탐욕 알고리즘의 아이디어&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;주어야 할 거스름돈이 남아 있는 동안 다음을 반복한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;남은 동전들 중 액면가가 가장 큰 동전을 선택한다.&lt;/li&gt;
  &lt;li&gt;선택한 동전을 거스름돈에 추가하면 거스름돈이 주어야 할 금액을 
초과한다면 그 동전을 버린다. 아니면 그 동전을 거스름돈에 추가하고 주어야 할 거스름돈을 추가한 동전의 액면가만큼 감소시킨다.&lt;br /&gt;
주: 최적의 알고리즘&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;탐욕적인 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;coinChange(d[],m,n)
//거스름돈에 포함되는 동전들의 수를 최소화한다.&lt;br /&gt;
//입력: m - 액면가가 다른 동전들의 수&lt;br /&gt;
//     d[1..m] - 동전들의 액면가를 저장하는 배열&lt;br /&gt;
//     n - 거스름돈&lt;br /&gt;
//출력(반환 값): 거스름돈에 포함된 동전들의 최소 개수&lt;br /&gt;
1  count = 0&lt;br /&gt;
2  i = 1&lt;br /&gt;
3  while(n &amp;gt; 0 &amp;amp;&amp;amp; i &amp;lt;=m){&lt;br /&gt;
4    count = count + $\frac{n}{d[i]}$ 　//가치가 가장 큰 동전들을 최대한 많이 선택&lt;br /&gt;
5    n = n mod d[i] 　　　 //남은 거스름돈을 계산&lt;br /&gt;
6    i = i + 1 　　　　　　 //다음으로 가치가 큰 동전을 선택&lt;br /&gt;
    }&lt;br /&gt;
7  return count&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;시간 복잡도&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;입력의 크기: m(액면가가 다른 동전들의 수)&lt;/li&gt;
  &lt;li&gt;기본 연산: 4번의 배정문&lt;/li&gt;
  &lt;li&gt;기본 연산의 수행 횟수: 최대 m&lt;/li&gt;
  &lt;li&gt;시간 복잡도: m = $\theta$(m)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;최소 비용 신장 트리 찾기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;n(&amp;gt;1)개의 도시들을 최소한의 비용으로 연결하는 철도망을 새로 구축하려고 한다.&lt;/li&gt;
  &lt;li&gt;모든 도시들을 서로 연결하기 위해 도시간 철도를 최소한(n-1)개 깔아야 한다.&lt;/li&gt;
  &lt;li&gt;각 철도는 두 도시를 연결한다.&lt;/li&gt;
  &lt;li&gt;이 철도망들 중에서 철도 노선들의 총 길이가 최소가 되도록 철도망을 구축해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;최소 비용 신장 트리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;신장트리: 연결된, 무방향 그래프 안에 있는 모든 정점을 다 포함하면서 트리가 되는 연결된 부분 그래프&lt;/li&gt;
  &lt;li&gt;산장트리는 순환을 포함하지 않으며 그래프 안에 있는 모든 정점들을 연결시칸다.&lt;/li&gt;
  &lt;li&gt;신장트리의 가중치: 모든 간선들의 가중치들의 합&lt;/li&gt;
  &lt;li&gt;최소 비용 신장 트리: 최소 가중치를 가진 신장트리&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag12.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;억지 기법 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;모든 신장 트리를 찾은 후 그 중에서 최소 비용 신장 트리를 선택한다.&lt;/li&gt;
  &lt;li&gt;시간 복잡도 분석
    &lt;ul&gt;
      &lt;li&gt;최악의 경우, 지수 시간보다도 나쁘다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;탐욕적인 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;신장 트리에 추가할 최선의 간선들을 반복적으로 한 번에 하나씩 선택한다. 선택 시점에서 추가할 최선의 간선을 쉽게 알 수 있다고 가정한다.&lt;/li&gt;
  &lt;li&gt;(n-1)개의 간선들이 신장 트리에 포함된다면 종료한다.&lt;/li&gt;
  &lt;li&gt;한 간선이 선택되면 그 간선의 정점들을 합친다.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;적절한 이유&lt;br /&gt;
정점 a와 b가 연결된다면 정점a에 연결하는 것은 정점 b에 연결하는 것과 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;명제. n(&amp;gt;0)개의 정점들을 가진 그래프 G는 (n-1)개의 간선들을 가지고 순환이 없으면 트리이다. 또한 G가 트리이면 (n-1)개의 간선들이 있고 비순환 그래프이다.&lt;/p&gt;

&lt;p&gt;정리. 간선 e가 정점 v에 접합한 가장 가중치가 작은 간선이라면 e를 포함하는 최소 비용 신장 트리가 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;최소 비용 신장트리 찾기 - 정점지향 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;처음 시작할 때 한 정점 $v_0$를 선택한다.&lt;/li&gt;
  &lt;li&gt;$v_0$ 에서 나가는 가장 가중치가 작은 간선 ($v_0$, x)를 선택한다. 그 간선을 최소 비용 신장 트리 T에 추가하고 $v_0$와 x를 합친다. 모든 정점이 T에 포함될 때까지 이 과정을 반복한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;프림 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;적색 정점: 처음에 선택된 정점 $v_0$와 합쳐진 정점&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;청색 정점: 그 외 다른 정점&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;아이디어&lt;br /&gt;
다음을 (n-1)번 반복한다:
    &lt;ol&gt;
      &lt;li&gt;한 적색 정점과 한 청색 정점을 연결하는 가장 가중치가 작은 간선을 선택한다.&lt;/li&gt;
      &lt;li&gt;선택된 간선의 청색 정점을 적색으로 바꾸고 그 간선을 트리에 추가한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;그래프의 표현: 비용 행렬 W&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;R: 적색 정점들의 집합, B: 청색 정점들의 집합&lt;br /&gt;
V: 그래프내의 모든 정점들의 집합&lt;br /&gt;
T: 트리 내에 포함되는 간선들의 집합&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;  R = {$v_0$}&lt;/li&gt;
  &lt;li&gt;  B = V - {$v_0$}&lt;/li&gt;
  &lt;li&gt; T = $\emptyset${공집합}&lt;/li&gt;
  &lt;li&gt; for(i = 1; i &amp;lt; n; i++) {&lt;/li&gt;
  &lt;li&gt; 　　w[ r,b ]가 최소인 $r \in R$과 $b \in B$를 선택한다.&lt;/li&gt;
  &lt;li&gt; 　　T = T U {(r,b)}　　// 간선 (r,b)를 트리에 추가한다.&lt;/li&gt;
  &lt;li&gt; 　　B = B - {b}&lt;/li&gt;
  &lt;li&gt; 　　R = R U {b}　　　//정점 b를 적색으로 바꾼다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;명확하게 청색 정점의 관점을 취해야 한다. 단순히 어느 적색 정점이 자신에게 가장 가까운지만 기억한다. 이는 한 정점이 적색이 될 때 쉽게 갱신될 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;시간 복잡도&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 알고리즘은 중복 계산을 많이 한다. 매번 반복할 때마다 최소 간선을 거의 같은 집합에서 찾는다.&lt;br /&gt;
$\theta$($n^3$)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;개선된 프림 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;near[0 .. n - 1]: 각 청색 정점에 가장 가까운 적생 정점을 저장하는 배열&lt;br /&gt;
isblue[0 .. n - 1]: 각 정점이 청색이면 true를 아니면 false를 저장하는 배열&lt;br /&gt;
T: 트리 내에 포함되는 간선들의 집합&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt; isblue[0] = false 　　　　//정점 0은 적색이다&lt;/li&gt;
  &lt;li&gt; T = $\emptyset$&lt;/li&gt;
  &lt;li&gt; for(i = 1; i &amp;lt; n; i++){&lt;/li&gt;
  &lt;li&gt; 　　isblue[i] = true 　　　　//다른 정점들은 청색이다&lt;/li&gt;
  &lt;li&gt; 　　near[i] = 0 } 　　　　　 // 가장 가까운 적색 정점은 0이다&lt;/li&gt;
  &lt;li&gt; for(i = 1; i &amp;lt; n; i++){&lt;/li&gt;
  &lt;li&gt; 　　minval = $\infty$&lt;/li&gt;
  &lt;li&gt; 　　for(b = 0; b &amp;lt; n; b++)　//적색 정점들에 가장 가까운 청색 정점을 찾는다&lt;/li&gt;
  &lt;li&gt; 　　　if(isblue[b] &amp;amp;&amp;amp; W[b,near[b]]&amp;lt; minval){&lt;/li&gt;
  &lt;li&gt; 　　　　minval = W[b,near[b]]&lt;/li&gt;
  &lt;li&gt; 　　　　newred = b }&lt;/li&gt;
  &lt;li&gt; 　isblue[newred] = fasle 　　　//정점 newred를 적색으로 바꾼다&lt;/li&gt;
  &lt;li&gt; 　T = T $\cup$ { (newred, near[newred])}　//가장 가중치가 작은 간선을 T에 추가한다&lt;/li&gt;
  &lt;li&gt; 　for(b = 0; b &amp;lt; n; b++)&lt;/li&gt;
  &lt;li&gt; 　　　if(isblue[b] &amp;amp;&amp;amp; W[b,newred] &amp;lt; W[b,near[b]])near[b] = newred&lt;br /&gt;
　　}&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;시간 복잡도&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;입력 크기: n(정점들의 수)&lt;/li&gt;
  &lt;li&gt;기본 연산: isblue의 요소들에 대한 참조 횟수&lt;/li&gt;
  &lt;li&gt;참조 횟수
    &lt;ul&gt;
      &lt;li&gt;각 i, 1&amp;lt;= i &amp;lt; n, 에 대해 항상 n이다.&lt;/li&gt;
      &lt;li&gt;따라서 총 참조 횟수 = (n-1) x n $\in$ $\theta$($n^2$)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;최소 비용 신장 트리 찾기 - 간선 지향 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;그래프에 남아 있는 가장 가중치가 작은 간선을 선택한다.&lt;/li&gt;
  &lt;li&gt;선택된 간선이 합쳐진 두 개의 정덤들 사이에 있다면 그 간선을 버리고 아니면 최소 비용 신장 트리에 추가한다.&lt;/li&gt;
  &lt;li&gt;(n - 1)개의 간선들이 추가될 때까지 과정 1과 2를 반복한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;크루스칼 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;//e: 간선들의 수&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;  간선들을 가중치 순서로 오름차순으로 정렬하여 배열 EDGELIST[1 .. e]에 저장한다&lt;/li&gt;
  &lt;li&gt;  T = $\emptyset$&lt;/li&gt;
  &lt;li&gt;  ecount = 0  　 　 　 　//최소 비용 신장 트리에 추가된 간선들의 수&lt;/li&gt;
  &lt;li&gt;  k = 0  　 　 　 　 　 　 　//처리된 간선들의 수&lt;/li&gt;
  &lt;li&gt;  while (ecount &amp;lt; n - 1){&lt;/li&gt;
  &lt;li&gt;  　k = k + 1&lt;/li&gt;
  &lt;li&gt;  　(v, w) = EDGELIST[k]&lt;/li&gt;
  &lt;li&gt;  　if(! together(v,w)){&lt;/li&gt;
  &lt;li&gt;  　　T = T U {(v,W)}&lt;/li&gt;
  &lt;li&gt;  　　v와 w를 합친다&lt;/li&gt;
  &lt;li&gt;  　  ecount = ecount + 1 }&lt;br /&gt;
} &lt;br /&gt;
주: together(v,w) : v와 w가 이미 합쳐졌으면 true이다.&lt;br /&gt;
분삭: (n-1)번의 통합과 최대 e번의 together를 수행한다.&lt;br /&gt;
정렬시간 = $\theta$( e log e)&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;단일 출발점 최단 경로 찾기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;연결된 가중 그래프에서 한 특정 정점에서 다른 모든 정점으로 가는 최단 경로를 찾아라.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;다익스트라 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;아이디어: 출방 정점 $v_0$로 부터 가까운 순서로 다른 정점들까지의 최단 경로를 찾는다.&lt;/li&gt;
  &lt;li&gt;진행 과정
    &lt;ul&gt;
      &lt;li&gt;i번째 반복이 시작되기 전에 $v_0$에 가장 가까운 (i - 1)개의 정점들까지의 최단 경로들을 찾았다.&lt;/li&gt;
      &lt;li&gt;$v_0$, 이 정점들과 최단 경로들 상의 간선들은 주어진 그래프의 부분 트리 $T_i$를 형성한다.&lt;/li&gt;
      &lt;li&gt;$T_i$내에 있는 정덤들에 인접한 ‘가장자리 정점’들 중에서 찾는다.&lt;/li&gt;
      &lt;li&gt;$T_i$내에 있는 정점들에 인접한 ‘가장자리 정접’들 중에서 찾는다.&lt;/li&gt;
      &lt;li&gt;모든 가장자리 정점 u에 대해서 u에 인접한 트리내의 정점 v까지의 거리, W(u,v)와 출발 정점에서 v까지의 최단 경로의 길이, $d_v$의 합을 계산한다.&lt;/li&gt;
      &lt;li&gt;u에 인접한 트리 내의 정점들이 2개 이상인 경우에는 각 인접 정점에 대해 합을 계산한다. 그러한 합들 중 가장 작은 합을 갖는 가장자리 정점을 트리에 추가할 다음 정점으로 선택한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag13.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 트리 $T_i$이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;n( &amp;gt; 0): 정점들의 수&lt;/li&gt;
  &lt;li&gt;i, 0 &amp;lt;= i &amp;lt; n: 정덤의 번호&lt;/li&gt;
  &lt;li&gt;출발 정점: 0&lt;/li&gt;
  &lt;li&gt;정점 i에 d[i]와 p[i]를 저장한다.
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;d[i]: 출발 정점에서 각 정점까지의 최단 겅로의 거리
  d[0] = 0&lt;br /&gt;
  d[i] = $\infty$ ,i는 최단 경로 트리 내에 포함되지 않은 정점&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;p[i]: 출발 정점에서 각 정점까지의 최단 경로 상의 마지막에서 두 번째 정점(트리에서 부모 노드)의 번호&lt;br /&gt;
  i = 0혹은 트리안에 포함되지 않은 정점이면 p[i] = -1&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;주어진 그래프는 인접 행렬 w로 나타낸다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;트리에 추가할 정점 $u^*$를 선택한 후의 연산&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;$u^*$를 가장자리 정점에서 트리내에 포함되는 정점으로 바꾼다.&lt;/li&gt;
  &lt;li&gt;$u^&lt;em&gt;$에 인접한 트리에 포함되지 않은 각 가장자리 정점 v에 대해 다음 조건을 확인한다.&lt;br /&gt;
d[$u^&lt;/em&gt;$]  + w($u^&lt;em&gt;$ ,v) &amp;lt; d[v]&lt;br /&gt;
위 조건이 만족된다면 다음을 수행한다&lt;br /&gt;
d[v] = d[$u^&lt;/em&gt;$] + w($u^&lt;em&gt;$, v)&lt;br /&gt;
p[v] = $u^&lt;/em&gt;$&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;다익스트라 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;  T = $\emptyset$    //트리에 포함된 정점들의 집합을 공집합으로 초기화한다&lt;/li&gt;
  &lt;li&gt;  for( i = 0; i &amp;lt; n; i++){&lt;/li&gt;
  &lt;li&gt;  d[i] = $\infty$    //정점 i의 최단 거리를 $\infty$ 로 초기화 한다&lt;/li&gt;
  &lt;li&gt;  p[i] = -1 }    //정점 i의 부모 노드를 -1(없음)으로 초기화한다&lt;/li&gt;
  &lt;li&gt;  d[0] = 0    //출발 정점 0의 최단 거리를 0으로 한다&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;  while(&lt;/td&gt;
          &lt;td&gt;T&lt;/td&gt;
          &lt;td&gt;&amp;lt; n){}&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;  T에 포함되지 않은 정점들 중에서 배열 d의 요소값이 가장 작은 정점 u를 선택한다&lt;/li&gt;
  &lt;li&gt;  T = T U { u}    //선택된 정점을 트리에 추가한다&lt;br /&gt;
// 트리에 새로 추가된 정점의 인접 정점들의 출발 정점으로부터 최단 거리를 갱신한다&lt;/li&gt;
  &lt;li&gt;  for( v = 0; v &amp;lt; n; v++)&lt;/li&gt;
  &lt;li&gt;  if(v $\notin$ T and w[u,v]  0 and d[u] &amp;lt; $\infty$ and d[u] + w[u,v] &amp;lt; d[v] ){&lt;/li&gt;
  &lt;li&gt;  d[v] = d[u] + w[u,v]&lt;/li&gt;
  &lt;li&gt;   p[v] = u }&lt;br /&gt;
}&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;시간복잡도&lt;br /&gt;
    +  기본 연산: 10번 조건 확인
    +  9 ~ 12번의 반복문내에서 기본 연산의 수행 횟수 = n
    +  트리에 모든 정점이 포함되어야 하므로 $\theta$($n^2$)&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">탐욕 기법</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">동적 계획</title>
      <link href="https://lee989898.github.io/algorithm-04" rel="alternate" type="text/html" title="동적 계획" />
      <published>2021-10-05T01:09:00+09:00</published>
      <updated>2021-10-05T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-04</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-04">&lt;h3 id=&quot;동적-계획&quot;&gt;&lt;strong&gt;동적 계획&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;분할 정복과 같이 주어진 문제를 더 작은 부분 문제들로
나눈 후 부분 문제들의 해들을 합병하여 해결한다.&lt;/li&gt;
  &lt;li&gt;분할 정복과 달리 부분 문제들이 서로 겹친다.&lt;/li&gt;
  &lt;li&gt;많은 해들 중 최적의 해를 찾는 최적화 문제에 적용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag07.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 분할 정복과 동적 계획의 분할 과정의 예이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;동적 계획 전략&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;문제를 더 작은 부분 문제들로 분할한다.&lt;/li&gt;
  &lt;li&gt;작은 부분 문제들을 해결하고 해들을 표에 저장한다.&lt;/li&gt;
  &lt;li&gt;나중에 다른 (부분) 문제를 해결할 때 이미 해결한 부분 문제가 나오면
다시 해결하는 대신에 표에서 해를 찾아 사용한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;막대-자르기&quot;&gt;&lt;strong&gt;막대 자르기&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;막대의 길이는 n(양의 정수)이다.&lt;/li&gt;
  &lt;li&gt;막대의 길이가 i(양의 정수), 1 &amp;lt;= i &amp;lt;= n-1,인 조각막대로 자를 수 있다.&lt;/li&gt;
  &lt;li&gt;길이가 i, 1 &amp;lt;= i &amp;lt;= n, 인 (조각) 막대의 판매 가격은 $p_i$이다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;길이가 n인 막대를 여러 개의 양의 정수 길이의 조각 막대들로
잘라서 판매할 때 얻을 수 있는 최대 판매 금액을 구해야 한다.
물론 막대를 자르지 않고 통째로 팔 수도 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;억기 기법 알고리즘
    &lt;ol&gt;
      &lt;li&gt;막대를 자르는 모든 경우들을 찾아낸다.&lt;/li&gt;
      &lt;li&gt;각 경우에서 얻을 수 있는 판매 금액을 계산한 후 그 중 최대 판매
금액을 구한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag08.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 막대를 자르는 모든 방법들과 판매 금액이다.&lt;/p&gt;

&lt;p&gt;시간 복잡도: $\theta$($2^n$)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;분할 정복 알고리즘
    &lt;ol&gt;
      &lt;li&gt;길이가 n인 막대를 처음에 길이 i, 1&amp;lt;=i&amp;lt;=n-1, 인 막대와 
길이 (n-i)인 막대로 자른다.&lt;/li&gt;
      &lt;li&gt;길이 i인 막대는 그대로 팔고 길이 (n-i)인 막대는 최대 판매 금액을
얻을 수 있도록 통째로 팔거나 여러 개의 양의 정수 길이의 조각 막대들로 
잘라서 판다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;R(n): 길이가 n인 막대를 판매할 때 얻을 수 있는 최대 판매금액&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;R(n) = MAX($p_i$, R(n-i))
          1 &amp;lt;= i &amp;lt;= n
       R(0) = 0&lt;br /&gt;
$p_i$: 길이가 i인 막대의 판매 가격&lt;br /&gt;
R(n-i): 길이 (n - i)의 막대를 판매할 때 얻을 수 있는 최대 판매 금액&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cutRod_DC(p[], i)
//길이 i의 막대를 판매할 때 얻을 수 있는 최대 판매 금액, R[i]를 계산한다.
//입력: p[i..n] - 막대들의 판매 가격
        i - 막대의 길이
//출력(반환값): 최대 판매 금액
if(i = 0) return 0
else{
      maxSell = 0
      for(j = 1; j &amp;lt;= i; j++)
          maxSell = MAX(maxSell, p[j] + cutRod_DC(p,i-j))
      return maxSell
}
최초 호출 maxSellValue = cutRod_DC(p,n)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag09.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 cutRod_DC(p,4) 호출시 실행 트리 이다.&lt;/p&gt;

&lt;p&gt;시간 복잡도: $\theta$($2^n$)&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;동적 계획 알고리즘 설계 과정&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; cutRod_DP(p[], n)
 // 길이 n의 막대를 판매할 때 얻을 수 있는 최대 판매 금액을 계산
 // 입력: p[1 .. n] - 막대들의 판매 가격, n: 막대의 길이
 // 출력(반환값): 최대 판매 금액
 배열 maxSell[0 .. n]을 선언한다.
 maxSell[0] = 0
 for(j = 1; j&amp;lt;=n; j++){
      maxVal = 0
      for(k = 1; k &amp;lt;= j; k++)
          maxVal = MAX(maxVal, p[k] + maxSell[j - k])
      maxSell[j] = maxVal
  }
  return maxSell[n]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;시간복잡도: $\theta$($n^2$)&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;모든-쌍-최단-경로-찾기&quot;&gt;&lt;strong&gt;모든 쌍 최단 경로 찾기&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag10.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 한 그래프 내의 각 정점에서 모든 다른 정점으로 가는 가장 
짧은 경로를 찾는 문제이다.&lt;/p&gt;

&lt;p&gt;가중치를 포함한 방향(혹은 무방향)그래프 G = (V,E)가 주어지면 
각 정점에서 모든 다른 정점으로 가는 최단 경로의 거리를 찾아라.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;경로의 거리 = 경로 상의 모든 간선의 가중치들의 합&lt;/li&gt;
  &lt;li&gt;정점들의 수 = n&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정점들을 각각 1,2,3, …., n으로 나타낸다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;동적 계획 Floyd 알고리즘&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;문제: 행렬 W가 주어지면 최단 거리 행령 D를 구한다.
주 아이디어&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;최단 경로들을 단계적으로 만든다.&lt;/li&gt;
  &lt;li&gt;최단 경로들을 경유 가능한 정점들의 집합 L을 이용하여 만든다.
최단 경로는 L 내에 있는 정점(들)만을 이용한다.&lt;/li&gt;
  &lt;li&gt;L에 정점들을 한 번에 하나씩 정점의 번호 순서대로 추가한다.&lt;/li&gt;
  &lt;li&gt;최단 거리 행렬들을 다음과 같은 순서대로 계산한다.
     $D_0$,$D_1$,$D_2$, …, $D_n$&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag11.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 Floyd 알고리즘 예이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Floyd 알고리즘&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;AllPairShortestPath(W[])
//입력: 가중치 행렬 W [1..n, 1..n]
//출력: $D^(i)$ [1..n, 1..n], 0&amp;lt;=i&amp;lt;=n&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;   $D^0$ = W&lt;/li&gt;
  &lt;li&gt;   for(k = 1; k &amp;lt;= n; k++){&lt;/li&gt;
  &lt;li&gt;       n x n 행렬 $D^(k)$ = (d&lt;sub&gt;ij&lt;/sub&gt;&lt;sup&gt;(k)&lt;/sup&gt;)를 선언한다&lt;/li&gt;
  &lt;li&gt;       for(i = 1; i &amp;lt;= n; i++)&lt;/li&gt;
  &lt;li&gt;         for(j = 1; j &amp;lt;=n; j++)&lt;/li&gt;
  &lt;li&gt;           d&lt;sub&gt;ij&lt;/sub&gt;&lt;sup&gt;(k)&lt;/sup&gt; = MIN(d&lt;sub&gt;ij&lt;/sub&gt;&lt;sup&gt;(k-1)&lt;/sup&gt;,d&lt;sub&gt;i,k&lt;/sub&gt;&lt;sup&gt;(k-1)&lt;/sup&gt;+d&lt;sub&gt;k,j&lt;/sub&gt;&lt;sup&gt;(k-1)&lt;/sup&gt;
    }&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">동적 계획</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">분할 정복</title>
      <link href="https://lee989898.github.io/algorithm-03" rel="alternate" type="text/html" title="분할 정복" />
      <published>2021-09-21T01:09:00+09:00</published>
      <updated>2021-09-21T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-03</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-03">&lt;h3 id=&quot;분할-정복&quot;&gt;&lt;strong&gt;분할 정복&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;분할 정복 설계 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;분할 단계
    &lt;ul&gt;
      &lt;li&gt;문제를 같은 유형의 여러 개의 더 작은 부분 문제들로 나눈다.&lt;/li&gt;
      &lt;li&gt;부분 문제는 풀기 쉬울 때까지 계속 나눈다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정복 단계
    &lt;ul&gt;
      &lt;li&gt;부분 문제들을 보통 재귀적으로 해결하여 해를 구한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;합병 단계
    &lt;ul&gt;
      &lt;li&gt;문제에 대한 해를 구하기 위해 부분 문제들의 해를 합친다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;최댓값과-최솟값-찾기&quot;&gt;&lt;strong&gt;최댓값과 최솟값 찾기&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;문제: 크기가 n인 배열내의 요소들 중 최댓값과 최솟값을 찾는다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;쉬운 전략
    &lt;ol&gt;
      &lt;li&gt;최댓값을 찾는다&lt;/li&gt;
      &lt;li&gt;남은 배열 요소들의 최솟값을 찾는다&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;총 비교 횟수 = 2n - 3&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;분할 정복 전략
    &lt;ol&gt;
      &lt;li&gt;배열을 반으로 나눈다.&lt;/li&gt;
      &lt;li&gt;양쪽 절반들의 최댓값과 최솟값을 찾는다.&lt;/li&gt;
      &lt;li&gt;2에서 찾은 두개의 최댓값들과 두 개의
최솟값들을 비교하여 전체 배열의 최댓값과 최솟값을 구한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;의사코드&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;findMaxMin(A[],i,j,min,max)
// A[i..j]의 최댓값과 최솟값을 찾는다
// 입력: 배열 A[i..j]
// 출력: min(최솟값), max(최댓값)
1. if(i == j) { min = A[i]; max = A[j]}
2. else if(i = j - 1){
3.     if(A[i] &amp;lt; A[j]){
          min = A[i]; max = A[j]}
4.     else{ min = A[j]; max = A[i])}
   }
5. else{
6. mid = (i+j)/2
7. findMaxMin(A,i,mid,min1,max1)
8. findMaxMin(A,mid+1,j,min2,max2)
9. if(min1 &amp;lt; min2) min = min1
10.else min = min2
11.if(max1 &amp;lt; max2) max = max2
12.else max = max1
최초 호출: findMaxMin(A,0,n-1,min,max)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag04.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 실행 트리이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;합병-정렬&quot;&gt;&lt;strong&gt;합병 정렬&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;쉬운 전략
    &lt;ol&gt;
      &lt;li&gt;최솟값을 찾는다.&lt;/li&gt;
      &lt;li&gt;남은 요소들을 같은 방법을 사용하여 재귀적으로 정렬한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;총 비교횟수 $\theta$(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;분할 정복 전략
    &lt;ol&gt;
      &lt;li&gt;배열을 반으로 나눈다.&lt;/li&gt;
      &lt;li&gt;왼쪽 반과 오른쪽 반을 각각 정렬한다.&lt;/li&gt;
      &lt;li&gt;정렬된 왼쪽 반과 오른쪽 반을 합병한다..&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag05.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 합병 정렬의 진행 과정이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;합병 정렬 알고리즘&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;알고리즘 mergeSort(A[], low, high)
// 배열 A[low .. high]를 합병 정렬을 이용하여 정렬한다.
if(low &amp;lt; high){
      mid = (low+high)/2
      mergeSort(A,low,mid)
      mergeSort(A,mid+1,high)
      merge(A,low,mid,high)
}
최초 호출: mergeSort(A,0,n-1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Merge 메소드&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//정렬된 부분 배열 A[low .. mid]와 A[mid+1 .. high]를 합병한다.
MERGE(A[],low,mid,high){
  크기가 (high + 1)인 배열 B를 만든다
  h = low; i = low; j = mid + 1
  while(i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;=high){
      if(A[i] &amp;lt;= A[j] { B[h] = A[i]; i = i + 1}
      else{B[h] = A[j]; j = j + 1}
      h = h + 1
  }
  if( i &amp;gt; mid)
      for(k = j; k &amp;lt;= high; k++) { B[h] = A[k]; h = h + 1}
  else
      for(k = i; k &amp;lt;= mid; k++) {B[h] = A[k]; h = h + 1}
  for(k = low; k &amp;lt;= high; k++) A[k] = B[k];
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;시간 복잡도 $\theta$(n $log n$)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;비재귀 합병 정렬 알고리즘&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mergeSort2(A[], n)
//배열 A[0 .. n-1]를 비재귀 합병 정렬을 이용하여 정렬
size = 1
while(size &amp;lt; n){
  for(i = 0; i &amp;lt; n; i = i + 2*size)
      Merge(A,i,i+size-1,i+2*size-1)
  size = size * 2
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;합병 정렬의 단점&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;합병 정렬의 공간 복잡도: $\theta$(n)&lt;/li&gt;
  &lt;li&gt;입력을 위한 메모리 공간 외에 추가로 입력과 같은 크기의 공간이 별도로 필요&lt;/li&gt;
  &lt;li&gt;2개의 정렬된 부분을 하나로 합병하기 위해 합병된 결과를 저장할 공간이 필요하기 때문이다&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;빠른-정렬&quot;&gt;&lt;strong&gt;빠른 정렬&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;절대적으로 가장 빠른 정렬 알고리즘은 아니지만 평균적으로 매우 효율적이다&lt;/p&gt;

&lt;p&gt;평균 시간복잡도: $\theta$(n $log n$)&lt;/p&gt;

&lt;p&gt;최악 시간복잡도: $\theta$(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기본 아이디어&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;배열을 두 부분으로 분할한다.
    &lt;ul&gt;
      &lt;li&gt;배열내의 한 기준 요소보다 작거나 같은 요소들은 앞부분에 놓는다.&lt;/li&gt;
      &lt;li&gt;기준 요소보다 큰 요소들은 모두 뒷부분에 놓는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;각 분할된 부분을 재귀적으로 정렬한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag06.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 빠른 정렬의 진행과정이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;빠른 정렬 알고리즘&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;quickSort(A[], low, high)
// 배열: A[low .. high]를 빠른 정렬을 이용하여 정렬한다.
// 입력: 정렬할 수 있는 요소들의 배열 A[low .. high]
// 출력: 오름차순으로 정렬된 요소돌의 배열 A[low .. high]
if(low &amp;lt; high){
      s = partition(A,low,high) // 기준 요소 A[low]를 기준으로 분할
      quickSort(A,low,s-1)
      quickSort(A,s+1,high)
 }
 //최초 호출: quickSort(A,0,n-1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;분할 알고리즘&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;partition(A[], low, high)
//입력: 배열 A[0 .. n-1]의 부분 배열 A[low .. high], low &amp;lt; high
//출력: A[low .. high]의 분할 후 기준 요소의 최종 위치(지수)를 반환
i = low + 1
j = high
while( i &amp;lt;= j){
      if(A[i] &amp;lt;= A[low]) i = i + 1
      else if( A[j] &amp;gt; A[low]) j = j -1
      else { A[i] &amp;lt;-&amp;gt; A[j]
              i = i + 1
              j = j - 1
      }
 }
 A[low] &amp;lt;-&amp;gt; A[j]
 return j
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;분할-정복이-부적절한-경우&quot;&gt;&lt;strong&gt;분할 정복이 부적절한 경우&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;문제가 분할될 때만다 분할된 부분 문제들의 입력 크기의 합이 분할되기 전의 입력
크기보다 매우 커지는 경우&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">분할 정복</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">알고리즘의 효율성 분석</title>
      <link href="https://lee989898.github.io/algorithm-02" rel="alternate" type="text/html" title="알고리즘의 효율성 분석" />
      <published>2021-09-14T01:09:00+09:00</published>
      <updated>2021-09-14T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-02</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-02">&lt;h3 id=&quot;알고리즘-분석-체계&quot;&gt;&lt;strong&gt;알고리즘 분석 체계&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;입력 크기&lt;br /&gt;
ex) 배열의 크기, 연결 목록의 길이, 행렬에서 행과 열의 크기, 그래프에서 정점과 간선의 수&lt;/li&gt;
  &lt;li&gt;실행 시간 측정 단위
    &lt;ul&gt;
      &lt;li&gt;기본 연산: 알고리즘의 실행 시간에 가장 많이 기여하는 연산&lt;/li&gt;
      &lt;li&gt;실행 시간은 입력 크기가 작으면 거의 차이가 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;증가 차수
    &lt;ul&gt;
      &lt;li&gt;시간 복잡도 함수의 입력 크기(N)에 따른 증가율
        &lt;ul&gt;
          &lt;li&gt;로그 함수: N의 값이 4배 증가할 때 2만큼 증가&lt;/li&gt;
          &lt;li&gt;1차 선형 함수: N의 값에 비례하여 증가&lt;/li&gt;
          &lt;li&gt;2차 선형 함수: N의 값이 4배 증가할 때 16배 증가&lt;/li&gt;
          &lt;li&gt;지수 함수: N의 값이 4배 증가할 때 2의 4 제곱배 증가&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;시간-복잡도&quot;&gt;&lt;strong&gt;시간 복잡도&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;공간 복잡도: 알고리즘이 수행되는 동안 요구되는 메모리 공간의 크기를 나타낸다.&lt;/p&gt;

&lt;p&gt;시간 복잡도: 알고리즘이 얼마나 빨리 수행되는지를 나타낸다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;알고리즘의 기본 연산의 수행 횟수를 입력 크기의 함수로 표현&lt;/li&gt;
  &lt;li&gt;입력 크기뿐만이 아니라 특정 입력 값에도 좌우&lt;/li&gt;
  &lt;li&gt;복잡도는 입력 크기인 N의 함수로 나타낸다&lt;/li&gt;
  &lt;li&gt;복잡도 함수는 보통 여러 개의 항들을 갖는 다항식이다.&lt;/li&gt;
  &lt;li&gt;고차 항이 시간복잡도를 궁극적으로 지배한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;시간 복잡도의 분류&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;최악 경우 시간 복잡도
    &lt;ul&gt;
      &lt;li&gt;모든 입력에 대해서 기본 연산이 수행되는 최대 횟수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최선 경우 시간 복잡도
    &lt;ul&gt;
      &lt;li&gt;모든 입력에 대해서 기본 연산이 수행되는 최소 횟수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;평균 경우 시간 복잡도
    &lt;ul&gt;
      &lt;li&gt;모든 입력에 대해서 기본 연산이 수행되는 평균 횟수&lt;/li&gt;
      &lt;li&gt;일반적으로 최악 경우보다 구하기가 어려움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;복잡도를 간단한 함수로 표현하기 위해 점근적 표기 사용&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;O(Big O)-표기: 점근적 상한​&lt;/li&gt;
  &lt;li&gt;Ω(Big Ω)-표기: 점근적 하한​&lt;/li&gt;
  &lt;li&gt;$\theta$(Big $\theta$)-표기: 점근적 상한이면서 점근적 하한​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag03.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 주요 복잡도 함수의 증가율이다.&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">알고리즘 분석 체계</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">알고리즘</title>
      <link href="https://lee989898.github.io/algorithm-01" rel="alternate" type="text/html" title="알고리즘" />
      <published>2021-09-02T01:09:00+09:00</published>
      <updated>2021-09-02T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-01</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-01">&lt;h3 id=&quot;알고리즘&quot;&gt;&lt;strong&gt;알고리즘&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;문제를 해결하기 위한 단계적 절차 또는 방법&lt;/li&gt;
  &lt;li&gt;순서대로 구체적이고 명확하게 기술해야 함&lt;/li&gt;
  &lt;li&gt;유효한 입력을 받아 실행한 결과인 해(답)를 출력&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag01.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;알고리즘의 3가지 조건&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;명확성
    &lt;ul&gt;
      &lt;li&gt;알고리즘의 각 단계는 애매모호하지 않고 명확해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정확성
    &lt;ul&gt;
      &lt;li&gt;모든 유효한 입력에 대해 올바른 해를 출력해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정지성
    &lt;ul&gt;
      &lt;li&gt;유효한 입력이 주어지면 유한한 시간 내에 종료되어야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;알고리즘의 효율성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;시간 효율성
    &lt;ul&gt;
      &lt;li&gt;얼마나 빨리 실행되는 지를 나타낸다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;공간 효율성
    &lt;ul&gt;
      &lt;li&gt;컴퓨터 메모리를 얼마나 사용하는지를 나타낸다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;코드 효율성
    &lt;ul&gt;
      &lt;li&gt;코드가 얼마나 이해하기 쉬운가를 나타낸다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;알고리즘적-문제-해결-과정&quot;&gt;&lt;strong&gt;알고리즘적 문제 해결 과정&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag02.png&quot; width=&quot;25%&quot; height=&quot;5%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;알고리즘의-표현&quot;&gt;&lt;strong&gt;알고리즘의 표현&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;알고리즘의 표현&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;자연어(한글 또는 영어)&lt;/li&gt;
  &lt;li&gt;의사 코드(Pseudocode)&lt;/li&gt;
  &lt;li&gt;순서도(Flowchart)&lt;/li&gt;
  &lt;li&gt;프로그래밍 언어(자바, C 또는 파이선 등)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;예: 최댓값 찾기 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;한글
    &lt;ol&gt;
      &lt;li&gt;배열의 첫 번째 요소를 최댓값으로 정한다.&lt;/li&gt;
      &lt;li&gt;배열의 다음 요소가 최댓값보다 크다면 최댓값을 그 요소로 바꾼다.&lt;/li&gt;
      &lt;li&gt;배열 내에 비교할 요소가 남아 있으면 2단계로 가고 아니면 종료한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;의사 코드&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FindMaximum(A[0 . . N - 1])​      
// 배열 내의 최댓값을 찾는다.​      
// 입력: 크기가 N(&amp;gt; 1)인 숫자들의 배열 A​
// 출력: 배열 A내의 최댓값​
max = A[0]​
  
for (i = 1; i &amp;lt; N; i++)​
       if (A[i] &amp;gt; max) max = A[i]​
      ​     
return max​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로그래밍 언어(자바)&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class FindMaximum {​     
        public static void main(String[] args) {​
          int[ ] intArray  =  {72, 60, 83, 47, 89, 95};​
          int   maximum;​
          maximum =  findMaximum(intArray);​
          System.out.println(&quot;최댓값 = &quot; + maximum);​
         }​
        public static int findMaximum(int[ ] A) {​
          int i, max;​
          max = A[0]; ​
      for (i = 1 ; i &amp;lt; A.length ; i++)​
                if (A[i] &amp;gt; max) max = A[i];​
      return  max;​
      }​
   }​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;알고리즘의-분류&quot;&gt;&lt;strong&gt;알고리즘의 분류&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;알고리즘 설계 기법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;분할 정복(Divide-and-Conquer)​&lt;/li&gt;
  &lt;li&gt;동적 계획(Dynamic Programming)​&lt;/li&gt;
  &lt;li&gt;탐욕 기법(Greedy Technique)​&lt;/li&gt;
  &lt;li&gt;되추적(Backtracking)​&lt;/li&gt;
  &lt;li&gt;분기한정(Branch-and-Bound)​&lt;/li&gt;
  &lt;li&gt;억지 기법(brute-force technique)​&lt;/li&gt;
  &lt;li&gt;무작위(random) 알고리즘​&lt;/li&gt;
  &lt;li&gt;근사(approximate) 알고리즘​&lt;/li&gt;
  &lt;li&gt;병렬(parallel) 알고리즘​&lt;/li&gt;
  &lt;li&gt;분산(distributed) 알고리즘​&lt;/li&gt;
  &lt;li&gt;양자(quantum) 알고리즘​&lt;/li&gt;
  &lt;li&gt;유전자(genetic) 알고리즘​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;문제 유형에 따른 알고리즘의 분류&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;정렬(sorting) 알고리즘​&lt;/li&gt;
  &lt;li&gt;탐색(searching) 알고리즘​&lt;/li&gt;
  &lt;li&gt;문자열 처리(string processing) 알고리즘​&lt;/li&gt;
  &lt;li&gt;그래프(graph) 알고리즘​&lt;/li&gt;
  &lt;li&gt;조합(combinatorial) 알고리즘​&lt;/li&gt;
  &lt;li&gt;기하학적(geometric) 알고리즘​&lt;/li&gt;
  &lt;li&gt;수치(numerical) 알고리즘​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">알고리즘</summary>
      

      
      
    </entry>
  
</feed>
