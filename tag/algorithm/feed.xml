<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://lee989898.github.io/tag/algorithm/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://lee989898.github.io/" rel="alternate" type="text/html" />
  <updated>2022-04-14T23:27:04+09:00</updated>
  <id>https://lee989898.github.io/tag/algorithm/feed.xml</id>

  
  
  

  
    <title type="html">LEE | </title>
  

  
    <subtitle>공부 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">근사 알고리즘</title>
      <link href="https://lee989898.github.io/algorithm-09" rel="alternate" type="text/html" title="근사 알고리즘" />
      <published>2021-11-29T01:09:00+09:00</published>
      <updated>2021-11-29T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-09</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-09">&lt;h3 id=&quot;근사-알고리즘&quot;&gt;&lt;strong&gt;근사 알고리즘&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;근사-알고리즘-1&quot;&gt;근사 알고리즘&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-완전 문제 해결 방법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;문제의 크기가 작다면 완전 탐색 알고리즘 사용&lt;/li&gt;
  &lt;li&gt;문제의 특별한 경우(들)에는 다항 시간 알고리즘을 찾으려고 노력&lt;/li&gt;
  &lt;li&gt;문제의 최적해에 매우 근사한 해를 구하는 것이 허용된다면 비교적 빠른 근사 알고리즘을 찾으려고 노력&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;근사 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;NP-완전 문제와 같이 지금까지 알려진 실용적인 다항 시간 알고리즘이 없거나 최적의 해를 반드시 찾을 필요가 없을 때 사용&lt;/li&gt;
  &lt;li&gt;대부분의 근사 알고리즘은 특정 문제에만 적용되는 휴리스틱에 기초&lt;/li&gt;
  &lt;li&gt;휴리스틱은 경험을 통해 얻는 상식적인 접근법&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;근사 비율&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;근사해의 값과 최적해의 값의 비율&lt;/li&gt;
  &lt;li&gt;정의: 근사 비율 p
    &lt;ul&gt;
      &lt;li&gt;f: 목적 함수&lt;/li&gt;
      &lt;li&gt;$S_a$: 근사해&lt;/li&gt;
      &lt;li&gt;$S^*$: 최적해&lt;/li&gt;
      &lt;li&gt;$S_a$는 다음 부등식을 만족시켜야 한다
        &lt;ul&gt;
          &lt;li&gt;최소화 문제: $\frac{f(S_a)} {f(S^*)}$&amp;lt;= p&lt;/li&gt;
          &lt;li&gt;최대화 문제: $\frac{f(S^*)} {f(S_a)}$&amp;lt;= p&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;p-근사 알고리즘: 근사비율이 p인 알고리즘&lt;/li&gt;
  &lt;li&gt;1에 가까울수록 정확도가 높은 알고리즘&lt;/li&gt;
  &lt;li&gt;근사 비율은 보통 2를 사용&lt;/li&gt;
  &lt;li&gt;대부분의 경우에 목적 함수의 최적 값인 $f(S^*)$를 알 수 없기 때문에 근사 비율 계산 불가&lt;/li&gt;
  &lt;li&gt;$f(S^*)$를 대신할 수 있는 $f(S_a)$의 상한을 구하여 근사 비율을 계산&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;정점 커버 찾기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무방향 그래프에서 각 간선의 양쪽 끝의 두 정점들 중에서 적어도 1개의 정점을 포함하는 정점들의 집합&lt;/li&gt;
  &lt;li&gt;크기 = 정점 커버내에 있는 정점들의 수&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그래프는 여러 개의 정점 커버들을 가질 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;무방향 그래프내에 있는 최소 크기의 정점 커버를 찾아라
    &lt;ul&gt;
      &lt;li&gt;정점 지향 전략&lt;/li&gt;
      &lt;li&gt;간선 지향 전략&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;정점 지향 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;그래프의 모든 정점들을 차수(한 정점에 인접한 정점들의 수) 기준으로 내림차순으로 정렬한다&lt;/li&gt;
  &lt;li&gt;차수가 가장 큰 정점을 선택한다&lt;/li&gt;
  &lt;li&gt;선택된 정점에 인접한 모든 간선을 제거한다&lt;/li&gt;
  &lt;li&gt;남은 그래프에서 과정 2와 3을 반복한다&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;간선 지향 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;그래프의 한 간선 (u, v)를 임의로 선택한다&lt;/li&gt;
  &lt;li&gt;u와 v를 정점 커버에 포함시키고 u와 v에 인접한 간선들은 모두 그래프에서 제거한다&lt;/li&gt;
  &lt;li&gt;남은 간선들 중 임의로 한 간선을 선택하고 같은 과정을 반복한다. 선택할 간선들이 더 이상 남아 있지 않으면 종료한다&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;근사 정점 커버 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Approx_Vertex_Cover(G)&lt;br /&gt;
// 입력: 그래프 G = (V, E)&lt;br /&gt;
// 출력: C - 정점 커버&lt;br /&gt;
1 C = $\emptyset$&lt;br /&gt;
2 $E^&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$ = E  
3 while ( $E^&lt;/code&gt;$ $\neq$  $\emptyset$){&lt;br /&gt;
4   $E^&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$에서 임의로 간선 (u,v)를 선택한다  
5   C = C {u} {v}  
6   $E^&lt;/code&gt;$에서 정점 u나 v에 인접한 모든 간선들을 제거한다&lt;br /&gt;
    }&lt;br /&gt;
7 return C&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;시간 복잡도: O(&lt;/td&gt;
          &lt;td&gt;E&lt;/td&gt;
          &lt;td&gt;)&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;해밀토니안 회로&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;해밀토니안 회로: 그래프의 한 정점에서 출발하여 다른 모든 정점을 1번씩만 방문하고 출발 정점으로 돌아오는 경로&lt;/li&gt;
  &lt;li&gt;완전 그래프에는 반드시 해밀토니안 회로가 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;외판원 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;가중 완전 그래프의 최단 거리 해밀토니안 회로를 찾아라&lt;/li&gt;
  &lt;li&gt;NP-완전 문제&lt;/li&gt;
  &lt;li&gt;다음 조건들을 만족시켜야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;가중치가 있는 완전 무방향 그래프 G = (V, E)의 각 간선 (u, v) $\in$ E는 음이 아닌 가중치 c(u, v)를 가진다&lt;/li&gt;
  &lt;li&gt;모든 정점 u,v,w $\in$ V에 대해서 거리 함수 c가 다음과 같은 삼각 부등식을 만족한다
    &lt;ul&gt;
      &lt;li&gt;c(u,v) &amp;lt;= c(u, w) + c(w, v)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;근사 외판원 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;아이디어&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;프림의 최소 비용 신장 트리 알고리즘을 이용하여 주어진 그래프에서 최소 비용 신장 트리를 찾는다&lt;/li&gt;
  &lt;li&gt;이 트리에 깊이 우선 탐색을 하여 정점들의 방문 순서를 구한다&lt;/li&gt;
  &lt;li&gt;이 순서를 따라 정점들을 방문하면서 다시 방문하는 정점을 순서에서 제거하여 외판원 문제의 근사해를 구한다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Approx_MST_TSP(G, c)&lt;br /&gt;
// 입력: G = (V, E) - 가중 완전 그래프, c - G의 간선들의 가중치(삼각 부등식을 만족)&lt;br /&gt;
// 출력: 해밀토니안 회로 H&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;임의의 정점 r $\in$ V를 출발 정점으로 선택한다&lt;/li&gt;
  &lt;li&gt;Prim의 최소 비용 신장 트리 알고리즘을 이용하여 r이 루트 노드인 그래프 G의 최소 비용 신장 트리 T를 구한다&lt;/li&gt;
  &lt;li&gt;트리 T의 루트 노드에서 시작하여 깊이 우선 탐색을 하면서 노드들을 방문한 순서대로 나열한 목록 H를 구한다&lt;/li&gt;
  &lt;li&gt;목록 H에 있는 정점들을 출발 정점을 제외하고 처음부터 순서대로 스캔하면서 중복하여 나타나는 정점들을 H에서 제거한다&lt;/li&gt;
  &lt;li&gt;return H&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;시간복잡도: O($n^2$)&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">근사 알고리즘</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">분기 한정</title>
      <link href="https://lee989898.github.io/algorithm-08" rel="alternate" type="text/html" title="분기 한정" />
      <published>2021-11-22T01:09:00+09:00</published>
      <updated>2021-11-22T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-08</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-08">&lt;h3 id=&quot;분기-한정&quot;&gt;&lt;strong&gt;분기 한정&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;분기 한정&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;안내 표지판과 같은 지표를 활용하여 최종 해를 찾는 기법&lt;/li&gt;
  &lt;li&gt;상태 공간 트리 이용&lt;/li&gt;
  &lt;li&gt;최적화 문제에만 적용 가능&lt;/li&gt;
  &lt;li&gt;최적 해를 구하기 위해 모든 해를 다 고려해야 하므로 트리의 노드를 순회하는 방법과 무관&lt;/li&gt;
  &lt;li&gt;하지만 최적의 해에 더 빨리 도달하기 위해 가장 좋은 한계값을 가진 노드를 먼저 탐색하는 최선 우선 탐색 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;분기 한정의 핵심 원리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;상태 공간 트리의 각 노드를 탐색할 때마다, 그 노드가 유망한 지를 알기 위해 한계값(그 노드로부터 확장하여 얻을 수 있는 실현    가능한 해의 한계)을 계산한다.&lt;/li&gt;
  &lt;li&gt;만약 그 한계값이 그 때까지 찾은 최고 해의 값보다 더 좋으면 그 노드는 유망하다고 판단하고 확장을 하면서 탐색을 계속한다. 그렇지 않으면 그 노드는 유망하지 않다고 판단하고 탐색을 멈춘다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;노드에서 탐색 중단 이유&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;노드의 한계값이 그 때까지 찾은 최고 해의 값보다 못하다&lt;/li&gt;
  &lt;li&gt;노드는 문제의 제약 사항들을 만족시키지 못하므로 실현 가능한 해가 될 수 없다&lt;/li&gt;
  &lt;li&gt;노드가 나타내는 실형 가능한 해들의 부분 집합이 더 이상의 추가 선택들을 할 수 없는 경우에 해당한다
    &lt;ul&gt;
      &lt;li&gt;세 번째 경우에 실현 가능한 해에 대한 목적 함수의​ 값이 그때까지 찾은 최고 해의 값보다 더 좋다면 ​최고 해의 값을 목적 함수의 값으로 갱신한다.​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;최선 우선 탐색&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;최적의 해에 더 빨리 도달하기 위한 전략&lt;/li&gt;
  &lt;li&gt;너비 우선 탐색 사용&lt;/li&gt;
  &lt;li&gt;한 유망한 노드의 모든 자식 노드들을 만든 후 남아 있는 유망하나 확장되지 않은 노드들 중에서 최고의 한계값을 가진 노드를먼저 확장&lt;/li&gt;
  &lt;li&gt;최고의 한계값을 가진 노드를 우선적으로 선택하기 위해서 우선 순위 대기열 사용&lt;/li&gt;
  &lt;li&gt;우선 순위 대기열은 힙을 사용하여 효과적으로 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;너비 우선 탐색&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;트리의 노드들을 다음과 같은 순서로 탐색&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;트리의 루트 노드를 먼저 탐색&lt;/li&gt;
  &lt;li&gt;다음으로 트리의 수준 1에 있는 모든 노드를 왼쪽에서 오른쪽으로 탐색&lt;/li&gt;
  &lt;li&gt;다음으로 수준 2에 있는 모든 노드들을 왼쪽에서 오른쪽으로 탐색&lt;/li&gt;
  &lt;li&gt;마지막 수준까지 이 과정을 반복&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;최선 우선 탐색 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;v,u : 트리의 노드&lt;/li&gt;
  &lt;li&gt;value(v): 노드 v에 대응되는 실현 가능한 해의 값&lt;/li&gt;
  &lt;li&gt;bound(v): 노드 v의 한계값&lt;/li&gt;
  &lt;li&gt;best: 현재까지 찾은 최고 해&lt;/li&gt;
  &lt;li&gt;PQ: 상태 공간 트리를 대신하는 우선 순위 대기열
    &lt;ul&gt;
      &lt;li&gt;PQ는 유망하나 확장되지 않은 노드들 포함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Best&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;First&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Branch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;and&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Bound&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;space&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 입력: T – 상태 공간 트리​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 출력: 최적 해의 값​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;initialize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;PQ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// PQ를 빈 대기열로 초기화​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T의&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;루트&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;노드&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;best&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;PQ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;           &lt;span class=&quot;c1&quot;&gt;// 노드 v를 PQ에 삽입​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;PQ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// PQ에 노드들이 남아 있는지 확인​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;PQ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// PQ에서 최고 한계값을 가진 노드를 제거​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bound&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;best&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 노드 v가 유망한지 확인​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;       &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;           &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;best&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;best&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;          &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bound&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;best&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;PQ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;best&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;배낭 채우기 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;N(&amp;gt;=1)개의 물건들 중에서 배낭의 용량 C를 초과하지 않고 배낭에 넣을 수 있는 물건들의 최대 가치를 구하라&lt;/li&gt;
  &lt;li&gt;각 물건은 배낭에 넣거나 넣지 않을 수 있더&lt;/li&gt;
  &lt;li&gt;$w_i$: 물건 i, 1&amp;lt;=i&amp;lt;=N,의 무게&lt;/li&gt;
  &lt;li&gt;$v_i$: 물건 i, 1&amp;lt;=i&amp;lt;=N, 의 가치&lt;/li&gt;
  &lt;li&gt;가정: 물건들이 단위 무게당 가치($v_i$ / $w_i$)의 내림차순으로 정렬되어 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;배낭 채우기 상태 공간 트리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;루트 노드: 배낭에 물건들을 넣기 전의 초기 상태&lt;/li&gt;
  &lt;li&gt;트리의 수준 i, 1&amp;lt;=i&amp;lt;=N, 에 있는 각 노드는 첫 번째 물건부터 i번째까지의 물건들 중에서 배낭에 포함된 물건들의 특정 선택을 나타낸다. 이 특정 선택은 루트 노드부터 그 노드까지의 경로에 의해 유일무이하게 결정된다&lt;/li&gt;
  &lt;li&gt;한 노드의 왼쪽에 있는 자식 노드는 다음 물건을 배낭에 넣는 경우를 나타내고 오른쪽에 있는 자식 노드는 다음 물건을 배낭에 넣지 않는 경우를 나타낸다. 이 선택의 총 무게 w와 총 가치 v를 해당 노드에 한계값과 같이 저장한다. 그 노드의 한계값은 이 선택 후 남은 물건들 중 일부를 포함시킴으로써 얻을 수 있는 배낭의 물건들의 가치에 대한 상한을 나타낸다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;노드의 한계값 계산 방법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;배낭에 이미 포함된 물건들의 총 가치 v에 배낭의 남은 용량(C - w)를 전부 다음 물건으로만 채운 경우의 가치를 더한다(w는 배낭에 이미 포함된 물건들의 총 무게). 즉, 트리의 수준 i, 0 &amp;lt;= i &amp;lt; N, 에 있는 노드의 한계값은 다음과 같이 계산된다&lt;/li&gt;
  &lt;li&gt;한계값 &amp;gt;= 실현 가능한 해의 값&lt;/li&gt;
  &lt;li&gt;트리의 수준 n에 있는 노드의 한계값 = v&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;최선 우선 탐색 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;상태 공간 트리의 각 노드에 다음 값들을 저장한다.​
    &lt;ul&gt;
      &lt;li&gt;level: 트리에서 노드의 수준​&lt;/li&gt;
      &lt;li&gt;weight: 이미 선택된 물건들의 총 무게​&lt;/li&gt;
      &lt;li&gt;value: 이미 선택된 물건들의 총 가치​&lt;/li&gt;
      &lt;li&gt;bound: 한계값​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;root: 루트 노드​&lt;/li&gt;
  &lt;li&gt;u, v:  노드 ​&lt;/li&gt;
  &lt;li&gt;maxValue: 지금까지 찾은 최고 해의 값​&lt;/li&gt;
  &lt;li&gt;PQ: 상태 공간 트리를 대신하는 우선 순위 대기열​
    &lt;ul&gt;
      &lt;li&gt;주: PQ는 유망하나 확장되지 않은 노드들 포함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;KnapsackBandB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Wt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;–&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;–&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 입력: N – 물건들의 수​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Wt[0 . . N – 1]– 각 물건의 무게를 저장하는 배열​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Val[0 . . N – 1] – 각 물건의 가치를 저장하는 배열​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// C – 배낭의 용량​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 출력: 배낭에 넣을 수 있는 물건들의 최대 가치​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;initialize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;PQ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// PQ를 빈 대기열로 초기화​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;maxValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// maxValue를 0으로 초기화​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;level&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;weight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;bound&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;computeBound&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 루트 노드의 한계값 계산​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;PQ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;// root를 PQ에 삽입&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;PQ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;// PQ가 비어 있지 않은 동안 반복​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;PQ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;// PQ에서 최대 한계값을 가진 노드 v를 끄집어 낸다​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;bound&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;// 노드 v가 유망하면 확장​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;level&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;level&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;// 노드 u를 노드 v의 자식 노드로 만든다​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;weight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;weight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Wt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;level&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// u는 다음 물건을 넣는 경우​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;level&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;14&lt;/span&gt;      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;weight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;maxValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;// maxValue를 더 나은 해의 값으로 바꾼다​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;bound&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;computeBound&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 자식 노드의 한계값을 계산​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;17&lt;/span&gt;      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;bound&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;18&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;PQ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// u가 유망하므로 PQ에 삽입​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;19&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;level&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;level&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;                 &lt;span class=&quot;c1&quot;&gt;// 노드 w는 다음 물건을 넣지 않는 경우​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;weight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;weight&lt;/span&gt;  &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;21&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;bound&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;computeBound&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 자식 노드의 한계값 계산​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;bound&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;PQ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// w가 유망하므로 PQ에 삽입​&lt;/span&gt;
     &lt;span class=&quot;o&quot;&gt;}}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxValue&lt;/span&gt; 

&lt;span class=&quot;nf&quot;&gt;computeBound&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 노드 u의 한계값을 계산&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 입력: u - 트리의 노드&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 출력: u의 한계값&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;weight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;level&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;wight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;level&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]/&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Wt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;leve&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;시간 복잡도: O($2^n$)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;일 배정 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;N(&amp;gt;1) 명의 사람에게 N개의 일을 배정&lt;/li&gt;
  &lt;li&gt;한 사람에게 정확하게 하나의 일만 배정&lt;/li&gt;
  &lt;li&gt;모든 일은 정확하게 한 사람에게 배정&lt;/li&gt;
  &lt;li&gt;C[i,j], 1&amp;lt;= i, j&amp;lt;=N: 사람 i를 일 j에 배정하는 비용&lt;/li&gt;
  &lt;li&gt;총 배정 비용이 최소가 되도록 일을 배정&lt;/li&gt;
  &lt;li&gt;비용 행렬의 각 행에서 한 요소를 선택하는 문제와 같다&lt;/li&gt;
  &lt;li&gt;선택된 요소들은 다른 열에 있어야 하고 총 배정 비용이 가장 작아야 한다&lt;/li&gt;
  &lt;li&gt;가능한 해는 n-짝(n-tuple)($j_1$,$j_2$, … ,$j_n$)으로 나타낼 수 있다. $j_i$, 1 &amp;lt;=i &amp;lt;= n, 는 사람 i에게 배정된 일의 번호&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;완전 탐색 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;아이디어: 가능한 일 배정과 1부터 N사이의 정수들의 순열과 일대일 대응 관계가 있다는 사실을 이용&lt;/li&gt;
  &lt;li&gt;알고리즘: 1부터 N사이의 정수들의 모든 순열을 생성하고 각 순열에 대응하는 일 배정의 총 비용을 계산한 후 총 비용이 가장 작은 일 배정을 선택한다&lt;/li&gt;
  &lt;li&gt;시간 복잡도: 1부터 N사이의 정수들의 모든 순열의 수 = N!(&amp;gt;$2^n$)
    &lt;ul&gt;
      &lt;li&gt;O(N!)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;분기 한정 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;상태 공간 트리 = N항(N-ary) 트리​&lt;/li&gt;
  &lt;li&gt;해: 루트 노드로부터 잎까지의 경로​&lt;/li&gt;
  &lt;li&gt;살아 있는 노드: 아직 가지 치지 않은 유망한 잎​&lt;/li&gt;
  &lt;li&gt;현재 트리의 살아 있는 노드들중에서 가장 유망한 노드의 모든 자식 노드들을 생성 ​&lt;/li&gt;
  &lt;li&gt;가장 유망한 노드 = 한계값이 가장 작은 노드​&lt;/li&gt;
  &lt;li&gt;최선 우선 탐색 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;최선 우선 탐색 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;상태 공간 트리의 각 노드에 다음 값들을 저장한다
    &lt;ul&gt;
      &lt;li&gt;personNumber: 사람의 번호​&lt;/li&gt;
      &lt;li&gt;jobNumber: 일의 번호​&lt;/li&gt;
      &lt;li&gt;sumAssignedCost: 현재까지 배정된 일들의 비용들의 합​&lt;/li&gt;
      &lt;li&gt;bound: 한계값​&lt;/li&gt;
      &lt;li&gt;parent: 부모 노드​&lt;/li&gt;
      &lt;li&gt;assigned: 사람들에 일들의 배정 여부를 저장하는 배열&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;root: 루트 노드&lt;/li&gt;
  &lt;li&gt;child: 자식 노드&lt;/li&gt;
  &lt;li&gt;queue: 살아 있는 노드들을 포함하는 우선 순위 대기열&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;일 배정 분기 한정 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;JobAssignmentBandB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;–&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;–&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 입력: N – 사람들(일들)의 수​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//        C[0 . . N – 1, 0 . . N – 1]) – 특정 사람에게 특정 일을 배정하는 비용 배열​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 출력: 일 배정 결과와 최소 배정 비용​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;  &lt;span class=&quot;nc&quot;&gt;Initialize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// queue를 빈 대기열로 초기화​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 루트 노드의 값들을 초기화​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;personNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;jobNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sumAssignedCost&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;assigned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 루트 노드의 한계값 계산​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;bound&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;computeBound&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;assigned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 루트 노드를 queue에 삽입​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// queue가 비어 있지 않은 한 한계값이 최소인 살아 있는 노드를 ​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 찾아서 그 노드의 자식 노드들을 queue에 추가​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 최소 한계값을 가진 노드를 queue에서 끄집어 낸다​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;minNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;personNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// i는 일을 배정할 다음 사람​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;모든&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;사람들에게&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;일들이&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;배정된&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;결과를&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;출력한다&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;14&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;최소&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;배정&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;비용을&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;반환한다&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 사람 i에 배정 가능한 일을 배정하는 모든 자식 노드를 만들어 queue에 추가​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;assigned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 일 j가 배정되지 않았는지 확인 ​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;17&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;personNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;18&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;jobNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;19&lt;/span&gt;         &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;assigned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;assigned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;assigned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;21&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minNode&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 배정된 일들의 총 비용에 새로 배정된 일의 비용을 더한다​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sumAssignedCost&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sumAssignedCost&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 새 자식 노드의 한계값 계산​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;bound&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sumAssignedCost&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;computeBound&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;assigned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 새 자식 노드를 queue에 추가​&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;computeBound&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;assigned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 입력: x - 방금 배정된 사람의 번호&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//      y - 방금 배정된 일의 번호&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//      assigned - 사람들에 일들의 배정 여부를 알려 주는 배열&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 출력: 남은 사람들에게 남은 일들을 배정하는 데 드는 총 비용의 하한&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bound&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++){&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;minCost&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;infty&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;minIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;       &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++){&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 사람 i에 일을 배정하는 최소 비용을 찾는다&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;           &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;assigned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minCost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;               &lt;span class=&quot;n&quot;&gt;minIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;               &lt;span class=&quot;n&quot;&gt;minCost&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]}}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;bound&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bound&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minCost&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 다음 사람에게 배정 가능한 일의 최소 비용을&lt;/span&gt;
                                    &lt;span class=&quot;c1&quot;&gt;// 더한다&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bound&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;시간복잡도: O(N!)&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">분기 한정</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">되추적</title>
      <link href="https://lee989898.github.io/algorithm-07" rel="alternate" type="text/html" title="되추적" />
      <published>2021-11-15T01:09:00+09:00</published>
      <updated>2021-11-15T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-07</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-07">&lt;h3 id=&quot;되추적&quot;&gt;&lt;strong&gt;되추적&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;되추적&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;완전 탐색을 개선한 기법&lt;/li&gt;
  &lt;li&gt;후보 해들을 단계적으로 만들어 가는 과정에서 후보 해들을 평가&lt;/li&gt;
  &lt;li&gt;만약 한 후보 해가 최종 해가 될 수 없다고 판단되면 탐색을 멈추고 다른 후보 해를 탐색&lt;/li&gt;
  &lt;li&gt;최적화 문제와 결정 문제 해결 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;하산 길 선택&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;하산 길에 갈림길에 안내 표지판이 없다면&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;갈림길에서 한 길을 선택한 후 그 길을 따라 계속해서 간다&lt;/li&gt;
  &lt;li&gt;길이 끊기면 절벽에 도달하면 갈림길로 되돌아온다&lt;/li&gt;
  &lt;li&gt;갈림길에서 다른 길을 선택해서 간다&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;상태공간트리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;특정 알고리즘의 진행 과정을 나타낸 트리&lt;/li&gt;
  &lt;li&gt;노드: 한 해의 구성요소들에 대한 특정 선택&lt;/li&gt;
  &lt;li&gt;후보 해: 루트 노드에서 종단 노드까지의 경로
 후보 해 중에 해가 있음&lt;/li&gt;
  &lt;li&gt;해가 될 가능성이 전혀 없는 노드의 자손 노드들을 고려하지 않음&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;예: 미로 찾기&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;노드의 유망성
    &lt;ul&gt;
      &lt;li&gt;해가 될 가능성이 있는 노드는 유망하고 아니면 유망하지 않다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;되추적이란?
    &lt;ul&gt;
      &lt;li&gt;어떤 노드의 유망성을 점검한 후, 유망하지 않다고 판정이 되면 그 노드의 부모 노드로 돌아가서 다음 자식 노드에 대한 탐색을 계속한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;상태 공간 트리에서 깊이 우선 탐색
    &lt;ul&gt;
      &lt;li&gt;유망한 노드만 자식 노드 탐색&lt;/li&gt;
      &lt;li&gt;유망하지 않은 노드는 가지 쳐서 탐색 중단&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;순열 생성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&amp;lt;1,2, …, N&amp;gt;의 모든 순열을 생성하라&lt;/li&gt;
  &lt;li&gt;예: N = 3인 경우
    &lt;ul&gt;
      &lt;li&gt;&amp;lt;1,2,3&amp;gt;, &amp;lt;1,3,2&amp;gt;, &amp;lt;2,1,3&amp;gt;, &amp;lt;2,3,1&amp;gt;, &amp;lt;3,1,2&amp;gt;, &amp;lt;3,2,1&amp;gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ag\ag19.png&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;아이디어: 배열의 첫 번째, 두 번째와 세 번째 요소를 각각 첫 번째 요소와 교환한 후 배열의 나머지 부분에 대해 순열을 생성하는 일을 재귀적으로 반복한다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;permute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &amp;lt;A[k], A[k + 1], ..., A[N-1]&amp;gt;의 모든 순열을 생성&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 입력: A[0 .. N - 1] - 순열을 저장하는 배열, k - 배열 A의 지수&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 출력: &amp;lt;A[k], A[k + 1],..., A[N-1]&amp;gt;의 모든 수열&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;을&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;출력한다&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// A[k]를 i로 정하기 전에 가능한지 확인&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;promising&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// A[k]를 i로 정하는 것이 가능한 경우&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;       &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;permute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// A[k+1], ..., A[N-1]&amp;gt; 의 모든 순열을 생성&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 최초호출: permute(A[], 0) &lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// A[k]를 i로 정하는 것이 가능한지 확인&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;promising&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[],&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;해밀토니안 회로 찾기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;헤밀토니안 회로: 연결된 무방향 그래프에서 한 정점에서 출발하여 모든 정점을 정확히 한번씩 방문하고 다시 출발 정점으로 돌아오는 경로&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;헤밀토니안 회로 찾기 문제: 연결된 무방향 그래프에서 해밀토니안 회로를 찾아라&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;가정: n - 그래프내의 정점들의 수&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;트리의 루트 노드에 시작 정점을 놓는다&lt;/li&gt;
  &lt;li&gt;for(i = 1; i &amp;lt; n; i++)
    &lt;ul&gt;
      &lt;li&gt;트리의 수준 i에 i번째로 방문할 정점으로 시작 정점을 제외한 모든 정점을 선택하는 것을 고려한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;i번째 방문 정점 j의 선택 조건&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;i가 (n-1)이라면 j는 시작 정점과 인접해야 한다&lt;/li&gt;
  &lt;li&gt;i가 (n-1)보다 작다면 루트 노드로부터 j까지의 경로상의 (i-1)번째 정점과 인접해야 한다&lt;/li&gt;
  &lt;li&gt;j는 루트 노드로부터 j까지의 경로상에서 j 전에 방문한 (i-1)개의 정점들 중 하나가 되어서는 안된다&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;위 조건들을 만족하면 트리의 다음 수준 (i + 1)에 대해 같은 과정을 계속하고 아니면 해 탐색을 멈추고 부모 노드로 되돌아가서 i번째로 방문할 정점으로 아직 선택안한 정점들 중의 하나를 선택하고 조건을 확인한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;n: 정점들의 수&lt;/li&gt;
  &lt;li&gt;i, 1 &amp;lt;= i &amp;lt;= n : 정점의 번호&lt;/li&gt;
  &lt;li&gt;1: 시작 정점&lt;/li&gt;
  &lt;li&gt;그래프 G = (V,E)는 인접 행렬 G로 표현한다.
    &lt;ul&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;G[i - 1][j - 1] = { 1, (i,j) $\in$ E&lt;/td&gt;
              &lt;td&gt;0, (i,j) $\notin$ E}&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;path[i], 0&amp;lt;= i &amp;lt;= n-1: 해밀토니안 회로에서 i번째 정점&lt;/li&gt;
  &lt;li&gt;path[0] = 1&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;hamiltonian&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;G&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[][],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 입력: i - 그래프의 정점&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//      G[0 .. n - 1][0 .. n - 1] - 그래프의 인접 행렬&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 출력: 해밀토니안 회로&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;valid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;G&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;을&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;출력한다&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// i번째로 방문할 정점을 모든 정점을 시도해 본다&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;       &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++){&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;           &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;           &lt;span class=&quot;n&quot;&gt;hamiltonian&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;G&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 최초 호출: hamiltonian(G, 0)&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;valid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;G&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[][],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 경로상의 i번째 정점이 유효한 선택인지 확인&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;G&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 경로상의 마지막 정저이 첫 번째 정점과 인접하지 않은 경우&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;G&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 경로상의 i번째 정점이 이미 선택되었는지를 확인&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 경로상의 j번째 정점이 이미 선택되었는지를 확인&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;       &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;시간 복잡도: O($n^n)$&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;그래프 색칠하기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;m-색칠하기 문제: 무방향 그래프에서 최대 m(&amp;gt;1)개의 색들을 사용하여 인접한 정점들을 서로 다른 색으로 칠하라&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;응용 분야: 지도 색칠하기&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;지도에서 각 국가는 그래프에서 한 정점으로 나타내고 국경을 맞대고 있는 두 개의 국가들은 대응하는 정점들 사이의 간선으로 나타내면 모든 지도는 그에 상응하는 평면 그래프로 표현할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ag\ag21.png&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;m-색칠하기 상태 공간 트리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;수준 i, 1&amp;lt;=i&amp;lt;=n,에서 정점 i에 가능한 m개의 색들을 각각 시도해 본다(n은 정점들의 수)&lt;/li&gt;
  &lt;li&gt;루트 노드에서 종단 노드까지의 경로가 각각 후보 해가 된다. 이 경로상의 어떤 두 개의 인접한 정점들이 같은 색인지를 확인하여 같은 색이면 그 경로는 더 이상 고려하지 않고 가지 친다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;m-색칠하기 되추적 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;n: 정점들의 수&lt;/li&gt;
  &lt;li&gt;m: 색들의 수&lt;/li&gt;
  &lt;li&gt;i, 1&amp;lt;= i &amp;lt;= n: 정점의 번호&lt;/li&gt;
  &lt;li&gt;1: 시작 정점&lt;/li&gt;
  &lt;li&gt;그래프 G = (V,E)는 인접 행렬 G로 표현한다
    &lt;ul&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;G[i-1][j-1] = {1, (i,j) $\in$ E&lt;/td&gt;
              &lt;td&gt;0, (i,j) $\notin$ E}&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;vcolor[i], 1&amp;lt;=i&amp;lt;=n: 정점 i에 칠해진 색&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;m_coloring&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;G&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[][],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 입력: G[0 .. n - 1][0 .. n - 1] - 그래프의 인접 행렬&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//      i - 그래프의 정점&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 출력: vcolor[1..n] - 정점들에 칠해진 색들의 배열&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;valid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;G&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;vcolor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;을&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;출력한다&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;       &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//다음 정점에 모든 색을 시도해 본다&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;       &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++){&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;           &lt;span class=&quot;n&quot;&gt;vcolor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;           &lt;span class=&quot;n&quot;&gt;m_coloring&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;G&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 최초 호출: hamiltonian(G,0)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 정점 i에 칠해진 색이 유효한지 확인한다&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;valid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;G&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[][],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// i의 색이 인접한 정점(들)의 색과 같은지 확인&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;G&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vcolor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vcolor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;       &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;시간복잡도: O($m^n$)&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">되추적</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">NP-완전</title>
      <link href="https://lee989898.github.io/algorithm-06" rel="alternate" type="text/html" title="NP-완전" />
      <published>2021-11-09T01:09:00+09:00</published>
      <updated>2021-11-09T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-06</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-06">&lt;h3 id=&quot;np-완전&quot;&gt;&lt;strong&gt;NP-완전&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;문제의 분류&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;풀 수 있는(solvable) 문제​
    &lt;ul&gt;
      &lt;li&gt;P 문제: 다항 시간 내에 풀 수 있는 문제 ​&lt;/li&gt;
      &lt;li&gt;NP 문제: 다항 시간 내에 풀 수 없는 문제​
        &lt;ul&gt;
          &lt;li&gt;비결정론적 다항 시간 알고리즘으로 해결할 수 있는 문제​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;NP-완전 문제: 지수 시간 내에 풀 수 있는 문제​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;풀 수 없는(unsolvable) 문제​
    &lt;ul&gt;
      &lt;li&gt;예: 정지 문제(Halting Problem)​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ag\ag14.png&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;결정 문제​
    &lt;ul&gt;
      &lt;li&gt;Yes 혹은 No의 해를 요구하는 문제​&lt;/li&gt;
      &lt;li&gt;예: 무방향그래프의 정점 s 에서 정점 f 까지 가는 경로의 거리가 K(상수) 이하인 경로가 있는가?​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최적화 문제​
    &lt;ul&gt;
      &lt;li&gt;최적의 해를 요구하는 문제​&lt;/li&gt;
      &lt;li&gt;예: 무방향그래프의 정점 s 에서 정점 f 까지 가는 최단 경로의 거리는 얼마인가?​&lt;/li&gt;
      &lt;li&gt;최적화 문제는 모두 대응하는 결정 문제로 바꾼 다음 해결한다.​&lt;/li&gt;
      &lt;li&gt;최적화 문제는 대응하는 결정 문제보다 풀기가 쉽지 않다. ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;비결정론적 다항 시간 알고리즘에 의해 해결할 수 있는 결정 문제들의 집합​&lt;/li&gt;
  &lt;li&gt;비결정론적 다항 시간 알고리즘이란?​
    &lt;ul&gt;
      &lt;li&gt;한 결정 문제의 사례 I를 입력으로 받아 다음을 수행하는 2 단계 알고리즘​&lt;/li&gt;
      &lt;li&gt;비결정론적 ‘추측’ 단계: 주어진 사례 I에 대한 해 S를 ‘추측’한다.​&lt;/li&gt;
      &lt;li&gt;결정론적 ‘확인’ 단계: 사례 I와 해 S를 입력으로 받아 S가 I에  대한 해임을 결정론적 다항 시간에 확인하고 그 해가 맞으면 ‘Yes’ 라고 답하고 해가 아니라면 ‘No’ 라고 답하거나 알고리즘이 종료되지 않게 한다. ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;NP 문제는 해가 Yes 라는 근거가 주어졌을 때 그 해가 옳은 근거임을 다항 시간에 확인해 줄 수 있다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-완전 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;NP에 속하는 문제​&lt;/li&gt;
  &lt;li&gt;어떤 NP-완전 문제를 다항 시간 알고리즘에 의해 풀 수 있다면 나머지 모든 NP-완전 문제들도 다항 시간 알고리즘에 의해 풀 수 있다.​&lt;/li&gt;
  &lt;li&gt;NP-완전 문제는 결정 문제만으로 국한한다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-완전 문제의 핵심 원리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;결정 문제의 변환을 이용한 해결 과정​
    &lt;ul&gt;
      &lt;li&gt;결정 문제 A를 다항 시간에 해결할 수 있는지 알고 싶다.​&lt;/li&gt;
      &lt;li&gt;가정​
        &lt;ul&gt;
          &lt;li&gt;다항 시간에 해결 가능한 결정 문제 B를 이미 알고 있다.​&lt;/li&gt;
          &lt;li&gt;문제 A를 다항 시간에 문제 B로 변환할 수 있고 문제 B의 해(Yes 혹은 No)가 문제 A의 해와 항상 일치한다.​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;문제 A의 사례를 문제 B의 사례로 변환한다. ​&lt;/li&gt;
  &lt;li&gt;변환된 문제 B의 사례를 문제 B의 알고리즘을 이용하여 해결한다.&lt;br /&gt;
주: 문제 A도 다항 시간에 해결할 수 있다&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;다항 시간에 해결할 수 있는 결정 문제가 아직까지 발견되지   않았다. 따라서 문제 A를 다항 시간에 해결할 수 있는지는 알 수 없다. ​&lt;/li&gt;
  &lt;li&gt;NP-완전 문제들은 서로 다항 시간에 변환 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-완전 정의&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;결정 문제 D는 다음 조건들을 만족시켜야 한다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;문제 D는 NP에 속한다.​&lt;/li&gt;
  &lt;li&gt;NP에 속한 모든 문제는 다항 시간에 문제 D로  변환 가능하다.​&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-hard&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;NP-완전보다 넓은 범위의 문제를 포함한다. ​&lt;/li&gt;
  &lt;li&gt;문제 A가 다음 조건을 만족하면 NP-hard이다.​
    &lt;ul&gt;
      &lt;li&gt;NP에 속한 모든 문제는 다항 시간에 문제 A로 변환 가능하다. ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;NP-완전 문제는 NP-hard에 속한다. ​&lt;/li&gt;
  &lt;li&gt;NP-hard 문제는 반드시 NP 문제일 필요는 없다.​&lt;/li&gt;
  &lt;li&gt;NP-hard는 최적화 문제도 포함한다.​&lt;/li&gt;
  &lt;li&gt;문제 A가 다음 조건들을 만족하면 NP-완전이다. ​
    &lt;ol&gt;
      &lt;li&gt;A는 NP에 속한다.​&lt;/li&gt;
      &lt;li&gt;A는 NP-hard이다. ​&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ag\ag15.png&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;한 문제가 NP-hard에 속한다는 것을 증명하는 것은 매우 어렵다. 왜냐하면 NP에 속한 모든 문제를 다항 시간에 그 문제로 변환 가능함을 보여야 하기 때문이다. ​&lt;/li&gt;
  &lt;li&gt;정리: 한 NP-hard 문제를 다항 시간에 주어진 문제로 변환 가능하다면 그 문제는 NP-hard에 속한다. ​&lt;/li&gt;
  &lt;li&gt;한 문제가 NP-hard에 속한다는 증명은 이 정리를 이용한다.​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;문제 A의 NP-완전 증명 방법​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;문제 A가 NP에 속함을 보인다.​&lt;/li&gt;
  &lt;li&gt;한 NP-hard 문제 C의 사례를 다항 시간에 문제 A의 사례로 변환하는 알고리즘을 작성한다.​&lt;/li&gt;
  &lt;li&gt;2의 알고리즘을 수행하여 얻은 결과 사례 C와 사례 A의 Yes/No 해가 일치함을 보인다.​&lt;br /&gt;
주: 어떤 문제가 NP-완전 문제임을 증명하는 것은 쉽지 않다. ​&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-완전 문제​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;논리곱 정규형-만족​&lt;/li&gt;
  &lt;li&gt;완전 부분 그래프​&lt;/li&gt;
  &lt;li&gt;정점 커버​&lt;/li&gt;
  &lt;li&gt;부분 집합의 합​&lt;/li&gt;
  &lt;li&gt;그래프 색칠하기​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;논리곱 정규형-만족 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;부울 연산식은 논리곱 정규형으로 표현될 수 있다.&lt;/li&gt;
  &lt;li&gt;문제: 논리곱 정규형의 주어진 부울 연산식의 값이 true가 되도록 부울 연산식의 변수들에 true나 false 값을 할당할 수 있는가?&lt;/li&gt;
  &lt;li&gt;예: a,b,c -부울 변수,$\bar{a}$, $\bar{b}$ , $\bar{c}$ : a,b,c의 역&lt;br /&gt;
부울 연산삭: ($\bar{a}$ $\lor$ $\bar{b}$ $\lor$ c) $\land$ ($\bar{a}$ $\lor$ b) $\land$ (a $\lor$ $\bar{b}$ $\lor$ $\bar{c}$ )
해: a = true, b = true, c = true&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;완전 부분 그래프​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무방향 그래프 내에 있는 최대 크기의 완전 부분 그래프를 찾아라&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ag\ag16.png&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;정점 커버​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무방향 그래프 내에 있는 최소 크기의 정점 커버를 찾아라&lt;/li&gt;
  &lt;li&gt;정점 커버: 무방향 그래프에서 각 간선의 양쪽 끝의 두 정점들 중에서 적어도 1개의 정점을 포함하는 정점들의 집합&lt;/li&gt;
  &lt;li&gt;예: 아래 그래프에서 최소 크기의 정점 커버 C = {a,c,e}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ag\ag17.png&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;부분 집합의 합 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;정수들의 집합 S의 요소들의 합이 K가 되는 S의 부분 집합을 찾아라.&lt;/li&gt;
  &lt;li&gt;예: S = {10,20,40,70,80}, K = 160
    &lt;ul&gt;
      &lt;li&gt;부분 집합{10,70,80}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;그래프 색칠하기 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무방향 그래프에서 인접한 정점들을 서로 다른색으로 가장 적은 수의 색을 사용하여 색칠하라&lt;/li&gt;
  &lt;li&gt;예: 아래 그래프에서 a,c: 빨강, b,d: 초록, e: 파랑&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ag\ag18.png&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">NP-완전</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">탐욕 기법</title>
      <link href="https://lee989898.github.io/algorithm-05" rel="alternate" type="text/html" title="탐욕 기법" />
      <published>2021-10-26T01:09:00+09:00</published>
      <updated>2021-10-26T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-05</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-05">&lt;h3 id=&quot;탐욕-기법&quot;&gt;&lt;strong&gt;탐욕 기법&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;탐욕 기법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;매 번 선택할 때 마다 그 순간에 좋은 선택을 함으로써 최종적인 해에 도달한다.&lt;/li&gt;
  &lt;li&gt;최적인 해들을 모아서 최종 해를 만들었다고 해서, 그 해가 궁극 적으로 최적이라는 보장이 없다.&lt;/li&gt;
  &lt;li&gt;따라서 탐욕 기법은 항상 최적의 해를 만들어내는 지를 반드시 검증해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;선택 기준&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;선택이 실현 가능해야 한다.&lt;/li&gt;
  &lt;li&gt;모든 선택들 중에서 최적이라고 여겨지는 선택을 해야 한다.&lt;/li&gt;
  &lt;li&gt;한 번 선택하면 나중에 되돌릴 수 없다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;설계 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;비어 있는 해 모음으로 시작한다.&lt;/li&gt;
  &lt;li&gt;탐욕적인 기준에 따라 해 모음에 추가할 다음 해를 선택한다.&lt;/li&gt;
  &lt;li&gt;새 해 모음이 실형 가능한지를 확인한다. 실현 가능하다면 새 해 모음을 확정하고 아니면 선택한 해를 버린다.&lt;/li&gt;
  &lt;li&gt;새 해 모음이 최종 해라면 종료한다. 아니면 2번으로 간다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;거스름돈 주기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;거스름돈을 동전들의 수가 최소가 되도록 주어야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;액면가가 다른 m(&amp;gt;=1)개의 동전들이 있다.&lt;/li&gt;
  &lt;li&gt;동전 i,1&amp;lt;=i&amp;lt;=m,의 액면가는 $d_i$ 이고 $d_1$ &amp;gt; $d_2$ &amp;gt; … &amp;gt; $d_m$ = 1이다.&lt;/li&gt;
  &lt;li&gt;액면가가 같은 동전들의 개수는 무한히 많이 있다.&lt;/li&gt;
  &lt;li&gt;거스름돈 n(&amp;gt;=1)을 최소 개수의 동전들을 사용하여 주어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;탐욕 알고리즘의 아이디어&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;주어야 할 거스름돈이 남아 있는 동안 다음을 반복한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;남은 동전들 중 액면가가 가장 큰 동전을 선택한다.&lt;/li&gt;
  &lt;li&gt;선택한 동전을 거스름돈에 추가하면 거스름돈이 주어야 할 금액을
초과한다면 그 동전을 버린다. 아니면 그 동전을 거스름돈에 추가하고 주어야 할 거스름돈을 추가한 동전의 액면가만큼 감소시킨다.&lt;br /&gt;
주: 최적의 알고리즘&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;탐욕적인 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;coinChange(d[],m,n)
//거스름돈에 포함되는 동전들의 수를 최소화한다.&lt;br /&gt;
//입력: m - 액면가가 다른 동전들의 수&lt;br /&gt;
//     d[1..m] - 동전들의 액면가를 저장하는 배열&lt;br /&gt;
//     n - 거스름돈&lt;br /&gt;
//출력(반환 값): 거스름돈에 포함된 동전들의 최소 개수&lt;br /&gt;
1  count = 0&lt;br /&gt;
2  i = 1&lt;br /&gt;
3  while(n &amp;gt; 0 &amp;amp;&amp;amp; i &amp;lt;=m){&lt;br /&gt;
4    count = count + $\frac{n}{d[i]}$ 　//가치가 가장 큰 동전들을 최대한 많이 선택&lt;br /&gt;
5    n = n mod d[i] 　　　 //남은 거스름돈을 계산&lt;br /&gt;
6    i = i + 1 　　　　　　 //다음으로 가치가 큰 동전을 선택&lt;br /&gt;
    }&lt;br /&gt;
7  return count&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;시간 복잡도&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;입력의 크기: m(액면가가 다른 동전들의 수)&lt;/li&gt;
  &lt;li&gt;기본 연산: 4번의 배정문&lt;/li&gt;
  &lt;li&gt;기본 연산의 수행 횟수: 최대 m&lt;/li&gt;
  &lt;li&gt;시간 복잡도: m = $\theta$(m)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;최소 비용 신장 트리 찾기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;n(&amp;gt;1)개의 도시들을 최소한의 비용으로 연결하는 철도망을 새로 구축하려고 한다.&lt;/li&gt;
  &lt;li&gt;모든 도시들을 서로 연결하기 위해 도시간 철도를 최소한(n-1)개 깔아야 한다.&lt;/li&gt;
  &lt;li&gt;각 철도는 두 도시를 연결한다.&lt;/li&gt;
  &lt;li&gt;이 철도망들 중에서 철도 노선들의 총 길이가 최소가 되도록 철도망을 구축해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;최소 비용 신장 트리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;신장트리: 연결된, 무방향 그래프 안에 있는 모든 정점을 다 포함하면서 트리가 되는 연결된 부분 그래프&lt;/li&gt;
  &lt;li&gt;산장트리는 순환을 포함하지 않으며 그래프 안에 있는 모든 정점들을 연결시칸다.&lt;/li&gt;
  &lt;li&gt;신장트리의 가중치: 모든 간선들의 가중치들의 합&lt;/li&gt;
  &lt;li&gt;최소 비용 신장 트리: 최소 가중치를 가진 신장트리&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ag\ag12.png&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;억지 기법 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;모든 신장 트리를 찾은 후 그 중에서 최소 비용 신장 트리를 선택한다.&lt;/li&gt;
  &lt;li&gt;시간 복잡도 분석
    &lt;ul&gt;
      &lt;li&gt;최악의 경우, 지수 시간보다도 나쁘다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;탐욕적인 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;신장 트리에 추가할 최선의 간선들을 반복적으로 한 번에 하나씩 선택한다. 선택 시점에서 추가할 최선의 간선을 쉽게 알 수 있다고 가정한다.&lt;/li&gt;
  &lt;li&gt;(n-1)개의 간선들이 신장 트리에 포함된다면 종료한다.&lt;/li&gt;
  &lt;li&gt;한 간선이 선택되면 그 간선의 정점들을 합친다.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;적절한 이유&lt;br /&gt;
정점 a와 b가 연결된다면 정점a에 연결하는 것은 정점 b에 연결하는 것과 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;명제. n(&amp;gt;0)개의 정점들을 가진 그래프 G는 (n-1)개의 간선들을 가지고 순환이 없으면 트리이다. 또한 G가 트리이면 (n-1)개의 간선들이 있고 비순환 그래프이다.&lt;/p&gt;

&lt;p&gt;정리. 간선 e가 정점 v에 접합한 가장 가중치가 작은 간선이라면 e를 포함하는 최소 비용 신장 트리가 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;최소 비용 신장트리 찾기 - 정점지향 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;처음 시작할 때 한 정점 $v_0$를 선택한다.&lt;/li&gt;
  &lt;li&gt;$v_0$ 에서 나가는 가장 가중치가 작은 간선 ($v_0$, x)를 선택한다. 그 간선을 최소 비용 신장 트리 T에 추가하고 $v_0$와 x를 합친다. 모든 정점이 T에 포함될 때까지 이 과정을 반복한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;프림 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;적색 정점: 처음에 선택된 정점 $v_0$와 합쳐진 정점&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;청색 정점: 그 외 다른 정점&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;아이디어&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음을 (n-1)번 반복한다:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;한 적색 정점과 한 청색 정점을 연결하는 가장 가중치가 작은 간선을 선택한다.&lt;/li&gt;
  &lt;li&gt;선택된 간선의 청색 정점을 적색으로 바꾸고 그 간선을 트리에 추가한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;그래프의 표현: 비용 행렬 W&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;R: 적색 정점들의 집합, B: 청색 정점들의 집합&lt;br /&gt;
V: 그래프내의 모든 정점들의 집합&lt;br /&gt;
T: 트리 내에 포함되는 간선들의 집합&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;  R = {$v_0$}&lt;/li&gt;
  &lt;li&gt;  B = V - {$v_0$}&lt;/li&gt;
  &lt;li&gt; T = $\emptyset${공집합}&lt;/li&gt;
  &lt;li&gt; for(i = 1; i &amp;lt; n; i++) {&lt;/li&gt;
  &lt;li&gt; 　　w[ r,b ]가 최소인 $r \in R$과 $b \in B$를 선택한다.&lt;/li&gt;
  &lt;li&gt; 　　T = T U {(r,b)}　　// 간선 (r,b)를 트리에 추가한다.&lt;/li&gt;
  &lt;li&gt; 　　B = B - {b}&lt;/li&gt;
  &lt;li&gt; 　　R = R U {b}　　　//정점 b를 적색으로 바꾼다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;명확하게 청색 정점의 관점을 취해야 한다. 단순히 어느 적색 정점이 자신에게 가장 가까운지만 기억한다. 이는 한 정점이 적색이 될 때 쉽게 갱신될 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;시간 복잡도&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 알고리즘은 중복 계산을 많이 한다. 매번 반복할 때마다 최소 간선을 거의 같은 집합에서 찾는다.&lt;br /&gt;
$\theta$($n^3$)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;개선된 프림 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;near[0 .. n - 1]: 각 청색 정점에 가장 가까운 적생 정점을 저장하는 배열&lt;br /&gt;
isblue[0 .. n - 1]: 각 정점이 청색이면 true를 아니면 false를 저장하는 배열&lt;br /&gt;
T: 트리 내에 포함되는 간선들의 집합&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt; isblue[0] = false 　　　　//정점 0은 적색이다&lt;/li&gt;
  &lt;li&gt; T = $\emptyset$&lt;/li&gt;
  &lt;li&gt; for(i = 1; i &amp;lt; n; i++){&lt;/li&gt;
  &lt;li&gt; 　　isblue[i] = true 　　　　//다른 정점들은 청색이다&lt;/li&gt;
  &lt;li&gt; 　　near[i] = 0 } 　　　　　 // 가장 가까운 적색 정점은 0이다&lt;/li&gt;
  &lt;li&gt; for(i = 1; i &amp;lt; n; i++){&lt;/li&gt;
  &lt;li&gt; 　　minval = $\infty$&lt;/li&gt;
  &lt;li&gt; 　　for(b = 0; b &amp;lt; n; b++)　//적색 정점들에 가장 가까운 청색 정점을 찾는다&lt;/li&gt;
  &lt;li&gt; 　　　if(isblue[b] &amp;amp;&amp;amp; W[b,near[b]]&amp;lt; minval){&lt;/li&gt;
  &lt;li&gt; 　　　　minval = W[b,near[b]]&lt;/li&gt;
  &lt;li&gt; 　　　　newred = b }&lt;/li&gt;
  &lt;li&gt; 　isblue[newred] = fasle 　　　//정점 newred를 적색으로 바꾼다&lt;/li&gt;
  &lt;li&gt; 　T = T $\cup$ { (newred, near[newred])}　//가장 가중치가 작은 간선을 T에 추가한다&lt;/li&gt;
  &lt;li&gt; 　for(b = 0; b &amp;lt; n; b++)&lt;/li&gt;
  &lt;li&gt; 　　　if(isblue[b] &amp;amp;&amp;amp; W[b,newred] &amp;lt; W[b,near[b]])near[b] = newred&lt;br /&gt;
　　}&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;시간 복잡도&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;입력 크기: n(정점들의 수)&lt;/li&gt;
  &lt;li&gt;기본 연산: isblue의 요소들에 대한 참조 횟수&lt;/li&gt;
  &lt;li&gt;참조 횟수
    &lt;ul&gt;
      &lt;li&gt;각 i, 1&amp;lt;= i &amp;lt; n, 에 대해 항상 n이다.&lt;/li&gt;
      &lt;li&gt;따라서 총 참조 횟수 = (n-1) x n $\in$ $\theta$($n^2$)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;최소 비용 신장 트리 찾기 - 간선 지향 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;그래프에 남아 있는 가장 가중치가 작은 간선을 선택한다.&lt;/li&gt;
  &lt;li&gt;선택된 간선이 합쳐진 두 개의 정덤들 사이에 있다면 그 간선을 버리고 아니면 최소 비용 신장 트리에 추가한다.&lt;/li&gt;
  &lt;li&gt;(n - 1)개의 간선들이 추가될 때까지 과정 1과 2를 반복한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;크루스칼 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;//e: 간선들의 수&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;  간선들을 가중치 순서로 오름차순으로 정렬하여 배열 EDGELIST[1 .. e]에 저장한다&lt;/li&gt;
  &lt;li&gt;  T = $\emptyset$&lt;/li&gt;
  &lt;li&gt;  ecount = 0  　 　 　 　//최소 비용 신장 트리에 추가된 간선들의 수&lt;/li&gt;
  &lt;li&gt;  k = 0  　 　 　 　 　 　 　//처리된 간선들의 수&lt;/li&gt;
  &lt;li&gt;  while (ecount &amp;lt; n - 1){&lt;/li&gt;
  &lt;li&gt;  　k = k + 1&lt;/li&gt;
  &lt;li&gt;  　(v, w) = EDGELIST[k]&lt;/li&gt;
  &lt;li&gt;  　if(! together(v,w)){&lt;/li&gt;
  &lt;li&gt;  　　T = T U {(v,W)}&lt;/li&gt;
  &lt;li&gt;  　　v와 w를 합친다&lt;/li&gt;
  &lt;li&gt;  　  ecount = ecount + 1 }&lt;br /&gt;
}
주: together(v,w) : v와 w가 이미 합쳐졌으면 true이다.&lt;br /&gt;
분삭: (n-1)번의 통합과 최대 e번의 together를 수행한다.&lt;br /&gt;
정렬시간 = $\theta$( e log e)&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;단일 출발점 최단 경로 찾기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;연결된 가중 그래프에서 한 특정 정점에서 다른 모든 정점으로 가는 최단 경로를 찾아라.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;다익스트라 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;아이디어: 출방 정점 $v_0$로 부터 가까운 순서로 다른 정점들까지의 최단 경로를 찾는다.&lt;/li&gt;
  &lt;li&gt;진행 과정
    &lt;ul&gt;
      &lt;li&gt;i번째 반복이 시작되기 전에 $v_0$에 가장 가까운 (i - 1)개의 정점들까지의 최단 경로들을 찾았다.&lt;/li&gt;
      &lt;li&gt;$v_0$, 이 정점들과 최단 경로들 상의 간선들은 주어진 그래프의 부분 트리 $T_i$를 형성한다.&lt;/li&gt;
      &lt;li&gt;$T_i$내에 있는 정덤들에 인접한 ‘가장자리 정점’들 중에서 찾는다.&lt;/li&gt;
      &lt;li&gt;$T_i$내에 있는 정점들에 인접한 ‘가장자리 정접’들 중에서 찾는다.&lt;/li&gt;
      &lt;li&gt;모든 가장자리 정점 u에 대해서 u에 인접한 트리내의 정점 v까지의 거리, W(u,v)와 출발 정점에서 v까지의 최단 경로의 길이, $d_v$의 합을 계산한다.&lt;/li&gt;
      &lt;li&gt;u에 인접한 트리 내의 정점들이 2개 이상인 경우에는 각 인접 정점에 대해 합을 계산한다. 그러한 합들 중 가장 작은 합을 갖는 가장자리 정점을 트리에 추가할 다음 정점으로 선택한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ag\ag13.png&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 트리 $T_i$이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;n( &amp;gt; 0): 정점들의 수&lt;/li&gt;
  &lt;li&gt;i, 0 &amp;lt;= i &amp;lt; n: 정덤의 번호&lt;/li&gt;
  &lt;li&gt;출발 정점: 0&lt;/li&gt;
  &lt;li&gt;정점 i에 d[i]와 p[i]를 저장한다.
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;d[i]: 출발 정점에서 각 정점까지의 최단 겅로의 거리
d[0] = 0&lt;br /&gt;
d[i] = $\infty$ ,i는 최단 경로 트리 내에 포함되지 않은 정점&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;p[i]: 출발 정점에서 각 정점까지의 최단 경로 상의 마지막에서 두 번째 정점(트리에서 부모 노드)의 번호&lt;br /&gt;
i = 0혹은 트리안에 포함되지 않은 정점이면 p[i] = -1&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;주어진 그래프는 인접 행렬 w로 나타낸다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;트리에 추가할 정점 $u^*$를 선택한 후의 연산&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;$u^*$를 가장자리 정점에서 트리내에 포함되는 정점으로 바꾼다.&lt;/li&gt;
  &lt;li&gt;$u^&lt;em&gt;$에 인접한 트리에 포함되지 않은 각 가장자리 정점 v에 대해 다음 조건을 확인한다.&lt;br /&gt;
d[$u^&lt;/em&gt;$]  + w($u^&lt;em&gt;$ ,v) &amp;lt; d[v]&lt;br /&gt;
위 조건이 만족된다면 다음을 수행한다&lt;br /&gt;
d[v] = d[$u^&lt;/em&gt;$] + w($u^&lt;em&gt;$, v)&lt;br /&gt;
p[v] = $u^&lt;/em&gt;$&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;다익스트라 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;  T = $\emptyset$    //트리에 포함된 정점들의 집합을 공집합으로 초기화한다&lt;/li&gt;
  &lt;li&gt;  for( i = 0; i &amp;lt; n; i++){&lt;/li&gt;
  &lt;li&gt;  d[i] = $\infty$    //정점 i의 최단 거리를 $\infty$ 로 초기화 한다&lt;/li&gt;
  &lt;li&gt;  p[i] = -1 }    //정점 i의 부모 노드를 -1(없음)으로 초기화한다&lt;/li&gt;
  &lt;li&gt;  d[0] = 0    //출발 정점 0의 최단 거리를 0으로 한다&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;  while(&lt;/td&gt;
          &lt;td&gt;T&lt;/td&gt;
          &lt;td&gt;&amp;lt; n){}&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;  T에 포함되지 않은 정점들 중에서 배열 d의 요소값이 가장 작은 정점 u를 선택한다&lt;/li&gt;
  &lt;li&gt;  T = T U { u}    //선택된 정점을 트리에 추가한다&lt;br /&gt;
// 트리에 새로 추가된 정점의 인접 정점들의 출발 정점으로부터 최단 거리를 갱신한다&lt;/li&gt;
  &lt;li&gt;  for( v = 0; v &amp;lt; n; v++)&lt;/li&gt;
  &lt;li&gt;  if(v $\notin$ T and w[u,v]  0 and d[u] &amp;lt; $\infty$ and d[u] + w[u,v] &amp;lt; d[v] ){&lt;/li&gt;
  &lt;li&gt;  d[v] = d[u] + w[u,v]&lt;/li&gt;
  &lt;li&gt;   p[v] = u }&lt;br /&gt;
}&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;시간복잡도&lt;br /&gt;
    +  기본 연산: 10번 조건 확인
    +  9 ~ 12번의 반복문내에서 기본 연산의 수행 횟수 = n
    +  트리에 모든 정점이 포함되어야 하므로 $\theta$($n^2$)&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">탐욕 기법</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">동적 계획</title>
      <link href="https://lee989898.github.io/algorithm-04" rel="alternate" type="text/html" title="동적 계획" />
      <published>2021-10-05T01:09:00+09:00</published>
      <updated>2021-10-05T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-04</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-04">&lt;h3 id=&quot;동적-계획&quot;&gt;&lt;strong&gt;동적 계획&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;분할 정복과 같이 주어진 문제를 더 작은 부분 문제들로
나눈 후 부분 문제들의 해들을 합병하여 해결한다.&lt;/li&gt;
  &lt;li&gt;분할 정복과 달리 부분 문제들이 서로 겹친다.&lt;/li&gt;
  &lt;li&gt;많은 해들 중 최적의 해를 찾는 최적화 문제에 적용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ag\ag07.png&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 분할 정복과 동적 계획의 분할 과정의 예이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;동적 계획 전략&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;문제를 더 작은 부분 문제들로 분할한다.&lt;/li&gt;
  &lt;li&gt;작은 부분 문제들을 해결하고 해들을 표에 저장한다.&lt;/li&gt;
  &lt;li&gt;나중에 다른 (부분) 문제를 해결할 때 이미 해결한 부분 문제가 나오면
다시 해결하는 대신에 표에서 해를 찾아 사용한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;막대-자르기&quot;&gt;&lt;strong&gt;막대 자르기&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;막대의 길이는 n(양의 정수)이다.&lt;/li&gt;
  &lt;li&gt;막대의 길이가 i(양의 정수), 1 &amp;lt;= i &amp;lt;= n-1,인 조각막대로 자를 수 있다.&lt;/li&gt;
  &lt;li&gt;길이가 i, 1 &amp;lt;= i &amp;lt;= n, 인 (조각) 막대의 판매 가격은 $p_i$이다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;길이가 n인 막대를 여러 개의 양의 정수 길이의 조각 막대들로
잘라서 판매할 때 얻을 수 있는 최대 판매 금액을 구해야 한다.
물론 막대를 자르지 않고 통째로 팔 수도 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;억기 기법 알고리즘&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;막대를 자르는 모든 경우들을 찾아낸다.&lt;/li&gt;
  &lt;li&gt;각 경우에서 얻을 수 있는 판매 금액을 계산한 후 그 중 최대 판매
금액을 구한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ag\ag08.png&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 막대를 자르는 모든 방법들과 판매 금액이다&lt;/p&gt;

&lt;p&gt;시간 복잡도: $\theta$($2^n$)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;분할 정복 알고리즘&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;길이가 n인 막대를 처음에 길이 i, 1&amp;lt;=i&amp;lt;=n-1, 인 막대와 길이 (n-i)인 막대로 자른다.&lt;/li&gt;
  &lt;li&gt;길이 i인 막대는 그대로 팔고 길이 (n-i)인 막대는 최대 판매 금액을
얻을 수 있도록 통째로 팔거나 여러 개의 양의 정수 길이의 조각 막대들로 잘라서 판다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;R(n): 길이가 n인 막대를 판매할 때 얻을 수 있는 최대 판매금액&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;R(n) = MAX($p_i$, R(n-i))
          1 &amp;lt;= i &amp;lt;= n
       R(0) = 0&lt;br /&gt;
$p_i$: 길이가 i인 막대의 판매 가격&lt;br /&gt;
R(n-i): 길이 (n - i)의 막대를 판매할 때 얻을 수 있는 최대 판매 금액&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;cutRod_DC&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//길이 i의 막대를 판매할 때 얻을 수 있는 최대 판매 금액, R[i]를 계산한다.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//입력: p[i..n] - 막대들의 판매 가격&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;막대의&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;길이&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//출력(반환값): 최대 판매 금액&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;maxSell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;maxSell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maxSell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cutRod_DC&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxSell&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;최초&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;호출&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxSellValue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cutRod_DC&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ag\ag09.png&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 cutRod_DC(p,4) 호출시 실행 트리 이다.&lt;/p&gt;

&lt;p&gt;시간 복잡도: $\theta$($2^n$)&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;동적 계획 알고리즘 설계 과정&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;cutRod_DP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 길이 n의 막대를 판매할 때 얻을 수 있는 최대 판매 금액을 계산&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 입력: p[1 .. n] - 막대들의 판매 가격, n: 막대의 길이&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 출력(반환값): 최대 판매 금액&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;배열&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxSell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;을&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;선언한다&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;maxSell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;maxVal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;maxVal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maxVal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxSell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;maxSell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxVal&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxSell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;시간복잡도:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;theta&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;$n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;모든-쌍-최단-경로-찾기&quot;&gt;&lt;strong&gt;모든 쌍 최단 경로 찾기&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ag\ag10.png&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 한 그래프 내의 각 정점에서 모든 다른 정점으로 가는 가장 짧은 경로를 찾는 문제이다.&lt;/p&gt;

&lt;p&gt;가중치를 포함한 방향(혹은 무방향)그래프 G = (V,E)가 주어지면
각 정점에서 모든 다른 정점으로 가는 최단 경로의 거리를 찾아라&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;경로의 거리 = 경로 상의 모든 간선의 가중치들의 합&lt;/li&gt;
  &lt;li&gt;정점들의 수 = n&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정점들을 각각 1,2,3, …., n으로 나타낸다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;동적 계획 Floyd 알고리즘&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;문제: 행렬 W가 주어지면 최단 거리 행령 D를 구한다.
주 아이디어&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;최단 경로들을 단계적으로 만든다.&lt;/li&gt;
  &lt;li&gt;최단 경로들을 경유 가능한 정점들의 집합 L을 이용하여 만든다.
최단 경로는 L 내에 있는 정점(들)만을 이용한다.&lt;/li&gt;
  &lt;li&gt;L에 정점들을 한 번에 하나씩 정점의 번호 순서대로 추가한다.&lt;/li&gt;
  &lt;li&gt;최단 거리 행렬들을 다음과 같은 순서대로 계산한다.
     $D_0$,$D_1$,$D_2$, …, $D_n$&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ag\ag11.png&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 Floyd 알고리즘 예이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Floyd 알고리즘&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;AllPairShortestPath(W[])
//입력: 가중치 행렬 W [1..n, 1..n]
//출력: $D^(i)$ [1..n, 1..n], 0&amp;lt;=i&amp;lt;=n&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;   $D^0$ = W&lt;/li&gt;
  &lt;li&gt;   for(k = 1; k &amp;lt;= n; k++){&lt;/li&gt;
  &lt;li&gt;       n x n 행렬 $D^(k)$ = ($d_{ij}^{(k)}$)를 선언한다&lt;/li&gt;
  &lt;li&gt;       for(i = 1; i &amp;lt;= n; i++)&lt;/li&gt;
  &lt;li&gt;         for(j = 1; j &amp;lt;=n; j++)&lt;/li&gt;
  &lt;li&gt;           ($d_{ij}^{(k)}$) = MIN(($d_{ij}^{(k-1)}$) ($d_{ik}^{(k-1)}$) ($d_{kj}^{(k-1)}$))&amp;lt;/sup&amp;gt;
    }&lt;/li&gt;
&lt;/ol&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">동적 계획</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">분할 정복</title>
      <link href="https://lee989898.github.io/algorithm-03" rel="alternate" type="text/html" title="분할 정복" />
      <published>2021-09-21T01:09:00+09:00</published>
      <updated>2021-09-21T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-03</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-03">&lt;h3 id=&quot;분할-정복&quot;&gt;&lt;strong&gt;분할 정복&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;분할 정복 설계 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;분할 단계
    &lt;ul&gt;
      &lt;li&gt;문제를 같은 유형의 여러 개의 더 작은 부분 문제들로 나눈다.&lt;/li&gt;
      &lt;li&gt;부분 문제는 풀기 쉬울 때까지 계속 나눈다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정복 단계
    &lt;ul&gt;
      &lt;li&gt;부분 문제들을 보통 재귀적으로 해결하여 해를 구한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;합병 단계
    &lt;ul&gt;
      &lt;li&gt;문제에 대한 해를 구하기 위해 부분 문제들의 해를 합친다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;최댓값과-최솟값-찾기&quot;&gt;&lt;strong&gt;최댓값과 최솟값 찾기&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;문제: 크기가 n인 배열내의 요소들 중 최댓값과 최솟값을 찾는다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;쉬운 전략&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;최댓값을 찾는다&lt;/li&gt;
  &lt;li&gt;남은 배열 요소들의 최솟값을 찾는다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;총 비교 횟수 = 2n - 3&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;분할 정복 전략&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;배열을 반으로 나눈다.&lt;/li&gt;
  &lt;li&gt;양쪽 절반들의 최댓값과 최솟값을 찾는다.&lt;/li&gt;
  &lt;li&gt;2에서 찾은 두개의 최댓값들과 두 개의
최솟값들을 비교하여 전체 배열의 최댓값과 최솟값을 구한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;의사코드&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;findMaxMin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[],&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// A[i..j]의 최댓값과 최솟값을 찾는다&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 입력: 배열 A[i..j]&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 출력: min(최솟값), max(최댓값)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]}&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]){&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]}&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])}&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;findMaxMin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;findMaxMin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min1&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min2&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max2&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;최초&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;호출:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;findMaxMin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ag\ag04.png&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 실행 트리이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;합병-정렬&quot;&gt;&lt;strong&gt;합병 정렬&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;쉬운 전략&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;최솟값을 찾는다.&lt;/li&gt;
  &lt;li&gt;남은 요소들을 같은 방법을 사용하여 재귀적으로 정렬한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;총 비교횟수 $\theta$($n^2$)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;분할 정복 전략&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;배열을 반으로 나눈다.&lt;/li&gt;
  &lt;li&gt;왼쪽 반과 오른쪽 반을 각각 정렬한다.&lt;/li&gt;
  &lt;li&gt;정렬된 왼쪽 반과 오른쪽 반을 합병한다..&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ag\ag05.png&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 합병 정렬의 진행 과정이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;합병 정렬 알고리즘&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;알고리즘&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mergeSort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;high&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 배열 A[low .. high]를 합병 정렬을 이용하여 정렬한다.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;low&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;high&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;high&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mergeSort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mergeSort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;high&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;merge&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;high&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;최초&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;호출:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mergeSort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Merge 메소드&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//정렬된 부분 배열 A[low .. mid]와 A[mid+1 .. high]를 합병한다.&lt;/span&gt;
&lt;span class=&quot;no&quot;&gt;MERGE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[],&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;high&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;크기가&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;high&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;인&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;배열&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;B를&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;만든다&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;high&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;high&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
     &lt;span class=&quot;nf&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;high&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;시간 복잡도 $\theta$(n $log n$)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;비재귀 합병 정렬 알고리즘&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;mergeSort2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//배열 A[0 .. n-1]를 비재귀 합병 정렬을 이용하여 정렬&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;Merge&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;합병 정렬의 단점&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;합병 정렬의 공간 복잡도: $\theta$(n)&lt;/li&gt;
  &lt;li&gt;입력을 위한 메모리 공간 외에 추가로 입력과 같은 크기의 공간이 별도로 필요&lt;/li&gt;
  &lt;li&gt;2개의 정렬된 부분을 하나로 합병하기 위해 합병된 결과를 저장할 공간이 필요하기 때문이다&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;빠른-정렬&quot;&gt;&lt;strong&gt;빠른 정렬&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;절대적으로 가장 빠른 정렬 알고리즘은 아니지만 평균적으로 매우 효율적이다&lt;/p&gt;

&lt;p&gt;평균 시간복잡도: $\theta$ (n $log n$)&lt;/p&gt;

&lt;p&gt;최악 시간복잡도: $\theta$ $(n^2)$&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;기본 아이디어&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;배열을 두 부분으로 분할한다.
      &lt;ul&gt;
        &lt;li&gt;배열내의 한 기준 요소보다 작거나 같은 요소들은 앞부분에 놓는다.&lt;/li&gt;
        &lt;li&gt;기준 요소보다 큰 요소들은 모두 뒷부분에 놓는다.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;각 분할된 부분을 재귀적으로 정렬한다.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ag\ag06.png&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 빠른 정렬의 진행과정이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;빠른 정렬 알고리즘&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;quickSort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;high&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 배열: A[low .. high]를 빠른 정렬을 이용하여 정렬한다.&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 입력: 정렬할 수 있는 요소들의 배열 A[low .. high]&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 출력: 오름차순으로 정렬된 요소돌의 배열 A[low .. high]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;low&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;high&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;partition&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;high&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 기준 요소 A[low]를 기준으로 분할&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;quickSort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;quickSort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;high&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//최초 호출: quickSort(A,0,n-1)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;분할 알고리즘&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;partition&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;high&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//입력: 배열 A[0 .. n-1]의 부분 배열 A[low .. high], low &amp;lt; high&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//출력: A[low .. high]의 분할 후 기준 요소의 최종 위치(지수)를 반환&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;low&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;high&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;low&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;분할-정복이-부적절한-경우&quot;&gt;&lt;strong&gt;분할 정복이 부적절한 경우&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;문제가 분할될 때만다 분할된 부분 문제들의 입력 크기의 합이 분할되기 전의 입력
크기보다 매우 커지는 경우&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">분할 정복</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">알고리즘의 효율성 분석</title>
      <link href="https://lee989898.github.io/algorithm-02" rel="alternate" type="text/html" title="알고리즘의 효율성 분석" />
      <published>2021-09-14T01:09:00+09:00</published>
      <updated>2021-09-14T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-02</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-02">&lt;h3 id=&quot;알고리즘-분석-체계&quot;&gt;&lt;strong&gt;알고리즘 분석 체계&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;입력 크기&lt;br /&gt;
ex) 배열의 크기, 연결 목록의 길이, 행렬에서 행과 열의 크기, 그래프에서 정점과 간선의 수&lt;/li&gt;
  &lt;li&gt;실행 시간 측정 단위
    &lt;ul&gt;
      &lt;li&gt;기본 연산: 알고리즘의 실행 시간에 가장 많이 기여하는 연산&lt;/li&gt;
      &lt;li&gt;실행 시간은 입력 크기가 작으면 거의 차이가 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;증가 차수
    &lt;ul&gt;
      &lt;li&gt;시간 복잡도 함수의 입력 크기(N)에 따른 증가율
        &lt;ul&gt;
          &lt;li&gt;로그 함수: N의 값이 4배 증가할 때 2만큼 증가&lt;/li&gt;
          &lt;li&gt;1차 선형 함수: N의 값에 비례하여 증가&lt;/li&gt;
          &lt;li&gt;2차 선형 함수: N의 값이 4배 증가할 때 16배 증가&lt;/li&gt;
          &lt;li&gt;지수 함수: N의 값이 4배 증가할 때 2의 4 제곱배 증가&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;시간-복잡도&quot;&gt;&lt;strong&gt;시간 복잡도&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;공간 복잡도: 알고리즘이 수행되는 동안 요구되는 메모리 공간의 크기를 나타낸다.&lt;/p&gt;

&lt;p&gt;시간 복잡도: 알고리즘이 얼마나 빨리 수행되는지를 나타낸다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;알고리즘의 기본 연산의 수행 횟수를 입력 크기의 함수로 표현&lt;/li&gt;
  &lt;li&gt;입력 크기뿐만이 아니라 특정 입력 값에도 좌우&lt;/li&gt;
  &lt;li&gt;복잡도는 입력 크기인 N의 함수로 나타낸다&lt;/li&gt;
  &lt;li&gt;복잡도 함수는 보통 여러 개의 항들을 갖는 다항식이다.&lt;/li&gt;
  &lt;li&gt;고차 항이 시간복잡도를 궁극적으로 지배한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;시간 복잡도의 분류&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;최악 경우 시간 복잡도
    &lt;ul&gt;
      &lt;li&gt;모든 입력에 대해서 기본 연산이 수행되는 최대 횟수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최선 경우 시간 복잡도
    &lt;ul&gt;
      &lt;li&gt;모든 입력에 대해서 기본 연산이 수행되는 최소 횟수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;평균 경우 시간 복잡도
    &lt;ul&gt;
      &lt;li&gt;모든 입력에 대해서 기본 연산이 수행되는 평균 횟수&lt;/li&gt;
      &lt;li&gt;일반적으로 최악 경우보다 구하기가 어려움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;복잡도를 간단한 함수로 표현하기 위해 점근적 표기 사용&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;O(Big O)-표기: 점근적 상한​&lt;/li&gt;
  &lt;li&gt;Ω(Big Ω)-표기: 점근적 하한​&lt;/li&gt;
  &lt;li&gt;$\theta$(Big $\theta$)-표기: 점근적 상한이면서 점근적 하한​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ag\ag03.png&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 주요 복잡도 함수의 증가율이다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">알고리즘 분석 체계</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">알고리즘</title>
      <link href="https://lee989898.github.io/algorithm-01" rel="alternate" type="text/html" title="알고리즘" />
      <published>2021-09-02T01:09:00+09:00</published>
      <updated>2021-09-02T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-01</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-01">&lt;h3 id=&quot;알고리즘&quot;&gt;&lt;strong&gt;알고리즘&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;문제를 해결하기 위한 단계적 절차 또는 방법&lt;/li&gt;
  &lt;li&gt;순서대로 구체적이고 명확하게 기술해야 함&lt;/li&gt;
  &lt;li&gt;유효한 입력을 받아 실행한 결과인 해(답)를 출력&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ag\ag01.png&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;알고리즘의 3가지 조건&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;명확성
    &lt;ul&gt;
      &lt;li&gt;알고리즘의 각 단계는 애매모호하지 않고 명확해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정확성
    &lt;ul&gt;
      &lt;li&gt;모든 유효한 입력에 대해 올바른 해를 출력해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정지성
    &lt;ul&gt;
      &lt;li&gt;유효한 입력이 주어지면 유한한 시간 내에 종료되어야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;알고리즘의 효율성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;시간 효율성
    &lt;ul&gt;
      &lt;li&gt;얼마나 빨리 실행되는 지를 나타낸다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;공간 효율성
    &lt;ul&gt;
      &lt;li&gt;컴퓨터 메모리를 얼마나 사용하는지를 나타낸다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;코드 효율성
    &lt;ul&gt;
      &lt;li&gt;코드가 얼마나 이해하기 쉬운가를 나타낸다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;알고리즘적-문제-해결-과정&quot;&gt;&lt;strong&gt;알고리즘적 문제 해결 과정&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ag\ag02.png&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;알고리즘의-표현&quot;&gt;&lt;strong&gt;알고리즘의 표현&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;알고리즘의 표현&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;자연어(한글 또는 영어)&lt;/li&gt;
  &lt;li&gt;의사 코드(Pseudocode)&lt;/li&gt;
  &lt;li&gt;순서도(Flowchart)&lt;/li&gt;
  &lt;li&gt;프로그래밍 언어(자바, C 또는 파이선 등)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;예: 최댓값 찾기 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;한글&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;배열의 첫 번째 요소를 최댓값으로 정한다.&lt;/li&gt;
  &lt;li&gt;배열의 다음 요소가 최댓값보다 크다면 최댓값을 그 요소로 바꾼다.&lt;/li&gt;
  &lt;li&gt;배열 내에 비교할 요소가 남아 있으면 2단계로 가고 아니면 종료한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;의사 코드&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;FindMaximum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;      
&lt;span class=&quot;c1&quot;&gt;// 배열 내의 최댓값을 찾는다.​      &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 입력: 크기가 N(&amp;gt; 1)인 숫자들의 배열 A​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 출력: 배열 A내의 최댓값​&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
      
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
            &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;     
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;프로그래밍 언어(자바)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FindMaximum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;     
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intArray&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;72&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;83&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;47&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;89&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;95&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;maximum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;maximum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;findMaximum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intArray&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;최댓값 = &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maximum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findMaximum&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
           &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;알고리즘의-분류&quot;&gt;&lt;strong&gt;알고리즘의 분류&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;알고리즘 설계 기법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;분할 정복(Divide-and-Conquer)​&lt;/li&gt;
  &lt;li&gt;동적 계획(Dynamic Programming)​&lt;/li&gt;
  &lt;li&gt;탐욕 기법(Greedy Technique)​&lt;/li&gt;
  &lt;li&gt;되추적(Backtracking)​&lt;/li&gt;
  &lt;li&gt;분기한정(Branch-and-Bound)​&lt;/li&gt;
  &lt;li&gt;억지 기법(brute-force technique)​&lt;/li&gt;
  &lt;li&gt;무작위(random) 알고리즘​&lt;/li&gt;
  &lt;li&gt;근사(approximate) 알고리즘​&lt;/li&gt;
  &lt;li&gt;병렬(parallel) 알고리즘​&lt;/li&gt;
  &lt;li&gt;분산(distributed) 알고리즘​&lt;/li&gt;
  &lt;li&gt;양자(quantum) 알고리즘​&lt;/li&gt;
  &lt;li&gt;유전자(genetic) 알고리즘​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;문제 유형에 따른 알고리즘의 분류&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;정렬(sorting) 알고리즘​&lt;/li&gt;
  &lt;li&gt;탐색(searching) 알고리즘​&lt;/li&gt;
  &lt;li&gt;문자열 처리(string processing) 알고리즘​&lt;/li&gt;
  &lt;li&gt;그래프(graph) 알고리즘​&lt;/li&gt;
  &lt;li&gt;조합(combinatorial) 알고리즘​&lt;/li&gt;
  &lt;li&gt;기하학적(geometric) 알고리즘​&lt;/li&gt;
  &lt;li&gt;수치(numerical) 알고리즘​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">알고리즘</summary>
      

      
      
    </entry>
  
</feed>
