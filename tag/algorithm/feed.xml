<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://lee989898.github.io/tag/algorithm/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://lee989898.github.io/" rel="alternate" type="text/html" />
  <updated>2021-10-18T00:22:52+09:00</updated>
  <id>https://lee989898.github.io/tag/algorithm/feed.xml</id>

  
  
  

  
    <title type="html">LEE | </title>
  

  
    <subtitle>공부 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">알고리즘의 효율성 분석</title>
      <link href="https://lee989898.github.io/algorithm-02" rel="alternate" type="text/html" title="알고리즘의 효율성 분석" />
      <published>2021-09-24T01:09:00+09:00</published>
      <updated>2021-09-24T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-02</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-02">&lt;h3 id=&quot;알고리즘-분석-체계&quot;&gt;알고리즘 분석 체계&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;입력 크기
  ex) 배열의 크기, 연결 목록의 길이, 행렬에서 행과 열의 크기, 그래프에서 정점과 간선의 수&lt;/li&gt;
  &lt;li&gt;실행 시간 측정 단위
    &lt;ul&gt;
      &lt;li&gt;기본 연산: 알고리즘의 실행 시간에 가장 많이 기여하는 연산&lt;/li&gt;
      &lt;li&gt;실행 시간은 입력 크기가 작으면 거의 차이가 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;증가 차수
    &lt;ul&gt;
      &lt;li&gt;시간 복잡도 함수의 입력 크기(N)에 따른 증가율
        &lt;ul&gt;
          &lt;li&gt;로그 함수: N의 값이 4배 증가할 때 2만큼 증가&lt;/li&gt;
          &lt;li&gt;1차 선형 함수: N의 값에 비례하여 증가&lt;/li&gt;
          &lt;li&gt;2차 선형 함수: N의 값이 4배 증가할 때 16배 증가&lt;/li&gt;
          &lt;li&gt;지수 함수: N의 값이 4배 증가할 때 2의 4 제곱배 증가&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;시간-복잡도&quot;&gt;시간 복잡도&lt;/h3&gt;

&lt;p&gt;공간 복잡도: 알고리즘이 수행되는 동안 요구되는 메모리 공간의 크기를 나타낸다.&lt;/p&gt;

&lt;p&gt;시간 복잡도: 알고리즘이 얼마나 빨리 수행되는지를 나타낸다.
    + 알고리즘의 기본 연산의 수행 횟수를 입력 크기의 함수로 표현
    + 입력 크기뿐만이 아니라 특정 입력 값에도 좌우
    + 복잡도는 입력 크기인 N의 함수로 나타낸다
    + 복잡도 함수는 보통 여러 개의 항들을 갖는 다항식이다.
    + 고차 항이 시간복잡도를 궁극적으로 지배한다.&lt;/p&gt;

&lt;p&gt;시간 복잡도의 분류&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;최악 경우 시간 복잡도
    &lt;ul&gt;
      &lt;li&gt;모든 입력에 대해서 기본 연산이 수행되는 최대 횟수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최선 경우 시간 복잡도
    &lt;ul&gt;
      &lt;li&gt;모든 입력에 대해서 기본 연산이 수행되는 최소 횟수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;평균 경우 시간 복잡도
    &lt;ul&gt;
      &lt;li&gt;모든 입력에 대해서 기본 연산이 수행되는 평균 횟수&lt;/li&gt;
      &lt;li&gt;일반적으로 최악 경우보다 구하기가 어려움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;복잡도를 간단한 함수로 표현하기 위해 점근적 표기 사용&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;O(Big O)-표기: 점근적 상한​&lt;/li&gt;
  &lt;li&gt;Ω(Big Ω)-표기: 점근적 하한​&lt;/li&gt;
  &lt;li&gt;θ(Big Θ)-표기: 점근적 상한이면서 점근적 하한​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag03.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 주요 복잡도 함수의 증가율이다.&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">알고리즘 분석 체계</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">알고리즘</title>
      <link href="https://lee989898.github.io/algorithm-01" rel="alternate" type="text/html" title="알고리즘" />
      <published>2021-09-24T01:09:00+09:00</published>
      <updated>2021-09-24T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-01</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-01">&lt;h3 id=&quot;알고리즘이란&quot;&gt;알고리즘이란?&lt;/h3&gt;

&lt;p&gt;알고리즘&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;문제를 해결하기 위한 단계적 절차 또는 방법&lt;/li&gt;
  &lt;li&gt;순서대로 구체적이고 명확하게 기술해야 함&lt;/li&gt;
  &lt;li&gt;유효한 입력을 받아 실행한 결과인 해(답)를 출력&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag01.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;알고리즘의 3가지 조건&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;명확성
    &lt;ul&gt;
      &lt;li&gt;알고리즘의 각 단계는 애매모호하지 않고 명확해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정확성
    &lt;ul&gt;
      &lt;li&gt;모든 유효한 입력에 대해 올바른 해를 출력해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정지성
    &lt;ul&gt;
      &lt;li&gt;유효한 입력이 주어지면 유한한 시간 내에 종료되어야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;알고리즘의 효율성&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;시간 효율성
    &lt;ul&gt;
      &lt;li&gt;얼마나 빨리 실행되는 지를 나타낸다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;공간 효율성
    &lt;ul&gt;
      &lt;li&gt;컴퓨터 메모리를 얼마나 사용하는지를 나타낸다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;코드 효율성
    &lt;ul&gt;
      &lt;li&gt;코드가 얼마나 이해하기 쉬운가를 나타낸다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;알고리즘적-문제-해결-과정&quot;&gt;알고리즘적 문제 해결 과정&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag02.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;알고리즘의-표현&quot;&gt;알고리즘의 표현&lt;/h3&gt;

&lt;p&gt;알고리즘의 표현&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;자연어(한글 또는 영어)&lt;/li&gt;
  &lt;li&gt;의사 코드(Pseudocode)&lt;/li&gt;
  &lt;li&gt;순서도(Flowchart)&lt;/li&gt;
  &lt;li&gt;프로그래밍 언어(자바, C 또는 파이선 등)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;예: 최댓값 찾기 알고리즘&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;한글
    &lt;ol&gt;
      &lt;li&gt;배열의 첫 번째 요소를 최댓값으로 정한다.&lt;/li&gt;
      &lt;li&gt;배열의 다음 요소가 최댓값보다 크다면 최댓값을 그 요소로 바꾼다.&lt;/li&gt;
      &lt;li&gt;배열 내에 비교할 요소가 남아 있으면 2단계로 가고 아니면 종료한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;의사 코드&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FindMaximum(A[0 . . N - 1])​      
// 배열 내의 최댓값을 찾는다.​      
// 입력: 크기가 N(&amp;gt; 1)인 숫자들의 배열 A​
// 출력: 배열 A내의 최댓값​
max = A[0]​
  
for (i = 1; i &amp;lt; N; i++)​
       if (A[i] &amp;gt; max) max = A[i]​
      ​     
return max​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로그래밍 언어(자바)&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class FindMaximum {​     
        public static void main(String[] args) {​
          int[ ] intArray  =  {72, 60, 83, 47, 89, 95};​
          int   maximum;​
          maximum =  findMaximum(intArray);​
          System.out.println(&quot;최댓값 = &quot; + maximum);​
         }​
        public static int findMaximum(int[ ] A) {​
          int i, max;​
          max = A[0]; ​
      for (i = 1 ; i &amp;lt; A.length ; i++)​
                if (A[i] &amp;gt; max) max = A[i];​
      return  max;​
      }​
   }​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;알고리즘의-분류&quot;&gt;알고리즘의 분류&lt;/h3&gt;

&lt;p&gt;알고리즘 설계 기법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;분할 정복(Divide-and-Conquer)​&lt;/li&gt;
  &lt;li&gt;동적 계획(Dynamic Programming)​&lt;/li&gt;
  &lt;li&gt;탐욕 기법(Greedy Technique)​&lt;/li&gt;
  &lt;li&gt;되추적(Backtracking)​&lt;/li&gt;
  &lt;li&gt;분기한정(Branch-and-Bound)​&lt;/li&gt;
  &lt;li&gt;억지 기법(brute-force technique)​&lt;/li&gt;
  &lt;li&gt;무작위(random) 알고리즘​&lt;/li&gt;
  &lt;li&gt;근사(approximate) 알고리즘​&lt;/li&gt;
  &lt;li&gt;병렬(parallel) 알고리즘​&lt;/li&gt;
  &lt;li&gt;분산(distributed) 알고리즘​&lt;/li&gt;
  &lt;li&gt;양자(quantum) 알고리즘​&lt;/li&gt;
  &lt;li&gt;유전자(genetic) 알고리즘​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;문제 유형에 따른 알고리즘의 분류&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정렬(sorting) 알고리즘​&lt;/li&gt;
  &lt;li&gt;탐색(searching) 알고리즘​&lt;/li&gt;
  &lt;li&gt;문자열 처리(string processing) 알고리즘​&lt;/li&gt;
  &lt;li&gt;그래프(graph) 알고리즘​&lt;/li&gt;
  &lt;li&gt;조합(combinatorial) 알고리즘​&lt;/li&gt;
  &lt;li&gt;기하학적(geometric) 알고리즘​&lt;/li&gt;
  &lt;li&gt;수치(numerical) 알고리즘​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">알고리즘이란?</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">분할 정복</title>
      <link href="https://lee989898.github.io/algorithm-03" rel="alternate" type="text/html" title="분할 정복" />
      <published>2021-09-24T01:09:00+09:00</published>
      <updated>2021-09-24T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-03</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-03">&lt;ul&gt;
  &lt;li&gt;분할 정복 설계 전략&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;분할 단계
    &lt;ul&gt;
      &lt;li&gt;문제를 같은 유형의 여러 개의 더 작은 부분 문제들로 나눈다.&lt;/li&gt;
      &lt;li&gt;부분 문제는 풀기 쉬울 때까지 계속 나눈다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정복 단계
    &lt;ul&gt;
      &lt;li&gt;부분 문제들을 보통 재귀적으로 해결하여 해를 구한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;합병 단계
    &lt;ul&gt;
      &lt;li&gt;문제에 대한 해를 구하기 위해 부분 문제들의 해를 합친다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;최댓값과-최솟값-찾기&quot;&gt;최댓값과 최솟값 찾기&lt;/h3&gt;

&lt;p&gt;문제: 크기가 n인 배열내의 요소들 중 최댓값과 최솟값을 찾는다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;쉬운 전략
    &lt;ol&gt;
      &lt;li&gt;최댓값을 찾는다&lt;/li&gt;
      &lt;li&gt;남은 배열 요소들의 최솟값을 찾는다&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;총 비교 횟수 = 2n - 3&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;분할 정복 전략
    &lt;ol&gt;
      &lt;li&gt;배열을 반으로 나눈다.&lt;/li&gt;
      &lt;li&gt;양쪽 절반들의 최댓값과 최솟값을 찾는다.&lt;/li&gt;
      &lt;li&gt;2에서 찾은 두개의 최댓값들과 두 개의
최솟값들을 비교하여 전체 배열의 최댓값과 최솟값을 구한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;의사코드&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;findMaxMin(A[],i,j,min,max)
// A[i..j]의 최댓값과 최솟값을 찾는다
// 입력: 배열 A[i..j]
// 출력: min(최솟값), max(최댓값)
1. if(i == j) { min = A[i]; max = A[j]}
2. else if(i = j - 1){
3.     if(A[i] &amp;lt; A[j]){
          min = A[i]; max = A[j]}
4.     else{ min = A[j]; max = A[i])}
   }
5. else{
6. mid = (i+j)/2
7. findMaxMin(A,i,mid,min1,max1)
8. findMaxMin(A,mid+1,j,min2,max2)
9. if(min1 &amp;lt; min2) min = min1
10.else min = min2
11.if(max1 &amp;lt; max2) max = max2
12.else max = max1
최초 호출: findMaxMin(A,0,n-1,min,max)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag04.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 실행 트리이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;합병-정렬&quot;&gt;합병 정렬&lt;/h3&gt;

&lt;h3 id=&quot;빠른-정렬&quot;&gt;빠른 정렬&lt;/h3&gt;

&lt;h3 id=&quot;선택&quot;&gt;선택&lt;/h3&gt;

&lt;h3 id=&quot;분할-정복이-부적절한-경우&quot;&gt;분할 정복이 부적절한 경우&lt;/h3&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">분할 정복 설계 전략</summary>
      

      
      
    </entry>
  
</feed>
