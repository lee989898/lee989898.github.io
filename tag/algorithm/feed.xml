<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://lee989898.github.io/tag/algorithm/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://lee989898.github.io/" rel="alternate" type="text/html" />
  <updated>2021-10-21T23:14:24+09:00</updated>
  <id>https://lee989898.github.io/tag/algorithm/feed.xml</id>

  
  
  

  
    <title type="html">LEE | </title>
  

  
    <subtitle>공부 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">중복 숫자 제거</title>
      <link href="https://lee989898.github.io/algorithm-09" rel="alternate" type="text/html" title="중복 숫자 제거" />
      <published>2021-09-24T01:09:00+09:00</published>
      <updated>2021-09-24T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-09</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-09">&lt;h3 id=&quot;중복-숫자-제거&quot;&gt;중복 숫자 제거&lt;/h3&gt;

&lt;p&gt;N 개의 숫자들의 배열이 있다. 
이 배열 안에 있는 숫자들 중
 일부는 값들이 서로 같다. 다시 말
 해, 어떤 숫자는 배열 안에 두 번 이상
  저장되어 있다. 배열 안에 있는 중복된
   숫자들을 모두 제거하는 알고리즘을 작성하라.&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;partition(A[], low, high)
    
i = low + 1
j = high
while(i &amp;lt;= j){
    if(A[i] &amp;lt; 0) i = i + 1
    else if(A[j] &amp;gt; 0) j = j - 1
    else if(A[i] == 0 &amp;amp;&amp;amp; A[i+1] == 0) i = i + 2
    else if(A[j] == 0 &amp;amp;&amp;amp; A[j-1] == 0) j = j -2
    else if(A[i] == 0 ) A[i] &amp;lt;-&amp;gt; A[i+1]
    else if(A[j] == 0 ) A[j] &amp;lt;-&amp;gt; A[j-1] 
    else { A[i] &amp;lt;-&amp;gt; A[j]
            i = i+1
            j = j-1
            }
    }
}
A[low] &amp;lt;-&amp;gt; 
return j
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">중복 숫자 제거</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">숫자들 재배치</title>
      <link href="https://lee989898.github.io/algorithm-08" rel="alternate" type="text/html" title="숫자들 재배치" />
      <published>2021-09-24T01:09:00+09:00</published>
      <updated>2021-09-24T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-08</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-08">&lt;h3 id=&quot;숫자들-재배치&quot;&gt;숫자들 재배치&lt;/h3&gt;

&lt;p&gt;N(&amp;gt; 0)개의 정수들의 배열이 주어져 있다. 
배열 요소들은 음수, 양수 혹은 0 이다. 
이 배열의 요소들을 모든 음수(들)이 먼저 나오고 
다음으로 0(들)이 나오고 마지막으로 
양수(들)이 나오도록 재정렬하는 O(N) 알고리즘을 작성하라.&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;partition(A[], low, high)
    
i = low
j = high
while(i &amp;lt;= j){
    if(A[i] &amp;lt; 0) i = i + 1
    else if(A[j] &amp;gt; 0) j = j - 1
    else if(A[i] == 0 &amp;amp;&amp;amp; A[i+1] == 0) i = i + 2
    else if(A[j] == 0 &amp;amp;&amp;amp; A[j-1] == 0) j = j -2
    else if(A[i] == 0 ) A[i] &amp;lt;-&amp;gt; A[i+1]
    else if(A[j] == 0 ) A[j] &amp;lt;-&amp;gt; A[j-1] 
    else { A[i] &amp;lt;-&amp;gt; A[j]
            i = i+1
            j = j-1
            }
    }
}

return j
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">숫자들 재배치</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">올바른 문자열들의 수</title>
      <link href="https://lee989898.github.io/algorithm-07" rel="alternate" type="text/html" title="올바른 문자열들의 수" />
      <published>2021-09-24T01:09:00+09:00</published>
      <updated>2021-09-24T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-07</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-07">&lt;h3 id=&quot;올바른-문자열들의-수&quot;&gt;올바른 문자열들의 수&lt;/h3&gt;

&lt;p&gt;0과 1로 이루어진 문자열이 있다. 이 문자
열에는 1이 연속하여 나올 수는 있지만 0 이 
연속하여 나올 수는 없다. 예를 들면 ‘1111’, ‘1
10111’, ‘010101’은 올바른 문자열이지만, ‘000’,
 ‘1100111’ 등은 잘못된 문자열이다. 길이가 N
 (&amp;gt; 0)인 올바른 문자열들의 수를 구하려고 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;길이가 1인 올바른 문자열들의 수는 몇 개인가?
    &lt;ul&gt;
      &lt;li&gt;2개&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;길이가 2인 올바른 문자열들의 수는 몇 개인가?
    &lt;ul&gt;
      &lt;li&gt;3게&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;길이가 3인 올바른 문자열들의 수는 몇 개인가?
    &lt;ul&gt;
      &lt;li&gt;5개&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;길이가 N(&amp;gt; 0)인 올바른 문자열들의 수에 대한 점화식을 작성하라.
    &lt;ul&gt;
      &lt;li&gt;a1 = 2, a2= 3, an = a(n-1) + a(n-2) (n&amp;gt;2)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;4번의 점화식을 이용하여 길이가 N(&amp;gt; 0)인 올바른 문자열들의 수를 구하
는 재귀 알고리즘을 작성하라.&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int stringNum(int N){
 int a=2,b=3
 int c=a+b
 if(N==1)
     return 2;
 else if(N==2)
     return 3;
    
 return stringNum(N-1)+stringNum(N-2);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;길이가 N(&amp;gt; 0)인 올바른 문자열들의 수를 반복을 이용하여 구하는 
빅오(N) 알고리즘을 작성하라.&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int a=2,b=3
int c=a+b
if(N==1)
    return 2;
else if(N==2)
    return 3;
else{
     for(int i = 3; i &amp;lt; N; i++)
     {
         a = b
         b = c
         c = a + b
     }
     return c;
     }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">올바른 문자열들의 수</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">등수 매기기</title>
      <link href="https://lee989898.github.io/algorithm-06" rel="alternate" type="text/html" title="등수 매기기" />
      <published>2021-09-24T01:09:00+09:00</published>
      <updated>2021-09-24T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-06</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-06">&lt;h3 id=&quot;등수-매기기&quot;&gt;등수 매기기&lt;/h3&gt;

&lt;p&gt;시험 점수들을 값이 큰 순서대로 등수를 매기려고 한다. 
예를 들면, 5명의 시험 점수가 82, 75, 98, 63, 40이라면 
각 점수의 등수는 2등, 3등, 1등, 4등, 5등이 된다. 
시험 점수들의 갯수는 N(&amp;gt; 0)이다. 시험 점수들은 크기가 N
인 Score라는 배열에 저장되어 있다. 각 점수의 등
수는 크기가 N인 Rank라는 배열에 저장해야 한다. 등수를
 매기는 알고리즘을 작성하라. 정렬을 사용하지 말아라.&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Score[N] = {82,75,98,63,40, ''', }
Rank[N] = {1,}

for(i = 0; i &amp;lt; N; i++){
    for(j = i+1; j &amp;lt; N; j++){
        if(Score[i] &amp;gt; Score[j])
            Rank[j]++;
        else
            Rank[i]++
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">등수 매기기</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">빠진 번호 찾기</title>
      <link href="https://lee989898.github.io/algorithm-05" rel="alternate" type="text/html" title="빠진 번호 찾기" />
      <published>2021-09-24T01:09:00+09:00</published>
      <updated>2021-09-24T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-05</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-05">&lt;h3 id=&quot;빠진-번호-찾기&quot;&gt;빠진 번호 찾기&lt;/h3&gt;

&lt;p&gt;경품 추첨을 위한 N개의 번호(0보다 큰 정수)들이 있다. 
이 번호들은 1부터 N사이의 정수들 중의 하나여야 한다.&lt;br /&gt;
이 번호들 중 빠진 번호가 있는지를 찾아내는 알고리즘을 기술하라.&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    int num[N] = {1,2,2,3,4, ''',N}
    int tmp[N] = {0, }
    
    for(i = 0; i &amp;lt; N; i++){
            tmp[num[i] - 1]++;
    }
    
    for(i = 0; i &amp;lt; N; i++){
            if(tmp[i] == 0)
            {
                printf(&quot;빠진 번호가 있습니다.&quot;);
                break;
            }
    }               
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">빠진 번호 찾기</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">동적 계획</title>
      <link href="https://lee989898.github.io/algorithm-04" rel="alternate" type="text/html" title="동적 계획" />
      <published>2021-09-24T01:09:00+09:00</published>
      <updated>2021-09-24T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-04</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-04">&lt;h3 id=&quot;동적-계획&quot;&gt;동적 계획&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;분할 정복과 같이 주어진 문제를 더 작은 부분 문제들로
나눈 후 부분 문제들의 해들을 합병하여 해결한다.&lt;/li&gt;
  &lt;li&gt;분할 정복과 달리 부분 문제들이 서로 겹친다.&lt;/li&gt;
  &lt;li&gt;많은 해들 중 최적의 해를 찾는 최적화 문제에 적용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag07.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 분할 정복과 동적 계획의 분할 과정의 예이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;동적 계획 전략
    &lt;ol&gt;
      &lt;li&gt;문제를 더 작은 부분 문제들로 분할한다.&lt;/li&gt;
      &lt;li&gt;작은 부분 문제들을 해결하고 해들을 표에 저장한다.&lt;/li&gt;
      &lt;li&gt;나중에 다른 (부분) 문제를 해결할 때 이미 해결한 부분 문제가 나오면
다시 해결하는 대신에 표에서 해를 찾아 사용한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;막대-자르기&quot;&gt;막대 자르기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;막대의 길이는 n(양의 정수)이다.&lt;/li&gt;
  &lt;li&gt;막대의 길이가 i(양의 정수), 1 &amp;lt;= i &amp;lt;= n-1,인 조각막대로 자를 수 있다.&lt;/li&gt;
  &lt;li&gt;길이가 i, 1 &amp;lt;= i &amp;lt;= n, 인 (조각) 막대의 판매 가격은 pi이다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;길이가 n인 막대를 여러 개의 양의 정수 길이의 조각 막대들로
잘라서 판매할 때 얻을 수 있는 최대 판매 금액을 구해야 한다.
물론 막대를 자르지 않고 통째로 팔 수도 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;억기 기법 알고리즘
    &lt;ol&gt;
      &lt;li&gt;막대를 자르는 모든 경우들을 찾아낸다.&lt;/li&gt;
      &lt;li&gt;각 경우에서 얻을 수 있는 판매 금액을 계산한 후 그 중 최대 판매
금액을 구한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag08.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 막대를 자르는 모든 방법들과 판매 금액이다.&lt;/p&gt;

&lt;p&gt;시간 복잡도: 빅오(2의n승)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;분할 정복 알고리즘
    &lt;ol&gt;
      &lt;li&gt;길이가 n인 막대를 처음에 길이 i, 1&amp;lt;=i&amp;lt;=n-1, 인 막대와 
길이 (n-i)인 막대로 자른다.&lt;/li&gt;
      &lt;li&gt;길이 i인 막대는 그대로 팔고 길이 (n-i)인 막대는 최대 판매 금액을
얻을 수 있도록 통째로 팔거나 여러 개의 양의 정수 길이의 조각 막대들로 
잘라서 판다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;R(n): 길이가 n인 막대를 판매할 때 얻을 수 있는 최대 판매금액&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;R(n) = MAX(pi, R(n-i))
          1 &amp;lt;= i &amp;lt;= n
       R(0) = 0&lt;br /&gt;
pi: 길이가 i인 막대의 판매 가격&lt;br /&gt;
R(n-i): 길이 (n - i)의 막대를 판매할 때 얻을 수 있는 최대 판매 금액&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cutRod_DC(p[], i)
//길이 i의 막대를 판매할 때 얻을 수 있는 최대 판매 금액, R[i]를 계산한다.
//입력: p[i..n] - 막대들의 판매 가격
        i - 막대의 길이
//출력(반환값): 최대 판매 금액
if(i = 0) return 0
else{
      maxSell = 0
      for(j = 1; j &amp;lt;= i; j++)
          maxSell = MAX(maxSell, p[j] + cutRod_DC(p,i-j))
      return maxSell
}
최초 호출 maxSellValue = cutRod_DC(p,n)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag09.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 cutRod_DC(p,4) 호출시 실행 트리 이다.&lt;/p&gt;

&lt;p&gt;시간 복잡도: 빅오(2의n제곱)&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;동적 계획 알고리즘 설계 과정&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; cutRod_DP(p[], n)
 // 길이 n의 막대를 판매할 때 얻을 수 있는 최대 판매 금액을 계산
 // 입력: p[1 .. n] - 막대들의 판매 가격, n: 막대의 길이
 // 출력(반환값): 최대 판매 금액
 배열 maxSell[0 .. n]을 선언한다.
 maxSell[0] = 0
 for(j = 1; j&amp;lt;=n; j++){
      maxVal = 0
      for(k = 1; k &amp;lt;= j; k++)
          maxVal = MAX(maxVal, p[k] + maxSell[j - k])
      maxSell[j] = maxVal
  }
  return maxSell[n]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;시간복잡도: 박오(n의2제곱)&lt;/p&gt;

&lt;h3 id=&quot;모든-쌍-최단-경로-찾기&quot;&gt;모든 쌍 최단 경로 찾기&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag10.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 한 그래프 내의 각 정점에서 모든 다른 정점으로 가는 가장 
짧은 경로를 찾는 문제이다.&lt;/p&gt;

&lt;p&gt;가중치를 포함한 방향(혹은 무방향)그래프 G = (V,E)가 주어지면 
각 정점에서 모든 다른 정점으로 가는 최단 경로의 거리를 찾아라.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;경로의 거리 = 경로 상의 모든 간선의 가중치들의 합&lt;/li&gt;
  &lt;li&gt;정점들의 수 = n&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정점들을 각각 1,2,3, …., n으로 나타낸다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;동적 계획 Floyd 알고리즘&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;문제: 행렬 W가 주어지면 최단 거리 행령 D를 구한다.
주 아이디어&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;최단 경로들을 단계적으로 만든다.&lt;/li&gt;
  &lt;li&gt;최단 경로들을 경유 가능한 정점들의 집합 L을 이용하여 만든다.
최단 경로는 L 내에 있는 정점(들)만을 이용한다.&lt;/li&gt;
  &lt;li&gt;L에 정점들을 한 번에 하나씩 정점의 번호 순서대로 추가한다.&lt;/li&gt;
  &lt;li&gt;최단 거리 행렬들을 다음과 같은 순서대로 계산한다.
     D(0),D(1),D(2), …, D(n)&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag11.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 Floyd 알고리즘 예이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Floyd 알고리즘&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AllPairShortestPath(W[])
//입력: 가중치 행렬 W
//출력: D(i)
D(0) = W
for(k = 1; k &amp;lt;= n; k++){
  n x n 행렬 D(k) = (dij(k))를 선언한다
  for(i = 1; i &amp;lt;= n; i++)
      for(j = 1; j &amp;lt;=n; j++)
          dij(k) = MIN(dij(k-1),dik(k-1)+dkj(k-1)
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">동적 계획</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">분할 정복</title>
      <link href="https://lee989898.github.io/algorithm-03" rel="alternate" type="text/html" title="분할 정복" />
      <published>2021-09-24T01:09:00+09:00</published>
      <updated>2021-09-24T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-03</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-03">&lt;ul&gt;
  &lt;li&gt;분할 정복 설계 전략&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;분할 단계
    &lt;ul&gt;
      &lt;li&gt;문제를 같은 유형의 여러 개의 더 작은 부분 문제들로 나눈다.&lt;/li&gt;
      &lt;li&gt;부분 문제는 풀기 쉬울 때까지 계속 나눈다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정복 단계
    &lt;ul&gt;
      &lt;li&gt;부분 문제들을 보통 재귀적으로 해결하여 해를 구한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;합병 단계
    &lt;ul&gt;
      &lt;li&gt;문제에 대한 해를 구하기 위해 부분 문제들의 해를 합친다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;최댓값과-최솟값-찾기&quot;&gt;최댓값과 최솟값 찾기&lt;/h3&gt;

&lt;p&gt;문제: 크기가 n인 배열내의 요소들 중 최댓값과 최솟값을 찾는다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;쉬운 전략
    &lt;ol&gt;
      &lt;li&gt;최댓값을 찾는다&lt;/li&gt;
      &lt;li&gt;남은 배열 요소들의 최솟값을 찾는다&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;총 비교 횟수 = 2n - 3&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;분할 정복 전략
    &lt;ol&gt;
      &lt;li&gt;배열을 반으로 나눈다.&lt;/li&gt;
      &lt;li&gt;양쪽 절반들의 최댓값과 최솟값을 찾는다.&lt;/li&gt;
      &lt;li&gt;2에서 찾은 두개의 최댓값들과 두 개의
최솟값들을 비교하여 전체 배열의 최댓값과 최솟값을 구한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;의사코드&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;findMaxMin(A[],i,j,min,max)
// A[i..j]의 최댓값과 최솟값을 찾는다
// 입력: 배열 A[i..j]
// 출력: min(최솟값), max(최댓값)
1. if(i == j) { min = A[i]; max = A[j]}
2. else if(i = j - 1){
3.     if(A[i] &amp;lt; A[j]){
          min = A[i]; max = A[j]}
4.     else{ min = A[j]; max = A[i])}
   }
5. else{
6. mid = (i+j)/2
7. findMaxMin(A,i,mid,min1,max1)
8. findMaxMin(A,mid+1,j,min2,max2)
9. if(min1 &amp;lt; min2) min = min1
10.else min = min2
11.if(max1 &amp;lt; max2) max = max2
12.else max = max1
최초 호출: findMaxMin(A,0,n-1,min,max)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag04.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 실행 트리이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;합병-정렬&quot;&gt;합병 정렬&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;쉬운 전략
    &lt;ol&gt;
      &lt;li&gt;최솟값을 찾는다.&lt;/li&gt;
      &lt;li&gt;남은 요소들을 같은 방법을 사용하여 재귀적으로 정렬한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;총 비교횟수 n의2제곱&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;분할 정복 전략
    &lt;ol&gt;
      &lt;li&gt;배열을 반으로 나눈다.&lt;/li&gt;
      &lt;li&gt;왼쪽 반과 오른쪽 반을 각각 정렬한다.&lt;/li&gt;
      &lt;li&gt;정렬된 왼쪽 반과 오른쪽 반을 합병한다..&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag05.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 합병 정렬의 진행 과정이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;합병 정렬 알고리즘&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;알고리즘 mergeSort(A[], low, high)
// 배열 A[low .. high]를 합병 정렬을 이용하여 정렬한다.
if(low &amp;lt; high){
      mid = (low+high)/2
      mergeSort(A,low,mid)
      mergeSort(A,mid+1,high)
      merge(A,low,mid,high)
}
최초 호출: mergeSort(A,0,n-1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Merge 메소드&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//정렬된 부분 배열 A[low .. mid]와 A[mid+1 .. high]를 합병한다.
MERGE(A[],low,mid,high){
  크기가 (high + 1)인 배열 B를 만든다
  h = low; i = low; j = mid + 1
  while(i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;=high){
      if(A[i] &amp;lt;= A[j] { B[h] = A[i]; i = i + 1}
      else{B[h] = A[j]; j = j + 1}
      h = h + 1
  }
  if( i &amp;gt; mid)
      for(k = j; k &amp;lt;= high; k++) { B[h] = A[k]; h = h + 1}
  else
      for(k = i; k &amp;lt;= mid; k++) {B[h] = A[k]; h = h + 1}
  for(k = low; k &amp;lt;= high; k++) A[k] = B[k];
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;시간 복잡도 nlogn&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;비재귀 합병 정렬 알고리즘&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mergeSort2(A[], n)
//배열 A[0 .. n-1]를 비재귀 합병 정렬을 이용하여 정렬
size = 1
while(size &amp;lt; n){
  for(i = 0; i &amp;lt; n; i = i + 2*size)
      Merge(A,i,i+size-1,i+2*size-1)
  size = size * 2
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;합병 정렬의 단점&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;합병 정렬의 공간 복잡도: 빅오(n)&lt;/li&gt;
  &lt;li&gt;입력을 위한 메모리 공간 외에 추가로 입력과 같은 크기의 공간이 별도로 필요&lt;/li&gt;
  &lt;li&gt;2개의 정렬된 부분을 하나로 합병하기 위해 합병된 결과를 저장할 공간이 필요하기 때문이다&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;빠른-정렬&quot;&gt;빠른 정렬&lt;/h3&gt;

&lt;p&gt;절대적으로 가장 빠른 정렬 알고리즘은 아니지만 평균적으로 매우 효율적이다&lt;/p&gt;

&lt;p&gt;평균 시간복잡도: 빅오(nlogn)&lt;/p&gt;

&lt;p&gt;최악 시간복잡도: 빅오(n의2제곱)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기본 아이디어
    &lt;ol&gt;
      &lt;li&gt;배열을 두 부분으로 분할한다.&lt;/li&gt;
    &lt;/ol&gt;
    &lt;ul&gt;
      &lt;li&gt;배열내의 한 기준 요소보다 작거나 같은 요소들은 앞부분에 놓는다.&lt;/li&gt;
      &lt;li&gt;기준 요소보다 큰 요소들은 모두 뒷부분에 놓는다.
        &lt;ol&gt;
          &lt;li&gt;각 분할된 부분을 재귀적으로 정렬한다.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag06.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 빠른 정렬의 진행과정이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;빠른 정렬 알고리즘&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;quickSort(A[], low, high)
// 배열: A[low .. high]를 빠른 정렬을 이용하여 정렬한다.
// 입력: 정렬할 수 있는 요소들의 배열 A[low .. high]
// 출력: 오름차순으로 정렬된 요소돌의 배열 A[low .. high]
if(low &amp;lt; high){
      s = partition(A,low,high) // 기준 요소 A[low]를 기준으로 분할
      quickSort(A,low,s-1)
      quickSort(A,s+1,high)
 }
 //최초 호출: quickSort(A,0,n-1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;분할 알고리즘&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;partition(A[], low, high)
//입력: 배열 A[0 .. n-1]의 부분 배열 A[low .. high], low &amp;lt; high
//출력: A[low .. high]의 분할 후 기준 요소의 최종 위치(지수)를 반환
i = low + 1
j = high
while( i &amp;lt;= j){
      if(A[i] &amp;lt;= A[low]) i = i + 1
      else if( A[j] &amp;gt; A[low]) j = j -1
      else { A[i] &amp;lt;-&amp;gt; A[j]
              i = i + 1
              j = j - 1
      }
 }
 A[low] &amp;lt;-&amp;gt; A[j]
 return j
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;분할-정복이-부적절한-경우&quot;&gt;분할 정복이 부적절한 경우&lt;/h3&gt;

&lt;p&gt;문제가 분할될 때만다 분할된 부분 문제들의 입력 크기의 합이 분할되기 전의 입력
크기보다 매우 커지는 겨우&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">분할 정복 설계 전략</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">알고리즘의 효율성 분석</title>
      <link href="https://lee989898.github.io/algorithm-02" rel="alternate" type="text/html" title="알고리즘의 효율성 분석" />
      <published>2021-09-24T01:09:00+09:00</published>
      <updated>2021-09-24T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-02</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-02">&lt;h3 id=&quot;알고리즘-분석-체계&quot;&gt;알고리즘 분석 체계&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;입력 크기
  ex) 배열의 크기, 연결 목록의 길이, 행렬에서 행과 열의 크기, 그래프에서 정점과 간선의 수&lt;/li&gt;
  &lt;li&gt;실행 시간 측정 단위
    &lt;ul&gt;
      &lt;li&gt;기본 연산: 알고리즘의 실행 시간에 가장 많이 기여하는 연산&lt;/li&gt;
      &lt;li&gt;실행 시간은 입력 크기가 작으면 거의 차이가 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;증가 차수
    &lt;ul&gt;
      &lt;li&gt;시간 복잡도 함수의 입력 크기(N)에 따른 증가율
        &lt;ul&gt;
          &lt;li&gt;로그 함수: N의 값이 4배 증가할 때 2만큼 증가&lt;/li&gt;
          &lt;li&gt;1차 선형 함수: N의 값에 비례하여 증가&lt;/li&gt;
          &lt;li&gt;2차 선형 함수: N의 값이 4배 증가할 때 16배 증가&lt;/li&gt;
          &lt;li&gt;지수 함수: N의 값이 4배 증가할 때 2의 4 제곱배 증가&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;시간-복잡도&quot;&gt;시간 복잡도&lt;/h3&gt;

&lt;p&gt;공간 복잡도: 알고리즘이 수행되는 동안 요구되는 메모리 공간의 크기를 나타낸다.&lt;/p&gt;

&lt;p&gt;시간 복잡도: 알고리즘이 얼마나 빨리 수행되는지를 나타낸다.
    + 알고리즘의 기본 연산의 수행 횟수를 입력 크기의 함수로 표현
    + 입력 크기뿐만이 아니라 특정 입력 값에도 좌우
    + 복잡도는 입력 크기인 N의 함수로 나타낸다
    + 복잡도 함수는 보통 여러 개의 항들을 갖는 다항식이다.
    + 고차 항이 시간복잡도를 궁극적으로 지배한다.&lt;/p&gt;

&lt;p&gt;시간 복잡도의 분류&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;최악 경우 시간 복잡도
    &lt;ul&gt;
      &lt;li&gt;모든 입력에 대해서 기본 연산이 수행되는 최대 횟수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최선 경우 시간 복잡도
    &lt;ul&gt;
      &lt;li&gt;모든 입력에 대해서 기본 연산이 수행되는 최소 횟수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;평균 경우 시간 복잡도
    &lt;ul&gt;
      &lt;li&gt;모든 입력에 대해서 기본 연산이 수행되는 평균 횟수&lt;/li&gt;
      &lt;li&gt;일반적으로 최악 경우보다 구하기가 어려움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;복잡도를 간단한 함수로 표현하기 위해 점근적 표기 사용&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;O(Big O)-표기: 점근적 상한​&lt;/li&gt;
  &lt;li&gt;Ω(Big Ω)-표기: 점근적 하한​&lt;/li&gt;
  &lt;li&gt;θ(Big Θ)-표기: 점근적 상한이면서 점근적 하한​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag03.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 주요 복잡도 함수의 증가율이다.&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">알고리즘 분석 체계</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">알고리즘</title>
      <link href="https://lee989898.github.io/algorithm-01" rel="alternate" type="text/html" title="알고리즘" />
      <published>2021-09-24T01:09:00+09:00</published>
      <updated>2021-09-24T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-01</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-01">&lt;h3 id=&quot;알고리즘이란&quot;&gt;알고리즘이란?&lt;/h3&gt;

&lt;p&gt;알고리즘&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;문제를 해결하기 위한 단계적 절차 또는 방법&lt;/li&gt;
  &lt;li&gt;순서대로 구체적이고 명확하게 기술해야 함&lt;/li&gt;
  &lt;li&gt;유효한 입력을 받아 실행한 결과인 해(답)를 출력&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag01.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;알고리즘의 3가지 조건&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;명확성
    &lt;ul&gt;
      &lt;li&gt;알고리즘의 각 단계는 애매모호하지 않고 명확해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정확성
    &lt;ul&gt;
      &lt;li&gt;모든 유효한 입력에 대해 올바른 해를 출력해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정지성
    &lt;ul&gt;
      &lt;li&gt;유효한 입력이 주어지면 유한한 시간 내에 종료되어야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;알고리즘의 효율성&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;시간 효율성
    &lt;ul&gt;
      &lt;li&gt;얼마나 빨리 실행되는 지를 나타낸다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;공간 효율성
    &lt;ul&gt;
      &lt;li&gt;컴퓨터 메모리를 얼마나 사용하는지를 나타낸다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;코드 효율성
    &lt;ul&gt;
      &lt;li&gt;코드가 얼마나 이해하기 쉬운가를 나타낸다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;알고리즘적-문제-해결-과정&quot;&gt;알고리즘적 문제 해결 과정&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag02.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;알고리즘의-표현&quot;&gt;알고리즘의 표현&lt;/h3&gt;

&lt;p&gt;알고리즘의 표현&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;자연어(한글 또는 영어)&lt;/li&gt;
  &lt;li&gt;의사 코드(Pseudocode)&lt;/li&gt;
  &lt;li&gt;순서도(Flowchart)&lt;/li&gt;
  &lt;li&gt;프로그래밍 언어(자바, C 또는 파이선 등)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;예: 최댓값 찾기 알고리즘&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;한글
    &lt;ol&gt;
      &lt;li&gt;배열의 첫 번째 요소를 최댓값으로 정한다.&lt;/li&gt;
      &lt;li&gt;배열의 다음 요소가 최댓값보다 크다면 최댓값을 그 요소로 바꾼다.&lt;/li&gt;
      &lt;li&gt;배열 내에 비교할 요소가 남아 있으면 2단계로 가고 아니면 종료한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;의사 코드&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FindMaximum(A[0 . . N - 1])​      
// 배열 내의 최댓값을 찾는다.​      
// 입력: 크기가 N(&amp;gt; 1)인 숫자들의 배열 A​
// 출력: 배열 A내의 최댓값​
max = A[0]​
  
for (i = 1; i &amp;lt; N; i++)​
       if (A[i] &amp;gt; max) max = A[i]​
      ​     
return max​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로그래밍 언어(자바)&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class FindMaximum {​     
        public static void main(String[] args) {​
          int[ ] intArray  =  {72, 60, 83, 47, 89, 95};​
          int   maximum;​
          maximum =  findMaximum(intArray);​
          System.out.println(&quot;최댓값 = &quot; + maximum);​
         }​
        public static int findMaximum(int[ ] A) {​
          int i, max;​
          max = A[0]; ​
      for (i = 1 ; i &amp;lt; A.length ; i++)​
                if (A[i] &amp;gt; max) max = A[i];​
      return  max;​
      }​
   }​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;알고리즘의-분류&quot;&gt;알고리즘의 분류&lt;/h3&gt;

&lt;p&gt;알고리즘 설계 기법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;분할 정복(Divide-and-Conquer)​&lt;/li&gt;
  &lt;li&gt;동적 계획(Dynamic Programming)​&lt;/li&gt;
  &lt;li&gt;탐욕 기법(Greedy Technique)​&lt;/li&gt;
  &lt;li&gt;되추적(Backtracking)​&lt;/li&gt;
  &lt;li&gt;분기한정(Branch-and-Bound)​&lt;/li&gt;
  &lt;li&gt;억지 기법(brute-force technique)​&lt;/li&gt;
  &lt;li&gt;무작위(random) 알고리즘​&lt;/li&gt;
  &lt;li&gt;근사(approximate) 알고리즘​&lt;/li&gt;
  &lt;li&gt;병렬(parallel) 알고리즘​&lt;/li&gt;
  &lt;li&gt;분산(distributed) 알고리즘​&lt;/li&gt;
  &lt;li&gt;양자(quantum) 알고리즘​&lt;/li&gt;
  &lt;li&gt;유전자(genetic) 알고리즘​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;문제 유형에 따른 알고리즘의 분류&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정렬(sorting) 알고리즘​&lt;/li&gt;
  &lt;li&gt;탐색(searching) 알고리즘​&lt;/li&gt;
  &lt;li&gt;문자열 처리(string processing) 알고리즘​&lt;/li&gt;
  &lt;li&gt;그래프(graph) 알고리즘​&lt;/li&gt;
  &lt;li&gt;조합(combinatorial) 알고리즘​&lt;/li&gt;
  &lt;li&gt;기하학적(geometric) 알고리즘​&lt;/li&gt;
  &lt;li&gt;수치(numerical) 알고리즘​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">알고리즘이란?</summary>
      

      
      
    </entry>
  
</feed>
