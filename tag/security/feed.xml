<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://lee989898.github.io/tag/security/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://lee989898.github.io/" rel="alternate" type="text/html" />
  <updated>2021-11-15T21:05:41+09:00</updated>
  <id>https://lee989898.github.io/tag/security/feed.xml</id>

  
  
  

  
    <title type="html">LEE | </title>
  

  
    <subtitle>공부 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">Key Management (KDC &amp;amp; CA)</title>
      <link href="https://lee989898.github.io/sc-13" rel="alternate" type="text/html" title="Key Management (KDC &amp; CA)" />
      <published>2021-11-11T01:06:00+09:00</published>
      <updated>2021-11-11T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-13</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-13">&lt;h3 id=&quot;key-management-kdc--ca&quot;&gt;&lt;strong&gt;Key Management (KDC &amp;amp; CA)&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Session Key&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Session: 회기, 입회기간&lt;/li&gt;
  &lt;li&gt;통신 seesion이 시작될 때 생성되서 종료될때 폐기되는 동적 대칭키&lt;/li&gt;
  &lt;li&gt;통신 session마다 다른 키를 사용하면 안전&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;다중사용자가 세션키사용 할 경우&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;2명의 사용자 간에 1개의 비밀키 사용&lt;/li&gt;
  &lt;li&gt;3명의 사용자 간에 3개의 비밀키 사용&lt;/li&gt;
  &lt;li&gt;사용자 1명 추가 시 3개의 비밀키가 추가로 필요&lt;/li&gt;
  &lt;li&gt;n명이면 n(n-1)/2 만큼의 키가 필요&lt;/li&gt;
  &lt;li&gt;대칭키 유지 및 관리 부하&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;KDC (Key Distribution Centre)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;중앙의 신뢰할 수 있는 키관리, 분배 책임주체&lt;/li&gt;
  &lt;li&gt;사용자들은 KDC 등록신청하면, KDC가 각 사용자들과 비밀키를 공유&lt;/li&gt;
  &lt;li&gt;각 사용자는 이 키를 사용하여 KDC와 통신한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc23.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Operation&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Alice와 Bob은 KDC와의 통신을 위한 $K_{A-KDC}$, $K_{B-KDC}$ 를 알고 있다. Alice는 KDC와 통신하여 세션키 R1 과 $K_{B-KDC}$(A,R1)을 얻는다.
Alice는 Bob에게 $K_{B-KDC}$(A,R1)을 보내고 Bob은 R1을 추출해낸다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;KDC 장단점&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;KDC의 장점
    &lt;ul&gt;
      &lt;li&gt;비밀키 방식은 비교적 속도가 빠름&lt;/li&gt;
      &lt;li&gt;서버를 사용하지 않는 경우보다 키 관리를 쉽게 해줌&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;KDC의 단점
    &lt;ul&gt;
      &lt;li&gt;단일 실패 지점 (SPoF, Single Point of Failure)
        &lt;ul&gt;
          &lt;li&gt;KDC가 고장나면 전혀 서비스를 할 수 없음&lt;/li&gt;
          &lt;li&gt;해결책: 미러 서버 가동
            &lt;ul&gt;
              &lt;li&gt;서버와 미러간의 일관성 문제 발생 가능&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;+KDC가 공격되면 모든 비밀키가 노출될 수 있음&lt;/li&gt;
      &lt;li&gt;KDC의 신뢰성이 매우 중요함&lt;/li&gt;
      &lt;li&gt;KDC에 대한 병목현상 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hierarchical Key Control&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;단일 KDC는 대규모 네트워크에서 비효율적&lt;/li&gt;
  &lt;li&gt;KDC를 계층화
    &lt;ul&gt;
      &lt;li&gt;local KDC
        &lt;ul&gt;
          &lt;li&gt;single LAN or building&lt;/li&gt;
          &lt;li&gt;같은 domain 에서의 통신시 키 분배&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;global KDC
        &lt;ul&gt;
          &lt;li&gt;다른 domain 간의 통신시 키 선택&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;KDC의 손상시 지역에 한정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;CA (Certification Authorities)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;for public key cryptography&lt;/li&gt;
  &lt;li&gt;전자서명을 위해선 신뢰성 있는 공개키 보관장소 필요 해커가 다른 사용자의 공개키를 자기것인 척 하는 것을 방지&lt;/li&gt;
  &lt;li&gt;공인인증서의 발급과 관리하는 기관&lt;/li&gt;
  &lt;li&gt;Role
    &lt;ul&gt;
      &lt;li&gt;사용자들의 공개키를 저장하고 관리&lt;/li&gt;
      &lt;li&gt;사용자들이 요청시 해당 공개키를 서명해서 전송(public key certificate, 공개키 인증서)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Operation&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Bob은 CA에 공개 키를 등록한다
    &lt;ul&gt;
      &lt;li&gt;Bob은 CA에 신원증멸 을 제공한다&lt;/li&gt;
      &lt;li&gt;CA는 Bob을 공개 키에 바인딩하는 인증서를 생성한다&lt;/li&gt;
      &lt;li&gt;CA가 디지털 서명한 Bob의 공개 키를 포함하는 인증서: CA는 “이것은 B의 공개 키이다”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Alice가 Bob의 공개 키를 원할 때:
    &lt;ul&gt;
      &lt;li&gt;Bob의 인증서를 얻는다.&lt;/li&gt;
      &lt;li&gt;CA의 공개 키를 Bob의 인증서에 적용하고 Bob의 공개 키를 가져온다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;공개키 인증서 (공인인증서, Public Key Certificate)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;특정 공개키가 해당 사용자의 공개키임을 신뢰할수있는 기관에서 보증하는 문서 -&amp;gt; 사용자 인증&lt;/li&gt;
  &lt;li&gt;사용자 공개키에 공인인증기관의 전자서명을 첨부한 것&lt;/li&gt;
  &lt;li&gt;4요소
    &lt;ul&gt;
      &lt;li&gt;공개키인증서: 공개키가 누구것인지, 대칭되는 비밀키는 누가 갖고있는지&lt;/li&gt;
      &lt;li&gt;인증서정책: 인증서 사용방식&lt;/li&gt;
      &lt;li&gt;인증서경로: 인증서를 연결하는 방식&lt;/li&gt;
      &lt;li&gt;인증서 철회리스트: 유효성확인&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;공개키 기반구조 (PKI, Public key Infrastructure)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;정의​
    &lt;ul&gt;
      &lt;li&gt;공개키 방식을 통해 암호화 및 전자서명/인증서의 사용을 가능하도록 해주는 기반구조로 X.509(표준), PGP, AADS/X9.59 등 있다​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;​구성 요소​
    &lt;ul&gt;
      &lt;li&gt;사용자 : 개인이나 기관 또는 응용 서비스​&lt;/li&gt;
      &lt;li&gt;인증기관(CA) : 공개키 인증서발급 및 관리​&lt;/li&gt;
      &lt;li&gt;등록기관(registration authority: RA): 사용자 인증서 신청시 인증기관대신 신분확인​&lt;/li&gt;
      &lt;li&gt;저장소(repository): 인증서,사용자정보,인증서취소,상호인증서 등을 저장 검색​&lt;/li&gt;
      &lt;li&gt;인증서정책(policy): 권한, 사용범위 정의​&lt;/li&gt;
      &lt;li&gt;공개키인증서​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;국내 인증기관(CA)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;전자서명법​
    &lt;ul&gt;
      &lt;li&gt;공인인증서: 전자서명을 생성하기 위하여 이용된 정보가 가입자에게 유일하게 속한다는 사실등을 확인하고 증명하는 전자정보. 이름, 유효기관, 발급기관, 전자서명방식, 인증번호등 포함​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;공인인증기관(CA) : 공인인증서의 발급과 관리를 담당하는 기관으로 금융결제원, 한국정보인증, 한국증권전산, 한국전자인증, 한국전산원, 한국무역정보통신, 코스콤​&lt;/li&gt;
  &lt;li&gt;주요역할​
    &lt;ul&gt;
      &lt;li&gt;공개키와 비밀키 생성, 인증서 발급/폐지​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;등록기관(RA, Registration Authority)​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;인증기관의 위임을 받아 사용자가 신청시 신원확인 및 공개키 생성/등록을 수행&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;국내 공인 인증서 발급절차​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;발급기관(CA or RA)에 공인인증서 발급신청(직접방문, 신분증제출)​&lt;/li&gt;
  &lt;li&gt;발급기관에서 등록확인서 발급 (참조번호, 인가코드)​&lt;/li&gt;
  &lt;li&gt;발급기관 홈페이지접속해서 공인인증서 발급 신청​&lt;/li&gt;
  &lt;li&gt;공인인증서 파일이 발급​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">Key Management (KDC &amp;amp; CA)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">접근 제어</title>
      <link href="https://lee989898.github.io/sc-12" rel="alternate" type="text/html" title="접근 제어" />
      <published>2021-11-04T01:06:00+09:00</published>
      <updated>2021-11-04T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-12</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-12">&lt;h3 id=&quot;접근-제어&quot;&gt;&lt;strong&gt;접근 제어&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Access Control&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;허가되지 않은 사용자의 자원 접근 막고&lt;/li&gt;
  &lt;li&gt;정당한 사용자라도 허가되지 않은 방법으로 자원사용 막고&lt;/li&gt;
  &lt;li&gt;정당한 사용자가 허가된 방식으로만 자원에 접근하도록&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Access control components&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc17.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Authentication function: 사용자가 시스템에 접근할 수 있는지 결정&lt;/li&gt;
  &lt;li&gt;Access control function: 사용자의 요청이 허용되는지 결정&lt;/li&gt;
  &lt;li&gt;Security admin: 사용자의 요청이 자원에 어떻게 접근하는지를 명시한 권한 DB를 관리&lt;/li&gt;
  &lt;li&gt;Audit: 사용자가 시스템 자원에 접근하는 것을 기록, 감시&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Access control architecture&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc18.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Access Control Policy&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;접근 제어 정책&lt;/li&gt;
  &lt;li&gt;어떤 상황에서, 누구에게 어떤 종류의 접근이 허용되는지를 결정&lt;/li&gt;
  &lt;li&gt;권한 DB에 저장되며 보안 admin이 관리&lt;/li&gt;
  &lt;li&gt;종류 (동시에 사용가능)
    &lt;ul&gt;
      &lt;li&gt;Discretinoary access control(DAC)&lt;/li&gt;
      &lt;li&gt;Mandatory access control(MAC)&lt;/li&gt;
      &lt;li&gt;Role-based access control(RBAC)&lt;/li&gt;
      &lt;li&gt;Attribute-based access control(ABAC)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Discretinoary access control(DAC)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;임의 접근 제어&lt;/li&gt;
  &lt;li&gt;요청자의 신분에 따라 무엇을 할 수 있는지 정의&lt;/li&gt;
  &lt;li&gt;Window, unix 등 컴퓨터 시스템 널리 사용&lt;/li&gt;
  &lt;li&gt;Access Matrix 사용
    &lt;ul&gt;
      &lt;li&gt;주체와 객체, 권한을 행렬로 표현&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Access matrix
    &lt;ul&gt;
      &lt;li&gt;행: 자원접근 주체, subject&lt;/li&gt;
      &lt;li&gt;열: subject가 접근하는 대상자원, object&lt;/li&gt;
      &lt;li&gt;Entry: 허용되는 접근&lt;/li&gt;
      &lt;li&gt;-Matrix가 커질 수 있고, 희박해지면 메모리 낭비&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc19.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;방법1. ACL - Access control lists
    &lt;ul&gt;
      &lt;li&gt;Access matrix를 열로 분리&lt;/li&gt;
      &lt;li&gt;객체에 대한 권한을 가진 주체 파악에 유리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc20.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;방법2. Capablility tickets
    &lt;ul&gt;
      &lt;li&gt;Access matrix 행으로 분리&lt;/li&gt;
      &lt;li&gt;특정 주체에 대해 승인된 객체와 권한 명시&lt;/li&gt;
      &lt;li&gt;특정 사용자에 허가된 객체/권한들을 정리하기 쉬움&lt;/li&gt;
      &lt;li&gt;다른 주체에서 티켓을 빌려 주거나 양도 -&amp;gt; 보안문제 발생&lt;/li&gt;
      &lt;li&gt;티켓 무결성, 기밀성, 인증성&lt;/li&gt;
      &lt;li&gt;OS가 관리&lt;/li&gt;
      &lt;li&gt;분산, Cloud 환경에 적합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc21.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;방법 3. authorization table
    &lt;ul&gt;
      &lt;li&gt;한 행에 한 주제의 한 자원에 대한 권한명시&lt;/li&gt;
      &lt;li&gt;RDB로 구현 용이&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc22.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;DAC 장단점 분석
    &lt;ul&gt;
      &lt;li&gt;장점
        &lt;ul&gt;
          &lt;li&gt;객체별 세분화된 접근 제어가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;단점
        &lt;ul&gt;
          &lt;li&gt;Access Matrix 사용에 따른 메모리 낭비&lt;/li&gt;
          &lt;li&gt;주체나 객체별로 제어하기 때문에, 전체 자원의 일관성 있는 제어 어려움&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Role-based access control (RBAC)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;각 사용자 대신에 역할에 접근 권할을 할당&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;상업적으로 회사,기관,조직에서 많이 쓰임&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자 vs 역할 vs 자원의 관계는 다대다&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;관계는 동적이다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;RBAC 장단점 분석
    &lt;ul&gt;
      &lt;li&gt;장점
        &lt;ul&gt;
          &lt;li&gt;전체적으로 일관성있는 제어정책가능&lt;/li&gt;
          &lt;li&gt;직무분석 용이&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;단점
        &lt;ul&gt;
          &lt;li&gt;각 주체, 객체별 유연하게 하기 어려움&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Attribute-based access control(ABAC)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;가장 최근&lt;/li&gt;
  &lt;li&gt;주체와 자원의 속성을 표현&lt;/li&gt;
  &lt;li&gt;DAC, RBAC의 기본개념 실형가능&lt;/li&gt;
  &lt;li&gt;유연성과 표현력이 우수&lt;/li&gt;
  &lt;li&gt;3요소 - 속성, 정책 모델, 아키텍처 모델&lt;/li&gt;
  &lt;li&gt;+유연하고 세분화 보안정책 설계&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-설계자 과다업무, 비용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;속성
    &lt;ul&gt;
      &lt;li&gt;주체, 객체, 환경, 권한에 의해 미리 정의되고 할당된 요구되는 동작의 특정 측면을 정의하는 성질​&lt;/li&gt;
      &lt;li&gt;주체 속성​
        &lt;ul&gt;
          &lt;li&gt;주체는 정보가 객체사이에 이동하거나 시스템 상태를 변경하는 능동적 존재(User, application, process, device)​&lt;/li&gt;
          &lt;li&gt;주체의 이름, 소속, 직책 등​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;객체 속성​
        &lt;ul&gt;
          &lt;li&gt;정보를 포함하거나 받는 수동적 시스템 존재 (file, device, table, record, process, program, network)​&lt;/li&gt;
          &lt;li&gt;MS Word문서는 이름, 저자, 날짜 등을 속성으로 가짐​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;환경 속성​
        &lt;ul&gt;
          &lt;li&gt;운영, 기술, 상황, 환경 기술​&lt;/li&gt;
          &lt;li&gt;현재 날짜, 시간, 네트워크 보안 레벨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">접근 제어</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">signature</title>
      <link href="https://lee989898.github.io/sc-10" rel="alternate" type="text/html" title="signature" />
      <published>2021-10-31T01:06:00+09:00</published>
      <updated>2021-10-31T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-10</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-10">&lt;h3 id=&quot;signature&quot;&gt;&lt;strong&gt;signature&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;서명&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;자기의 동일성을 표시하고 책임을 분명하기 하기 위하여 문서 따위에 자기 이름을 써넣음​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;전자서명의 기본 아이디어&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;송신자(alice)는 자신의 비밀키로 암호화​&lt;/li&gt;
  &lt;li&gt;수신자는 송신자의 공개키로 복호화&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;시나리오:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ Bob은 public key를 공개된 장소에 두고, private key는 자신이 가지고 있다
+ Alice는 Bob의 public key를 가져와, 메시지를 암호화해서 전송​
+ 이 메시지는 다른 사람이 보더라도 풀 수 없다. 메시지를 복호화하려면 Bob의 private key가 필요하기 때문-&amp;gt;기밀성보장​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;문제점1. Bob은 Alice가 메시지를 작성했다는것을 확신할 수 있을까? NO​&lt;/li&gt;
  &lt;li&gt;문제점2. Bob은 메시지가 중간에 변경되지않았다는것을 확신할 수 있을까? NO​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;해결법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Alice는 메시지로 MAC을 만들고, 이것을 Alice가 자신의 private key로 암호화 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc05.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;만들어진 것을 본래 메시지에 붙인다 -&amp;gt; 서명&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc06.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이것을 Bob의 public key로 암호화 해서 전송&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;다른 사람은 Bob의 private key가 없으므로 볼수없다 -&amp;gt; 기밀성​&lt;/li&gt;
  &lt;li&gt;Bob은 자신의 private key로 열면 평문과 시그니쳐가 나온다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc07.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Bob은 다음과 같이 무결성,인증을 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc08.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">signature</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">이메일 보안</title>
      <link href="https://lee989898.github.io/sc-11" rel="alternate" type="text/html" title="이메일 보안" />
      <published>2021-10-31T01:06:00+09:00</published>
      <updated>2021-10-31T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-11</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-11">&lt;h3 id=&quot;이메일-보안&quot;&gt;&lt;strong&gt;이메일 보안&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;PGP&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;운영체제에 상관없이 확정성이 뛰어나다&lt;/li&gt;
  &lt;li&gt;S/MIME&lt;/li&gt;
  &lt;li&gt;공개키 기반의 프로토콜이다&lt;/li&gt;
  &lt;li&gt;RSA, El Gamel을 사용한다&lt;/li&gt;
  &lt;li&gt;대칭키 방식과도 연동된다(3DES)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Requirements of secure E-mail&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;기밀성&lt;/li&gt;
  &lt;li&gt;송신자 인증&lt;/li&gt;
  &lt;li&gt;메시지 무결성&lt;/li&gt;
  &lt;li&gt;수신자 인증&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Secure e-mail: 기밀성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc10.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;앨리스는 기밀성을 입증한 e-mail, m을 밥에게 보내고 싶다&lt;/li&gt;
  &lt;li&gt;랜덤 대칭키를 생성한다, K&lt;sub&gt;S&lt;/sub&gt;&lt;/li&gt;
  &lt;li&gt;메시지를  K&lt;sub&gt;S&lt;/sub&gt;로 encrypt한다&lt;/li&gt;
  &lt;li&gt;또한 K&lt;sub&gt;S&lt;/sub&gt;를 밥의 공개키로 encrypt한다&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;밥에게 K&lt;sub&gt;S&lt;/sub&gt;(m)과 K&lt;sub&gt;B&lt;/sub&gt;(K&lt;sub&gt;S&lt;/sub&gt;)를 보낸다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;밥은 그의 private키로 decrypt하여 K&lt;sub&gt;S&lt;/sub&gt;를 찾아낸다&lt;/li&gt;
  &lt;li&gt;K&lt;sub&gt;S&lt;/sub&gt;로 K&lt;sub&gt;S&lt;/sub&gt;(m)을 decrypt하여 m을 찾아낸다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Secure e-mail: 송신자 인증, 무결성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc11.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;앨리스는 송신자 인증과 메시지 무결성을 지키고 싶다&lt;/li&gt;
  &lt;li&gt;앨리스는 메세지를 digitally 사인한다&lt;/li&gt;
  &lt;li&gt;메시지와 디지털 시그니처 모두 보낸다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Secure e-mail: all together&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc12.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;앨리스는 보안,송신자 인증,메시지 무결성을 지키고 싶다&lt;/li&gt;
  &lt;li&gt;앨리스는 3가지 키를 사용한다
    &lt;ul&gt;
      &lt;li&gt;그녀의 private key&lt;/li&gt;
      &lt;li&gt;밥의 public key&lt;/li&gt;
      &lt;li&gt;새로 만들어진 대칭키&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Email 보안 표준&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;PGP&lt;/li&gt;
  &lt;li&gt;S/MIME
    &lt;ul&gt;
      &lt;li&gt;이메일을 위해 MIME에 보안서비스 제공 표준&lt;/li&gt;
      &lt;li&gt;인증,무결성,부인방지,기밀성 제공&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc09.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">이메일 보안</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Hash</title>
      <link href="https://lee989898.github.io/sc-09" rel="alternate" type="text/html" title="Hash" />
      <published>2021-10-23T01:06:00+09:00</published>
      <updated>2021-10-23T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-09</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-09">&lt;h3 id=&quot;hash&quot;&gt;&lt;strong&gt;Hash&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Hash와 관련된 Key Concepts인 Integrity와 Authentication을 다시 한번 살펴보자&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Integrity&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무결성&lt;/li&gt;
  &lt;li&gt;원본 그대로임을 보장&lt;/li&gt;
  &lt;li&gt;변조가 없다는 것 혹은 변경이 있었음을 알게 됨&lt;/li&gt;
  &lt;li&gt;주요 공격: modification&lt;/li&gt;
  &lt;li&gt;Integrity를 지키기 위한 Solution : hash&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Authentication&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;인증&lt;/li&gt;
  &lt;li&gt;송수신자 서로간의 신원 확인&lt;/li&gt;
  &lt;li&gt;주요 공격 : impersonation&lt;/li&gt;
  &lt;li&gt;Authentication을 지키기 위환 solution : 전자서명, 공인인증서&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hash Functions&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;임의의 긴 입력 값을 적절하게 처리하여 고정된 길이의 짧은 값을 출력하는 함수&lt;/li&gt;
  &lt;li&gt;Message Authentication Code로 무결성 제공&lt;/li&gt;
  &lt;li&gt;전자 서명으로 sender authentication 제공&lt;/li&gt;
  &lt;li&gt;공인인증서, 가상화폐 등에 사용&lt;/li&gt;
  &lt;li&gt;컴퓨터보안에서 대표적인 hash function은 MD2,4,5 SHA1, HAS160&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://www.miraclesalad.com/webtools/md5.php&quot;&gt;http://www.miraclesalad.com/webtools/md5.php&lt;/a&gt;&lt;br /&gt;
위 사이트에서 임의의ㅣ 입력값에 대한 해쉬값을 관찰할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;해쉬의 특징으로는 대표적으로 3가지가 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;입력길이에 상관없이 출력길이가 일정&lt;/li&gt;
  &lt;li&gt;조금이라도 입력값이 다르면 출력값은 완전히 다름&lt;/li&gt;
  &lt;li&gt;revers가 어렵다(일방향성)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위 성질중 integrity는 2번에 의해서 보장된다.&lt;br /&gt;
Encrypt/decrypt와의 차이점은 3번이다. 복호화가 어렵기 때문이다.&lt;/p&gt;

&lt;p&gt;예를 들어보자 h(x): x/23해서 소수점 7~10자리 수를 추출&lt;br /&gt;
h(345689) = xx.95652177391&lt;br /&gt;
출력값은 일정하나, reverse는 불가능하다.&lt;/p&gt;

&lt;p&gt;그러나 h(232.8395049993) = 7391 처럼 다른 값을 넣었음에도 값이 같은 일명 collision이 일어날 수 있다.&lt;br /&gt;
Collison은 서로 다른 입력값이 같은 해시값을 계산하는 것을 의미한다.&lt;br /&gt;
충동저항성은 collision이 일어날 확률이 작음을 의미한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;MAC&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;메시지 무결성: 변경되지 않은 원본이 맞음&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc01.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;메시지와 해쉬값을 붙어서 보낸다.&lt;br /&gt;
받는사람은 비교해서 같으면 원본 다르면 원본이 아닌걸 알 수 있다.&lt;br /&gt;
하지만 여기서 sender authenticationd은 제공되지 않는다.&lt;br /&gt;
Digital Signature에서 이문제를 해결한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Digital Signature&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무결성과 인증을 동시에 제공&lt;/li&gt;
  &lt;li&gt;키를 사용한다(키를 모르는 사용자는 생성불가)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc02.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;비교하여 같으면 변조되지 않고 보낸사람을 인증해준다.&lt;br /&gt;
하지만 mac도 한계가 있는데 제 3자에 대한 sender authentication이 불가능 하다.&lt;br /&gt;
키를 모르면 인증을 못하기 때문이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Replay Attack&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc03.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 MAC 공격방법이다.&lt;br /&gt;
Attacker는 고객이 보낸 똑같은 패킷을 복사하여 고객으로 위장하는 공격 방법이다.&lt;br /&gt;
이러한 공격을 막는 방법은 패킷에 추가정보로 시간을 알려주는 time stamp를 넣어 해결할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;대표적인 해쉬 함수로는 두가지 계열이 있는데 MD와 SHA 계열이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;MD (Message Digest)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;MD2,4,5,6​&lt;/li&gt;
  &lt;li&gt;Ron Rivest (RSA), 1990~92​&lt;/li&gt;
  &lt;li&gt;Merkle structure기반​&lt;/li&gt;
  &lt;li&gt;128bit hash 값​&lt;/li&gt;
  &lt;li&gt;512 bit block size ​&lt;/li&gt;
  &lt;li&gt;MD4는 32bit CPU 전용 (MS)​&lt;/li&gt;
  &lt;li&gt;MD5는 SHA1등 최신 해시들의 기초가됨​&lt;/li&gt;
  &lt;li&gt;2005 강한 충돌 내성 깨짐&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;SHA (Secure Hash Algorithm)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;NIST 1993​&lt;/li&gt;
  &lt;li&gt;Merkle structure기반​&lt;/li&gt;
  &lt;li&gt;SHA0,1은 160bit hash 값, SHA2는 224~512bit​&lt;/li&gt;
  &lt;li&gt;512 bit block size ​&lt;/li&gt;
  &lt;li&gt;최대 2^64-1 bit 메시지처리​&lt;/li&gt;
  &lt;li&gt;가장 많이 사용​&lt;/li&gt;
  &lt;li&gt;2005 강한 충돌 내성 깨짐&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc04.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 Merkle structure의 예시이다.&lt;br /&gt;
MD, SHA 두가지 모두 Merkle structure기반인데 이것은
Message를 block으로 나누어서 고정된 길이의 입력값을 받아들여 고정된 길이로 출력하는 압축함수를 반복 사용하여 긴 길이의 입력을 처리할 수 있는 해쉬 함수로 학대하여 설계하는 방식이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hash attack&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;같은 해시값을 갖는 다른 입력값을 찾아낸다​&lt;/li&gt;
  &lt;li&gt;예를 들면, (ID, PWD)값은 해시값으로 저장되어 있다.​&lt;/li&gt;
  &lt;li&gt;만일 같은 해시값을 갖는 (ID2, PWD2)를 찾는다면, (ID, PWD)로 로그인 가능​하다&lt;/li&gt;
  &lt;li&gt;(ID, PWD), (ID2, PWD2)를 충돌쌍(collision pairs)라 한다​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">Hash</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">ECC</title>
      <link href="https://lee989898.github.io/sc-08" rel="alternate" type="text/html" title="ECC" />
      <published>2021-10-14T01:06:00+09:00</published>
      <updated>2021-10-14T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-08</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-08">&lt;h3 id=&quot;ecc&quot;&gt;&lt;strong&gt;ECC&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;ECC&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Public key&lt;/li&gt;
  &lt;li&gt;RSA의 대안&lt;/li&gt;
  &lt;li&gt;암호화는 잘 안 쓰인다 대신 전자서명과 키교환에서 주로 사용&lt;/li&gt;
  &lt;li&gt;회의적 시각 많다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;ECC vs RSA&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;ECC는 이산대수문제 기반&lt;/li&gt;
  &lt;li&gt;A = $B^c$, c 찾기문제&lt;/li&gt;
  &lt;li&gt;RSA보다 작은 길이의 키로 비슷한 보안 제공&lt;/li&gt;
  &lt;li&gt;RSA보다 작은 키를 사용하지만 수학적 계산량 많다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;타원곡선&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;타원곡선은 타원이 아니다&lt;/li&gt;
  &lt;li&gt;타원곡선 방정식을 만족하는 점들의 집합
    &lt;ul&gt;
      &lt;li&gt;$y^2$ = $x^3$ + ax + b&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;타원 곡선 모양&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/sc/sc15.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;타원곡선의 덧셈
    &lt;ul&gt;
      &lt;li&gt;곡선상의 두점 P,Q&lt;/li&gt;
      &lt;li&gt;P + Q는 두 점을 잇는 직선과 타원곡서의 접점을 x축에 대칭&lt;/li&gt;
      &lt;li&gt;여기에 mod p를 한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/sc/sc16.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;EC Discrete Log Problem&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;주어진 조건 ​
    &lt;ul&gt;
      &lt;li&gt;E: an EC over (field of modulo p), p:prime​&lt;/li&gt;
      &lt;li&gt;P: a point in E(Fp), and suppose that P has prime order n​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;키 생성(Key generation)​
    &lt;ul&gt;
      &lt;li&gt;Private key d: selected in random in [1,n-1]​&lt;/li&gt;
      &lt;li&gt;Public key Q =dP, 소수 p, P​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ECDLP: The problem of finding d given the domain parameters and Q  (Q = dP일때, P, Q, p를 알더라도 d를 구하기 어렵다)​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;ElGamal EC Encryption&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Input​
    &lt;ul&gt;
      &lt;li&gt;EC domain para (p,E,P,n), Public key Q,  Plaintext m​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;OutPut
    &lt;ul&gt;
      &lt;li&gt;Ciphertext (C1, C2)​
        &lt;ul&gt;
          &lt;li&gt;Represent the message m as a point M in E​&lt;/li&gt;
          &lt;li&gt;Select k in [1,n-1],  ​&lt;/li&gt;
          &lt;li&gt;Compute C1 = kP, ​&lt;/li&gt;
          &lt;li&gt;Compute   C2 = M + kQ​&lt;/li&gt;
          &lt;li&gt;Return(C1, C2)​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Q = dp일때, P,Q를 알더라도 d를 구하기 어렵다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">ECC</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">ElGamal</title>
      <link href="https://lee989898.github.io/sc-07" rel="alternate" type="text/html" title="ElGamal" />
      <published>2021-10-14T01:06:00+09:00</published>
      <updated>2021-10-14T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-07</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-07">&lt;h3 id=&quot;elgamal&quot;&gt;&lt;strong&gt;ElGamal&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;ElGamal&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Taher Elgamal, 1985 NSF&lt;/li&gt;
  &lt;li&gt;이산대수의 어려움을 이용&lt;/li&gt;
  &lt;li&gt;RSA보다 안전성향상&lt;/li&gt;
  &lt;li&gt;A = $B^c$, c찾기&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Key genetation&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;큰 소수 p, p보다 작은 임의의 g,x 선택&lt;/li&gt;
  &lt;li&gt;Y = $g^x$ mod p를 계산&lt;/li&gt;
  &lt;li&gt;공개키: Y,p,g&lt;/li&gt;
  &lt;li&gt;비밀키: x&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Encryptin/decryption&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;공개키: Y,p,g&lt;/li&gt;
  &lt;li&gt;비밀키: x&lt;/li&gt;
  &lt;li&gt;Encrypt: p-1과 relative prime인 임의의 k(1&amp;lt; k &amp;lt; p-1)&lt;br /&gt;
a = $g^k$  mod p, b = $Y^k$ M mod p 를 계산
    &lt;ul&gt;
      &lt;li&gt;여기서, k를 임의로 선택하기 때문에 동일한 M에 대해서 매번 다르게 암호화된다. (RSA와 차이점)&lt;/li&gt;
      &lt;li&gt;Ciphertext는 dnjsfo M 길이의 2배가 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Decrypt: b/$a^x$ mod p = $y^k$ M / $a^x$ mod p = M&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;ElGamal 서명 기법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;RSA와 달리 서명만을 위해 설계됨&lt;/li&gt;
  &lt;li&gt;ElGamal 서명기법은 약간 변형된 형태로 NIST의 디지털 서명 표준(DSS)으로 채택&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">ElGamal</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">RSA</title>
      <link href="https://lee989898.github.io/sc-06" rel="alternate" type="text/html" title="RSA" />
      <published>2021-09-29T01:06:00+09:00</published>
      <updated>2021-09-29T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-06</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-06">&lt;h3 id=&quot;rsa&quot;&gt;&lt;strong&gt;RSA&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;RSA&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;1978, MIT&lt;/li&gt;
  &lt;li&gt;가장 널리 사용 (공인인증서 등)&lt;/li&gt;
  &lt;li&gt;Key size = 1024 ~ 4096 bits&lt;/li&gt;
  &lt;li&gt;DES is 100 times faster in S/W and 10000 times faster in H/W&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;RSA Algorithm&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;키 생성 부분과 암/복호화 부분으로 구성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Part 1. 키생성
    &lt;ul&gt;
      &lt;li&gt;Public key : e, n&lt;/li&gt;
      &lt;li&gt;Private key: d&lt;/li&gt;
      &lt;li&gt;2개 큰 소수 p,q 선정 n = p * q , p , q는 secret, n은 공개&lt;/li&gt;
      &lt;li&gt;Public key e는 φ(n) = (p-1)(q-1)과 relative prime하게 선정(유클리드 algorithm), e는 공개&lt;/li&gt;
      &lt;li&gt;e * d mod φ(n) = 1 인 private key d를 계산(extended euclid algorithm) d는 secret&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Part 2. 암호화/복호화&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Encryption&lt;/li&gt;
  &lt;li&gt;Receiver의 public key (e,n)을 받는다&lt;/li&gt;
  &lt;li&gt;Message M을 정수로 전환하여&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;E(M) = $M^e$(mod n) = C를 계산&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Decryption&lt;/li&gt;
  &lt;li&gt;D(c) = $C^d$ (mod n) = M (fermat, ouler)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;RSA 안정성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;해커는 공개키(E,N), 암호문 C를 쉽게 얻을 수 있음&lt;/li&gt;
  &lt;li&gt;비밀키 D를 얻으려면 N을 인수분해하여 φ(N)를 구해야함&lt;/li&gt;
  &lt;li&gt;큰 수에 대한 인수분해는 매무 많은 수행시간 요구 (현재 brute force외에 방법없음)&lt;/li&gt;
  &lt;li&gt;양자 컴퓨터&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">RSA</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Public Key Cipher</title>
      <link href="https://lee989898.github.io/sc-04" rel="alternate" type="text/html" title="Public Key Cipher" />
      <published>2021-09-23T01:06:00+09:00</published>
      <updated>2021-09-23T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-04</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-04">&lt;h3 id=&quot;public-key-cipher&quot;&gt;&lt;strong&gt;Public Key Cipher&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Symmetric vs public key&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Encryption key와 decryption key 동일 여부&lt;/li&gt;
  &lt;li&gt;같으면 symmetric, 다르면 public key&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Why no Symmetric key?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Symmetric은 빠르고, 안전하다&lt;/li&gt;
  &lt;li&gt;동일한 키를 나눠 갖기 어렵다&lt;/li&gt;
  &lt;li&gt;인터넷에서 키를 나눠 갖기 어렵다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Public key Cipher&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;송신자, 수신자가 키를 나누어 가지 필요가 없다&lt;/li&gt;
  &lt;li&gt;private,public키 2가지를 나눠 갖는다&lt;/li&gt;
  &lt;li&gt;Public key로 잠그면 private key로 열고, private key로 잠그면 public key로 열린다&lt;/li&gt;
  &lt;li&gt;Internet환경에서 대표적으로 사용&lt;/li&gt;
  &lt;li&gt;RSA(99%), ECC, El Gammal&lt;/li&gt;
  &lt;li&gt;주로 수학적 이론에 바탕 -&amp;gt; 정수론 필요&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">Public Key Cipher</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Number Theory for RSA</title>
      <link href="https://lee989898.github.io/sc-05" rel="alternate" type="text/html" title="Number Theory for RSA" />
      <published>2021-09-23T01:06:00+09:00</published>
      <updated>2021-09-23T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-05</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-05">&lt;h3 id=&quot;number-theory-for-rsa&quot;&gt;&lt;strong&gt;Number Theory for RSA&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;–&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Introduction&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;number theory = 정수론&lt;/li&gt;
  &lt;li&gt;a branch of pure mathematics devoted primarily to the study of the integers&lt;/li&gt;
  &lt;li&gt;숫자의 성질을 탐구&lt;/li&gt;
  &lt;li&gt;수학은 과학의 여왕, 정수론은 수학의 여왕(여기서는 양의 정수만 다룬다)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;약수&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;어던 수 m에 대해서 a = mb 라면
    &lt;ul&gt;
      &lt;li&gt;b $\neq$ 0 일때 b는 a를 나눈다 =&amp;gt; 약수&lt;/li&gt;
      &lt;li&gt;여기서 a,b,m은 정수&lt;/li&gt;
      &lt;li&gt;나눗셈에서 나머지가 없을 때 약수라고 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예) 24의 양의 약수
    &lt;ul&gt;
      &lt;li&gt;1,2,3,4,6,8,12,24&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;소수 (Prime numbers)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;어떤 수 p의 약수가 $\pm$ 1과 $\pm$ p만을 가진다면 p는 소수이다.&lt;/li&gt;
  &lt;li&gt;1과 자신이외의 자연수로 나눌수 없는 1보다 큰 자연수&lt;/li&gt;
  &lt;li&gt;고대 이집트 파피루스에도 기록&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;소수 찾기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;어떤 자연수 n이 소수인지는 root(n)까지의 수 중 1을 제외한 약수가 있는지 확인&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;소수의 분포에 규칙성이 있을까? (리만의 가설)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;소인수 분해&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;어떠한 정수 a&amp;gt;1은 다음과 같이 유일하게 소수의 곱으로 표현가능
    &lt;ul&gt;
      &lt;li&gt;a = $p_1^{a1}$ $p_2^{a2}$ … $p_t^{at}$&lt;/li&gt;
      &lt;li&gt;$p_t$ &amp;gt; $p_{t-1}$ &amp;gt; … $p_1$ 는 소수, $a_1$ &amp;gt; 0&lt;/li&gt;
      &lt;li&gt;예) 91 = 7x13, 3600 = $2^4$ x $3^2$ x $5^2$ , 10164 = 7 x $11^2$ x 12&lt;/li&gt;
      &lt;li&gt;하지만, 여기서 7 x $11^2$ x 12 -&amp;gt; 10164는 쉽지만 역은 어렵다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;서로소 (relatively prime number)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;어떤 두 수가 공통적인 소인수를 갖지 못할 때 두 수는 서로소&lt;/li&gt;
  &lt;li&gt;두 수의 최대 공약수가 1이면 서로소&lt;/li&gt;
  &lt;li&gt;8과 15는 서로소인가? 서로소이다&lt;/li&gt;
  &lt;li&gt;모든 정수의 솟수 표현법을 이용하면 최대 공약수 결정이 쉬워짐
    &lt;ul&gt;
      &lt;li&gt;300 = $2^2$ x $3^1$ x $5^2$, 18 = $2^1$ x $3^2$&lt;/li&gt;
      &lt;li&gt;GCD(300,18) = $2^1$ x $3^1$ x $5^0$ = 6&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;모듈러 연산 (mod)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;나머지 연산&lt;/li&gt;
  &lt;li&gt;a mod b: a를 b로 나눈 나머지&lt;/li&gt;
  &lt;li&gt;어떤 양의 정수 n과 a가 주어지고, 만약 a를 n으로 나눈다면 다음과 같은 관계를 가지고 몫 q와 나머지 r을 얻는다
    &lt;ul&gt;
      &lt;li&gt;a = qn + r&lt;/li&gt;
      &lt;li&gt;a = r mod n&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;example: a =11, n = 7
    &lt;ul&gt;
      &lt;li&gt;11 = 1 x 7 + 4 = 4 mod 7&lt;/li&gt;
      &lt;li&gt;11 = 4 mod 7&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모듈러 연산자 특성
    &lt;ul&gt;
      &lt;li&gt;[(a mod n) + (b mod n)] mod n = (a+b) mod n&lt;/li&gt;
      &lt;li&gt;[(a mod n) x (b mod n)] mod n = (axb) mod n&lt;/li&gt;
      &lt;li&gt;(w + x) mod n = (x+w) mod n (교환법칙)&lt;/li&gt;
      &lt;li&gt;(w * x) mod n = (x * w) mod n (교환법칙)&lt;/li&gt;
      &lt;li&gt;[ (w+x)+y ] mod n = [ w + (x+y) ] mod n (결합법칙)&lt;/li&gt;
      &lt;li&gt;[ (w * x) * y ] mod n = [ w * (x * y) ] mod n (결합법칙)&lt;/li&gt;
      &lt;li&gt;[ w *  (x + y) ] mod n = [( w * x) + (w * y)] mod n (분배법칙)&lt;/li&gt;
      &lt;li&gt;(0 + w) mod n = w mod n&lt;/li&gt;
      &lt;li&gt;(1 * w) mod n = w mod n&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모듈러 연산의 항등원과 역원
    &lt;ul&gt;
      &lt;li&gt;항등원
        &lt;ul&gt;
          &lt;li&gt;어떤 원소와 연산을 해도 자기 자신이 되게 하는 원소&lt;/li&gt;
          &lt;li&gt;항등원을 만들어 주는 유일한 원소가 역원&lt;/li&gt;
          &lt;li&gt;모듈러 연산의 역원은?&lt;/li&gt;
          &lt;li&gt;mod 5 연산, 3의 곱셉의 역원은?
            &lt;ul&gt;
              &lt;li&gt;(3 * ?) mod 5 = 1 ?는 mod 5 연산에 대한 3의 곱셉의  역원&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;합동 (Congruent)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;(a mod n) = (b mod n), e두 정수 a와 b는 modulo n에 대해 합동&lt;/li&gt;
  &lt;li&gt;a $\equiv$ b mod n으로 표기&lt;/li&gt;
  &lt;li&gt;예를 들어, 14와 20은 mod 6에 대하여 합동&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;페르마 정리 (Fermat Theorem)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;만약 p가 소수라면 a는 p에 의해 나누어지지 않는 양의 정수이면, 다음이 성립한다
    &lt;ul&gt;
      &lt;li&gt;$a^{p-1}$ $\equiv$ 1 mod p&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;페르마 정리의 다른 유용한 형태
    &lt;ul&gt;
      &lt;li&gt;만약 p가 소수이고 a가 양의 정수라면 $a^p$ $\equiv$ a mod p가 성립한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;오일러 정리 (Euler Theorem)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;오일러의 Totient 함수
    &lt;ul&gt;
      &lt;li&gt;정수론에서 오일러의 totient 함수는 φ(n)라고 표기된다&lt;/li&gt;
      &lt;li&gt;φ(n): n보다 작고 n과 서로 소인 양의 정수의 개수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;오일러 함수의 특성
    &lt;ul&gt;
      &lt;li&gt;φ(1) = 1&lt;/li&gt;
      &lt;li&gt;소수n에 대해서 φ(n) = n - 1&lt;/li&gt;
      &lt;li&gt;소수 p와 q에 대해서 n = pq
        &lt;ul&gt;
          &lt;li&gt;φ(n) = φ(pq) = φ(p) * φ(q) = (p-1)(q-1)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;오일러 정리
    &lt;ul&gt;
      &lt;li&gt;서로소인 모든 a와 n에 대한 관계를 나타낸다ㅏ
        &lt;ul&gt;
          &lt;li&gt;$a^{φ(n)}$ $\equiv$ 1 mod n&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;오일러 정리의 추가적인 특성
    &lt;ul&gt;
      &lt;li&gt;$a^{φ(n)+1}$ $\equiv$ a mod n&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이러한 속성은 RSA 알고리즘의 유용성을 증명할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;확장된 유클리드 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;유클리드 알고리즘
    &lt;ul&gt;
      &lt;li&gt;두 양의 정수들에 대한 최대 공약수 찾기&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;확장된 유클리드 알고리즘
    &lt;ul&gt;
      &lt;li&gt;한 수에 대한 곱셈의 역원 결정&lt;/li&gt;
      &lt;li&gt;만약 GCD(d,f)=1이라면 그때 d는 modulo f 상에서 곱셉에 대한 역원을 갖는다&lt;/li&gt;
      &lt;li&gt;양의 정수 d &amp;lt; f에 대해, d $d^{-1}$ = 1 mod f인 $d^{-1}$ &amp;lt; f가 유일하게 존재&lt;/li&gt;
      &lt;li&gt;알고리즘은 $d^{-1}$를 찾아주는 것이다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">Number Theory for RSA</summary>
      

      
      
    </entry>
  
</feed>
