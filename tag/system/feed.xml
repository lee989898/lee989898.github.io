<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://lee989898.github.io/tag/system/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://lee989898.github.io/" rel="alternate" type="text/html" />
  <updated>2021-12-24T17:41:23+09:00</updated>
  <id>https://lee989898.github.io/tag/system/feed.xml</id>

  
  
  

  
    <title type="html">LEE | </title>
  

  
    <subtitle>공부 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">POSIX Thread Programming</title>
      <link href="https://lee989898.github.io/st-10" rel="alternate" type="text/html" title="POSIX Thread Programming" />
      <published>2021-11-24T01:06:00+09:00</published>
      <updated>2021-11-24T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/st-10</id>
      <content type="html" xml:base="https://lee989898.github.io/st-10">&lt;h3 id=&quot;posix-thread-programming&quot;&gt;&lt;strong&gt;POSIX Thread Programming&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;thread-overview-&quot;&gt;Thread Overview ​&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스처럼 독립적으로 수행되는 프로그램 코드​
    &lt;ul&gt;
      &lt;li&gt;“경량 프로세스(light-weight process)”라고도 함​&lt;/li&gt;
      &lt;li&gt;“프로세스 내에서 독립적으로, 순차적으로 수행되는 instruction stream 또는 제어의 흐름”이라고도 함​&lt;/li&gt;
      &lt;li&gt;여러 스레드는 동시에 실행이 가능​&lt;/li&gt;
      &lt;li&gt;스레드들의 실행에 관한 스케쥴링은 OS가 담당​&lt;/li&gt;
      &lt;li&gt;싱글 코어에서도 여러 스레드의 실행이 가능 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;한 프로세스내의 스레드들은 같은 주소 공간을 사용 ​
    &lt;ul&gt;
      &lt;li&gt;공유 매모리를 이용하여 스레드간의 통신을 이용함으로써 복잡한 프로세스간 통신(IPC) 기능을 사용하지 않아도 됨​&lt;/li&gt;
      &lt;li&gt;스레드간의 통신 비용이 IPC 비용보다 낮음​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st25.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Process는 실행을 위하여 resource들이 필요하며 실행 상태를 메모리에 저장 ​
    &lt;ul&gt;
      &lt;li&gt;Process ID, group ID, … ​&lt;/li&gt;
      &lt;li&gt;Program instructions​&lt;/li&gt;
      &lt;li&gt;Registers, Stack​&lt;/li&gt;
      &lt;li&gt;Heap ​&lt;/li&gt;
      &lt;li&gt;File descriptor, …​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Thread는 Process 내부에 존재하면서 resource들을 같이 사용 ​
    &lt;ul&gt;
      &lt;li&gt;Registers, stack, 등은 thread 별로 따로 존재  ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st26.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;공통 스레드 구현​
    &lt;ul&gt;
      &lt;li&gt;병렬 소스 코드 내에서 호출되는 서브루틴 라이브러리&lt;/li&gt;
      &lt;li&gt;직렬 또는 병렬 소스 코드에 포함된 컴파일러 지시문 세트&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스레드 구현은 컴퓨팅에서 새로운 것이 아니다
    &lt;ul&gt;
      &lt;li&gt;역사적으로 하드웨어 공급업체는 고유한 스레드 버전을 구현했다&lt;/li&gt;
      &lt;li&gt;이러한 구현은 서로 상당히 다르다&lt;/li&gt;
      &lt;li&gt;프로그래머가 휴대용 스레드 응용 프로그램을 개발하기 어려움​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;관련 없는 표준화 노력으로 인해 두 개의 매우 다른 스레드 구현이 발생했다
    &lt;ul&gt;
      &lt;li&gt;POSIX Threads (Pthread)​&lt;/li&gt;
      &lt;li&gt;OpenMP​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;pthread-introduction-&quot;&gt;Pthread Introduction ​&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;IEEE POSIX (Portable Operating System Interface for UNIX) 1003.1c Standard​
    &lt;ul&gt;
      &lt;li&gt;과거에 하드웨어 업체별로 각각 제작되어 사용되었던 스레드에 관한 구현을 표준화 ​&lt;/li&gt;
      &lt;li&gt;이 표준에 따라 구현된 스레드를 POSIX Thread 또는 Pthread로 부름​
        &lt;ul&gt;
          &lt;li&gt;스레드를 생성하고 동기화하는 system call 들로 구성​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;표준화는 계속 진행 중​
        &lt;ul&gt;
          &lt;li&gt;가장 최근의  표준은 IEEE Std 1003.1, 2004 Edition​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;C-프로그래밍 언어의 type과 procedure call의 집합으로 정의 ​
    &lt;ul&gt;
      &lt;li&gt;
        &lt;pthread.h&gt; header 파일 및 thread library로 구현​
&lt;/pthread.h&gt;
        &lt;ul&gt;
          &lt;li&gt;libc library의 일부로 구현되기도 함​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;우수한 성능 : 프로세스와 비교​
    &lt;ul&gt;
      &lt;li&gt;스레드 생성에 드는 OS overhead가 프로세스 생성에 비해 현격히 낮음​
        &lt;ul&gt;
          &lt;li&gt;50,000번의 프로세스 생성(fork() 사용) vs. 스레드 생성(pthread_create() 사용) ​&lt;/li&gt;
          &lt;li&gt;실행 시간의 단위는 second, time 커맨드에 의해 측정​&lt;/li&gt;
          &lt;li&gt;스레드 관리에 드는 resource도 프로세스에 비해 현격히 적음​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pthread에서는 ​
    &lt;ul&gt;
      &lt;li&gt;Parallelism 생성​&lt;/li&gt;
      &lt;li&gt;동기화(synchronization)​을 지원함​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Communication에 대한 explicit한 지원은 없음​
    &lt;ul&gt;
      &lt;li&gt;Shared-memory 모델이므로 communication은 implicit하게 일어남​
​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스레드의 상태​
    &lt;ul&gt;
      &lt;li&gt;준비(ready) : 스레드가 실행될 수 있는 상태​&lt;/li&gt;
      &lt;li&gt;실행(running) : CPU의 서비스를 받고 있는 상태​&lt;/li&gt;
      &lt;li&gt;블록(block) : sleep(), read(), 세마포어 연산 등으로 기다리는 상태​&lt;/li&gt;
      &lt;li&gt;종료(terminated) : 스레드가 종료 또는 취소된 상태​
​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;준비 상태​
    &lt;ul&gt;
      &lt;li&gt;스레드가 처음 생성되면 준비 상태로 감​&lt;/li&gt;
      &lt;li&gt;CPU의 서비스를 받을 수 있는 상태​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실행 상태​
    &lt;ul&gt;
      &lt;li&gt;OS의 스케줄러에 의해 CPU의 서비스를 받고 있는 상태​&lt;/li&gt;
      &lt;li&gt;스케줄링에 의해 준비상태로 갈 수 있음​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;블록 상태​
    &lt;ul&gt;
      &lt;li&gt;실행 상태에서 즉시 처리할 수 없는 작업을 만나는 경우​
        &lt;ul&gt;
          &lt;li&gt;read(), wait(), sleep(), 세마포어/뮤텍스/조건변수를 기다리는 경우​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;원하는 조건이 만족되면 준비 상태가 됨​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;종료 상태​
    &lt;ul&gt;
      &lt;li&gt;스레드 시작함수에서 return 또는 pthread_exit()가 호출된 경우​&lt;/li&gt;
      &lt;li&gt;사용하던 자원의 대부분을 시스템에 반납​&lt;/li&gt;
      &lt;li&gt;종료 상태 값을 부모 스레드에게 넘겨주기 위한 자원은 부모 스레드에서 pthread_join()을 통해 읽어가면 완전히 삭제​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Application 프로그램은 하나의 스레드로 시작​
    &lt;ul&gt;
      &lt;li&gt;Main 스레드 또는 master 스레드로 불림 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;pthread_create() 호출에 의해 새로운 child 스레드를 생성​
    &lt;ul&gt;
      &lt;li&gt;새로운 child 스레드의 생성은 procedure 호출의 형태를 띔​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;pthread_exit() 또는 pthread_join() 호출에 의해 새로 생성되었던 스레드 종료​
    &lt;ul&gt;
      &lt;li&gt;Master 스레드만 남게 됨​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st27.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;스레드 생성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int pthread_create (​
  pthread_t   *thread, // 생성된 스레드의 핸들 ​
  pthread_attr_t   *attr, // 스레드 속성을 지정하는 인자​
  void   *(*start_routine) (void *), // 스레드 시작함수(start routine) 주소​
  void   *arg ) // 스레드 시작 함수의 인자(들)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;thread : 새로운 child 스레드가 성공적으로 생성될 경우 생성된 스레드의 핸들​&lt;/li&gt;
  &lt;li&gt;attr : 생성되는 child 스레드의 속성을 지정(디폴트 값은 NULL)​&lt;/li&gt;
  &lt;li&gt;start_routine : 새로 생성되는 child 스레드를 지정하는 함수의 시작 주소​&lt;/li&gt;
  &lt;li&gt;arg : 시작 함수들의 인자(들)​&lt;/li&gt;
  &lt;li&gt;리턴 값 ​
    &lt;ul&gt;
      &lt;li&gt;성공시 0을 리턴​&lt;/li&gt;
      &lt;li&gt;에러 발생시 에러코드의 정수 값(errno)을 리턴​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Pthread 프로그램 컴파일&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;일반적으로 –lpthread 옵션이 필요​
    &lt;ul&gt;
      &lt;li&gt;스레드 라이브러리가 다른 라이브러리(예 : libc)에 통합된 경우는 불필요 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;-D_REENTRANT 옵션​
    &lt;ul&gt;
      &lt;li&gt;멀티 스레드 환경에서 싱글 스레드의 경우와 구별된 errno를 사용하도록 함​&lt;/li&gt;
      &lt;li&gt;일반 함수들이 멀티 스레드 환경에 적합하게 동작하도록 함​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컴파일 예제​
    &lt;ul&gt;
      &lt;li&gt;Linux/GCC의 경우​
        &lt;ul&gt;
          &lt;li&gt;% gcc test.c –lpthread (-lpthread 옵션에 –D_REENTRANT 포함)​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Solaris/Studio 컴파일러의 경우​
        &lt;ul&gt;
          &lt;li&gt;% cc –mt test.c (-mt 옵션에 –D_REENTRANT 포함, 스레드 라이브러리는 libc 라이브러리에 포함됨) ​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;스레드 종료&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void  pthread_exit(void   *retval);​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;생성된 child 스레드의 종료​
    &lt;ul&gt;
      &lt;li&gt;프로세스와 마찬가지로 return을 만나면 종료​&lt;/li&gt;
      &lt;li&gt;또는 pthread_exit() 호출시 종료​&lt;/li&gt;
      &lt;li&gt;pthread_exit() 호출에 의해 child 스레드가 종료할 경우 할당되었던 자원들은 반납되지 않음​&lt;/li&gt;
      &lt;li&gt;나중에 pthread_join() 호출에 의해 반납됨 ​&lt;/li&gt;
      &lt;li&gt;Detach 된 스레드는 예외  ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int  pthread_join(pthread_t   thrd,   void   **thread_return);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Parent 스레드에서 호출​
    &lt;ul&gt;
      &lt;li&gt;자신이 생성한 child 스레드가 종료할 때까지 기다림​
        &lt;ul&gt;
          &lt;li&gt;thrd​
            &lt;ul&gt;
              &lt;li&gt;종료를 기다릴 스레드의 핸들​&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;thread_return​
            &lt;ul&gt;
              &lt;li&gt;child 스레드의 종료 상태가 저장됨​&lt;/li&gt;
              &lt;li&gt;NULL로 하면 종료 상태를 받지 않음​&lt;/li&gt;
              &lt;li&gt;child 스레드의 종료값은 return, pthread_exit()로 남길 수 있음​&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Child 스레드가 종료되기 전에 parent 스레드가 먼저 종료되지 않게 할 때 사용​
    &lt;ul&gt;
      &lt;li&gt;Parent 스레드가 종료하면 child 스레드가 함께 종료되며​&lt;/li&gt;
      &lt;li&gt;Child 스레드의 작업이 모두 이루어 지지 않은 상태일 수 있음​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Child 스레드의 종료 시점을 정확히 파악하여 어떤 작업을 하고 싶거나 종료 상태 값을 얻기 위해 사용​&lt;/li&gt;
  &lt;li&gt;종료된 child 스레드에 할당되었던 resource 들은 반납됨 ​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;스레드 Detach&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int   pthread_detach(pthread_t   thrd);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Detached 스레드​
    &lt;ul&gt;
      &lt;li&gt;Join이 가능한 스레드(pthread_join()을 사용)와 대비​&lt;/li&gt;
      &lt;li&gt;Parent 스레드가 생성한 child 스레드에 대해 pthread_detach()를 호출하면 parent 스레드가 나중에 wait하지 않음​
        &lt;ul&gt;
          &lt;li&gt;빠른 스레드의 실행에 도움이 됨​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Detach 된 스레드에 pthread_join()를 호출하면 error 발생​&lt;/li&gt;
      &lt;li&gt;Detach 된 스레드는 pthread_join() 호출 없이 할당되었던 resources 들이 반납됨 
​
        &lt;blockquote&gt;
          &lt;p&gt;스레드 Attribute&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스레드의 attribute는 스레드가 생성될 때 설정됨
    &lt;ul&gt;
      &lt;li&gt;이미 생성된 스레드의 attribute 값을 바꾸는 것은 제한적인 경우에만 가능 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;따라서 pthread_create를 호출하기 전에 원하는 attribute 값들을 설정해야 ​&lt;/li&gt;
  &lt;li&gt;Attribute 설정과 관련된 pthread API
    &lt;ul&gt;
      &lt;li&gt;pthread_attr_init()​&lt;/li&gt;
      &lt;li&gt;pthread_attr_destroy()​&lt;/li&gt;
      &lt;li&gt;pthread_attr_setdetachstate()​&lt;/li&gt;
      &lt;li&gt;pthread_attr_getstacksize()​&lt;/li&gt;
      &lt;li&gt;pthread_attr_setstacksize()​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스레드는 joinable 또는 detached 스레드로 생성 가능​&lt;/li&gt;
  &lt;li&gt;Default stack size는 OS 마다 다른 값을 지정​&lt;/li&gt;
  &lt;li&gt;최소 스택 크기는 변수 PTHREAD_STACK_MIN에 저장된다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;기타 스레드 Attribute들&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Guard size: 스택 오버플로로부터 보호하기 위해 사용&lt;/li&gt;
  &lt;li&gt;스케줄링 속성 상속(스레드 생성에서) or not&lt;/li&gt;
  &lt;li&gt;Scheduling parameter(s): 특히 스레드 우선순위&lt;/li&gt;
  &lt;li&gt;Scheduling policy: FIFO or Round Robin​&lt;/li&gt;
  &lt;li&gt;Contention scope: 이 스레드는 어떤 스레드와 CPU를 놓고 경쟁하는가&lt;/li&gt;
  &lt;li&gt;Stack address: 스택의 위치를 ​​명시적으로 지정&lt;/li&gt;
  &lt;li&gt;Lazy stack allocation: 요청 시 할당(lazy) 또는 한 번에 모두 선행&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;synchronization&quot;&gt;Synchronization​&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;스레드의 동기화 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;여러 스레드가 공유 데이터에 접근하여 값들을 읽거나 저장
    &lt;ul&gt;
      &lt;li&gt;Run time 에 공유 데이터가 어떤 값을 가질지 예측하기 어려움​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Data race 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;두 개 이상의 스레드가 같은 변수를 access, 그 중 적어도 하나의 access는 write 연산을 실행​&lt;/li&gt;
  &lt;li&gt;Access들이 동시에 발생, 그러나 동기화되지 않은 상태로&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;기본적인 동기화 Mechanism: Mutex&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;스레드들이 서로 배타적으로 공유데이터에 접근하도록 하기위해 Mutex (mutual exclusion)를 사용​
    &lt;ul&gt;
      &lt;li&gt;스레드들은 거의 독립적으로 실행​&lt;/li&gt;
      &lt;li&gt;Common한 data structure를 사용함​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Mutex외에도 세마포어를 많이 사용​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Mutex 사용방법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Critical 영역에 들어가기 전에 mutex 를 잠금​&lt;/li&gt;
  &lt;li&gt;Critical 영역에서 나오면서 mutex 잠금을 해제​&lt;/li&gt;
  &lt;li&gt;다른 스레드들은 이 mutex 잠금이 해제될 때까지 대기​&lt;/li&gt;
  &lt;li&gt;Mutex 사용 절차&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pthread_mutex_t mutex; // 뮤텍스 선언​
Pthread_mutex_init(&amp;amp;mutex); // 뮤텍스 초기화 작업​
pthread_mutex_lock(mutex); // 뮤텍스 잠금​
... // 공유데이터(크리티컬 영역) 액세스​
pthread_mutex_unlock(mutex); // 뮤텍스 잠금 해제​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Mutex 선언 및 초기화&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Mutex의 변수 타입 : pthread_mutex_t​&lt;/li&gt;
  &lt;li&gt;여러 스레드들이 사용하므로 전역 변수로 선언​&lt;/li&gt;
  &lt;li&gt;반드시 초기화를 해야 사용 가능​&lt;/li&gt;
  &lt;li&gt;초기화 방법​
    &lt;ul&gt;
      &lt;li&gt;함수를 통한 초기화​&lt;/li&gt;
      &lt;li&gt;매크로를 통한 초기화​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Mutex 초기화에 특별한 타입을 지정하지 않음 ​&lt;/li&gt;
  &lt;li&gt;단 한 번의 잠금만 허용​
    &lt;ul&gt;
      &lt;li&gt;스레드 A가 잠금을 하고 있는 상황에서 스레드 B가 잠금을 시도하면 B는 A의 잠금이 해제될 때까지 기다림​&lt;/li&gt;
      &lt;li&gt;A에 의해 잠긴 뮤텍스에 대해 A가 다시 잠금을 시도하면 deadlock이 발생하여 A는 영원히 블록 상태가 됨​&lt;/li&gt;
      &lt;li&gt;이러한 현상을 피하기 위해 pthread_mutex_trylock()을 사용​&lt;/li&gt;
      &lt;li&gt;Mutex를 얻지 못하는 경우 블록되지 않고 바로 리턴되고 EBUSY 에러 발생​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;잠금되어 있는 않은 mutex에 잠금해제를 시도하면 아무 동작을 하지 않음​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Mutex의 삭제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;더 이상 mutex를 사용하지 않을 때 삭제​&lt;/li&gt;
  &lt;li&gt;잠금 상태의 mutex를 삭제하려 시도하면 에러 발생​
    &lt;ul&gt;
      &lt;li&gt;EBUSY 에러 발생​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Mutex의 현재 상태(잠금, 잠금해제) 확인 함수는 없음​&lt;/li&gt;
  &lt;li&gt;안전하게 mutex를 삭제하기 위해서는 삭제 전에 무조건 mutex를 해제해야 함​&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pthread_mutex_unlock(&amp;amp;mutex);​
pthread_mutex_destory(&amp;amp;mutex);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Mutex와 deadlock&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Deadlock​
    &lt;ul&gt;
      &lt;li&gt;두 개의 스레드가 두 개의 mutex를 사용​&lt;/li&gt;
      &lt;li&gt;각 스레드가 mutex를 하나씩 잠그고 있는 상태에서 상대방의 mutex 해제를 기다리는 현상​&lt;/li&gt;
      &lt;li&gt;deadlock이 발생하면 프로그램은 영원히 블록​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Deadlock을 피하는 방법​
    &lt;ul&gt;
      &lt;li&gt;Mutex를 잠그는데 일정한 순서를 정하여 사용​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;성능​
    &lt;ul&gt;
      &lt;li&gt;Mutex를 많이 사용하면 프로그램의 성능이 저하됨​&lt;/li&gt;
      &lt;li&gt;Mutex를 얻은 상태에서 처리하는 작업의 양(Critical Section)을 최소화 해야 함​
        &lt;ul&gt;
          &lt;li&gt;Mutex가 잠긴 동안 다른 스레드가 블록될 가능성이 높으며 Critical Section이 길수록 전체 프로그램 성능이 저하될 수 있음​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;다른 data structure에 대해서는 다른 lock을 적용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Spin Lock​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Mutex lock 과 달리, lock을 얻을때까지 CPU cycle을 소비하면서 계속 spinning 함​
    &lt;ul&gt;
      &lt;li&gt;Mutex lock : lock을 얻지 못하면 바로 sleep 모드로 들어감 ​&lt;/li&gt;
      &lt;li&gt;Adaptive mutex lock : 잠깐 동안 spinning 하다가 sleep 모드로 들어감 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Spin lock APIs​
    &lt;ul&gt;
      &lt;li&gt;pthread_spin_init() ​
        &lt;ul&gt;
          &lt;li&gt;PTHREAD_PROCESS_PRIVATE : 생성되는 spin lock이 프로세스에 private 하게 사용될 경우 ​&lt;/li&gt;
          &lt;li&gt;PTHREAD_PROCESS_SHARED : 다른 프로세스와 공유할 경우​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;pthread_spin_lock()​&lt;/li&gt;
      &lt;li&gt;pthread_spin_unlock()​&lt;/li&gt;
      &lt;li&gt;pthread_spin_destroy()​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;pthread_spin_trylock() ​
    &lt;ul&gt;
      &lt;li&gt;Lock을 얻으려 시도​&lt;/li&gt;
      &lt;li&gt;Lock을 얻는 경우나 얻지 못하는 경우 모두 바로 리턴&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Barrier&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Barrier: 글로벌 동기화
    &lt;ul&gt;
      &lt;li&gt;특히 SPMD(동일한 기능의 여러 복사본을 병렬로 실행할 때)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Simple use of barriers: all threads hit the same one​
    &lt;ul&gt;
      &lt;li&gt;work_on_my_subgrid();​&lt;/li&gt;
      &lt;li&gt;barrier;​&lt;/li&gt;
      &lt;li&gt;read_neighboring_values();​&lt;/li&gt;
      &lt;li&gt;barrier;​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;more complicated: barriers on branches (or loops)​
    &lt;ul&gt;
      &lt;li&gt;if (thread_id % 2 == 0) {​&lt;/li&gt;
      &lt;li&gt;work1();​&lt;/li&gt;
      &lt;li&gt;barrier; } ​&lt;/li&gt;
      &lt;li&gt;else ​&lt;/li&gt;
      &lt;li&gt;barrier;​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 스레드 라이브러리에 Barrier가 제공되지 않는다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Barrier APIs​
    &lt;ul&gt;
      &lt;li&gt;pthread_barrier_init(&amp;amp;barrier, attr, no_of_threads)
        &lt;ul&gt;
          &lt;li&gt;pthread_barrier_t  barrier;&lt;/li&gt;
          &lt;li&gt;Default value of attr is “NULL”&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;pthread_barrier_destroy(&amp;amp;barrier)&lt;/li&gt;
      &lt;li&gt;pthread_barrier_wait(&amp;amp;barrier)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;semaphore&quot;&gt;&lt;strong&gt;Semaphore&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Semaphore : counting and signaling mechanism
    &lt;ul&gt;
      &lt;li&gt;지정된 개수의 아이템들을 위한 접근 제어에 활용
        &lt;ul&gt;
          &lt;li&gt;아이템 개수가 하나이면 mutex와 동일​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;스레드간에 신호를 보내는 역할​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;두 종류의 semaphore​
    &lt;ul&gt;
      &lt;li&gt;Named semaphore​&lt;/li&gt;
      &lt;li&gt;Unnamed semaphore&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Unnamed semaphore의 초기화​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;sem_t *sem;​&lt;br /&gt;
int sem_init(sem_t *sem, int pshared, unsigned int value);&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;sem : 세마포어 객체​&lt;/li&gt;
  &lt;li&gt;pshared : 다른 스레드와 공유할 것인지의 여부​&lt;/li&gt;
  &lt;li&gt;value : 세마포어의 초기값​&lt;/li&gt;
  &lt;li&gt;예 : sem_init(&amp;amp;sem, 0, 10)​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Unnamed semaphore의 종료​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;sem_destroy(&amp;amp;sem)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Named semaphore의 초기화​
    &lt;ul&gt;
      &lt;li&gt;sem_open(sem_name, FLAGS, permission, value)​&lt;/li&gt;
      &lt;li&gt;예 : sem_open(“/my_sem”, O_CREAT, 0777, 10)​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Named semaphore의 종료​
    &lt;ul&gt;
      &lt;li&gt;sem_close(sem) : semaphore와의 연결을 끊지만, 시스템 상에 semaphore를 남겨둠​&lt;/li&gt;
      &lt;li&gt;sem_unlink(sem_name) : semaphore에 사용된 resource를 free 시킴&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;세마포어의 값을 감소시키는 함수 ​
    &lt;ul&gt;
      &lt;li&gt;크리티컬 영역에 진입하면서 자동으로 세마포어의 값을 감소(-1)시킴&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;int sem_wait(sem_t *sem);​&lt;br /&gt;
int sem_trywait(sem_t *sem);&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;세마포어의 값을 1 증가시키는 함수&lt;br /&gt;
int sem_post(sem_t *sem);&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;현재 세마포어의 값을 읽는 함수&lt;br /&gt;
int sem_getvalue(sem_t *sem, int *sval);&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;conditional-variable&quot;&gt;&lt;strong&gt;Conditional Variable&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;조건변수​
    &lt;ul&gt;
      &lt;li&gt;스레드 간에 특정 조건이 발생했음을 알리는 통신을 위해 사용​&lt;/li&gt;
      &lt;li&gt;조건변수는 반드시 mutex와 함께 사용되어야 한다​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;조건변수의 생성​
    &lt;ul&gt;
      &lt;li&gt;함수를 이용한 초기화와 매크로를 이용한 초기화 방법이 있음​&lt;br /&gt;
pthread_cond_t cond;​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;pthread_cond_init(&amp;amp;cond, NULL); // 함수를 이용한 초기화​&lt;/p&gt;

&lt;p&gt;pthread_cond_t cond = PTHREAD_COND_INITIALIZER; // 매크로를 이용​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;조건변수의 삭제​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;pthread_cond_destory(&amp;amp;cond);&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;조건변수를 기다리는 함수​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;cond : 조건 알림이 발생할 때까지 대기​&lt;/li&gt;
  &lt;li&gt;mutex : mutex가 cond를 제어​&lt;/li&gt;
  &lt;li&gt;동작​
    &lt;ul&gt;
      &lt;li&gt;Mutex 해제 -&amp;gt; 블록 상태 -&amp;gt; 조건 알림을 받음 -&amp;gt; 깨어나면서 mutex를 얻음​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;조건 알림을 보내는 함수​
int pthread_cond_signal(pthread_cond_t *cond);&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;조건 변수 cond에 의해 기다리던 조건이 발생했음을 대기하고 있는 스레드에게 통보​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;하나의 생산자 스레드와 여러개의 소비자 스레드가 있는 경우​
    &lt;ul&gt;
      &lt;li&gt;pthread_cond_signal() 함수를 사용하면 단 하나의 스레드만 깨우고 나머지 스레드는 영원히 기다릴 가능성이 있음​&lt;/li&gt;
      &lt;li&gt;pthread_cond_broadcast()를 사용​
        &lt;ul&gt;
          &lt;li&gt;여러 스레드를 동시에 깨움​&lt;/li&gt;
          &lt;li&gt;깨어난 스레드들 중 공유 데이터를 위한 mutex를 얻은 스레드만이 공유 데이터에 접근​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Producer-Consumer 예제 ​
    &lt;ul&gt;
      &lt;li&gt;Queue를 사용​
        &lt;ul&gt;
          &lt;li&gt;생산자 스레드는 queue에 메시지 쓰기 작업을 수행​&lt;/li&gt;
          &lt;li&gt;소비자 스레드는 queue에서 메시지 읽기 작업을 수행​&lt;/li&gt;
          &lt;li&gt;운영체제의 scheduler는 생산자와 소비자 스레드가 교대로 실행되는 것을 보장하지 않음​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;조건변수를 사용하여 queue의 길이가 0보다 클 경우 소비자 스레드를 깨움​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="system" />
      

      
        <summary type="html">POSIX Thread Programming</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">프로세스통신-socket</title>
      <link href="https://lee989898.github.io/st-09" rel="alternate" type="text/html" title="프로세스통신-socket" />
      <published>2021-11-16T01:06:00+09:00</published>
      <updated>2021-11-16T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/st-09</id>
      <content type="html" xml:base="https://lee989898.github.io/st-09">&lt;h3 id=&quot;프로세스통신-socket&quot;&gt;&lt;strong&gt;프로세스통신-socket&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Socket&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Pipe는 통신하는 프로세스들을 하나의 시스템 내부로 한정 ​&lt;/li&gt;
  &lt;li&gt;Socket은 같은 시스템에 속한 프로세스들 뿐만 아니라, 서로 다른 시스템들에 속한 프로세스들 간의 통신을 가능케 함​
    &lt;ul&gt;
      &lt;li&gt;socket() 시스템 호출에 의해 만들어 짐 ​&lt;/li&gt;
      &lt;li&gt;응용 프로그램의 관점에서는 pipe와 마찬가지로 파일 디스크립터를 통해 접근(read, write, 등) 가능​&lt;/li&gt;
      &lt;li&gt;Kernel의 관점에서 socket은 IPC를 위한 통신의 끝점(또는 출입구)에 해당함​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;전혀 관계없는 프로세스간에 통신을 위해 socket을 식별할 목적으로 이름을 붙임​
    &lt;ul&gt;
      &lt;li&gt;파일 이름 또는 번호​&lt;/li&gt;
      &lt;li&gt;bind() 시스템 호출 사용​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;이름 붙이기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Linux 도메인에서는 socket 이름으로 파일 이름 사용 (경로명 포함)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;INET(Internet) 도메인에서는 socket 이름으로 포트번호 사용​&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;Well-known port: ftp는 21번, telnet은 23번, 등등. ​&lt;/li&gt;
      &lt;li&gt;통신 상대 프로세스가 속한 컴퓨터 시스템 이름(IP address) + 
  포트 번호&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st21.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Stream Socket을 이용한 IPC&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Virtual circuit​
    &lt;ul&gt;
      &lt;li&gt;통신 대상에 연결(논리적 접속)을 설정​&lt;/li&gt;
      &lt;li&gt;그 연결을 통하여 데이터를 송수신​&lt;/li&gt;
      &lt;li&gt;송수신이 끝나면 연결 해제​&lt;/li&gt;
      &lt;li&gt;연결형 통신이라고 부름 : 전화에 비유​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Stream socket​
    &lt;ul&gt;
      &lt;li&gt;Virtual circuit 기능을 이용하여 구현한 socket​&lt;/li&gt;
      &lt;li&gt;프로세스간에 대량의 데이터를 송수신하는 경우 이용 ​&lt;/li&gt;
      &lt;li&gt;통신의 신뢰성 보증​&lt;/li&gt;
      &lt;li&gt;송신한 정보가 없어지거나 바뀌지 않음​&lt;/li&gt;
      &lt;li&gt;올바른 순서로 수신됨​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;연결형 프로토콜의 예 : TCP (Transmission Control Protocol)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Client :​
    &lt;ul&gt;
      &lt;li&gt;Socket 작성 : socket() 시스템 호출​&lt;/li&gt;
      &lt;li&gt;Socket에 이름 붙임 : bind()  생략 가능​&lt;/li&gt;
      &lt;li&gt;Server에 접속 요구 : connect()​&lt;/li&gt;
      &lt;li&gt;데이터 송수신 : read()/write()  socket이 파일 디스크립터로 접근 가능하므로​&lt;/li&gt;
      &lt;li&gt;Socket 제거 : close()​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Server : ​
    &lt;ul&gt;
      &lt;li&gt;Socket 작성 : socket() 시스템 호출​&lt;/li&gt;
      &lt;li&gt;Socket에 이름 붙임 : bind()​&lt;/li&gt;
      &lt;li&gt;Client의 접속 요구 받을 준비 : listen()​&lt;/li&gt;
      &lt;li&gt;접속 요구 허가 : accept()​&lt;/li&gt;
      &lt;li&gt;데이터 송수신 : read()/write()​&lt;/li&gt;
      &lt;li&gt;Socket 제거 : close()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st22.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Datagram Socket을 이용한 IPC&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Datagram​
    &lt;ul&gt;
      &lt;li&gt;통신 대상에 연결(논리적 접속)을 설정할 필요 없음​&lt;/li&gt;
      &lt;li&gt;개개의 데이터를 그때 그때 상대방에게 보냄​&lt;/li&gt;
      &lt;li&gt;비 연결형 통신이라고 부름 : 편지에 비유​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Datagram socket​
    &lt;ul&gt;
      &lt;li&gt;Datagram 기능을 이용하여 구현한 socket​&lt;/li&gt;
      &lt;li&gt;프로세스간에 작은 데이터를 계속해서 보내는 통신​&lt;/li&gt;
      &lt;li&gt;매번 데이터를 보낼 때마다 상대방을 지정 ​&lt;/li&gt;
      &lt;li&gt;전송 데이터의 신뢰성이 보증되지 않음 : 시간, 순서, 등​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;비 연결형 프로토콜의 예 : UDP (User Datagram Protocol)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Client :​
    &lt;ul&gt;
      &lt;li&gt;Socket 작성 : socket() 시스템 호출​&lt;/li&gt;
      &lt;li&gt;Socket에 이름 붙임 : bind()  생략 가능​&lt;/li&gt;
      &lt;li&gt;데이터 송신 : sendto() ​&lt;/li&gt;
      &lt;li&gt;데이터 수신 : recvfrom()​&lt;/li&gt;
      &lt;li&gt;Socket 제거 : close()​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Server : ​
    &lt;ul&gt;
      &lt;li&gt;Socket 작성 : socket() 시스템 호출​&lt;/li&gt;
      &lt;li&gt;Socket에 이름 붙임 : bind()​&lt;/li&gt;
      &lt;li&gt;데이터 수신 : recvfrom()​&lt;/li&gt;
      &lt;li&gt;데이터 송신 : sendto()​&lt;/li&gt;
      &lt;li&gt;Socket 제거 : close()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;socket() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int socket(int domain, int type, int protocol)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;소켓을 생성​
    &lt;ul&gt;
      &lt;li&gt;int domain :  사용하는 도메인의 종류​&lt;/li&gt;
      &lt;li&gt;int type :      사용하는 소켓 타입​&lt;/li&gt;
      &lt;li&gt;int protocol : 사용하는 프로토콜의 종류​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정상 종료시 생성된 소켓에 대한 파일 디스크립터 반환, 에러시 -1 반환&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Domain의 종류 ​
    &lt;ul&gt;
      &lt;li&gt;PF_UNIX : unix domain ​&lt;/li&gt;
      &lt;li&gt;PF_INET : inet domain​&lt;/li&gt;
      &lt;li&gt;그 이외​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Socket type의 종류​
    &lt;ul&gt;
      &lt;li&gt;Sock_stream : stream socket​&lt;/li&gt;
      &lt;li&gt;Sock_dgram : datagram socket​&lt;/li&gt;
      &lt;li&gt;그 이외​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용되는 고유의 protocol 지정. 대부분 0을 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;bind() system call​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int bind(int sockfd, struct sockaddr *my_addr, int len)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;int sockfd : socket() 시스템 호출에서 돌려 받은 socket 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;struct sockaddr *my_addr : 이름을 붙일 구조체​
    &lt;ul&gt;
      &lt;li&gt;struct sockaddr *my_addr 에는 다음을 지정​
        &lt;ul&gt;
          &lt;li&gt;Unix domain 또는 Inet domain 중 어느 쪽을 사용할 지​&lt;/li&gt;
          &lt;li&gt;Socket 이름​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;int len :  이름이 붙여진 구조체(*my_addr)의 길이​&lt;/li&gt;
  &lt;li&gt;Unix Domain에서 socket의 주소 정보는 socketaddr_un 구조체에서 정의​
```
#include &amp;lt;sys/un.h&amp;gt;​
#define UNIX_PATH_MAX 108​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;struct sockaddr_un {​
    sa_family_t   sun_family;     /* sa_family_t는 short과 같은 타입&lt;em&gt;/​
     /&lt;/em&gt; PF_UNIX 설정 &lt;em&gt;/​
    char sun_path[UNIX_PATH_MAX];   /&lt;/em&gt; 경로명 */​&lt;/p&gt;

&lt;p&gt;};&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ Inet Domain에서 socket의 주소 정보는 socketaddr_in 구조체에서 정의​

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;#include &amp;lt;netinet/in.h&amp;gt;​&lt;/p&gt;

&lt;p&gt;struct sockaddr_in {​
    sa_family_t     sin_family;   /* PF_INET 설정 &lt;em&gt;/
    u_int16_t        sin_port;      /&lt;/em&gt; 포트 번호 &lt;em&gt;/​
    struct in_addr   sin_addr;    /&lt;/em&gt; IP 주소 */​&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;}; ​ struct in_addr { u_int32_t  s_addr; };  /* IP 주소 */ ```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;connect() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;netinet/in.h&amp;gt;​
#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int connect(int sockfd, const struct socketaddr *serv_addr, socklen_t addr_len)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;스트림 소켓 이용시 client에서 호출 (서버에 접속 요청)​&lt;/li&gt;
  &lt;li&gt;정상 종료시 0을 반환, 에러시 -1 반환​
    &lt;ul&gt;
      &lt;li&gt;int sockfd : socket 파일 디스크립터를 지정​&lt;/li&gt;
      &lt;li&gt;struct sockaddr *serv_addr : 접속하고 싶은 서버의 소켓 주소 정보 ​&lt;/li&gt;
      &lt;li&gt;socklen_t addr_len : 서버의 소켓 주소 정보 구조체의 길이​
​
        &lt;blockquote&gt;
          &lt;p&gt;listen() system call&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/socket.h&amp;gt;​

int listen(int sockfd, int backlog)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;스트림 소켓 이용시 server에서 호출 정상 종료시 0을 반환, 에러시 -1 반환​&lt;/li&gt;
  &lt;li&gt;int sockfd : socket 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;int backlog : 연결 요청에 대한 대기열의 최대 길이(대개 5)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;accept() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int accept(int sockfd, struct sockaddr *client_addr, socklen_t *addrlen)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;스트림 소켓 이용시 server에서 호출​&lt;/li&gt;
  &lt;li&gt;정상 종료시 소켓에 대한 새로운 파일 디스크립터를 반환, 에러시 -1 반환​&lt;/li&gt;
  &lt;li&gt;int sockfd : socket 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;struct sockaddr *client_addr : client의 socket 주소 정보 구조체를 가리키는 포인터​&lt;/li&gt;
  &lt;li&gt;socklen_t *addrlen : client의 socket 주소 정보 구조체의 길이&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;send() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int send(int sockfd, const void *buf, size_t len, int flags)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Send() : 소켓으로 데이터 보냄&lt;/li&gt;
  &lt;li&gt;정상 종료시 실제 보낸 바이트 수를 반환, 에러시 -1 반환​&lt;/li&gt;
  &lt;li&gt;int sockfd : accept로 반환된 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;const void *buf : 송신 버퍼의 시작 주소​&lt;/li&gt;
  &lt;li&gt;size_t len : 송신 데이터의 길이​&lt;/li&gt;
  &lt;li&gt;int flags : 송신 옵션&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;recv() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int recv(int sockfd, void *buf, size_t len, int flags)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Recv() : 소켓으로부터 데이터 받음&lt;/li&gt;
  &lt;li&gt;정상 종료시 실제 받은 바이트 수를 반환, 에러시 -1 반환​&lt;/li&gt;
  &lt;li&gt;int sockfd : accept로 반환된 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;void *buf : 수신 버퍼의 시작 주소​&lt;/li&gt;
  &lt;li&gt;size_t len : 수신 데이터의 길이​&lt;/li&gt;
  &lt;li&gt;int flags : 수신 옵션&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;sendto() system call​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;​

int sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *to, socklen_t tolen)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Sendto() : 데이터그램 소켓으로 데이터 보냄​&lt;/li&gt;
  &lt;li&gt;정상 종료시 실제 보낸 바이트 수를 반환, 에러시 -1 반환​&lt;/li&gt;
  &lt;li&gt;int sockfd : 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;const void *buf : 송신 버퍼의 시작 주소​&lt;/li&gt;
  &lt;li&gt;size_t len : 송신 데이터의 길이​&lt;/li&gt;
  &lt;li&gt;int flags : 송신 옵션 ​&lt;/li&gt;
  &lt;li&gt;const struct sockaddr *to : 받을 곳의 소켓 주소 정보 구조체를 가리키는 포인터​&lt;/li&gt;
  &lt;li&gt;socklen_t tolen : 받을 곳의 소켓 주소 정보 구조체의 길이​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;recvfrom() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlen)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;Recvfrom() : 데이터그램 소켓에서 데이터 받음​&lt;/li&gt;
  &lt;li&gt;정상 종료시 실제 받은 바이트 수를 반환, 에러시 -1 반환​&lt;/li&gt;
  &lt;li&gt;int sockfd : 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;void *buf : 수신 버퍼의 시작 주소​&lt;/li&gt;
  &lt;li&gt;size_t len : 수신 데이터의 길이​&lt;/li&gt;
  &lt;li&gt;int flags : 수신 옵션​&lt;/li&gt;
  &lt;li&gt;struct sockaddr *from : 보내는 곳의 소켓 주소 정보 구조체를 가리키는 포인터​&lt;/li&gt;
  &lt;li&gt;socklen_t tolen : 보내는 곳의 소켓 주소 정보 구조체의 길이&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;System V IPC​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;Semaphores​&lt;/li&gt;
  &lt;li&gt;Shared memory​&lt;/li&gt;
  &lt;li&gt;Message queues​&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Semaphores&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;여러 프로세스에 대한 공유 데이터 개체에 대한 액세스를 제공하는 카운터&lt;/li&gt;
  &lt;li&gt;공유 리소스를 얻으려면
    &lt;ul&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;Test semaphore controlling resource​
            &lt;ul&gt;
              &lt;li&gt;1-1 If value &amp;gt; 0, value –, grant use​&lt;/li&gt;
              &lt;li&gt;1-2 If value == 0, sleep until value &amp;gt; 0​&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;ol&gt;
          &lt;li&gt;Release resource, value ++​&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Steps 1-1, 1-2 atomic 연산이어야 한다&lt;/li&gt;
  &lt;li&gt;세마포어는 하나 이상의 세마포어 값의 집합으로 정의되다
    &lt;ul&gt;
      &lt;li&gt;세마포어가 생성될 때 집합에 값의 개수도 지정된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st23.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Functions&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/sem.h&amp;gt;​

int semget(key_t key, int num_sems, int sem_flags);​
int semctl(int sem_id, int sem_num, int command, …);​
int semop(int sem_id, struct sembuf *sem_ops, size_t num_sem_ops);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;semget : 세마포어 생성 또는 세마포어 키 반환
    &lt;ul&gt;
      &lt;li&gt;Key : 동일한 세마포어에 액세스하기 위한 10진수 값&lt;/li&gt;
      &lt;li&gt;num_sems : 세마포어의 수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;semctl : 세마포어 정보 제어
    &lt;ul&gt;
      &lt;li&gt;sem_id : 세마포어 ID​&lt;/li&gt;
      &lt;li&gt;sem_num : 세마포어의 수&lt;/li&gt;
      &lt;li&gt;command : 세마포어 명령&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;semop : 세마포어 값 변경&lt;/li&gt;
  &lt;li&gt;생성(semget)은 초기화(semctl)와 무관하다​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shared memory&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;가장 빠른 형태의 IPC: 프로세스 간 데이터 복사 불필요&lt;/li&gt;
  &lt;li&gt;공유 메모리 세그먼트에 대한 액세스를 동기화해야 함 -&amp;gt; 세마포어가 사용됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st24.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Functions&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt; ​
#include &amp;lt;sys/ipc.h&amp;gt; ​
#include &amp;lt;sys/shm.h&amp;gt; ​

int shmget(key_t key, int size, int flag); ​
        Returns: shared memory ID if OK, -1 on error
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;공유 메모리 식별자 얻기&lt;/li&gt;
  &lt;li&gt;Size : 공유 메모리 세그먼트의 크기&lt;/li&gt;
  &lt;li&gt;Flag : ipc_perm.mode​&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt; ​
#include &amp;lt;sys/ipc.h&amp;gt; ​
#include &amp;lt;sys/shm.h&amp;gt; ​

int shmctl(int shmid, int cmd, struct shmid_ds *buf);​
        Returns: 0 if OK, -1 on error
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;다양한 공유 메모리 작업​&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt; ​
#include &amp;lt;sys/ipc.h&amp;gt; ​
#include &amp;lt;sys/shm.h&amp;gt; ​

void *shmat (int shmid, void *addr, int flag); ​
        Returns: pointer to shared memory segment if OK, -1 on error
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;주소에 공유 메모리 첨부&lt;/li&gt;
  &lt;li&gt;flag ​
    &lt;ul&gt;
      &lt;li&gt;SHM_RDONLY : 세그먼트가 읽기 전용이다​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;addr==0: 커널이 선택한 첫 번째 주소에서
    &lt;ul&gt;
      &lt;li&gt;recommended​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;addr!=0 &amp;amp;&amp;amp; SHM_RND is not specified:​
    &lt;ul&gt;
      &lt;li&gt;addr이 제공한 주소에서&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;addr!=0 &amp;amp;&amp;amp; SHM_RND is specified:​
    &lt;ul&gt;
      &lt;li&gt;주어진 주소에서 (addr – (addr modulus SHMLBA))​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt; ​
#include &amp;lt;sys/ipc.h&amp;gt; ​
#include &amp;lt;sys/shm.h&amp;gt; ​

void shmdt (void *addr); ​
        Returns: 0 if OK, -1 on error
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;공유 메모리 세그먼트 분리&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Message queues&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;메시지의 연결 목록
    &lt;ul&gt;
      &lt;li&gt;커널에 저장&lt;/li&gt;
      &lt;li&gt;메시지 대기열 식별자로 식별&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;msgget: 새 대기열 생성 또는 기존 대기열 열기&lt;/li&gt;
  &lt;li&gt;msgsnd: 대기열에 새 메시지 추가&lt;/li&gt;
  &lt;li&gt;msgrcv: 대기열에서 메시지 수신&lt;/li&gt;
  &lt;li&gt;Fetching order: based on type&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt; ​
#include &amp;lt;sys/ipc.h&amp;gt; ​
#include &amp;lt;sys/msg.h&amp;gt; ​

int msgget(key_t key, int flag); ​
        Returns: msg queue ID if OK, -1 on error
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;새 대기열 생성 또는 기존 대기열 열기&lt;/li&gt;
  &lt;li&gt;Flag : ipc_perm.mode​&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt; ​
#include &amp;lt;sys/ipc.h&amp;gt; ​
#include &amp;lt;sys/msg.h&amp;gt; ​
​
int msgsnd(int msqid, const void *ptr, size_t nbytes, int flag); ​
        Returns: 0 if OK, -1 on error

struct mymesg {​
  long mtype;         /* positive message type */​
  char mtext[512];    /* message data, of length nbytes */​
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;큐의 끝에 메시지 배치&lt;/li&gt;
  &lt;li&gt;ptr은 메시지를 가리킨다&lt;/li&gt;
  &lt;li&gt;nbytes : 메시지 데이터의 길이&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt; ​
#include &amp;lt;sys/ipc.h&amp;gt; ​
#include &amp;lt;sys/msg.h&amp;gt; ​

int msgrcv(int msqid, void *ptr, size_t nbytes, long type, int flag); ​
        Returns: data size in message if OK, -1 on error
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;대기열에서 메시지 검색&lt;/li&gt;
  &lt;li&gt;type == 0 : 큐의 첫 번째 메시지가 반환된다&lt;/li&gt;
  &lt;li&gt;type &amp;gt; 0 : 메시지 유형이 유형과 동일한 큐의 첫 번째 메시지가 반환된다&lt;/li&gt;
  &lt;li&gt;type &amp;lt; 0 : 메시지 유형이 유형의 절대값보다 작거나 같은 가장 낮은 값인 큐의 첫 번째 메시지가 반환된다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="system" />
      

      
        <summary type="html">프로세스통신-socket</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">프로세스통신-pipe</title>
      <link href="https://lee989898.github.io/st-08" rel="alternate" type="text/html" title="프로세스통신-pipe" />
      <published>2021-11-03T01:06:00+09:00</published>
      <updated>2021-11-03T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/st-08</id>
      <content type="html" xml:base="https://lee989898.github.io/st-08">&lt;h3 id=&quot;프로세스통신-pipe&quot;&gt;&lt;strong&gt;프로세스통신-pipe&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Inter-Process Communication (IPC)​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스들끼리 데이터를 주고 받는 기능 수행&lt;/li&gt;
  &lt;li&gt;예: Client/Serve 응용 프로그램, 등&lt;/li&gt;
  &lt;li&gt;Pipe/Socket: 파일 디스크립터를 사용하여 접근 가능한 IPC방법들&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Pipe&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;리눅스에서 가장 오래된 IPC이다&lt;/li&gt;
  &lt;li&gt;Pipe은 메모리 버퍼 영역을 가리킴​
    &lt;ul&gt;
      &lt;li&gt;읽기용 입구 하나, 쓰기용 입구 하나를 가짐​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파일 디스크립터로 접근(access)​
    &lt;ul&gt;
      &lt;li&gt;읽기용 입구와 쓰기용 입구에 각각 다른 파일 디스크립터가 할당됨​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;통신을 하게 될 프로세스들이 파일 디스크립터 들을 공유해야 : (예) 부모, 자식 관계​
    &lt;ul&gt;
      &lt;li&gt;프로세스는 pipe() system call을 사용하여 파이프를 생성한다&lt;/li&gt;
      &lt;li&gt;동일한 프로세스가 fork()를 호출하여 자식 프로세스를 생성한다&lt;/li&gt;
      &lt;li&gt;그러면 파이프는 parent 프로세스와 child 프로세스 간에 사용된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파이프의 한계
    &lt;ul&gt;
      &lt;li&gt;Half duplex: 데이터는 한 방향으로만 흐른다&lt;/li&gt;
      &lt;li&gt;공통 조상이 있는 프로세스 사이에서만 사용할 수 있다​
        &lt;ul&gt;
          &lt;li&gt;일반적으로 parent 프로세스와 child 프로세스 사이에 사용&lt;/li&gt;
          &lt;li&gt;프로세스가 파이프를 생성하면 모든 자식이 파이프를 상속할 수 있다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;휘발성: 파이프를 생성한 프로세스가 종료되면 사라진다&lt;/li&gt;
      &lt;li&gt;process는 파이프를 전달할 수 없으며 parent로부터 상속해야 한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;Linux 셸에서 파이프 기호는 “&lt;/td&gt;
          &lt;td&gt;“이다&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;% ls -alg&lt;/td&gt;
              &lt;td&gt;more​&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;%  cmd1&lt;/td&gt;
              &lt;td&gt;cmd2​&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;터미널에서 cmd1 입력&lt;/li&gt;
      &lt;li&gt;cmd1의 출력은 cmd2의 입력&lt;/li&gt;
      &lt;li&gt;cmd2의 출력은 터미널 화면에 연결한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st17.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Long pipes:​
    &lt;ul&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;$ pic paper.ms&lt;/td&gt;
              &lt;td&gt;tbl&lt;/td&gt;
              &lt;td&gt;eqn&lt;/td&gt;
              &lt;td&gt;ditroff -ms​&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pipe을 이용하여 두 개의 프로세스 들이 통신을 할 경우, producer가 write한 순서대로 consumer가 read하게 된다​
    &lt;ul&gt;
      &lt;li&gt;선입선출(First-In First-Out)관계​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단방향 pipe : ​
    &lt;ul&gt;
      &lt;li&gt;Producer 프로세스는 pipe에 대한 write용 입구만 사용​&lt;/li&gt;
      &lt;li&gt;Consumer 프로세스는 pipe에 대한 read용 입구만 사용​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;쌍방향 pipe : ​
    &lt;ul&gt;
      &lt;li&gt;Pipe을 두 개 열어 사용​&lt;/li&gt;
      &lt;li&gt;하나의 pipe는 한쪽 방향의 통신에만 사용됨​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Pipe: pipe() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;
int pipe(int fd[2]) // int fd[2]; 파일 디스크립터
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;정상 종료하면 0을 반환, 에러 발생시에는 -1을 반환​&lt;/li&gt;
  &lt;li&gt;pipe() system call은 인자로 넘겨 받은 fd[0], fd[1]에 파일 디스크립터를 저장해서 반환​&lt;/li&gt;
  &lt;li&gt;fd[0]: 읽기 모드에서 연 파일 디스크립터(읽기용 입구)​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;fd[1]: 쓰기 모드에서 연 파일 디스크립터(쓰기용 출구)​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Pipe(), fork() 시스템 호출에 의해 부모/자식 프로세스가 fd[0], fd[1]를 공유한다고 가정​&lt;/li&gt;
  &lt;li&gt;쓰는 쪽(write() system call) 프로세스에서는 읽기용 파일 디스크립터(fd[0])를 닫아 놓음(close() system call)​&lt;/li&gt;
  &lt;li&gt;읽는 쪽(read() system call) 프로세스에서는 쓰기용 파일 디스크립터(fd[1])를 닫아 놓음(close() system call) ​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Pipe: popen()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

FILE *popen(const char *cmdstring, const char *type);
    반환값: 정상이면 파일 포인터, 오류 시 NULL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;popen은 “cmdstring”을 실행하기 위해 fork() 및 exec()를 수행한다​&lt;/li&gt;
  &lt;li&gt;popen의 유형은 “r” 또는 “w”이다​
    &lt;ul&gt;
      &lt;li&gt;type이 “r”이면 반환된 파일 포인터는 “cmdstring”의 stdout에 연결된다&lt;/li&gt;
      &lt;li&gt;type이 “w”인 경우 반환된 파일 포인터는 “cmdstring”의 표준 입력에 연결된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Pipe: pclose()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int pclose(FILE *fp);
    반환값: cmdstring의 종료 상태 또는 오류 시 -1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;“pclose”는 std I/O 스트림을 닫고 명령이 종료될 때까지 기다렸다가 셸의 종료 상태를 반환한다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;FIFO&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;파이프와 비슷하다, “named pipe” 라고 불리운다​&lt;/li&gt;
  &lt;li&gt;파일의 종류&lt;/li&gt;
  &lt;li&gt;FIFO는 파이프의 한계를 극복한다​&lt;/li&gt;
  &lt;li&gt;관련 없는 프로세스 간에 사용 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;    
#include &amp;lt;sys/stat.h&amp;gt;

int mkfifo(const char *filename, mode_t mode);
정상이면 0, 오류시 -1을 반환한다
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;FIFO 생성은 파일 생성과 유사하다
    &lt;ul&gt;
      &lt;li&gt;Mode: open() 함수와 동일한 권한&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;FIFO를 사용하는 것은 파일을 사용하는 것과 유사하다
    &lt;ul&gt;
      &lt;li&gt;생성되면 FIFO에 대한 열기, 닫기, 읽기, 쓰기, 연결 해제 등을 사용할 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파이프와 마찬가지로 읽기를 위해 열려 있는 프로세스가 없는 FIFO에 쓰면 SIGPIPE 신호가 생성된다&lt;/li&gt;
  &lt;li&gt;FIFO의 마지막 작성자가 FIFO를 닫으면 FIFO의 판독기에 대해 파일 끝이 생성된다&lt;/li&gt;
  &lt;li&gt;PIPE_BUF(커널의 파이프 버퍼 크기)는 FIFO에 원자적으로 쓸 수 있는 최대 데이터 양을 지정한다
    &lt;ul&gt;
      &lt;li&gt;여러 프로세스의 데이터 쓰기 &amp;lt;= PIPE_BUF는 인터리브되지 않는다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;FIFO 사용 예
    &lt;ul&gt;
      &lt;li&gt;셸 명령에서 중간 파일을 생성하지 않고 한 셸 파이프라인에서 다른 셸 파이프라인으로 데이터를 전달하는 데 사용​&lt;/li&gt;
      &lt;li&gt;클라이언트와 서버 간에 데이터를 전달하기 위해 클라이언트-서버 애플리케이션에서 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;FIFO : 출력 스트림 복제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;입력 스트림을 두 번 처리하는 절차 작성&lt;/li&gt;
  &lt;li&gt;tee(1)은 표준 입력을 표준 출력과 명령줄에 명명된 파일 모두에 복사한다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkfifo fifo1​
$ prog3 &amp;lt; fifo1 &amp;amp;​
$ prog1 &amp;lt; infile | tee fifo1 | prog2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st18.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;FIFO : 클라이언트-서버 통신&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;서버는 클라이언트와 통신하기 위해 “well-known” FIFO를 생성한다(well-known: FIFO의 경로 이름은 서버에 접속해야 하는 모든 클라이언트에게 알려져 있음)&lt;/li&gt;
  &lt;li&gt;클라이언트 데이터의 interleaving을 피하기 위해 클라이언트는 한 번에 최대 PIPE_BUF 바이트를 써야 하다​&lt;/li&gt;
  &lt;li&gt;문제: 서버가 단일 “well-known” FIFO를 사용하여 클라이언트에 응답할 수 없음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st19.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;서버는 클라이언트별 FIFO를 사용하여 응답할 수 있도록 각 클라이언트에 대해 FIFO를 생성한다
    &lt;ul&gt;
      &lt;li&gt;e.g.: /tmp/serv1.XXXX, where XXXXX is client’s process ID ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서버는 SIGPIPE를 잡아야 함(1개의 작성자가 있는 FIFO, 판독기 없음)​
    &lt;ul&gt;
      &lt;li&gt;클라이언트는 서버에서 응답을 읽기 전에 요청을 보내고 종료하여 클라이언트별 FIFO를 하나의 작성자(서버)와 리더 없이 남겨둔다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st20.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="system" />
      

      
        <summary type="html">프로세스통신-pipe</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Signal</title>
      <link href="https://lee989898.github.io/st-07" rel="alternate" type="text/html" title="Signal" />
      <published>2021-10-27T01:06:00+09:00</published>
      <updated>2021-10-27T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/st-07</id>
      <content type="html" xml:base="https://lee989898.github.io/st-07">&lt;h3 id=&quot;signal&quot;&gt;&lt;strong&gt;Signal&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Signal Concepts​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Signal은 프로세스에 보내는 메시지이다. signal은 시스템에서 어떤 유형의 이벤트가 발생했음을 알려준다
    &lt;ul&gt;
      &lt;li&gt;Signal은 커널에서 프로세스로 보내진다​&lt;/li&gt;
      &lt;li&gt;때로는 다른 프로세스의 요청으로 전송된다​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Signal은 exceptions,interrupts​과 유사하다&lt;/li&gt;
  &lt;li&gt;Signal은 일종의 IPC(Inter-Process Communication)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Sending a Signal&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;커널은 다음과 같은 이유로 신호를 보낸다​
    &lt;ul&gt;
      &lt;li&gt;커널이 0으로 나누기(SIGFPE), 잘못된 메모리 참조(SIGSEGV), child 프로세스 종료(SIGCHLD)와 같은 시스템 이벤트를 감지했다&lt;/li&gt;
      &lt;li&gt;다른 프로세스가 대상 프로세스에 signal를 보내도록 커널을 명시적으로 요청하기 위해 kill 시스템 호출을 호출했다
        &lt;ul&gt;
          &lt;li&gt;보낼 수 있는 신호를 표시하려면 “% kill -l”을 시도하자&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;터미널에서 CTRL-C를 입력하여 실행 중인 프로세스(SIGINT) 중지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Receiving a Signal​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;대상 프로세스는 커널에서 신호를 수신하고 세 가지 가능한 방법 중 하나로 반응한다
    &lt;ul&gt;
      &lt;li&gt;Signal 무시(아무것도 하지 않음)
        &lt;ul&gt;
          &lt;li&gt;SIGKILL 및 SIGSTOP을 제외한 모든 신호는 무시할 수 있다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;프로세스 종료(선택적 코어 덤프 사용) -&amp;gt; default action&lt;/li&gt;
      &lt;li&gt;시그널 핸들러라는 user-level 함수를 실행하여 Catch the signal
        &lt;ul&gt;
          &lt;li&gt;비동기 인터럽트에 대한 응답으로 호출될 때 하드웨어 예외 핸들러와 유사&lt;/li&gt;
          &lt;li&gt;신호 처리기는 signal() 시스템 호출을 호출하여 실행된다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로세스는 커널에게 “이 신호가 발생하면 위의 세 가지 중 하나를 수행하십시오”라고 알려야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Linux Signals / Linux Signal List&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Every signal has a name​
    &lt;ul&gt;
      &lt;li&gt;Begins with ‘SIG’​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Signals are all defined by positive integers (signal numbers) in the header &lt;signal.h&gt; and &lt;siglist.h&gt;​&lt;/siglist.h&gt;&lt;/signal.h&gt;&lt;/li&gt;
  &lt;li&gt;SVR4 and 4.3+BSD both have 31 different signals&lt;/li&gt;
  &lt;li&gt;SIGABRT​
    &lt;ul&gt;
      &lt;li&gt;Generated by calling the abort() system call​&lt;/li&gt;
      &lt;li&gt;Process terminates abnormally​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SIGFPE​
    &lt;ul&gt;
      &lt;li&gt;Floating-Point Exception Signal​&lt;/li&gt;
      &lt;li&gt;Signals an arithmetic exception, such as divide-by-0, floating point overflow, 등등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SIGILL​
    &lt;ul&gt;
      &lt;li&gt;Illegal Instruction Signal: illegal HW instruction executed​&lt;/li&gt;
      &lt;li&gt;Can’t be caught or ignored​&lt;/li&gt;
      &lt;li&gt;A sure way to kill any process​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SIGINT​
    &lt;ul&gt;
      &lt;li&gt;Interrupt Signal​&lt;/li&gt;
      &lt;li&gt;Generated by the terminal driver when we type the interrupt key (Ctrl C)​&lt;/li&gt;
      &lt;li&gt;Sent to all processes in the foreground process group​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SIGKILL​
    &lt;ul&gt;
      &lt;li&gt;Kill Signal​&lt;/li&gt;
      &lt;li&gt;Can’t be caught or ignored​&lt;/li&gt;
      &lt;li&gt;A sure way to kill any process​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;​SIGPIPE​
    &lt;ul&gt;
      &lt;li&gt;Generated when writing on a pipe with no process to read: reader has already terminated​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SIGQUIT​
    &lt;ul&gt;
      &lt;li&gt;Quit Signal​&lt;/li&gt;
      &lt;li&gt;Generated by the terminal driver when we type terminal quit key (Control + Backslash) and sent to all processes in the foreground process group​&lt;/li&gt;
      &lt;li&gt;Usually core file is generated​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SIGSEGV​
    &lt;ul&gt;
      &lt;li&gt;Indicates that the process has made an invalid memory reference​&lt;/li&gt;
      &lt;li&gt;SEGV means “segment violation” ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SIGTRAP​
    &lt;ul&gt;
      &lt;li&gt;Special signal used to transfer control to the debugger (like sdb, adb) ​&lt;/li&gt;
      &lt;li&gt;Usually ptrace system call is used to invoke SIGTRAP​&lt;/li&gt;
      &lt;li&gt;It is not usually used except for debugging​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SIGUSR1 &amp;amp; SIGUSR2​
    &lt;ul&gt;
      &lt;li&gt;User-defined signals, for use in application programs​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Linux Signal List&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st13.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프러그래밍&quot; /&gt; 
&lt;img src=&quot;/assets/built/images/st/st14.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프러그래밍&quot; /&gt; 
&lt;img src=&quot;/assets/built/images/st/st15.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프러그래밍&quot; /&gt; 
&lt;img src=&quot;/assets/built/images/st/st16.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프러그래밍&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;signal()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;signal.h&amp;gt;​

void (*signal(int signo, void(*func)(int))) (int)​
    반환: 정상이면 신호의 이전 처리, 오류 시 SIG_ERR ​ + signal function은 signal &quot;signo&quot; 수신과 관련된 기본 동작을 수정한다
+ signo: signal number를 나타낸다​
+ func:​
    + 신호 수신 시 사용자 정의 함수(signal handler) 호출
    + SIG_IGN: signal를 무시
    + SIG_DFL: default action을 취한다 + signal handler에 단일 정수 인수(signal number)가 전달되고 아무 것도 반환하지 않습니다
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;kill()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;signal.h&amp;gt;​

int kill(pid_t pid, int signo);​
    반환: 정상이면 0, 오류시 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Kill : 프로세스 또는 프로세스 그룹에 신호를 보낸다&lt;/li&gt;
  &lt;li&gt;super user는  모든 프로세스에 신호를 보낼 수 있다​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;발신자의 실제 또는 유효 사용자 ID는 수신자의 실제 또는 유효 사용자 ID와 같아야 한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Pid &amp;gt; 0​
    &lt;ul&gt;
      &lt;li&gt;Signal to the process whose process ID is pid​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pid == 0​
    &lt;ul&gt;
      &lt;li&gt;Signal to the processes whose process group ID equals that of sender​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pid &amp;lt; 0​
    &lt;ul&gt;
      &lt;li&gt;Signal to the processes whose process group ID equals abs. of pid​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pid == -1​
    &lt;ul&gt;
      &lt;li&gt;POSIX.1 leaves this condition unspecified (used as a broadcast signal in SVR4, 4.3+BSD)​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;killpg()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;signal.h&amp;gt;​

int killpg(int pgrp, int sig)​

// int pgrp -&amp;gt; 프로세스 그룹 ID​
// int  sig -&amp;gt; 시그널 번호​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스 그룹으로 시그널을 보냄​&lt;/li&gt;
  &lt;li&gt;반환값 : 정상 종료시에는 0, 에러 발생시 -1​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="system" />
      

      
        <summary type="html">Signal</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Process_Control</title>
      <link href="https://lee989898.github.io/st-06" rel="alternate" type="text/html" title="Process_Control" />
      <published>2021-10-20T01:06:00+09:00</published>
      <updated>2021-10-20T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/st-06</id>
      <content type="html" xml:base="https://lee989898.github.io/st-06">&lt;h3 id=&quot;process-control&quot;&gt;&lt;strong&gt;Process Control&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Process Identifiers&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;모든 프로세스에는 음이 아닌 정수인 고유한 프로세스 ID가 있다&lt;/li&gt;
  &lt;li&gt;Process ID 0: swapper (scheduler process)​
    &lt;ul&gt;
      &lt;li&gt;시스템 프로세스&lt;/li&gt;
      &lt;li&gt;커널의 일부&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Process ID 1:  init  process​
    &lt;ul&gt;
      &lt;li&gt;부트스트랩 절차가 끝날 때 커널에 의해 호출됨&lt;/li&gt;
      &lt;li&gt;/etc/init  or  /sbin/init​&lt;/li&gt;
      &lt;li&gt;시스템을 특정 상태로 만든다(다중 사용자)&lt;/li&gt;
      &lt;li&gt;일반 사용자 프로세스이지만 수퍼유저 권한으로 실행&lt;/li&gt;
      &lt;li&gt;PID 1 is 불멸이다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Process ID 2:  pagedaemon​
    &lt;ul&gt;
      &lt;li&gt;가상 메모리 시스템의 페이징 지원&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;kernel process&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   #include &amp;lt;sys/types.h&amp;gt;​
  #include &amp;lt;unistd.h&amp;gt;​

  pid_t getpid(void);      // returns process ID​
  pid_t getppid(void);     // returns parent process ID​
  uid_t getuid(void);      // returns real user ID​
  uid_t geteuid(void);     // returns effective user ID​
  gid_t getgid(void);      // returns real group ID​
  gid_t getegid(void);     // returns effective group ID​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이 함수 중 어느 것도 오류 반환이 없다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;fork()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;unistd.h&amp;gt;​

pid_t fork(void);

반환값: 자식의 경우 0, 부모의 자식 프로세스 ID, 오류 시 -1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;fork()는 Unix 커널에서 프로세스를 생성하는 유일한 방법이다&lt;/li&gt;
  &lt;li&gt;자식 프로세스는 fork()에 의해 생성된 새로운 프로세스이다​&lt;/li&gt;
  &lt;li&gt;fork()는 한 번 호출되지만 두 번 반환된다
    &lt;ul&gt;
      &lt;li&gt;returns 0 in child process​&lt;/li&gt;
      &lt;li&gt;returns the child process ID in parent process​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자식 프로세스는 getppid()를 호출하여 부모 프로세스 ID를 얻을 수 있다.&lt;/li&gt;
  &lt;li&gt;부모와 자식은 fork() 호출에 따라 명령을 계속 실행한다&lt;/li&gt;
  &lt;li&gt;자식은 부모의 데이터 공간, 힙 및 스택의 복사본을 얻는다&lt;/li&gt;
  &lt;li&gt;종종 읽기 전용 텍스트 세그먼트가 공유된다&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;종종 fork() 다음에 exec()가 온다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;child에게 상속되는 속성
    &lt;ul&gt;
      &lt;li&gt;실제 사용자 및 그룹 ID, 유효 사용자 및 그룹 ID&lt;/li&gt;
      &lt;li&gt;보조 그룹 ID&lt;/li&gt;
      &lt;li&gt;프로세스 그룹 ID, 세션 ID,&lt;/li&gt;
      &lt;li&gt;set-user-ID 및 set-group ID 플래그&lt;/li&gt;
      &lt;li&gt;현재 작업 디렉토리&lt;/li&gt;
      &lt;li&gt;루트 디렉토리&lt;/li&gt;
      &lt;li&gt;파일 모드 creation mask&lt;/li&gt;
      &lt;li&gt;signal mask 및 배치&lt;/li&gt;
      &lt;li&gt;열려 있는 파일 설명자에 대한 close-on-exec 플래그&lt;/li&gt;
      &lt;li&gt;environment&lt;/li&gt;
      &lt;li&gt;연결된 공유 메모리 세그먼트&lt;/li&gt;
      &lt;li&gt;리소스 제한&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;child에게 상속되지 않는 속성
    &lt;ul&gt;
      &lt;li&gt;fork()의 반환 값&lt;/li&gt;
      &lt;li&gt;프로세스 ID가 다르다&lt;/li&gt;
      &lt;li&gt;file locks&lt;/li&gt;
      &lt;li&gt;보류 중인 알람이 child에 대해 지워진다&lt;/li&gt;
      &lt;li&gt;child에 대한 보류 중인 신호 집합은 빈 집합으로 설정된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;exit()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스는 5가지 방법으로 종료할 수 있다:​
    &lt;ul&gt;
      &lt;li&gt;Normal Termination​
        &lt;ul&gt;
          &lt;li&gt;main()에서 반환을 실행한다. exit() 호출과 동일&lt;/li&gt;
          &lt;li&gt;exit()​&lt;/li&gt;
          &lt;li&gt;_exit()​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Abnormal Termination​
        &lt;ul&gt;
          &lt;li&gt;calling abort() (generates SIGABRT signal)​&lt;/li&gt;
          &lt;li&gt;프로세스는 자체적으로(abort()에 의해) 또는 다른 프로세스에 의해 생성된 신호를 수신한다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로세스가 어떻게 종료되든 상관없이 커널의 동일한 코드가 결국 실행된다
    &lt;ul&gt;
      &lt;li&gt;프로세스에 대해 열려 있는 모든 설명자를 닫는다​&lt;/li&gt;
      &lt;li&gt;메모리 해제 등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;exit(): Termination status&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Exit status: ​
    &lt;ul&gt;
      &lt;li&gt;Argument of  exit(), _exit() ​&lt;/li&gt;
      &lt;li&gt;main()의 반환 값&lt;/li&gt;
      &lt;li&gt;프로세스 종료 방법에 대한 정보&lt;/li&gt;
      &lt;li&gt;자식 프로세스에서 부모 프로세스로 전달&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Termination status:​
    &lt;ul&gt;
      &lt;li&gt;Normal termination: Exit status -&amp;gt; Termination status​&lt;/li&gt;
      &lt;li&gt;Abnormal termination: kernel indicates reason -&amp;gt; Termination status​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;부모는 자식 프로세스의 종료 상태를 얻을 수 있다
    &lt;ul&gt;
      &lt;li&gt;by wait() or waitpid()​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;부모가 자식보다 먼저 해지하면 어떻게 되나?
    &lt;ul&gt;
      &lt;li&gt;init는 자식 프로세스의 부모가 된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자식이 먼저 종료된다고 가정
    &lt;ul&gt;
      &lt;li&gt;죽은 자식 프로세스의 최소 정보(pid, 종료 상태, CPU 시간)는 부모가 wait() 또는 waitpid()를 호출할 수 있도록 커널에 의해 유지된다&lt;/li&gt;
      &lt;li&gt;Zombie: 완료되었지만 부모가 아직 기다리지 않은 프로세스&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;wait(), waitpid()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;child가 종료될 때
    &lt;ul&gt;
      &lt;li&gt;커널은 부모에게 SIGCHLD 신호를 보낸다&lt;/li&gt;
      &lt;li&gt;비동기식 이벤트​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;parent가 취한 조치
    &lt;ul&gt;
      &lt;li&gt;기본 작업: “무시”&lt;/li&gt;
      &lt;li&gt;또는 부모가 사용자가 정의한 신호 처리기를 호출할 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;wait 또는 waitpid를 호출하는 프로세스는
    &lt;ul&gt;
      &lt;li&gt;block(자식이 아직 실행 중인 경우), 또는&lt;/li&gt;
      &lt;li&gt;child의 해지 상태로 즉시 반환, 또는&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;오류와 함께 즉시 반환(child 프로세스가 없는 경우)&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  #include &amp;lt;sys/types.h&amp;gt;​
  #include &amp;lt;sys/wait.h&amp;gt;​​

  pid_t wait(int *statloc);​
  pid_t waitpid(pid_t pid, int *statloc, int options);​

  ​둘 다 반환: 정상이면 프로세스 ID, 오류 발생 시 0 또는 -1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;statloc​
    &lt;ul&gt;
      &lt;li&gt;종료 상태를 저장할 정수에 대한 포인터&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모든 자식이 끝날 때까지 Wait() 블록&lt;/li&gt;
  &lt;li&gt;Waitpid()는 block 되지 않도록 선택할 수 있다.​
    &lt;ul&gt;
      &lt;li&gt;그것은 많은 옵션을 가질 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;종료 상태를 검사하는 매크로&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Macro&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;WIFEXITED(status)​&lt;/td&gt;
      &lt;td&gt;자식이 정상적으로 종료되면 참 WEXITSATUS(상태): 종료 상태 가져오기(하위 8비트)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;WIFSIGNALED(status)​&lt;/td&gt;
      &lt;td&gt;자식이 비정상 종료되면 참(신호 수신)WTERMSIG(status): 종료를 일으킨 신호 번호를 가져온다.WCOREDUMP(status): 코어 파일이 생성된 경우 true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;WIFSTOPPED(status)​&lt;/td&gt;
      &lt;td&gt;자식이 현재 중지되어 있으면 참 WSTOPSIG(status): 정지를 일으킨 신호 번호를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;WEXITSTATUS(stat_val)&lt;/td&gt;
      &lt;td&gt;WIFEXITED가 0이 아니면 자식 종료 코드를 반환한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;WTERMSIG(stat_val)&lt;/td&gt;
      &lt;td&gt;WIFSIGNALED가 0이 아니면 신호 번호를 반환한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;WSTOPSIG(stat_val)&lt;/td&gt;
      &lt;td&gt;WIFSTOPPED가 0이 아니면 신호 번호를 반환한다&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/wait.h&amp;gt;​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​   pid_t waitpid(pid_t pid, int *statloc, int options);&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;waitpid()​
    &lt;ul&gt;
      &lt;li&gt;하나의 특정 프로세스를 기다린다&lt;/li&gt;
      &lt;li&gt;provides a nonblocking version of wait​&lt;/li&gt;
      &lt;li&gt;supports job control (with the WUNTRACED option)​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;the pid argument for waitpid​
    &lt;ul&gt;
      &lt;li&gt;-1  : 모든 자식 프로세스를 기다린다&lt;/li&gt;
      &lt;li&gt;&amp;gt; 0 : 프로세스 ID가 pid인 자식 프로세스를 기다린다&lt;/li&gt;
      &lt;li&gt;0   : 프로세스 GID가 같은 자식을 기다린다(호출 프로세스의)&lt;/li&gt;
      &lt;li&gt;&amp;lt; -1 : 프로세스 GID가 같은 자식을 기다린다(pid의 절대값)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;waitpid에 대한 옵션 상수
    &lt;ul&gt;
      &lt;li&gt;WNOHANG  :
        &lt;ul&gt;
          &lt;li&gt;pid로 지정된 자식을 즉시 사용할 수 없으면 차단하지 않고 0을 반환환다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;WUNTRACED:
        &lt;ul&gt;
          &lt;li&gt;상태가 아직 보고되지 않은 경우 pid로 지정된 중지된 자식의 상태를 반환환다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;exec&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;프로세스가 exec 함수 중 하나를 호출할 때&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로세스는 새 프로그램으로 완전히 대체된다. 텍스트, 데이터, 힙 및 스택 세그먼트를 부모의 주소 공간에 로드한다.&lt;/li&gt;
  &lt;li&gt;새 program은 main function에서 시작한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;새 program은 caller와 동일한 PID를 사용한다.&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;
main()
{ printf(&quot;execiton ls\n&quot;)};
execl(&quot;/bin/ls&quot;,&quot;ls&quot;,&quot;-l&quot;, (char *)0);
perror(&quot;execl failed to run ls\n&quot;);
exit(1);}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;exec: Program Execution&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스 실행을 맡고 있는 시스템 콜은 execve()이다&lt;/li&gt;
  &lt;li&gt;같은 기능을 하면서 라이브러리 함수로 분류되어 있는것으로 execv(), execvp(), execle(), execl(), execlp()가 있다 ​&lt;/li&gt;
  &lt;li&gt;이 6가지를 합쳐서 exec()시스템 콜이라 부른다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;exec() 이후에 오는 문자에 의해 구별되는 표시는 다음의 의미가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;l -&amp;gt; argv 정보를 개개의 문자열 데이터를 가르키는 포인터 arg0,arg1……. argn으로 전달한다&lt;/li&gt;
  &lt;li&gt;v -&amp;gt; argv 정보를 개개의 문자열 데이터를 가리키는 포인터 배열의 ​
선두주소 argv로 전달한다​&lt;/li&gt;
  &lt;li&gt;e -&amp;gt; envp 정보를 전달한다​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;p -&amp;gt; p를 사용하는 경우, 실행할 파일이름을 환경 변수 PATH로 지정한 디렉토리 안에서 찾아내어 실행한다​&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int execl(const char *path, const char *arg0, ... *argn,
(char *)0);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;path: 실행 가능한 파일 경로&lt;/li&gt;
  &lt;li&gt;arg0~argn: 파일에 전달한 argv 정보(명령 인수)&lt;/li&gt;
  &lt;li&gt;(char*)0: 마지막임을 알리는 표시로 NULL 포인터&lt;/li&gt;
  &lt;li&gt;리턴값: 에러시 -1&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;execl.c&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include&amp;lt;unistd.h&amp;gt;

main(int argc, char *argv[]){
    execl(&quot;/bin/ls&quot;,&quot;ls&quot;,argv[1],(char *)0);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;execv.c&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include&amp;lt;unistd.h&amp;gt;
main(){
    char *av[3];

    av[0]=&quot;ls&quot;;
    av[1]=&quot;-1&quot;;
    av[2]=(char *)0;

    execv(&quot;/bin/ls&quot;,av);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;execle()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; #include &amp;lt;unistd.h&amp;gt;

 int execle(const char *path, const char *arg0...*argn,
                    (char *)0, char *const envp[]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;path: 파일의 경로명&lt;/li&gt;
  &lt;li&gt;arg0 ~ argn: 파일에 전달한 argv 정보(명령 인수)&lt;/li&gt;
  &lt;li&gt;envp[]: envp 정보(환경변수)&lt;/li&gt;
  &lt;li&gt;리턴 값: 에러시 -1&lt;/li&gt;
  &lt;li&gt;execl()에 환경 변수 정보를 전달하는 기능을 추가한 것&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;execve()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int execve(const char* path, char *const argv[],
                char *const envp[]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;path: 파일의 경로명&lt;/li&gt;
  &lt;li&gt;argv: 파일에 전달한 argv 정보(명령 인수)&lt;/li&gt;
  &lt;li&gt;envp[]: envp 정보(환경변수)&lt;/li&gt;
  &lt;li&gt;리턴 값: 에러시 -1&lt;/li&gt;
  &lt;li&gt;execv()에 환경 변수 정보를 전달하는 기능을 추가한 것&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;execlp()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int execlp(const char *file, const char *arg0, .... *argn);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;file: 실행하는 파일의 파일 이름&lt;/li&gt;
  &lt;li&gt;arg0 ~ argn: 파일에 전달한 argv 정보(명령 인수)&lt;/li&gt;
  &lt;li&gt;리턴 값: 에러시 -1&lt;/li&gt;
  &lt;li&gt;execlp()는 첫 번째 인자 file에서 지정한 파일 이름을 환경 변수 PATH에서 지정하고 있는 디렉토리 안에서 찾아 실행한다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;execvp()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int execvp(const char *file, char *const argv[]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;file: 실행하는 파일의 파일 이름&lt;/li&gt;
  &lt;li&gt;argv: 파일에 전달한 argv 정보(명령 인수)&lt;/li&gt;
  &lt;li&gt;리턴 값: 에러시 -1&lt;/li&gt;
  &lt;li&gt;execlp()는 첫 번째 인자 file에서 지정한 파일 이름을 환경 변수 PATH에서 지정하고 있는 디렉토리 안에서 찾아 실행한다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Race Conditions&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;여러 프로세스가 일부 데이터를 공유&lt;/li&gt;
  &lt;li&gt;결과는 실행 순서(예: RACE)에 따라 다르다&lt;/li&gt;
  &lt;li&gt;fork() 후에는 부모 또는 자식이 먼저 실행되는지 예측할 수 없다&lt;/li&gt;
  &lt;li&gt;실행 순서는 다음에 따라 다르다
    &lt;ul&gt;
      &lt;li&gt;시스템 부하&lt;/li&gt;
      &lt;li&gt;커널의 스케줄링 알고리즘&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Race condition 문제는 대부분의 시간 작동하기 때문에 감지하기 어렵다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;after fork
    &lt;ul&gt;
      &lt;li&gt;parent,child 모두 스스로 무언가를 한다&lt;/li&gt;
      &lt;li&gt;예를 들어 parent: 로그 파일에 기록 쓰기&lt;/li&gt;
      &lt;li&gt;예를 들어 child: 로그 파일 생성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;parent,child는 다음을 수행해야 한다
    &lt;ul&gt;
      &lt;li&gt;초기 작업 세트가 완료되면 서로 알리고&lt;/li&gt;
      &lt;li&gt;서로 완료될 때까지 기다린다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;system()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;

int system(const char *cmdstring);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;문자열이 터미널에서 명령으로 입력된 것처럼 문자열이 sh(1)에 입력으로 제공한다. ex) system(“date &amp;gt; file”);&lt;/li&gt;
  &lt;li&gt;fork, exec 및 waitpid를 호출하여 시스템을 구현한다.&lt;/li&gt;
  &lt;li&gt;반환 값:
    &lt;ul&gt;
      &lt;li&gt;-1 with errno: fork 또는 waitpid 실패&lt;/li&gt;
      &lt;li&gt;127 : 실행 실패&lt;/li&gt;
      &lt;li&gt;쉘 종료 상태: 3개 모두 성공&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Process Times&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/times.h&amp;gt;

clock_t times(struct tms *buf);

struct tms(
    clock_t tms_utime;
    clock_t tms_stime;
    clock_t tms_cutime;
    clock_t tms_cstime;
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;wall clock time: 프로세스가 실행되는 데 걸리는 시간이며 시스템 부하에 따라 다르다.
    &lt;ul&gt;
      &lt;li&gt;반환된 wall clock time의 시간은 과거의 임의의 지점에서 측정된다. 상대 값을 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자 CPU 시간: 사용자 지침에 기인&lt;/li&gt;
  &lt;li&gt;시스템 CPU 시간: 프로세스를 대신하여 실행될 때 커널에 귀속됨&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="system" />
      

      
        <summary type="html">Process Control</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Process</title>
      <link href="https://lee989898.github.io/st-05" rel="alternate" type="text/html" title="Process" />
      <published>2021-10-06T01:06:00+09:00</published>
      <updated>2021-10-06T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/st-05</id>
      <content type="html" xml:base="https://lee989898.github.io/st-05">&lt;h3 id=&quot;process&quot;&gt;&lt;strong&gt;Process&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Definition of Process&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;실행 중인 프로그램&lt;/li&gt;
  &lt;li&gt;프로그램
    &lt;ul&gt;
      &lt;li&gt;데이터와 instructions로 구성된 파일&lt;/li&gt;
      &lt;li&gt;프로그램은 수동적이다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로그램을 실행시키기 위해서는 커널 루틴, 리소스(cpu,메모리 등)으로부터 지원을 받아야 한다&lt;/li&gt;
  &lt;li&gt;프로세스는 다음과 같이 다르게 정의될 수 있다
    &lt;ul&gt;
      &lt;li&gt;프로그램 + HW/SW 실행에 필요한 프로그램&lt;/li&gt;
      &lt;li&gt;프로그램을 실행할 수 있는 환경&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Environment ​
    &lt;ul&gt;
      &lt;li&gt;이미지 또는 컨텍스트라고도 함&lt;/li&gt;
      &lt;li&gt;프로그램 텍스트, 힙, 스택, 레지스터 값, 시스템 데이터(현재 디렉토리, open 파일 디스크립터, 누적 CPU 시간 등)로 구성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Modes of Process&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;사용자 프로세스는 호출될 커널 프로세스를 트리거하는 시스템 호출을 사용할 수 있다&lt;/li&gt;
  &lt;li&gt;User process / kernel process
    &lt;ul&gt;
      &lt;li&gt;트랩 명령(또는 인터럽트)은 사용자 프로세스(모드)에서 커널 프로세스(모드)로의 전환을 할 수 있다&lt;/li&gt;
      &lt;li&gt;커널 프로세스에서 사용자 프로세스로 복귀&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Process Level&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Level 0: swapper (scheduler)​&lt;/li&gt;
  &lt;li&gt;Level 1: kernel process​&lt;/li&gt;
  &lt;li&gt;Level 2: system process​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Level 3: cmd process&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Swapper (scheduler) process​
    &lt;ul&gt;
      &lt;li&gt;스스로 프로세스가 되어 실행을 시작하는 커널 프로그램&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;fork() system call​
    &lt;ul&gt;
      &lt;li&gt;부모 프로세스는 fork()를 호출하여 자식 프로세스를 생성한다&lt;/li&gt;
      &lt;li&gt;자식 프로세스는 부모 프로세스의 모든 환경을 상속한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;각 프로세스가 생성될 때 고유 번호(프로세스 ID)가 할당된다&lt;/li&gt;
  &lt;li&gt;ID가 0인 프로세스는 특별한 커널 프로세스이다&lt;/li&gt;
  &lt;li&gt;프로세스 0 forks()하면 init라고 하는 다른 프로세스(ID 1)생긴다&lt;/li&gt;
  &lt;li&gt;fork init 후 프로세스 0은 스와퍼(또는 스케줄러)가 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Process Tree&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Init 프로세스는 시스템에서 생성된 모든 프로세스의 조상이 된다&lt;/li&gt;
  &lt;li&gt;Init​
    &lt;ul&gt;
      &lt;li&gt;sendmail, crom, etc. ​&lt;/li&gt;
      &lt;li&gt;사용자 ID/암호를 묻는 프로세스 -&amp;gt; Shell​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;따라서 init 프로세스를 루트로 하여 “프로세스 트리”가 형성된다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Process: State&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;New: 프로세스 생성 중&lt;/li&gt;
  &lt;li&gt;Running: 명령이 실행되고 있다&lt;/li&gt;
  &lt;li&gt;Waiting: 프로세스가 어떤 이벤트가 발생하기를 기다리고 있다&lt;/li&gt;
  &lt;li&gt;Ready: 프로세스가 프로세서에 할당되기를 기다리고 있다&lt;/li&gt;
  &lt;li&gt;Terminated: 프로세스가 실행을 완료했다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Process Group&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;동일한 로그인 셸(상위 프로세스)에서 생성된 프로세스를 프로세스 그룹이라고 한다&lt;/li&gt;
  &lt;li&gt;프로세스 그룹 ID로 식별한다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Process Priority&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;각 프로세스에는 우선 순위가 지정된다&lt;/li&gt;
  &lt;li&gt;Swapper는 우선 순위가 가장 높은 프로세스를 선택한다&lt;/li&gt;
  &lt;li&gt;우선 순위 범위는 0(최고) ~ 127(최저)
    &lt;ul&gt;
      &lt;li&gt;프로세스의 우선 순위를 확인하려면 “%ps -ef” 및 “%ps -el”을 사용하면 된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모든 프로세스에 동등한 기회를 제공하기 위해 우선 순위가 동적으로 변경된다&lt;/li&gt;
  &lt;li&gt;“nice” 명령(nice() 시스템 호출)은 자발적으로 프로세스의 우선 순위를 낮추는 데 사용된다 ​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Process ID&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;User ID​
    &lt;ul&gt;
      &lt;li&gt;Real user ID​&lt;/li&gt;
      &lt;li&gt;Effective user ID​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Group ID​
    &lt;ul&gt;
      &lt;li&gt;Real user ID​&lt;/li&gt;
      &lt;li&gt;Effective user ID​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Signal&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;실행중인 프로세스를 외부에서 제어하는 수단​&lt;/li&gt;
  &lt;li&gt;프로세스간에 동기화를 얻는 수단​&lt;/li&gt;
  &lt;li&gt;SW interrupt 로 구현됨​&lt;/li&gt;
  &lt;li&gt;kill() system call 을 이용하여 process 간에 signal 들을 보냄​&lt;/li&gt;
  &lt;li&gt;signal() system call specifies “what to do” when a process receives a signal​&lt;/li&gt;
  &lt;li&gt;Try “% kill –l”&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Process: Creation
    &lt;ul&gt;
      &lt;li&gt;프로세스는 여러 개의 새로운 프로세스를 생성할 수 있다&lt;/li&gt;
      &lt;li&gt;생성 프로세스: parent 프로세스&lt;/li&gt;
      &lt;li&gt;새로 생성된 프로세스: child 프로세스
        &lt;ul&gt;
          &lt;li&gt;fork() 시스템 호출은 새로운 프로세스를 생성한다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;리소스 공유
        &lt;ul&gt;
          &lt;li&gt;자식은 부모의 일부 리소스를 공유합니다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Execution​
        &lt;ul&gt;
          &lt;li&gt;부모와 자식이 함께 실행&lt;/li&gt;
          &lt;li&gt;부모는 자식이 끝날 때까지 기다린다&lt;/li&gt;
          &lt;li&gt;wait() 시스템 호출은 자식이 종료될 때까지 기다린다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Process: Exit&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스는 최종 명령 실행을 마치면 종료된다&lt;/li&gt;
  &lt;li&gt;exit() 시스템 호출을 사용하여 운영 체제에 자신을 삭제하도록 요청한다
    &lt;ul&gt;
      &lt;li&gt;프로세스는 데이터를 부모 프로세스로 반환할 수 있다(wait() 시스템 호출을 통해)&lt;/li&gt;
      &lt;li&gt;프로세스의 모든 리소스(물리적 및 가상 메모리, open 파일 및 I/O 버퍼 포함)는 운영 체제에 의해 할당 해제된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로세스는 적절한 시스템 호출(예: abort())을 통해 다른 프로세스를 종료할 수 있다.&lt;/li&gt;
  &lt;li&gt;사용자가 임의로 프로세스를 종료(kill)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Process Start&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;int main(int argc, char *argv[]);​
    &lt;ul&gt;
      &lt;li&gt;arc :     command-line arguments의 수​&lt;/li&gt;
      &lt;li&gt;argv[] :  arguments​에 대한 포인터 배열&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;C start-up routine​
    &lt;ul&gt;
      &lt;li&gt;커널에 의해 시작됨(by the exec system call)​&lt;/li&gt;
      &lt;li&gt;커널에서 command-line arguments와 environment 가져오기&lt;/li&gt;
      &lt;li&gt;Call main&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Process Termination&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Normal termination
    &lt;ul&gt;
      &lt;li&gt;return from main()​&lt;/li&gt;
      &lt;li&gt;calling exit() : ​&lt;/li&gt;
      &lt;li&gt;calling _exit() ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Abnormal termination
    &lt;ul&gt;
      &lt;li&gt;calling abort()​&lt;/li&gt;
      &lt;li&gt;terminated by a signal&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;exit()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    #include &amp;lt;stdlib.h&amp;gt;

    void exit(int status);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;정상적인 프로세스 종료&lt;/li&gt;
  &lt;li&gt;Execution of clean-up processing​
    &lt;ul&gt;
      &lt;li&gt;열려 있는 모든 스트림 닫기&lt;/li&gt;
      &lt;li&gt;출력 버퍼의 내용을 디스크에 쓰기&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;상태
    &lt;ul&gt;
      &lt;li&gt;프로세스의 종료 상태&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;_exit()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    #include &amp;lt;unistd.h&amp;gt;

    void _exit(int status);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;정상적인 프로세스 종료&lt;/li&gt;
  &lt;li&gt;즉시 커널로 돌아가기&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;atexit()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    #include &amp;lt;stdlib.h&amp;gt;

    void atexit(void (*func)(void));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;사용자가 정의한 종료 핸들러를 등록한다
    &lt;ul&gt;
      &lt;li&gt;프로세스당 최대 32개&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기능
    &lt;ul&gt;
      &lt;li&gt;종료 핸들러&lt;/li&gt;
      &lt;li&gt;함수 포인터&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;exit()는 등록의 역순으로 exit 핸들러를 호출한다&lt;/li&gt;
  &lt;li&gt;비정상 종료(abort) 시 atexit에 등록된 기능이 실행되지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Command-Line Arguments&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;exec() 및 C-start-up 루틴은 새 프로그램에 command-line arguments를 전달한다&lt;/li&gt;
  &lt;li&gt;Linux 셸의 정상 작동의 일부&lt;/li&gt;
  &lt;li&gt;argv[argc]는 NULL 문자(ANSI, POSIX.1)이다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Environment Variable&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;환경 변수는 부모 프로세스에서 자식 프로세스로 전송된다&lt;/li&gt;
  &lt;li&gt;파일(.login 또는 .cshrc)에 설정된 환경 변수&lt;/li&gt;
  &lt;li&gt;환경 변수: 이름 = 값&lt;/li&gt;
  &lt;li&gt;전역 변수 “environ”을 사용하여 환경 변수에 액세스한다
    &lt;ul&gt;
      &lt;li&gt;#include &lt;stdlib.h&gt;&lt;/stdlib.h&gt;&lt;/li&gt;
      &lt;li&gt;extern char ** environ;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;각 환경 변수는 “name=value” 형식의 문자열로 구성된다
    &lt;ul&gt;
      &lt;li&gt;각 문자열은 ‘\0’으로 끝난다&lt;/li&gt;
      &lt;li&gt;마지막 환경 변수 목록은 널 포인터이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;argv와 같은 구조&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;getenv()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    #include &amp;lt;stdlib.h&amp;gt;

    char *getenv(const char *name);
        반환값: 이름과 관련된 값에 대한 포인터, 찾을 수 없으면 NULL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;주어진 이름의 문자열에 대한 환경 목록 검색&lt;/li&gt;
  &lt;li&gt;일치하는 항목이 발견되면 해당 이름과 관련된 값을 반환한다.&lt;/li&gt;
  &lt;li&gt;요청한 변수가 존재하지 않으면 null을 반환한다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;putenv()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    #include &amp;lt;stdlib.h&amp;gt;

    int putenv(const char *str);
        반환값: 정상이면 0, 오류 시 0이 아닌 값
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;“name=value” 형식의 문자열을 취한다.&lt;/li&gt;
  &lt;li&gt;현재 환경 목록에 추가&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;setenv() / unsetenv()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    #include &amp;lt;stdlib.h&amp;gt;​

    int setenv(const char *name, const char *value, int rewrite);                                                                반환값: 정상이면 0, 오류 시 0이 아님

    void unsetenv(const char *name);​ 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;etenv 등록 환경 변수 이름 = 값&lt;/li&gt;
  &lt;li&gt;같은 이름의 환경변수가 존재하는 경우
    &lt;ul&gt;
      &lt;li&gt;rewrite != 0 -&amp;gt; change new value​&lt;/li&gt;
      &lt;li&gt;rewrite = 0 -&amp;gt; not change&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;unsetenv는 환경 변수 이름을 제거한다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Memory Layout of a program​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st11.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프러그래밍&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;텍스트 세그먼트: 기계 instructions(읽기 전용, 공유 가능)&lt;/li&gt;
  &lt;li&gt;초기화된 데이터 세그먼트:​
    &lt;ul&gt;
      &lt;li&gt;e.g. int maxcount = 99; (initialized)​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;초기화되지 않은 데이터 세그먼트 또는 bss (block started by symbol)​
    &lt;ul&gt;
      &lt;li&gt;e.g. long sum[1000];​&lt;/li&gt;
      &lt;li&gt;프로그램이 실행되기 전에 exec에 의해 0 또는 널 포인터로 초기화됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(Use “size” command: % size a.out)​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Heap: ​
    &lt;ul&gt;
      &lt;li&gt;동적 메모리 할당 (malloc, etc.)​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Stack: ​
    &lt;ul&gt;
      &lt;li&gt;자동 변수, 임시 변수, 반환 주소, 호출자 환경(레지스터)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shared library&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Static linking library​
    &lt;ul&gt;
      &lt;li&gt;라이브러리 루틴이 실행 파일에 추가된다&lt;/li&gt;
      &lt;li&gt;실행 파일 크기 증가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Shared library​
    &lt;ul&gt;
      &lt;li&gt;파일 실행을 위한 라이브러리 루틴 포함&lt;/li&gt;
      &lt;li&gt;라이브러리 루틴은 공유 메모리에 로드되고 실행 중에 공유된다&lt;/li&gt;
      &lt;li&gt;프로그램 크기는 증가하지 않는다&lt;/li&gt;
      &lt;li&gt;처음 실행할 때 오버헤드가 발생한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Static libraries as .a (archive files)​
    &lt;ul&gt;
      &lt;li&gt;관련된 재배치 가능한 개체 파일을 인덱스(아카이브라고 함)가 있는 단일 파일로 연결한다&lt;/li&gt;
      &lt;li&gt;아카이브 구성원 파일이 참조를 확인하는 경우 실행 파일에 링크한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st12.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프러그래밍&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;libc.a (the C standard library)​
    &lt;ul&gt;
      &lt;li&gt;1392개 개체 파일의 8MB 아카이브.&lt;/li&gt;
      &lt;li&gt;I/O, memory allocation, signal handling, string handling, data and time, random numbers, integer math​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;libm.a (the C math library)​
    &lt;ul&gt;
      &lt;li&gt;401개 개체 파일의 1MB 아카이브.​&lt;/li&gt;
      &lt;li&gt;floating point math (sin, cos, tan, log, exp, sqrt, …) ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shared Libraries&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;정적 라이브러리에는 저장된 실행 파일이 중복된다는 단점이 있다(모든 기능에는 std libc가 필요함)&lt;/li&gt;
  &lt;li&gt;최신 솔루션: 공유 라이브러리​
    &lt;ul&gt;
      &lt;li&gt;응용 프로그램에 동적으로 로드 및 연결,​
        &lt;ul&gt;
          &lt;li&gt;로드 타임 또는 런타임 시&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;동적 링크 라이브러리, DLL, .so 파일이라고도 함&lt;/li&gt;
      &lt;li&gt;일반적으로 동적으로 연결되는 표준 C 라이브러리(libc.so)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;동적 연결은 프로그램이 시작된 후에도 발생할 수 있다 (런타임 링크)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Memory Allocation​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;​

void *malloc(size_t size);​
void *calloc(size_t nobj, size_t size);​
void *realloc(void *ptr, size_t newsize);​
            반환: 정상이면 널이 아닌 포인터, 오류 시 NULL
void free(void *ptr);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;힙에 동적 메모리 할당&lt;/li&gt;
  &lt;li&gt;적절한 정렬 제공
    &lt;ul&gt;
      &lt;li&gt;ex) double은 8의 배수인 주소에서 시작해야 한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;라이브러리는 메모리 풀을 관리한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;malloc(): ​
    &lt;ul&gt;
      &lt;li&gt;지정된 바이트 수 할당&lt;/li&gt;
      &lt;li&gt;메모리의 초기 값이 결정되지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;calloc(): ​
    &lt;ul&gt;
      &lt;li&gt;지정된 크기의 지정된 수의 개체 할당​&lt;/li&gt;
      &lt;li&gt;모두 0비트로 초기화&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;realloc(): ​
    &lt;ul&gt;
      &lt;li&gt;이전에 할당된 메모리의 크기를 변경합니다.&lt;/li&gt;
      &lt;li&gt;새로운 영역의 초기 값이 결정되지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;setjmp() / longjmp() ​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;setjmp.h&amp;gt;​

int setjmp(jmp_buf env);​
               반환값 : 0, 직접 호출된 경우
                없음 0, longjmp 호출에서 반환하는 경우
void longjmp(jmp_buf env, int val);​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;함수 호출 건너뛰기(nonlocal goto)&lt;/li&gt;
  &lt;li&gt;깊이 중첩된 함수 호출에서 오류 조건을 처리하는 데 유용하다
    &lt;ul&gt;
      &lt;li&gt;오류가 발생했을 때 빠르게 main()으로 돌아가고 싶은 경우&lt;/li&gt;
      &lt;li&gt;많은 수의 수준 각 오류에 대해 각 수준에서 반환 처리&lt;/li&gt;
      &lt;li&gt;Direct nonlocal goto: setjmp, longjmp​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;env: setjmp 및 longjmp에 사용되는 전역 변수​&lt;/li&gt;
  &lt;li&gt;setjmp: env의 setjmp 지점으로 돌아가기 위한 정보 저장
    &lt;ul&gt;
      &lt;li&gt;직접 호출하면 0 반환&lt;/li&gt;
      &lt;li&gt;longjmp에 대한 호출에서 반환하는 경우 0이 아닌 값을 반환한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;longjmp: env를 사용하여 setjmp 지점으로 이동하고 val을 반환 값으로 사용
    &lt;ul&gt;
      &lt;li&gt;여러 longjmp가 다른 val로 동일한 setjmp 위치를 사용할 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;env는 다른 함수에서 참조할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="system" />
      

      
        <summary type="html">Process</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">File 조작</title>
      <link href="https://lee989898.github.io/st-04" rel="alternate" type="text/html" title="File 조작" />
      <published>2021-09-24T01:06:00+09:00</published>
      <updated>2021-09-24T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/st-04</id>
      <content type="html" xml:base="https://lee989898.github.io/st-04">&lt;h3 id=&quot;file-조작&quot;&gt;&lt;strong&gt;File 조작&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;File system structure ​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st08.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;i-node
    &lt;ul&gt;
      &lt;li&gt;인덱스 노드의 준말&lt;/li&gt;
      &lt;li&gt;파일의 메타 데이터 저장되어있는 영역&lt;/li&gt;
      &lt;li&gt;하드디스크에 저장되어 있다&lt;/li&gt;
      &lt;li&gt;실제 내용
        &lt;ul&gt;
          &lt;li&gt;file type​&lt;/li&gt;
          &lt;li&gt;access permission bits​&lt;/li&gt;
          &lt;li&gt;file size​&lt;/li&gt;
          &lt;li&gt;pointers to data blocks for the file&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Stat 구조체의 field들은 i-node에서 읽어온다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st09.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;directory block
    &lt;ul&gt;
      &lt;li&gt;directory block에는 파일 목록이 있다​
        &lt;ul&gt;
          &lt;li&gt;파일 이름&lt;/li&gt;
          &lt;li&gt;파일의 i-노드 번호​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;hard link​
    &lt;ul&gt;
      &lt;li&gt;디렉토리 블록에서 i-node로 링크&lt;/li&gt;
      &lt;li&gt;i-노드 번호를 사용하여 링크 만들기​&lt;/li&gt;
      &lt;li&gt;Hard link는 같은 file system 내부에서만 연결 가능​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;i-노드의 링크 수
    &lt;ul&gt;
      &lt;li&gt;i-노드를 가리키는 디렉토리 항목 수&lt;/li&gt;
      &lt;li&gt;Stat 구조체의 st_link&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st10.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Directory file의 data block 내용으로는  (i-node no, file name) entry 들이 기록된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Symbolic link​
    &lt;ul&gt;
      &lt;li&gt;Linux 명령 ‘% ln –s /usr/lib lib’​&lt;/li&gt;
      &lt;li&gt;ex) lrwxrwxrwx 1 root   7   Sep 25  07:14   lib -&amp;gt; /usr/lib​
        &lt;ul&gt;
          &lt;li&gt;파일 이름: lib​&lt;/li&gt;
          &lt;li&gt;파일 내용: /usr/lib​&lt;/li&gt;
          &lt;li&gt;파일 크기: 7 bytes​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;파일(데이터 블록)의 내용은 대상 링크의 경로 이름이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;파일 삭제
    &lt;ul&gt;
      &lt;li&gt;디렉토리 블록에서 파일이 삭제되면 i-node의 링크 수가 감소한다&lt;/li&gt;
      &lt;li&gt;링크 수가 0이 되면 파일의 i-node와 데이터 블록이 모두 삭제된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파일 이동
    &lt;ul&gt;
      &lt;li&gt;리눅스 명령어: mv​&lt;/li&gt;
      &lt;li&gt;파일의 i-node 및 데이터 블록을 변경하지 않고 디렉토리 항목 변경&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;link() / unlink()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int link(const char * cur_path, const cbar * new_path)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이 호출은 기존 파일(cur_path)에 대한 새 링크/디렉토리 항목(new_path)을 만든다
    &lt;ul&gt;
      &lt;li&gt;같은 i-node를 가리키는 directory entry가 하나 더 만들어짐​&lt;/li&gt;
      &lt;li&gt;해당 i-node의 link count가 하나 증가​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;반환 값
    &lt;ul&gt;
      &lt;li&gt;성공: 0, 링크 수 증가&lt;/li&gt;
      &lt;li&gt;오류: -1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;매개변수
    &lt;ul&gt;
      &lt;li&gt;cur_path: 현재 하드 링크(또는 pathname)&lt;/li&gt;
      &lt;li&gt;new_path: 새로운 하드 링크(또는 pathname)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;보통 link count가 0이 되면 해당 파일은 삭제됨​&lt;/li&gt;
  &lt;li&gt;다른 프로세스가 사용중인 파일이 삭제되는 것을 방지하기 위해 link count가 0에 도달했더라도 그 파일을 open 한 프로세스의 수가 0 이상이면 삭제하지 않는다​&lt;/li&gt;
  &lt;li&gt;파일이 close 될 때 kernel은 그 파일을 open 한 프로세스 수가 0 인지 확인하고, 0 일 경우 link count가 0 인지 확인하고 삭제한다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;remove()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int remove(const char *pathname);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;remove()는 파일의 링크 수를 줄이기 때문에 unlink()와 유사하다&lt;/li&gt;
  &lt;li&gt;반환 값
    &lt;ul&gt;
      &lt;li&gt;성공 : 0&lt;/li&gt;
      &lt;li&gt;오류: -1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;매개변수
    &lt;ul&gt;
      &lt;li&gt;Pathname: 디렉토리 파일의 경로명이 있는 문자열&lt;/li&gt;
      &lt;li&gt;pathname이 파일이면 remove() = unlink()&lt;/li&gt;
      &lt;li&gt;pathname이 디렉토리이면 remove() = rmdir()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;rename()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int rename(const char *oldname, const char *newname);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;파일 또는 디렉토리 이름 지정&lt;/li&gt;
  &lt;li&gt;반환 값
    &lt;ul&gt;
      &lt;li&gt;성공: 0&lt;/li&gt;
      &lt;li&gt;오류: -1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;매개변수
    &lt;ul&gt;
      &lt;li&gt;oldname: 현재 하드 링크&lt;/li&gt;
      &lt;li&gt;newname: 새로운 하드 링크&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;umask()​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;

mode_t umask(mode_t newmask);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;새 파일의 mask 값 설정&lt;/li&gt;
  &lt;li&gt;umask()는 이전 마스크 값을 반환한다&lt;/li&gt;
  &lt;li&gt;매개변수
    &lt;ul&gt;
      &lt;li&gt;newmask: bitwise OR
        &lt;ul&gt;
          &lt;li&gt;S_IRUSR, S_IWUSR, S_IXUSR&lt;/li&gt;
          &lt;li&gt;S_IRGRP, S_IWGRP, S_IXGRP&lt;/li&gt;
          &lt;li&gt;S_IROTH, S_IWOTH, S_IXOTH&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;umask : 파일 모드 작성 mask (8진수로 표시)​
    &lt;ul&gt;
      &lt;li&gt;(예) root user의 umask 값 : 0022​&lt;/li&gt;
      &lt;li&gt;일반 user의 mask 값 : 0002​&lt;/li&gt;
      &lt;li&gt;umask –S 커맨드를 사용하면 symbolic 값을 볼 수 있음​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파일의 실제 허가(protection) mode​
    &lt;ul&gt;
      &lt;li&gt;현재의 umask값에 NOT 연산을 수행한 값과 파일이 생성될 때의 모드 값을 AND (논리 연산)시킨 값 : AND(mode, NOT(umask))​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;chmod() / fchmod()​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int chmod(const char *pathname, mode_t mode);
int fchmod(int fd, mode_t mode);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이 호출은 파일의 액세스 권한을 변경하는 데 사용된다.
    &lt;ul&gt;
      &lt;li&gt;Stat 구조체의 st_mode 변경&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;반환 값
    &lt;ul&gt;
      &lt;li&gt;성공 : 0&lt;/li&gt;
      &lt;li&gt;오류: -1, 변수를 설정합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;매개변수
    &lt;ul&gt;
      &lt;li&gt;pathname: pathname이 있는 문자열&lt;/li&gt;
      &lt;li&gt;fd: 파일 디스크립터&lt;/li&gt;
      &lt;li&gt;mode: 파일 보호 모드&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;truncate() / ftruncate()​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int truncate(const char *pathname, size_t length);
int ftruncate(int fd, size_t length);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이러한 호출은 파일 디스크립터 또는 pathname에서 참조하는 파일을 길이로 지정된 길이로 자른다.&lt;/li&gt;
  &lt;li&gt;반환 값
    &lt;ul&gt;
      &lt;li&gt;성공: 0&lt;/li&gt;
      &lt;li&gt;오류: -1, 변수 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;매개변수
    &lt;ul&gt;
      &lt;li&gt;pathname: pathname이 있는 문자열&lt;/li&gt;
      &lt;li&gt;fd: 파일 디스크립터&lt;/li&gt;
      &lt;li&gt;길이: 크기&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;utime()​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;unistd.h&amp;gt;​
#include &amp;lt;utime.h&amp;gt;​

int utime(const char *pathname, struct utimebuf *times);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;utime()은 타임스탬프를 수정한다&lt;/li&gt;
  &lt;li&gt;반환 값
    &lt;ul&gt;
      &lt;li&gt;성공: 0&lt;/li&gt;
      &lt;li&gt;오류: -1 및 변수 ‘errno’ 설정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;매개변수
    &lt;ul&gt;
      &lt;li&gt;pathname: 파일의 경로명&lt;/li&gt;
      &lt;li&gt;시간: 마지막 액세스 시간 및 수정 시간&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;struct utimebuf​{​
  time_t    actime;        /* access time &lt;em&gt;/​
  time_t    modtime;       /&lt;/em&gt; modify time */​
  };&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;각 필드는 1970-1-1 00:00 부터 현재까지의 경과 시간을 초로 환산한 값​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Directory​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;디렉토리는 일종의 파일이다
    &lt;ul&gt;
      &lt;li&gt;디렉토리에는 소유자, 그룹 및 권한도 있다.&lt;/li&gt;
      &lt;li&gt;디렉토리에 대해 open, read, fstat, close를 사용할 수 있다&lt;/li&gt;
      &lt;li&gt;차이 creat() 및 open()을 사용하여 디렉토리를 생성할 수 없음 -&amp;gt; 그렇게 하려면 mkdir() 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;각 디렉토리 항목에는 i-노드 번호와 파일 이름이 있다.&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;dirent.h&amp;gt; ​

struct dirent {​
ino_t d_ino;          /* i-node number */​
char  d_name[ ];  /* filename */​
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;mkdir()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int mkdir(const char *pathname, mode_t mode);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;mkdir()은 디렉토리를 만드는 데 사용된다&lt;/li&gt;
  &lt;li&gt;매개변수
    &lt;ul&gt;
      &lt;li&gt;pathname: 새 디렉토리의 경로명&lt;/li&gt;
      &lt;li&gt;mode: 디렉토리 권한&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;반환 값
    &lt;ul&gt;
      &lt;li&gt;성공: 0&lt;/li&gt;
      &lt;li&gt;오류: -1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;. 과 .. 을 새로 생성된 디렉토리에 넣는다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;opendir() / readdir() / closedir() / rewinddir()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;dirent.h&amp;gt;​
typedef struct dirent Dirent;​

DIR *opendir(const char *pathname);​

dirent *readdir(DIR *dir_fd);​

int closedir(DIR *dir_fd);​

void rewinddir (DIR *dir_fd); 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;DIR 구조체​
    &lt;ul&gt;
      &lt;li&gt;open된 디렉토리를 다루는데 사용되는 구조체​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;opendir() 함수는 open()과 유사하다&lt;/li&gt;
  &lt;li&gt;opendir()은 디렉토리 파일을 읽기 전용으로 연다&lt;/li&gt;
  &lt;li&gt;opendir()은 열린 디렉토리의 파일 포인터를 반환한다&lt;/li&gt;
  &lt;li&gt;closedir()은 dir_fd가 가리키는 디렉토리 파일을 닫는다&lt;/li&gt;
  &lt;li&gt;readdir()
    &lt;ul&gt;
      &lt;li&gt;첫 번째 호출이 성공하면 디렉토리의 첫 번째 항목을 struct dirent에서 읽는다&lt;/li&gt;
      &lt;li&gt;그런 다음 자동으로 디렉토리 포인터가 다음 항목으로 이동한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;rewinddir()은 디렉토리 포인터를 디렉토리의 첫 번째 항목으로 이동한다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;rmdir()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;​

int rmdir(const char *pathname);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;디렉토리 파일 제거&lt;/li&gt;
  &lt;li&gt;성공하려면 디렉토리가 비어 있어야 합니다&lt;/li&gt;
  &lt;li&gt;반환 값
    &lt;ul&gt;
      &lt;li&gt;성공: 0&lt;/li&gt;
      &lt;li&gt;오류: -1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;매개변수
    &lt;ul&gt;
      &lt;li&gt;경로명: 디렉토리의 경로명&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;chdir()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;​​

int chdir(const char *pathname);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;디렉토리 변경&lt;/li&gt;
  &lt;li&gt;반환 값
    &lt;ul&gt;
      &lt;li&gt;성공: 0&lt;/li&gt;
      &lt;li&gt;오류: -1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;매개변수
    &lt;ul&gt;
      &lt;li&gt;pathname: 디렉토리의 전체 또는 상대 경로 이름이 있는 문자열&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;getcwd()​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;​

char *getcwd(char *buf, size_t size);​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;현재 작업 디렉토리의 경로 이름을 가져온다&lt;/li&gt;
  &lt;li&gt;매개변수
    &lt;ul&gt;
      &lt;li&gt;buf: 현재 디렉토리의 경로명을 저장할 버퍼&lt;/li&gt;
      &lt;li&gt;크기: buf의 크기&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Symbolic link​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;하드 링크의 한계
    &lt;ul&gt;
      &lt;li&gt;디렉토리에 대한 링크를 생성할 수 없다
        &lt;ul&gt;
          &lt;li&gt;루트유저만 가능성&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;다른 파일 시스템에 있는 파일에 대한 링크를 생성할 수 없다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;하드링크의 한계 해결&lt;/li&gt;
  &lt;li&gt;파일에 대한 간접 포인터
    &lt;ul&gt;
      &lt;li&gt;실제 파일에 대한 경로를 저장하고 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파일을 다루는 함수를 사용할 때 심볼릭 링크를 자체를 다루는지 아니면 링크된 대상 파일을 다루는지​&lt;/li&gt;
  &lt;li&gt;심볼릭 링크 자체를 다루는 함수​
    &lt;ul&gt;
      &lt;li&gt;lchown, lstat, readlink, remove, rename, unlink 등​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;링크된 대상 파일을 다루는 함수​
    &lt;ul&gt;
      &lt;li&gt;access, chdir, chmod, chown, creat, exec, link, mkdir, mkfifo, open, opendir, pathconf, stat, truncate 등​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;symlink()&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  #include &amp;lt;unistd.h&amp;gt;​

  int symlink(const char *realname, const char *symname);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;반환 값
    &lt;ul&gt;
      &lt;li&gt;성공 : 0&lt;/li&gt;
      &lt;li&gt;오류: -1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;매개변수
    &lt;ul&gt;
      &lt;li&gt;realname : 현재 파일의 경로명&lt;/li&gt;
      &lt;li&gt;symname : 심볼릭 링크의 경로명&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;readlink()&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  #include &amp;lt;unistd.h&amp;gt;​

  int readlink(const char *pathname, char *buf, int bufsize);​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;심볼릭 링크 파일의 내용을 읽는 함수​
    &lt;ul&gt;
      &lt;li&gt;symlink() 에서 저장된 actualpath 가 buf에 채워진다​&lt;/li&gt;
      &lt;li&gt;null 문자는 채워지지 않는다​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Return values​
    &lt;ul&gt;
      &lt;li&gt;Success : length of string read​&lt;/li&gt;
      &lt;li&gt;Error : -1​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;심볼릭 링크를 open 으로 열면 링크된 대상 파일이 열린다​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;sync() / fsync()​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;버퍼에 있는 내용을 디스크에 쓰도록 한다&lt;/li&gt;
  &lt;li&gt;sync()는 시스템 데몬 프로세스에 의해서 30초마다 호출된다
    &lt;ul&gt;
      &lt;li&gt;I/O 작업이 끝나기 전에 리턴한다​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;fsync()는 지정된 파일에 대해서만 I/O 작업을 수행하도록 한다
    &lt;ul&gt;
      &lt;li&gt;I/O 작업이 끝난 후 리턴한다​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="system" />
      

      
        <summary type="html">File 조작</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">File IO</title>
      <link href="https://lee989898.github.io/st-03" rel="alternate" type="text/html" title="File IO" />
      <published>2021-09-15T01:06:00+09:00</published>
      <updated>2021-09-15T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/st-03</id>
      <content type="html" xml:base="https://lee989898.github.io/st-03">&lt;h3 id=&quot;file-io&quot;&gt;&lt;strong&gt;File IO&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;open() : 열기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;open()은 버퍼 공간을 확보하여 파일을 읽거나 쓸 때 사용한다&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;파일이 존재하지 않을 경우 open()에 의해 새로운 파일이 만들어지기도 한다&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;pathname: 경로(path)명을 포함한 파일의 이름 또는 장치 이름&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;flag: 파일 상태 플래그
    &lt;ul&gt;
      &lt;li&gt;파일을 열 때 취해지는 구체적 행동을 기술한다&lt;/li&gt;
      &lt;li&gt;파일 액세스 flag와 선택적인 flag의 OR 연산으로 나타낸다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파일 액세스 flag: 다음 중 하나만 사용할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;모드(값,8진수)&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;O_RDONLY(00)&lt;/td&gt;
      &lt;td&gt;읽기 전용으로 열기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_WRONLY(01)&lt;/td&gt;
      &lt;td&gt;쓰기 전용으로 열기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_RDWR(02)&lt;/td&gt;
      &lt;td&gt;읽기/쓰기용으로 열기&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;선택적인 flag:&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;모드(값,8진수)&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;O_APPEND(02000)&lt;/td&gt;
      &lt;td&gt;파일의 끝에서부터 데이터를 추가하여 쓴다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_TRUNC(01000)&lt;/td&gt;
      &lt;td&gt;파일의 크기를 0으로 만든다(내용삭제)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_CREAT(0100)&lt;/td&gt;
      &lt;td&gt;파일이 존재하지 않을 경우 생성한다&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;mode:
    &lt;ul&gt;
      &lt;li&gt;mode_t 타입(unsigned int)&lt;/li&gt;
      &lt;li&gt;새로운 파일을 만들 대만 필요&lt;/li&gt;
      &lt;li&gt;Flag에 O_CREAT를 지정한 경우에만 필요 &lt;img src=&quot;/assets/built/images/st/st05.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프러그래밍&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;0~8비트 : 파일의 보호 모드&lt;/li&gt;
      &lt;li&gt;sticky 비트(공유모드)
        &lt;ul&gt;
          &lt;li&gt;여러 사용자들이 이용하는 실행파일에 설정&lt;/li&gt;
          &lt;li&gt;실행 후 텍스트 이미지를 메모리에 보관함으로써 다음 번에 실행될 떄 빠르게 실행하도록 하기 위해 지정&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;setuid 비트 : 1로 셋트 되면 일반사용자가 해당 파일의 소유자 권한으로 파일을 실행할 수 있도록 해준다&lt;/li&gt;
      &lt;li&gt;setgid 비트 : 1로 셋트 되면 일반그룹이 해당 그룹의 소유자  권한으로 파일을 실행 할 수 있도록 해준다​&lt;/li&gt;
      &lt;li&gt;setuid , setgid 비트를 설정하면, 그 파일을 실행하고 있는 동안만 그 프로세스의 실효 사용자 ID와 실효 그룹 ID를 그 실행파일의 소유자 ID와  그룹 ID로 변경할 수 있다 ​&lt;/li&gt;
      &lt;li&gt;예 : root 사용자만이 실행할 수 있는 프로그램을 setuid/setgid 비트를 설정하여 일반 사용자가 실행할 수 있도록 해 준다&lt;/li&gt;
      &lt;li&gt;O_CREAT flag를 사용하여 파일 생성시, 다음의 매개인자를 사용한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;매크로&lt;/th&gt;
      &lt;th&gt;의미&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;S_IRUSR&lt;/td&gt;
      &lt;td&gt;소유자에게 읽기 권한&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;S_IWUSR&lt;/td&gt;
      &lt;td&gt;소유자에게 쓰기 권한&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;S_IXUSR&lt;/td&gt;
      &lt;td&gt;소유자에게 실행 권한&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;S_IRGRP&lt;/td&gt;
      &lt;td&gt;소유그룹에게 읽기권한​&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;S_IWGRP&lt;/td&gt;
      &lt;td&gt;소유그룹에게 쓰기권한​&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;S_IXGRP&lt;/td&gt;
      &lt;td&gt;소유그룹에게 실행권한&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;S_IROTH​&lt;/td&gt;
      &lt;td&gt;other에게 읽기권한​&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;S_IWOTH​&lt;/td&gt;
      &lt;td&gt;other에게 쓰기권한​&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;S_IXOTH&lt;/td&gt;
      &lt;td&gt;other에게 실행권한&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;S_IRWXU​&lt;/td&gt;
      &lt;td&gt;소유자에게 읽기, 쓰기, 실행권한&lt;/td&gt;
      &lt;td&gt;​&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;S_IRWXG​&lt;/td&gt;
      &lt;td&gt;소유그룹에게 읽기, 쓰기, 실행권한&lt;/td&gt;
      &lt;td&gt;​&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;S_IRWXO​&lt;/td&gt;
      &lt;td&gt;other에게 읽기, 쓰기, 실행권한​&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;S_ISUID​&lt;/td&gt;
      &lt;td&gt;셋 사용자 ID 비트를 설정​&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;S_ISGID​&lt;/td&gt;
      &lt;td&gt;셋 그룹 ID 비트를 설정&lt;/td&gt;
      &lt;td&gt;​&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;S_ISVTX​&lt;/td&gt;
      &lt;td&gt;STICKY 비트를 설정&lt;/td&gt;
      &lt;td&gt;​&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;세번째 인자인 mode는 sys/stat.h에서 정의된 플래그의 OR연산으로 만들어진다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;리턴 값: 파일 디스크립터 값 또는 -1(open()이 실패할 경우)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ex) int fd;&lt;br /&gt;
fd = open(“afile”, O_RDWR);&lt;br /&gt;
ex) int fd;&lt;br /&gt;
fd = open(“afile”, O_RDWR|O_CREAT,S_IRUSR|S_IWUSR);&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;File descriptor table: ​
    &lt;ul&gt;
      &lt;li&gt;열려진 모든 파일들은 각각 _IO_FILE 이라는 구조체(/usr/include/libio.h 에 정의 됨)에 정보가 저장됨 ​&lt;/li&gt;
      &lt;li&gt;한 프로세스에 의해 열려진 모든 파일들의 _IO_FILE  타입의 구조체들은 연결 리스트로 결합되어지며, 이것을 file descriptor table이라고 부른다 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;File descriptor table에서 특정 파일의 위치를 가리키는 index 값(int 타입)을 file descriptor 라고 부른다 ​&lt;/li&gt;
  &lt;li&gt;File descriptor 값들 중 0, 1, 2는 특별한 파일들을 위하여 사용된다​
    &lt;ul&gt;
      &lt;li&gt;0은 stdin, 1은 stdout, 그리고 2는 stderr 파일을 지칭한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;close(): 닫기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int close(int fd);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;close()는 작업을 종료하기 위해 사용된다​&lt;/li&gt;
  &lt;li&gt;리턴 값 : 성공이면 0, 에러 발생시 -1을 반환​&lt;/li&gt;
  &lt;li&gt;fd : 닫고자 하는 파일의 파일 디스크립터​&lt;/li&gt;
  &lt;li&gt;한 프로세스에서 열 수 있는 최대 파일 수는 limits.h 내의 상수 OPEN_MAX에서 정의됨(/usr/include/bits/posix1_lim.h)​&lt;/li&gt;
  &lt;li&gt;이 제한은 시스템에 따라 다르지만, POSIX에서는 적어도 20이 되도록 정해져 있다​&lt;/li&gt;
  &lt;li&gt;한꺼번에 열려진 파일의 개수가 OPEN_MAX가 넘지 않도록 close()를 적절히 사용하여야 한다 ​&lt;/li&gt;
  &lt;li&gt;파일을 닫지 않더라도 프로세스가 종료하면 모든 열려진 파일들은 자동적으로 닫힌다​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;creat(): 파일 생성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;새로운 파일을 만들거나, 이미 존재하고 있는 파일의 내용을 모두 무시하고 다시 쓸 때 사용한다​&lt;/li&gt;
  &lt;li&gt;pathname : 경로명​&lt;/li&gt;
  &lt;li&gt;mode : open()의 mode와 동일​&lt;/li&gt;
  &lt;li&gt;리턴 값 : 파일 디스크립터, 실패하면 -1&lt;/li&gt;
  &lt;li&gt;다음의 두 함수 호출은 기능이 동일하다​
    &lt;ul&gt;
      &lt;li&gt;creat( pathname, mode ); ​&lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;open ( pathname, O_WRONLY&lt;/td&gt;
              &lt;td&gt;O_CREAT&lt;/td&gt;
              &lt;td&gt;O_TRUNC, mode);​&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;creat()에서는 그 파일의 크기를 0으로 만든다 ​&lt;/li&gt;
  &lt;li&gt;이때 소유자 모드는 변경하지 않는다​&lt;/li&gt;
  &lt;li&gt;creat()는 open()이 있기 때문에 많이 쓰이지 않는다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;read(): 읽기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

ssize_t read(int filedes, void *buf, size_t nbytes);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;파일에서 원하는 크기의 데이터를 읽는다​&lt;/li&gt;
  &lt;li&gt;리턴 값 :​
    &lt;ul&gt;
      &lt;li&gt;성공하면 읽은 byte 수​&lt;/li&gt;
      &lt;li&gt;파일의 끝을 만나면 0  읽기 종료​&lt;/li&gt;
      &lt;li&gt;실패하면 -1​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;buf : 읽은 데이터를 저장할 메모리의 시작 주소​&lt;/li&gt;
  &lt;li&gt;nbytes : 읽을 바이트 수​&lt;/li&gt;
  &lt;li&gt;buf는 임의의 type의 포인터(generic 포인터)가 될 수 있도록 void 타입으로 지정한다​&lt;/li&gt;
  &lt;li&gt;읽을 데이터가 충분하면 한 번에 nbytes 만큼 읽는다​&lt;/li&gt;
  &lt;li&gt;읽을 데이터가 nbytes 보다 적은 경우 더 적게 읽기도 한다​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ssize_t  read (int filedes,  void *buf, size_t nbytes);​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;size_t  : unsigned integer (unistd.h에서 정의)​&lt;/li&gt;
  &lt;li&gt;ssize_t : signed integer (unistd.h에서 정의)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;write(): 쓰기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

ssize_t write(int filedes, void *buf, size_t nbytes);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;파일에 데이터를 쓴다​&lt;/li&gt;
  &lt;li&gt;리턴 값​
    &lt;ul&gt;
      &lt;li&gt;성공하면 파일에 쓰여진 데이터의 바이트 수​&lt;/li&gt;
      &lt;li&gt;실패하면 -1​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;buf : 쓸 데이터를 저장하고 있는 메모리 공간​&lt;/li&gt;
  &lt;li&gt;nbytes : 쓸 데이터의 바이트 수&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;lseek(): 파일의 현재 위치 이동&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

off_t lseek (int filedes, off_t offset, int whence);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;lseek는 파일에 대한 임의접근을 가능하게 한다​&lt;/li&gt;
  &lt;li&gt;파일의 현재 위치(current file offset)를 이동시킨다. 즉 읽기-쓰기 포인터의 위치, 다음에 읽거나 쓸 바이트의 위치를 변경할 수 있다​&lt;/li&gt;
  &lt;li&gt;파일의 현재 위치(current file offset)​
    &lt;ul&gt;
      &lt;li&gt;파일에 대한 읽기/쓰기는 파일의 현재 위치에서 실행된다​&lt;/li&gt;
      &lt;li&gt;파일을 처음 열면 현재 위치는 0, 즉 파일의 시작이다​&lt;/li&gt;
      &lt;li&gt;읽기/쓰기 후 파일의 현재 위치는 읽기/쓰기 한 byte 수 만큼 저절로 뒤로 이동된다​&lt;/li&gt;
      &lt;li&gt;lseek()를 사용하여  임의의 위치로 파일의 현재 위치를 이동할 수 있다​&lt;/li&gt;
      &lt;li&gt;offset은 음수가 될 수도 있다​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;리턴 값: 성공하면 현재의 읽기/쓰기 포인터의 위치를 리턴, 실패하면 -1&lt;/li&gt;
  &lt;li&gt;offset : 기준점에 더해질 바이트의 수 (byte 단위)​
    &lt;ul&gt;
      &lt;li&gt;SEEK_CUR, SEEK_END 와 같이 쓰일 때는 음수도 가능​&lt;/li&gt;
      &lt;li&gt;off_t는 long int와 같은 의미를 나타낸다​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;whence : 시작위치 정하는 방법으로, 다음 중 하나를 사용한다&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;매크로 이름&lt;/th&gt;
      &lt;th&gt;값&lt;/th&gt;
      &lt;th&gt;포인터 위치 지정 방법&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;SEEK_SET&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;offset이 파일의 맨 앞에서부터 더해져 이동&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SEEK_CUR&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;현재위치에 offset이 더해져 이동&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SEEK_END&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;파일의 마지막 바이트 번호에 더해 이동&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Disk&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st06.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프러그래밍&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Disk들은 platters들로 구성되어 있으며, 각 platter는 두개의 표면(surface)을 갖는다.​
    &lt;ul&gt;
      &lt;li&gt;각 surface는 동심원 모양의 track들로 구성​&lt;/li&gt;
      &lt;li&gt;각 track은 sectors들로 구성되는데, sector들은 gap으로 구분된다&lt;/li&gt;
      &lt;li&gt;정렬된 track들은 cylinder를 이룬다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최근의 disk는 track들을 recording zone들로 분할한다 ​
    &lt;ul&gt;
      &lt;li&gt;같은 zone 내부의 track들은 같은 개수의 sector들을 갖는다.&lt;/li&gt;
      &lt;li&gt;Zone마다 track 당 sector의 개수(sectors/track )가 달라진다. 바깥 쪽 zone은 track당 sector의 개수가 더 많아진다.   ​&lt;/li&gt;
      &lt;li&gt;따라서, disk의 용량을 계산할 때  track당 평균 sector의 개수를 사용한다. ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;I/O efficiency&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;디스크는 mechanical device로서 메모리 (DRAM) 에 비해서 상대적으로 성능이 매우 느린 장치​&lt;/li&gt;
  &lt;li&gt;성능을 위해서는 디스크 I/O의 횟수를 줄이는 것이 바람직(seek time + rotational delay)​
    &lt;ul&gt;
      &lt;li&gt;작은 양을 여러번 I/O 하는 것 보다​&lt;/li&gt;
      &lt;li&gt;많은 양을 한꺼번에 I/O 하여 횟수를 줄이는 것이 좋다​&lt;br /&gt;
  ​
—&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;dup(), dup2(): 파일 디스크립터 복제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;사용 중인 파일 디스크립터의 복사본을 제공​&lt;/li&gt;
  &lt;li&gt;Oldfd가 가리키는 사용자 파일 디스크립터 표의 구조체를 새로운 파일 디스크립터가 가리키도록 한다 ​&lt;/li&gt;
  &lt;li&gt;리턴 값: 성공하면 복사된 새 파일 디스크립터, 실패하면 -1​
    &lt;ul&gt;
      &lt;li&gt;dup() 함수는 할당 가능한 가장 작은 번호를 리턴한다​&lt;/li&gt;
      &lt;li&gt;dup2() 함수는 newfd를 리턴한다​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;fdin = open(“in-file”, O_RDONLY);​&lt;br /&gt;
close(0);​&lt;br /&gt;
dup(fdin);​&lt;br /&gt;
close(fdin);&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st07.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프러그래밍&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;stat(), fstat(), lstat(): 파일 조작&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;

int stat(const char * pathname, struct stat *buf);
int fstat(int fd, struct stat *buf);
int lstat(const char * pathname, struct stat * buf);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;파일 조작 시스템 호출은 파일 상태에 대한 정보를 stat 구조체에 가져온다​&lt;/li&gt;
  &lt;li&gt;리턴값: 성공시 0,  실패시 -1​&lt;/li&gt;
  &lt;li&gt;pathname: 파일의 경로명​&lt;/li&gt;
  &lt;li&gt;buf: stat 구조체(파일정보)를 저장하는 구조체​&lt;/li&gt;
  &lt;li&gt;stat()가 경로명으로 파일을 지정하는 반면, fstat()는 파일 디스크립터를 지정한다​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;lstat()는 대상 파일이 심볼릭 링크(symbolic link)인 경우에 링크가 나타내는 파일이 아니라 링크 자신의 상태를 가져온다​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;stat 구조체 내용&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  struct  stat {​
    mode_t   st_mode; 파일 모드에 대한 정보​
    ino_t      st_ino; 파일의 I-node 번호​
    dev_t      st_dev; I-node가 있는 디바이스의 디바이스번호​
    dev_t st_rdev; 디바이스번호(디바이스 파일의 경우)​
    nlink_t st_nlink;  파일에 관련된 링크의 수​
    uid_t st_uid;    소유자의 사용자 ID​
    gid_t st_gid;    소유자의 그룹 ID​
    off_t st_size;   파일크기(바이트 수)​
    time_t st_atime;  최종 엑세스 시각​
    time_t st_mtime; 최종 변경 시각​
    time_t st_ctime;  최종 상태 변경 시각​
    blksize_t st_blksize; 파일 시스템의 블록 크기​
    blkcnt_t st_blocks; 할당된 블록수​
    };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;access(): 파일에 대한 액세스 권한 검사&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int access(const char * pathname, int mode);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;파일에 대하여 mode로 전해준 액세스 권한이 있는지 없는지 확인한다​&lt;/li&gt;
  &lt;li&gt;pathname : 경로명​&lt;/li&gt;
  &lt;li&gt;mode : 모드​&lt;/li&gt;
  &lt;li&gt;리턴값 : 성공시 0, 에러시 -1&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;매크로 이름&lt;/th&gt;
      &lt;th&gt;비트패턴&lt;/th&gt;
      &lt;th&gt;액세스 권한&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;R_OK&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;읽기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;W_OK&lt;/td&gt;
      &lt;td&gt;010&lt;/td&gt;
      &lt;td&gt;쓰기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;X_OK&lt;/td&gt;
      &lt;td&gt;001&lt;/td&gt;
      &lt;td&gt;실행&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;F_OK&lt;/td&gt;
      &lt;td&gt;000&lt;/td&gt;
      &lt;td&gt;파일이 존재하는지 아닌지&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="system" />
      

      
        <summary type="html">File IO</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">File</title>
      <link href="https://lee989898.github.io/st-02" rel="alternate" type="text/html" title="File" />
      <published>2021-09-08T01:06:00+09:00</published>
      <updated>2021-09-08T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/st-02</id>
      <content type="html" xml:base="https://lee989898.github.io/st-02">&lt;h3 id=&quot;file&quot;&gt;&lt;strong&gt;File&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;File Structure&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Tree 구조&lt;/li&gt;
  &lt;li&gt;계층 구조&lt;/li&gt;
  &lt;li&gt;Three types: 일반 file(네모), directory file(동그라미), divice file(역삼각형) &lt;img src=&quot;/assets/built/images/st/st03.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프러그래밍&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;File Types&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;일반 파일
    &lt;ul&gt;
      &lt;li&gt;데이터를 포함하고 있는 텍스트 또는 이진 파일&lt;/li&gt;
      &lt;li&gt;트리 구조의 잎에 해당&lt;/li&gt;
      &lt;li&gt;Stream file (collection of bytes)임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;디렉토리 파일
    &lt;ul&gt;
      &lt;li&gt;자기 자신도 하나의 파일&lt;/li&gt;
      &lt;li&gt;상위 디렉토리에 등록되어 있음(트리 구조를 이룸)&lt;/li&gt;
      &lt;li&gt;파일의 이름들과 파일 정보에 대한 포인터들을 포함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;디바이스 파일
    &lt;ul&gt;
      &lt;li&gt;시스템에 접속하는 주변 기기나 메모리, 등의 장치 각각에 대응하는 특수 파일&lt;/li&gt;
      &lt;li&gt;/dev 디렉토리에서 관리&lt;/li&gt;
      &lt;li&gt;Special file 이라고 부름
        &lt;ul&gt;
          &lt;li&gt;Character special file과 block special file로 나뉨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Stream file임
        &lt;ul&gt;
          &lt;li&gt;사용자 프로그램 내에서 일반 파일과 같은 입출력 명령으로 처리&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;디바이스 파일의 종류
        &lt;ul&gt;
          &lt;li&gt;문자 특수 파일(Character special file)
            &lt;ul&gt;
              &lt;li&gt;문자 단위로 데이터를 처리하는 장치에 해당하는 파일&lt;/li&gt;
              &lt;li&gt;Treminal, printer, …&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;블럭 특수 파일(block special file)
            &lt;ul&gt;
              &lt;li&gt;블럭 단위로 데이터를 처리하는 장치에 해당하는 파일&lt;/li&gt;
              &lt;li&gt;Disk, magnetic tape&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;File Name&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;File name
    &lt;ul&gt;
      &lt;li&gt;같은 이름의 파일은 다른 디렉토리에 존재한다&lt;/li&gt;
      &lt;li&gt;구별하기 위해서 “path” 이름이 필요하다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Path name
    &lt;ul&gt;
      &lt;li&gt;Relative path: from .&lt;/li&gt;
      &lt;li&gt;Absolute path: from /&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Home directory: ~&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;File Info&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;%ls -la&lt;br /&gt;
합계 180&lt;br /&gt;
drwx——    4 mhlee    mhlee        4096  3월 23 14:19 C2​&lt;br /&gt;
drwx——    4 mhlee    mhlee        4096  3월 25 17:10 SUBMIT​&lt;br /&gt;
-rwxrwxr-x   1 mhlee    mhlee      11888   9월  5 10:35 a.out&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;u&gt;d&lt;/u&gt; &lt;u&gt;rwx&lt;/u&gt; &lt;u&gt;rwx&lt;/u&gt; &lt;u&gt;rwx&lt;/u&gt;​
    &lt;ul&gt;
      &lt;li&gt;d: directory file​&lt;/li&gt;
      &lt;li&gt;-: 일반 file​&lt;/li&gt;
      &lt;li&gt;l: symbolic link​&lt;/li&gt;
      &lt;li&gt;b: block device file​&lt;/li&gt;
      &lt;li&gt;c: char device file​&lt;/li&gt;
      &lt;li&gt;p: named pipe (FIFO)​&lt;/li&gt;
      &lt;li&gt;s: socket​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;rwx
    &lt;ul&gt;
      &lt;li&gt;Read&lt;/li&gt;
      &lt;li&gt;Write&lt;/li&gt;
      &lt;li&gt;Execute&lt;/li&gt;
      &lt;li&gt;-: no permission&lt;/li&gt;
      &lt;li&gt;Owner
        &lt;ul&gt;
          &lt;li&gt;User, Group, Other&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;chmod
    &lt;ul&gt;
      &lt;li&gt;Whom: u,g,o,a&lt;/li&gt;
      &lt;li&gt;What: r,w,x&lt;/li&gt;
      &lt;li&gt;How: +,-&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;chown&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;chgrp&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;File System 소개&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Disk
    &lt;ul&gt;
      &lt;li&gt;Collection of contiguous block&lt;/li&gt;
      &lt;li&gt;Sector, track, cylinder&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;논리적인 디스크로 나누어서 사용한다&lt;/li&gt;
  &lt;li&gt;각각의 파티션에 대응되는 디바이스 파일이 있다 &lt;img src=&quot;/assets/built/images/st/st04.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프러그래밍&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Root file system
    &lt;ul&gt;
      &lt;li&gt;OS가 동작하는데 필요한 최소한의 file과 directory들로 이루어짐&lt;/li&gt;
      &lt;li&gt;Kernel system file, /bin,/etc,/lib,/dev&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Swap file system
    &lt;ul&gt;
      &lt;li&gt;적어도 DRAM사이즈에 두배 이상이다&lt;/li&gt;
      &lt;li&gt;데이터를 메모리에 저장하기 위해서 사용한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Usr file system
    &lt;ul&gt;
      &lt;li&gt;Utilty files&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Home file system
    &lt;ul&gt;
      &lt;li&gt;User area&lt;/li&gt;
      &lt;li&gt;Login directories, etc&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;File System Structure&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;각각의 파일 시스템은 4개 영역으로 나뉜다.
    &lt;ul&gt;
      &lt;li&gt;Boot block
        &lt;ul&gt;
          &lt;li&gt;파일 시스템의 첫번째 블록&lt;/li&gt;
          &lt;li&gt;파일 시스템을 구동하기 위한 시스템이 위치&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Super block
        &lt;ul&gt;
          &lt;li&gt;Boot block 바로 다음의 영역&lt;/li&gt;
          &lt;li&gt;File system을 관리하는 정보가 저장됨&lt;/li&gt;
          &lt;li&gt;DRAM,disk에서 카피가 있다&lt;/li&gt;
          &lt;li&gt;관리자 유저가 “sync”를 사용할 수 있다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;i-node block list
        &lt;ul&gt;
          &lt;li&gt;Super block 다음의 영역&lt;/li&gt;
          &lt;li&gt;각 파일당 하나의 i-node가 대응한다&lt;/li&gt;
          &lt;li&gt;File 관리에 필요한 정보 저장&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Data block
        &lt;ul&gt;
          &lt;li&gt;마지막 영역&lt;/li&gt;
          &lt;li&gt;파일들의 실제 내용이 저장&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;File System Mount/Unmount&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;각각의 파일 시스템은 트리 형태로 표현가능하다&lt;/li&gt;
  &lt;li&gt;파일 시스템이 여러개면 파일 트리도 여러개 일 것이다&lt;/li&gt;
  &lt;li&gt;두개 이상의 파일 시스템을 합치는 것을 mount라고 하고 반대를 unmount라고 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="system" />
      

      
        <summary type="html">File</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">System Call</title>
      <link href="https://lee989898.github.io/st-01" rel="alternate" type="text/html" title="System Call" />
      <published>2021-09-02T01:06:00+09:00</published>
      <updated>2021-09-02T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/st-01</id>
      <content type="html" xml:base="https://lee989898.github.io/st-01">&lt;h3 id=&quot;system-call&quot;&gt;&lt;strong&gt;System Call&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;System Calls and Library Functions&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;System Call: 운영체제의 커널(kernal) 서비스를 받기 위한 일종의 함수 호출&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;​System Call의 구조 &lt;img src=&quot;/assets/built/images/st/st01.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프러그래밍&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Library Functions
    &lt;ul&gt;
      &lt;li&gt;ex) printf(), scanf(), fopen(), fclose(), gets(), puts(), getw(), fread(), fseek()&lt;/li&gt;
      &lt;li&gt;대게 system calls을 호출합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;System Calls
    &lt;ul&gt;
      &lt;li&gt;ex) open(), create(), close(), read(), write(), lseek(), unlink()&lt;/li&gt;
      &lt;li&gt;user’s program에서 호출할 수 있다&lt;/li&gt;
      &lt;li&gt;커널 함수를 호출하는 C 함수처럼 보인다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;System Call Structure&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;user 프로그램이 system call을 사용하면 커널 서비스를 호출한다&lt;/li&gt;
  &lt;li&gt;Two phases
    &lt;ul&gt;
      &lt;li&gt;User code 실행 -&amp;gt; user space/mode&lt;/li&gt;
      &lt;li&gt;Kernel code 실행 -&amp;gt; kernel space/mode&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Kernel mode
    &lt;ul&gt;
      &lt;li&gt;일반적으로 interrupts와 같은 예외에 의해 활성화된다&lt;/li&gt;
      &lt;li&gt;trap(SW interrupts)에 의한 시스템 호출 내에서 활성화된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;System Call Table entries
    &lt;ul&gt;
      &lt;li&gt;System call no: 3,4&lt;/li&gt;
      &lt;li&gt;No of parameters: 3,3&lt;/li&gt;
      &lt;li&gt;Routine name: read, write &lt;img src=&quot;/assets/built/images/st/st02.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프러그래밍&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;System Calls: No &amp;amp; Name&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;Exit&lt;/li&gt;
  &lt;li&gt;Fork&lt;/li&gt;
  &lt;li&gt;Read&lt;/li&gt;
  &lt;li&gt;Write&lt;/li&gt;
  &lt;li&gt;Open&lt;/li&gt;
  &lt;li&gt;Close&lt;/li&gt;
  &lt;li&gt;Wait&lt;/li&gt;
  &lt;li&gt;Create&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="system" />
      

      
        <summary type="html">System Call</summary>
      

      
      
    </entry>
  
</feed>
