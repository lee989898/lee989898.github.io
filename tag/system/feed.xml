<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://lee989898.github.io/tag/system/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://lee989898.github.io/" rel="alternate" type="text/html" />
  <updated>2021-11-03T19:45:04+09:00</updated>
  <id>https://lee989898.github.io/tag/system/feed.xml</id>

  
  
  

  
    <title type="html">LEE | </title>
  

  
    <subtitle>공부 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">Process_Control</title>
      <link href="https://lee989898.github.io/st-01" rel="alternate" type="text/html" title="Process_Control" />
      <published>2021-10-31T01:06:00+09:00</published>
      <updated>2021-10-31T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/st-01</id>
      <content type="html" xml:base="https://lee989898.github.io/st-01">&lt;h3 id=&quot;process-control&quot;&gt;&lt;strong&gt;Process Control&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;exec&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;프로세스가 exec 함수 중 하나를 호출할 때&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로세스는 새 프로그램으로 완전히 대체된다. 텍스트, 데이터, 힙 및 스택 세그먼트를 부모의 주소 공간에 로드한다.&lt;/li&gt;
  &lt;li&gt;새 program은 main function에서 시작한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;새 program은 caller와 동일한 PID를 사용한다.&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;
main()
{ printf(&quot;execiton ls\n&quot;)};
execl(&quot;/bin/ls&quot;,&quot;ls&quot;,&quot;-l&quot;, (char *)0);
perror(&quot;execl failed to run ls\n&quot;);
exit(1);}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;exec: Program Execution&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스 실행을 맡고 있는 시스템 콜은 execve()이다&lt;/li&gt;
  &lt;li&gt;같은 기능을 하면서 라이브러리 함수로 분류되어 있는것으로 execv(), execvp(), execle(), execl(), execlp()가 있다 ​&lt;/li&gt;
  &lt;li&gt;이 6가지를 합쳐서 exec()시스템 콜이라 부른다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;exec() 이후에 오는 문자에 의해 구별되는 표시는 다음의 의미가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;l -&amp;gt; argv 정보를 개개의 문자열 데이터를 가르키는 포인터 arg0,arg1……. argn으로 전달한다&lt;/li&gt;
  &lt;li&gt;v -&amp;gt; argv 정보를 개개의 문자열 데이터를 가리키는 포인터 배열의 ​
선두주소 argv로 전달한다​&lt;/li&gt;
  &lt;li&gt;e -&amp;gt; envp 정보를 전달한다​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;p -&amp;gt; p를 사용하는 경우, 실행할 파일이름을 환경 변수 PATH로 지정한 디렉토리 안에서 찾아내어 실행한다​&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int execl(const char *path, const char *arg0, ... *argn,
(char *)0);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;path: 실행 가능한 파일 경로&lt;/li&gt;
  &lt;li&gt;arg0~argn: 파일에 전달한 argv 정보(명령 인수)&lt;/li&gt;
  &lt;li&gt;(char*)0: 마지막임을 알리는 표시로 NULL 포인터&lt;/li&gt;
  &lt;li&gt;리턴값: 에러시 -1&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;execl.c&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include&amp;lt;unistd.h&amp;gt;

main(int argc, char *argv[]){
    execl(&quot;/bin/ls&quot;,&quot;ls&quot;,argv[1],(char *)0);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;execv.c&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include&amp;lt;unistd.h&amp;gt;
main(){
    char *av[3];

    av[0]=&quot;ls&quot;;
    av[1]=&quot;-1&quot;;
    av[2]=(char *)0;

    execv(&quot;/bin/ls&quot;,av);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;execle()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; #include &amp;lt;unistd.h&amp;gt;

 int execle(const char *path, const char *arg0...*argn,
                    (char *)0, char *const envp[]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;path: 파일의 경로명&lt;/li&gt;
  &lt;li&gt;arg0 ~ argn: 파일에 전달한 argv 정보(명령 인수)&lt;/li&gt;
  &lt;li&gt;envp[]: envp 정보(환경변수)&lt;/li&gt;
  &lt;li&gt;리턴 값: 에러시 -1&lt;/li&gt;
  &lt;li&gt;execl()에 환경 변수 정보를 전달하는 기능을 추가한 것&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;execve()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int execve(const char* path, char *const argv[],
                char *const envp[]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;path: 파일의 경로명&lt;/li&gt;
  &lt;li&gt;argv: 파일에 전달한 argv 정보(명령 인수)&lt;/li&gt;
  &lt;li&gt;envp[]: envp 정보(환경변수)&lt;/li&gt;
  &lt;li&gt;리턴 값: 에러시 -1&lt;/li&gt;
  &lt;li&gt;execv()에 환경 변수 정보를 전달하는 기능을 추가한 것&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;execlp()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int execlp(const char *file, const char *arg0, .... *argn);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;file: 실행하는 파일의 파일 이름&lt;/li&gt;
  &lt;li&gt;arg0 ~ argn: 파일에 전달한 argv 정보(명령 인수)&lt;/li&gt;
  &lt;li&gt;리턴 값: 에러시 -1&lt;/li&gt;
  &lt;li&gt;execlp()는 첫 번째 인자 file에서 지정한 파일 이름을 환경 변수 PATH에서 지정하고 있는 디렉토리 안에서 찾아 실행한다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;execvp()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int execvp(const char *file, char *const argv[]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;file: 실행하는 파일의 파일 이름&lt;/li&gt;
  &lt;li&gt;argv: 파일에 전달한 argv 정보(명령 인수)&lt;/li&gt;
  &lt;li&gt;리턴 값: 에러시 -1&lt;/li&gt;
  &lt;li&gt;execlp()는 첫 번째 인자 file에서 지정한 파일 이름을 환경 변수 PATH에서 지정하고 있는 디렉토리 안에서 찾아 실행한다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Race Conditions&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;여러 프로세스가 일부 데이터를 공유&lt;/li&gt;
  &lt;li&gt;결과는 실행 순서(예: RACE)에 따라 다르다&lt;/li&gt;
  &lt;li&gt;fork() 후에는 부모 또는 자식이 먼저 실행되는지 예측할 수 없다&lt;/li&gt;
  &lt;li&gt;실행 순서는 다음에 따라 다르다
    &lt;ul&gt;
      &lt;li&gt;시스템 부하&lt;/li&gt;
      &lt;li&gt;커널의 스케줄링 알고리즘&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Race condition 문제는 대부분의 시간 작동하기 때문에 감지하기 어렵다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;after fork
    &lt;ul&gt;
      &lt;li&gt;parent,child 모두 스스로 무언가를 한다&lt;/li&gt;
      &lt;li&gt;예를 들어 parent: 로그 파일에 기록 쓰기&lt;/li&gt;
      &lt;li&gt;예를 들어 child: 로그 파일 생성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;parent,child는 다음을 수행해야 한다
    &lt;ul&gt;
      &lt;li&gt;초기 작업 세트가 완료되면 서로 알리고&lt;/li&gt;
      &lt;li&gt;서로 완료될 때까지 기다린다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;system()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;

int system(const char *cmdstring);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;문자열이 터미널에서 명령으로 입력된 것처럼 문자열이 sh(1)에 입력으로 제공한다. ex) system(“date &amp;gt; file”);&lt;/li&gt;
  &lt;li&gt;fork, exec 및 waitpid를 호출하여 시스템을 구현한다.&lt;/li&gt;
  &lt;li&gt;반환 값:
    &lt;ul&gt;
      &lt;li&gt;-1 with errno: fork 또는 waitpid 실패&lt;/li&gt;
      &lt;li&gt;127 : 실행 실패&lt;/li&gt;
      &lt;li&gt;쉘 종료 상태: 3개 모두 성공&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Process Times&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/times.h&amp;gt;

clock_t times(struct tms *buf);

struct tms(
    clock_t tms_utime;
    clock_t tms_stime;
    clock_t tms_cutime;
    clock_t tms_cstime;
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;wall clock time: 프로세스가 실행되는 데 걸리는 시간이며 시스템 부하에 따라 다르다.
    &lt;ul&gt;
      &lt;li&gt;반환된 wall clock time의 시간은 과거의 임의의 지점에서 측정된다. 상대 값을 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자 CPU 시간: 사용자 지침에 기인&lt;/li&gt;
  &lt;li&gt;시스템 CPU 시간: 프로세스를 대신하여 실행될 때 커널에 귀속됨&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="system" />
      

      
        <summary type="html">Process Control</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Signal</title>
      <link href="https://lee989898.github.io/st-02" rel="alternate" type="text/html" title="Signal" />
      <published>2021-10-31T01:06:00+09:00</published>
      <updated>2021-10-31T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/st-02</id>
      <content type="html" xml:base="https://lee989898.github.io/st-02">&lt;h3 id=&quot;signal&quot;&gt;&lt;strong&gt;Signal&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="system" />
      

      
        <summary type="html">Signal</summary>
      

      
      
    </entry>
  
</feed>
