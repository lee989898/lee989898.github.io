<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://lee989898.github.io/tag/pl/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://lee989898.github.io/" rel="alternate" type="text/html" />
  <updated>2021-11-02T00:24:33+09:00</updated>
  <id>https://lee989898.github.io/tag/pl/feed.xml</id>

  
  
  

  
    <title type="html">LEE | </title>
  

  
    <subtitle>공부 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">서브프로그램</title>
      <link href="https://lee989898.github.io/pl-16" rel="alternate" type="text/html" title="서브프로그램" />
      <published>2021-10-29T19:18:00+09:00</published>
      <updated>2021-10-29T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-16</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-16">&lt;h3 id=&quot;서브프로그램&quot;&gt;&lt;strong&gt;서브프로그램&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Fundamentals of Subprograms&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서브프로그램이 무엇인지 왜 필요한지 살펴 보자.&lt;br /&gt;
동일한 코드 부분(segment)이 프로그램의 여러 곳에서 나타난다고 하면, 이 코드를 여러 곳에 중복해서 코딩하기보다는,​
한번만 코딩하고, 필요할 때마다 그 코드 부분으로 점프했다가 끝나면 되돌아 오는 방식으로, 프로그램을 짤 수 있다.&lt;br /&gt;
이러한 코드 부분을 서브프로그램이라고 한다.&lt;br /&gt;
동일한 코드 부분이 프로그램의 여러 곳에 나타나고, ​나타나는 곳마다 사용되는 변수가 다르다고 가정해 보자.&lt;br /&gt;
이때 파라미터를 갖는 서브프로그램을 사용할 수 있다.&lt;br /&gt;
서브프로그램의 개념은 쓰레드와 같은 것으로 발전하고 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;서브프로그램은 다음과 같은 특징을 갖는다. ​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;각 서브 프로그램은 단하나의 진입점을 갖는다. ​&lt;/li&gt;
  &lt;li&gt;호출한 서브프로그램(caller)는 호출된 서브프로그램(callee)의 실행 중에는 중지된다. ​&lt;/li&gt;
  &lt;li&gt;Callee가 종료되면, 컨트롤을 항상 caller에게 되돌려준다.  ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서브프로그램은 정의부와 선언부로 구성된다.&lt;br /&gt;
서브프로그램 정의부는 서브프로그램의 인터페이스와 액션을 서술하고, ​정의부의 맨앞에는 서브프로그램의 헤더가 있다.&lt;br /&gt;
헤더는 void adder(parameter) 처럼 서브프로그램 이름, 유형, 포말 파라미터 등을 포함한다. &lt;br /&gt;
포말 파라미터의 개수, 순서, 타입을 파라미터의 프로파일(시그니처, 요약)이라고 부른다. ​&lt;/p&gt;

&lt;p&gt;서브프로그램 선언부는 파라미터 프로파일과 반환 타입을 선언한다.&lt;br /&gt;
서브프로그램 호출(call)은 서브프로그램으로 점프한다. ​&lt;/p&gt;

&lt;p&gt;서브프로그램에서 데이터에 접근하는 방법은 두가지가 있다.
 ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;난로컬 변수에 직접 접근하는 경우 ​&lt;/li&gt;
  &lt;li&gt;파라미터 패싱을 사용하는 경우 ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파라미터 패싱을 사용하여 데이터를 접근할 때에는 ​로컬 변수명을 사용한다.&lt;br /&gt;
난로컬 변수에 직접 접근하는 것보다 융통성이 높아 파라미터화에 의한 계산이 가능하다.&lt;br /&gt;
난로컬 변수에 대한 광범위한 접근은 부작용으로 인해 신뢰성을 감소시킨다. ​&lt;br /&gt;
순수 함수 언어는 수정 가능한 데이터를 허용하지 않으며, 메모리 내용을 변경할 수 없도록 제한한다. ​&lt;/p&gt;

&lt;p&gt;포말 파라미터는 callee의 헤더에 있는 파라미터를 말한다.&lt;br /&gt;
서브프로그램이 호출될 때만 메모리에 바인딩되고, ​액추얼 파라미터를 통해서 바인딩되기 때문에, ​종종 더미 변수로 취급되기도 한다.&lt;br /&gt;
액추얼 파라미터는 caller에서 사용되는 값이나 주소를 나타낸다.&lt;/p&gt;

&lt;p&gt;액추얼 파라미터를 포말 파라미터에 바인딩하는 방법은 두 가지가 있다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;위치 파라미터: 파라미터의 순서가 중요 ​&lt;/li&gt;
  &lt;li&gt;키워드 파라미터: 파라미터의 이름이 중요, 순서는 중요하지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파이썬에서 sumer(my_length, list=my_array, sum = my_sum),  ​
포말 파라미터는 length, list, sum이고, ​
액추얼 파라미터는 my_length, my_array, my_sum 이라면, ​
첫번째 파라미터는 위치 파라미터이고, ​
두번째 세번째는 키워드 파라미터이다.  ​&lt;/p&gt;

&lt;p&gt;키워드 파라미터의 장점은 순서에 얽매이지 않는다는 것이고, ​
단점은 사용자가 포말 파라미터의 이름을 알고 있어야 한다는 것이다.&lt;/p&gt;

&lt;p&gt;C++, 파이썬 등에서는 액추얼 파라미터가 모두 다 패스되지 않을 경우, ​포말 파라미터는 대응되지 않는 나머지 파라미터에 대해 디폴트 값을 가질 수 있다. ​&lt;/p&gt;

&lt;p&gt;C++에서 파라미터는 위치에 연관되기 때문에 ​
디폴트 파라미터는 마지막에 나타나야 하며, ​
디폴트값은 서브프로그램 헤더에 있다. ​&lt;/p&gt;

&lt;p&gt;서브프로그램 내에 정의된 변수는 모두 로컬이며, ​
그들의 스코프는 항상 서브프로그램 안이다.&lt;br /&gt;
로컬 변수는 정적 또는 스택-동적으로 바인딩된다. ​
로컬 변수가 스택-동적이라면, ​
서브프로그램의 실행이 시작될 때 메모리에 바인딩되고, ​
실행이 끝나면 메모리에서 떨어진다. ​&lt;/p&gt;

&lt;p&gt;스택-동적 변수의 장점은, ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Recursive 서브프로그램이 스택-동적 로컬 변수를 갖는다 -&amp;gt; recursion 처리가 가능​&lt;/li&gt;
  &lt;li&gt;액티브 서브 프로그램의 로컬 변수가 ​
액티브하지 않은 서브프로그램이 해제한 로컬 변수의 메모리를 사용할 수 있다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;프로그램이 시작되고나서 아직 끝나지 않은 상태에서는 ​
자주 호출되는 서브프로그램의 실행이 끝났다고 해도 ​
그 서브 프로그램의 변수는 아직 메모리를 차지하고 있을 수 있다.&lt;br /&gt;
이때 서브프로그램의 상태를 액티브라고 한다. ​&lt;/p&gt;

&lt;p&gt;현대 언어에서, 서브프로그램의 로컬 변수는 디폴트로서 스택-동적으로 바인딩된다. ​&lt;/p&gt;

&lt;p&gt;C, C++ 함수에서, 로컬 변수는 정적이라고 명시되어 있지 않으면 스택-동적이다. ​&lt;/p&gt;

&lt;p&gt;서브프로그램이 다른 서브프로그램안에만 있어야 한다면, ​
이것을 중첩 서브프로그램이라고 한다. ​&lt;/p&gt;

&lt;p&gt;다른 서브프로그램 안에서 숨어서(hide) 다른 프로그램이 호출할 수 없게 만든다. ​&lt;/p&gt;

&lt;p&gt;서브프로그램의 중첩으로 처리 논리와 스코프의 계층구조를 생성할 수 있다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정적 스코핑의 사용 ​&lt;/li&gt;
  &lt;li&gt;알골, 파스칼에서 허용 ​&lt;/li&gt;
  &lt;li&gt;C 계열 언어는 서브프로그램의 중첩을 허용하지 않음​&lt;/li&gt;
  &lt;li&gt;자바스크립트, 파이썬 등은 중첩 허용&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Parameter-Passing Methods&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;파라미터 패싱에 대한 시맨틱 모델은 3가지가 있다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;포말 파라미터가 대응하는 액추얼 파라미터로부터 데이터를 받는 것이다. 이것을 in mode라고 한다. ​&lt;/li&gt;
  &lt;li&gt;포말 파라미터가 액추얼 파라미터에게 데이터를 보내는 것이다. 이것을 out mode라고 한다. ​&lt;/li&gt;
  &lt;li&gt;포말 파라미터가 대응하는 액추얼 파라미터로부터 데이터를 받고, 액추얼 파라미터에게 데이터를 보내는 것이다. 이것을 inout mode라고 한다.  ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파라미터간에 데이터를 주고 받는 방법은 두가지가 있다.&lt;br /&gt;
실제 값을 카피하여 주고 받는 방법과 액세스 패스(접근 경로)를 주고 받는 방법이다.&lt;/p&gt;

&lt;p&gt;파라미터 패싱 구현 모델에는 ​pass by value(in mode), pass by result(out mode), ​pass by value result(inout mode), pass by reference(inout mode)가 있다. ​&lt;/p&gt;

&lt;p&gt;Caller의 액추얼 파라미터를 Pass by value 모델로 callee에게 보낼때, 액추얼 파라미터의 값은 copy를 통해, ​대응되는 포말 파라미터의 초기화에 사용된다. ​&lt;/p&gt;

&lt;p&gt;단점은 다음과 같다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;copy 하면, ​  추가적인 메모리를 필요로하고, 실제 이동 비용이 발생한다. ​&lt;/li&gt;
  &lt;li&gt;만일 접근 경로(access path)에 의한다면, callee에서 쓰기 보호를 해야하는 동시에, ​간접 주소방식에 의한 접근 비용이 추가된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Callee의 파라미터를 pass by result 모델로 caller에게 보낼 때, ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;대응되는 포말 파라미터는 로컬 변수처럼 행동한다. ​&lt;/li&gt;
  &lt;li&gt;Callee가 종료되어 컨트롤을 caller에게 돌려주면, 포말 파라미터의 값을 caller의 액추얼 파라미터로 전달한다. ​&lt;/li&gt;
  &lt;li&gt;추가적인 메모리 위치와 copy 연산이 필요하다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pass by result에 내재하는 문제는 다음과 같다. ​&lt;/p&gt;

&lt;p&gt;Caller와 callee가 ​Caller: sub(p1, p1) actual parameter p1, p1​ Callee: sub(x, y) formal parameter x, y 라고 하자 액추얼 파라미터 두개가 p1으로 같고, ​대응하는 포말 파라미터 두개의 이름이 x, y로 다르다. ​&lt;/p&gt;

&lt;p&gt;Caller가 callee를 호출해서 callee가 실행 후 종료되고, ​
Callee가 calle에게 결과값을 반환할 때, ​
X, y 중 어느 것이 p1에 마지막으로 copy 되느냐에 따라, ​
p1의 값이 달라진다. ​
x거나 y이다. ​&lt;/p&gt;

&lt;p&gt;이것이 pass by result에 내재하는 문제이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Pass by value result는 ​pass by value와 pass by result의 결합으로 ​pass by copy라고도 부른다. ​&lt;br /&gt;
액추얼 파라미터의 값은 대응하는 포말 파라미터의 초기화에 쓰이고, ​포말 파라미터는 로컬 변수처럼 행동한다. ​&lt;br /&gt;
포말 파라미터의 값은 액추얼 파라미터에게 반환된다. ​
단점은 in, out 모두 카피에 의존. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Pass by reference 모델은 접근 통로의 패스를 통해, ​
파라미터를 패스한다. ​&lt;br /&gt;
즉, callee에게 caller의 액추얼 파라미터를 접근하도록 허용한다. &lt;br /&gt;
따라서 pass by sharing이라고도 한다. ​&lt;/p&gt;

&lt;p&gt;장점은 패싱 프로세스가 효율적이다. ​&lt;br /&gt;
Copy 연산, 메모리 모두 필요없다. ​&lt;br /&gt;
단점은 느리고, 예기치 않았던 난로컬 변수를 접근할 수도 있다. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;대부분 언어에서, 파라미터 패싱의 구현은 런타임 스택을 통해 일어난다. ​&lt;br /&gt;
C에서 파라미터 패싱은 pass by value를 지원한다.&lt;br /&gt;
포인터를 사용하면, Pass by reference를 구현할 수 있다.&lt;br /&gt;
자바는 모든 파라미터에 대해 pass by value를 지원하며,&lt;br /&gt;
객체 파라미터에 대해 pass by reference를 지원한다.&lt;/p&gt;

&lt;p&gt;파라미터에 대한 타입 검사는 ​액추얼 파라미터와 포말 파라미터 간에 타입의 일관성을 검사하는 것이다. ​&lt;br /&gt;
파라미터의 타입 검사는 소프트웨어의 신뢰성을 위해 매우 중요하다. ​&lt;br /&gt;
포트란 77, 원시 C에는 파라미터 타입 검사가 없다.&lt;br /&gt;
ANSI C, C++에는 선택적이며, ​파이썬, 루비에서는 변수가 타입을 갖지 않기 때문에 ​파라미터 타입 검사가 없다.&lt;/p&gt;

&lt;p&gt;파라미터의 타입이 다차원 배열일 경우, ​서브프로그램이 따로 컴파일되어 있고, ​다차원 배열이 서브프로그램으로 패스된다고 가정하자. ​&lt;br /&gt;
컴파일러는 메모리 매핑을 위해, ​선언된 배열의 크기를 알 필요가 있다.  ​&lt;/p&gt;

&lt;p&gt;Row-major 매트릭스의 메모리 매핑 함수는 ​&lt;/p&gt;

&lt;p&gt;address(mat[i,j]) = address(mat[0,0]) + i * #_columns + j 이다. ​&lt;/p&gt;

&lt;p&gt;즉, 컬럼의 길이만 알면 전체 크기를 알 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;현대 프로그래밍 언어에서 다차원 배열 파라미터를 어떻게 패스하는지 살펴 보자.​&lt;/p&gt;

&lt;p&gt;C, C++에서,&lt;br /&gt;
1) 프로그래머가 액추얼 파라미터의 첫번째 서브스크립트를 제외하고, ​나머지 서브스크립트의 크기를 선언하는 방법. ​&lt;/p&gt;

&lt;p&gt;슬라이드의 프로그램에서 mat은 2차원 배열이고, ​
함수 fun(mat)은 mat을 파라미터로 하는 함수이다.&lt;br /&gt;
이와 같은 방식은 서브프로그램의 유연성을 불허한다는 것이다. ​&lt;/p&gt;

&lt;p&gt;2) 이에 대한 해결책으로, ​&lt;/p&gt;

&lt;p&gt;배열에 대한 포인터, 차원 크기를 파라미터로 패스하는 방법이 있다.&lt;br /&gt;
다만, 배열 처리를 위해 ​사용자는 메모리 매핑 함수를 포함해야 하는 불편함이 있다.&lt;/p&gt;

&lt;p&gt;자바에서는 배열을 객체로 취급한다.&lt;br /&gt;
이들은 모두 일차원 배열이지만 ​배열의 각 요소가 배열일 수 있어서 ​다차원 배열을 파라미터로 쓸 수 있다.&lt;br /&gt;
자바에서 각 배열은 named constant(length와 같은)를 상속받는다.&lt;/p&gt;

&lt;p&gt;파라미터 패싱 방법의 구현시, 다음 두가지를 고려해야 한다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;효율성, ​&lt;/li&gt;
  &lt;li&gt;일방(in, out) 또는 쌍방(inout) 데이터 이동:caller-callee간에  ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러나 이들 고려사항은 서로 상충된다. ​&lt;/p&gt;

&lt;p&gt;프로그래밍을 잘하려면, 변수에 대한 접근을 가능한한 일방(in, out)으로 제한하는 것이 좋다.&lt;br /&gt;
pass by reference(inout)는 크기가 큰 데이터 스트럭처를 패스하는데 더욱 효율적인 반면, ​변수에 대한 접근을 제한하는데 문제를 일으킬 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Parameters That Are Subprograms&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이번엔 서브프로그램 이름을 파라미터로 패스하는 경우를 살펴보자. &lt;br /&gt;
종종 서브프로그램 이름을 파라미터로 패스하는 것이 편리할 때도 있다.&lt;br /&gt;
​즉, 계산을 서브프로그램으로 패스하는 것이다.&lt;/p&gt;

&lt;p&gt;파라미터 타입 검사? ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;C, C++ 함수 포인터로 패스함. ​-&amp;gt; 함수 포인터의 타입은 파라미터 타입을 포함하므로 파라미터 타입 검사는 가능함 ​&lt;/li&gt;
  &lt;li&gt;자바는 메소드 이름을 파라미터로 패스하는 것을 불허함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서브프로그램 중첩을 허용하는 언어에서, ​어떤 바인딩 방식에 의한 레퍼런싱 환경을 사용하는가? ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;쉘로우 바인딩: 패스된 서브프로그램을 실행시킨 call문(호출문)의 환경 ​&lt;/li&gt;
  &lt;li&gt;딥바인딩: 패스된 서브프로그램에 정의된 환경​&lt;/li&gt;
  &lt;li&gt;즉흥(ad hoc) 바인딩: 서브프로그램을 액추얼 파라미터로 패스한 호출문의 환경&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function sub1() {​
  var x;​
  function sub2() { alert(x); };​
  function sub3() {​
    var x; x = 3;​
    sub4(sub2); }​
  function sub4(subx) {​
    var x; x = 4;​
    subx(); }​
  x = 1;​
  sub3(); }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Sub4의 sub에 대해​&lt;/p&gt;

&lt;p&gt;쉘로우 바인딩을 했을 경우 ​
실행시킨 call문의 환경은 sub4가 되고, ​
sub4에서 x는 4이다. ​&lt;/p&gt;

&lt;p&gt;딥 바인딩을 했을 경우​
Sub2가 정의된 환경은 sub2가 되고,  ​
Sub2에서 x는 난로컬로서 sub1에 따른다. ​
따라서 x는 1이다. ​&lt;/p&gt;

&lt;p&gt;즉흥 바인딩일 경우, ​
Sub2를 파라미터로 넘긴 call문의 환경은 sub3가 되고, ​
Sub3에서 x는 3이다. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Design Issues for Functions&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;언어 설계시 고려사항은&lt;/p&gt;

&lt;p&gt;부작용 허용 여부? 부작용을 줄이려면 파라미터는 항상 in mode가 좋다. ​&lt;/p&gt;

&lt;p&gt;반환 값의 타입은? 대부분의 명령형 언어가 반환값의 타입을 제한함. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;C는 배열과 함수를 제외하고 모든 타입을 허용함. ​&lt;/li&gt;
  &lt;li&gt;C++은 C와 유사하나 사용자 정의 타입을 허용​&lt;/li&gt;
  &lt;li&gt;자바는 모든 타입 허용. ​&lt;/li&gt;
  &lt;li&gt;파이썬, 루비는 반환값 타입으로 객체도 허용&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Coroutines&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;코루틴에서 중요한 것은 재시작(resume) 명령.&lt;br /&gt;
프로그램 단위의 유사 동시 실행 기능을 제공함. 인터리빙.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl38.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위그림은 A가 먼저 시작하고, B를 재시작하고나서 스스로 중지했다가, ​
B가 A를 재시작하고 나서 스스로 중지했다가, ​
번갈아 가며 실행되는 형태를 보여주고 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl39.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 B가 먼저 시작하고, A를 재시작하면서 스스로 중지하고, ​
번갈아가며 실행되는 형태를 보이고 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl40.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위그림은 룹에서 서로 중지하고 상대방을 재시작하는 것을 반복함&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">서브프로그램</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">컨트롤 스트럭처</title>
      <link href="https://lee989898.github.io/pl-15" rel="alternate" type="text/html" title="컨트롤 스트럭처" />
      <published>2021-10-22T19:18:00+09:00</published>
      <updated>2021-10-22T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-15</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-15">&lt;h3 id=&quot;컨트롤-스트럭처&quot;&gt;&lt;strong&gt;컨트롤 스트럭처&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;프로그램의 컨트롤 스트럭처에는 3가지가 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;sequence(begin-end)&lt;/li&gt;
  &lt;li&gt;selection(if-else, case)&lt;/li&gt;
  &lt;li&gt;iteration(loop)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;각 컨트롤 스트럭처는 여러 개의 문장으로 구성된다. ​&lt;/p&gt;

&lt;p&gt;스트럭처는 여러 문장의 묶음으로, ​
실행 제어 방법에 따라 각각 키워드(begin, if, while,…)를 포함한다&lt;/p&gt;

&lt;p&gt;여기서 컨트롤 스트럭처의 if, while 문을 제어문이라고 하고, ​
제어문의 실행 결과에 따라 실행되는 문장을 실행문이라고 한다. ​&lt;/p&gt;

&lt;p&gt;시퀀스는 순차적으로 실행되는 문장들의 연속을 말하며, ​
실행 제어가 순차적이라서 시작과 끝만 명시하면 된다.&lt;/p&gt;

&lt;p&gt;Selection은 제어문이 참이냐 거짓이냐에 따라 실행문이 다르며,&lt;br /&gt;
하나의 selection 스트럭처에 제어문과 실행문을 여럿 포함하기도 한다. ​&lt;/p&gt;

&lt;p&gt;Iteration도 제어문과 실행문의 반복으로 구성되는데,&lt;br /&gt;
for, while, repeat 등 목적에 따라 그 신택스와 시맨틱스가 다양하다. ​&lt;/p&gt;

&lt;p&gt;프로그래머는 이들 컨트롤 스트럭처를 사용하여 쉽게 프로그램을 구조화한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;프로그램은 나름의 로직을 갖고 있어서, 이에 따른 실행 제어(flow control)가 필요하다. ​&lt;/p&gt;

&lt;p&gt;명령형 프로그램에서 계산은 다음과 같이 진행된다.&lt;br /&gt;
변수를 읽고 연산자를 실행하여 표현식을 계산하여, ​
변수에 결과 값을 부여한다.&lt;br /&gt;
또, 여러 경로 중에서 선택하여 실행을 제어하거나, ​반복 실행한다. ​&lt;/p&gt;

&lt;p&gt;컨트롤 스트럭처는 제어문과 실행문으로 구성된다. ​
이 표현은 문제가 있다. 시퀀스는 제어문이 없다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;selection-statements&quot;&gt;&lt;strong&gt;Selection Statements&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Selection문은 2개 이상의 실행 경로 중에서 선택하는 것이다. ​&lt;/p&gt;

&lt;p&gt;두가지 범주가 있는데, 둘 중에 하나 선택하는 것과 여럿 중에 선택하는 것이 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;If Statements&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If문의 일반적 형식은 if 제어 표현식 then 실행문1 else 실행문2 이다. ​&lt;/p&gt;

&lt;p&gt;제어 표현식은 산술식이거나 부울식이다. ​&lt;/p&gt;

&lt;p&gt;프로그래밍 언어에서 실행문1과 실행문2는 단순문이거나 복합문이다. ​&lt;/p&gt;

&lt;p&gt;C, C++에서 복합문을 { }로 둘러싼다.&lt;br /&gt;
펄에서 모든 실행문을 { }로 구분하고, 파이썬에서는 indentation으로 구분한다.&lt;/p&gt;

&lt;p&gt;자바에서는 중첩 if문을 허용한다.&lt;br /&gt;
dangling else 문제가 발생할 수 있으니 If에 대응되는 else가 어느 것인지 살펴가며 신중하게 써야 한다.&lt;br /&gt;
자바를 비롯한 대부분의 언어에서는 else를 가장 가까운 if에 대응시킨다.  ​&lt;/p&gt;

&lt;p&gt;C, C++에서는 가장 가까운 if에 else를 대응시키는 것의 대안으로서,&lt;br /&gt;
{}로 둘러싼 복합문을 사용할 수도 있다. ​&lt;/p&gt;

&lt;p&gt;​복합문 대신에 end를 사용하기도 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Switch Statements&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;​Switch는 여러 대안 중에 하나 선택하여 실행할 경우이다. ​&lt;/p&gt;

&lt;p&gt;전형적인 형식은 아래와 같다 ​&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Switch 표현식 {​

case 상수 표현식1 : 실행문1   ​

…​

default … }이다. 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;스위치문의 case는 동시에 상수 표현식을 비교하는 것이 아니라 상수 표현식을 순차적으로 비교하여 끝까지 실행한다. 
 ​이것을 피하려면, break 사용해야 한다.&lt;/p&gt;

&lt;p&gt;C에서는 스위치문의 제어 표현식으로 정수 타입만 허용한다.&lt;br /&gt;
 실행문은 시퀀스, 블록, 복합문을 모두 허용한다.&lt;br /&gt;
 조건이 맞으면 여러 case가 실행가능하다.&lt;br /&gt;
 디폴트시에, ​If문에 의한 제어가 가능하다.&lt;/p&gt;

&lt;p&gt;파이썬에서는 스위치 대신에 if elif를 사용할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;iterative-statements&quot;&gt;&lt;strong&gt;Iterative Statements&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Iteration, recursion은 문장이나 복합문의 반복 실행한다.​ &lt;br /&gt;
 카운터로 제어하는 counter-controlled loop은 반복문의 실행 횟수를 세는 변수를 갖는다. ​초기값, 종료값, 증분(반복할 때마다 더해지는 값)&lt;/p&gt;

&lt;p&gt;설계할 때 고려사항은 Loop 변수의 유형과 스코프를 정의해야 하며,&lt;br /&gt;
Loop에서 변화하는 Loop변수의 값이 룹 제어에 영향을 미치는지 확인해야 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;for Statenebts&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;C의 for 반복문을 보면, ​&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for ([expr_1] ; [expr_2] ; [expr_3]) ​

loop body… 와 같습니다. ​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음과 같이 카운터 변수가 여럿일 수 있고, ​
부울식을 포함할 수 있다. ​&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;For (count1 = 0, count2 = 1.0;​
     count1 &amp;lt;= 10 &amp;amp;&amp;amp; count2 &amp;lt;= 100.0;​
    sum = ++count1 + count2, count2 *= 2); ​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자바에서 컨트롤 표현식은 부울식이어야 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;while Loops&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;​While Loop은 부울식에 의해 제어된다.&lt;br /&gt;
Ctrl_expr는 부울식으로, Loop의 맨앞에 또는 맨뒤에 위치한다. ​&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while (ctrl_expr) ​
loop body… ​

do ​
loop body ​
while (ctrl_expr) ​ ​ 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;User-Located Loop Control&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Break 처럼 loop 컨트롤이 loop body의 중간에 위치하기도 한다.&lt;br /&gt;
이것을 user-located loop control이라고 부른다.&lt;br /&gt;
Break 외에도 continue가 있다.&lt;/p&gt;

&lt;p&gt;자료구조를 구성하는 요소에 의해 제어되는 반복 처리가 있다. ​
Iterator를 호출하면, 자료구조에서 다음 요소를 반환해준다. ​
이밖에 for에서도 자료구조에 의한 반복처리를 제어할 수 있다.  ​&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Unconditional Branching&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;앞에서 언급했듯이 goto는 가독성 문제를 일으킨다.&lt;br /&gt;
자바는 goto가 없다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;guarded-commands&quot;&gt;&lt;strong&gt;Guarded Commands&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;각 문장 앞에 부울식이 있는 것을 가디드 코멘드라고 한다. &lt;br /&gt;
즉 가디드 코멘드는 ​selection 문장의 각 라인이 ​부울식과 ‘하나의 문장 또는 문장의 시퀀스＇로 구성된다. ​&lt;/p&gt;

&lt;p&gt;이렇게 하는 목적은 ​프로그램 개발 중에도 프로그램의 correctness(올바름)를 증명하기 위한 것으로, ​Concurrent 프로그래밍의 기초가 된다. ​&lt;/p&gt;

&lt;p&gt;기존의 언어는 개발(코딩)을 마치고 테스트를 통해 프로그램의 올바름을 확인한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Selection Guarded Command&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Selection의 가디드 코멘드는 ​If 안의 각 문장마다 부울식이 있다. ​&lt;/p&gt;

&lt;p&gt;이 가디드 코멘드의 시맨틱은 다음과 같다.&lt;br /&gt;
부울식을 계산해서, ​나 이상이 참이면, 그 중에 아무거나 선택한다.&lt;br /&gt;
아무것도 참이 아니면, 실행 오류로 처리한다.​&lt;br /&gt;
프로그램의 correctness는 선택된 문장에 종속되지 않는다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if x &amp;gt;= y -&amp;gt; max := x​
[] y &amp;gt;= x =&amp;gt; max := y​
fi

if (x &amp;gt;= y)​  
    max = x;​
else​
    max = y;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;X, y가 같을 때, 전자는 아무거나 선택되어 수행되나, ​
후자는 max=x가 수행됨.&lt;br /&gt;
따라서, non-deterministic vs. deterministic&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Loop Guarded Command&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;do &amp;lt;Boolean&amp;gt; -&amp;gt; &amp;lt;statement&amp;gt;​
[] &amp;lt;Boolean&amp;gt; -&amp;gt; &amp;lt;statement&amp;gt;​
...​
[] &amp;lt;Boolean&amp;gt; -&amp;gt; &amp;lt;statement&amp;gt;​
od​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Loop 가디드 코멘드에서, ​Do 다음에 나오는 모든 문장의 앞에 부울식이 있다. ​
​
룹 가디드 코멘드의 시맥틱스는 다음과 같다.&lt;br /&gt;
부울식을 계산하고, ​
하나 이상이 참이면, ​
아무거나 선택하여 룹을 시작한다.&lt;br /&gt;
아무것도 참이 아니면, 룹에서 나온다.&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">컨트롤 스트럭처</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">복잡한 데이터 타입</title>
      <link href="https://lee989898.github.io/pl-13" rel="alternate" type="text/html" title="복잡한 데이터 타입" />
      <published>2021-10-14T19:18:00+09:00</published>
      <updated>2021-10-14T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-13</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-13">&lt;h3 id=&quot;복잡한-데이터-타입&quot;&gt;&lt;strong&gt;복잡한 데이터 타입&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;배열과 레코드 타입을 살펴보자&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;배열&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;배열은 동일한 유형의 데이터 요소의 모임으로, ​
각 요소의 위치에 의해 지칭된다(식별된다). ​
각 요소의 위치를 나타내는 방식은 ​
‘배열의 맨앞에서 시작하여 각 요소
의 상대적 위치를 지칭하는 인덱스(서브스크립트, subscript)’에 의한다. ​
이와 같이 상대적 위치를 지칭하기 위해서는, ​
인덱스와 요소 간의 매핑이 필요한데, ​
이러한 매핑을 배열 인덱싱 또는 subscripting이라고 한다. ​
1차원 배열 인덱싱은 사소한 문제에 불과하지만, ​
배열의 차원이 증가하고 각 차원의 범위가 다양해지면서 ​
배열의 인덱싱 문제는 복잡해진다.&lt;/p&gt;

&lt;p&gt;배열 인덱스 유형은 주로 정수형을 사용하나 언어에 따라 약간 다르다. ​
포트란, C, 자바는 정수형만을 지원하나, ​
파스칼은 모든 서수 유형(정수, 부울리언, 글자)을 지원한다. ​
C, C++, 펄, 포트란은 인덱스에 대해 범위 검사를 하지 않지만, ​
자바, ML, C#은 인덱스의 범위를 검사한다. ​&lt;/p&gt;

&lt;p&gt;배열의 범주를 서브스크립트의 범위와 메모리 할당 시기를 기준으로 나누면,  ​
정적 배열, 고정 스택-동적 배열, 고정 힙-동적 배열,
 힙-동적 배열로 구분한다. ​&lt;/p&gt;

&lt;p&gt;정적 배열은 서브스크립트의 범위가 정적으로 고정되어 있고, ​
런타임 이전에 메모리가 정적으로 할당된다.  ​
장점은 효율적이지만, ​
단점은 실행중 필요시마다 동적 할당이 불가능하여 융통성이 없다. ​
C, C++에서 static modifier를 포함하는 배열은 정적 배열이다. ​&lt;/p&gt;

&lt;p&gt;고정 스택-동적 배열은 서브스크립트의 범위가 정적으로 고정되어 있지만, ​
메모리는 미리 할당되지 않고, 선언문 실행 중에 할당된다. ​
장점은 실행되지 않는 서브프로그램에서 정의된 배열에 대해 ​
메모리가 미리 할당되지 않아, 메모리 공간 활용이 효율적이다. ​
C, C++에서 static modifier를 포함하지 않는 배열은 고정 스택-동적 배열이다.&lt;/p&gt;

&lt;p&gt;고정 힙-동적 배열은 스토리지 바인딩이 동적이지만, ​
힙에 할당된 후에는 서브스크립트의 범위가 고정된다. ​
C, C++에서 malloc에 의해 할당된 배열은 고정 힙-동적 배열이다. ​&lt;/p&gt;

&lt;p&gt;힙-동적 배열은 서브스크립트 범위와 스토리지의 바인딩이 ​
모두 동적이면서 변경 가능하다. ​
장점은 배열이 실행 중에 늘어나거나 줄어 들 수 있어서 융통성이 있다. ​
C#에서 ArrayList에 의해 정의된 배열은 힙-동적 배열이다. ​
배열의 요소없이 생성되고 나중에 add를 써서 배열을 늘인다.&lt;/p&gt;

&lt;p&gt;C, C++, C#, 자바에서는 ​
스토리지 할당시에 배열이 초기화된다. ​&lt;/p&gt;

&lt;p&gt;포트란은 배열에 대한 연산을 지원한다. ​
두 배열의 합(+)은 위치가 같은 배열의 각 요소들간의 합을 배열로 나타낸 것이다. ​
A = B + C ——- A, B, C 모두 배열…  ​
배열에 대한 연산을 지원하지 않는다면, ​
loop을 써서 반복적으로 ​
각 요소마다 합을 구해야 함 (A[i] = B[i] + C[i]에 의해)&lt;/p&gt;

&lt;p&gt;순서를 무시한 데이터 요소의 모임을 associative array라고 하며, ​
사용자가 정의한 Key를 인덱스로 사용한다. ​
따라서, associative array는 키와 값의 쌍을 나열한 것이다.  ​
펄에서 associative array를 다음과 같이 정의하고, ​
%hi_temps = (“Mon” =&amp;gt; 77, “Tue” =&amp;gt; 79, “Wed” =&amp;gt; 65, …);​
다음과 같이 배열에서 값을 찾는다.  ​
$hi_temps{“Wed”} = 83; 여기서 Wed가 키이다. ​
다음 명령어는 배열에서 값을 삭제한다.  ​
delete $hi_temps{“Tue”};&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;레코드&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;배열은 동일한 유현의 데이터 요소의 모임인 반면, ​
레코드는 다른 유형의 데이터 요소의 모임이다. ​
레코드에서는 그 요소의 이름으로 요소를 식별(지칭, 언급)한다. ​&lt;/p&gt;

&lt;p&gt;레코드 타입에서 각 필드를 지칭(언급)하는 방법은 필드명에 의하며, ​
서브 필드를 명확히 지칭하기 위해,  ​
코볼에서는 of를 키워드로 하고, ​
다른 언어에서는 dot(.)을 쓰기도 한다. ​
레코드 타입의 연산은 assignment(필드명에 값 할당), ​
레코드간의 필드값 카피 등이다.  ​&lt;/p&gt;

&lt;p&gt;튜플 타입은 레코드와 유사하나, 각 요소의 이름이 없다는 것이 다르다. ​
파이썬의 튜플은 튜플의 값을 변경할 수 없다. ​
만일 변경하고자 한다면, ​
List 함수를 써서 튜플을 배열로 변환한 다음에, ​
배열의 값을 변경한다. ​
변경한 후에, tuple 함수를 써서, 튜플로 재변환한다. ​
myTuple = (3, 5.8, ‘apple’)은 튜플을 생성한다. ​
myTuple[1]은 첫째 요소를 가리킨다. ​
+는 튜플 간의 concatenation을 실행하고, ​
del은 튜플을 삭제한다.&lt;/p&gt;

&lt;p&gt;리스트 타입은 튜플과 유사하나, ​
각 요소의 값을 변경 가능하다는 것이 다르다. ​
파이썬은 리스트 타입을 지원하며, 배열처럼 취급된다. ​
배열과 차이점은 각 요소의 값이 어떤 유형이든 상관없다는 것이다.  ​
생성, 지칭, 삭제 연산 등을 보면 튜플과 유사함을 알 수 있다.​
리스트 포함(comprehension)은 컨스트럭트에 리스트를 포함시키는 것을 말한다. ​
이것은 리스트를 필요시 정의할 수 있는 편리한 기능이다. ​
형식은 [expression for iterate_var in array if condition]
을 취한다.  ​
예를 들면, [x*x for x in range(12) if x%3==0]과 같다. ​
range(12)는 0에서 12까지의 배열을 생성하는 함수이고, ​
x%3은 x를 3으로 나눈 나머지를 말한다. ​
이 문장은 0에서 12로 구성된 배열을 생성하고 ​
0,3,6,9,12를 제곱하라는 뜻이다. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;포인터와 레퍼런스 타입에 대해 살펴보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;포인터&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;포인터 타입 변수가 가질 수 있는 값의 범위는 ​
메모리 주소와 영(nil)이다.  ​
포인터는 간접 주소 지정 방식과 동적 메모리 관리 방식을 제공한다. ​
포인터는 힙에 있는 메모리 위치를 접근할 때 사용된다.&lt;/p&gt;

&lt;p&gt;기본적 연산으로 assignment와 dereferencing이 있다. ​
Assignment는 포인터 변수의 값에 주소를 넣어 두는 것이다. ​
디레퍼런싱은 포인터의 값이 가리키는 주소에 저장된 값을 산출하는 것이다. ​
디레퍼런싱은 명시적이거나 암묵적이다. ​
C, C++에서는 명시적인 디레퍼런싱 연산자로 &lt;em&gt;를 사용한다. ​
j=&lt;/em&gt;ptr는 ptr의 값이 가리키는 주소에 저장된 값을 ​
변수 j의 메모리 위치에 넣어 두라는 의미이다. ​
아래 그림은 이것을 그림으로 나타낸 것이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl35.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;포인터 사용할 때 나타나는 문제는 다음의 두가지가 있다. ​
​&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;허상 포인터(dangling pointer)는 ​
힙-동적 변수에 할당된 메모리를 가리키지 않고 있는 포인터를 말한다.  ​
자세히 설명하면, ​
힙에 의해 변수에 메모리가 할당되면, ​
포인터는 이 메모리를 가리키고 있겠지만,  ​
이후 메모리가 해제되었다면, ​
이 포인터는 메모리를 가리키지 못하게 된다. ​
이러한 포인터를 허상 포인터라고 한다. ​
즉, 메모리는 없지만 포인터는 남아 있는 경우이다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;memory leakage(기억 상실)​
힙-동적 변수의 상실은 힙-동적 변수가 이미 메모리에 할당되어 있지만, ​
포인터가 상실되어 ​
사용자 프로그램에서 이 동적 변수에 더 이상 접근 가능하지
 않은 경우를 말한다. ​
즉, 포인터는 없지만 할당된 메모리는 남아 있는 경우이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;포인터는 언제 메모리에 할당되든지 어떤 변수든 가리킬 수 있으며,  ​
동적 스토리지 관리에서 사용된다. ​
포인터 산술 연산이 가능하고, ​
디레퍼런싱과 ‘무엇의 주소’ 연산이 가능하다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    float stuff[100];​
    float *p;​
    p = stuff;​

    *(p+5) is equivalent to stuff[5] and  p[5]​
    *(p+i) is equivalent to stuff[i] and  p[i]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;C, C++에서는 포인터에 대한 산술 연산이 가능하다. ​
5번째값, i번째값&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;레퍼런스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;레퍼런스는 포인터와 유사하나, ​
기본적으로 다른점은 ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;포인터는 메모리의 주소를 가리키지만, ​
  (주소에 대한 연산이 나름의 의미를 갖지만)​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;레퍼런스는 메모리의 값을 가리킨다. ​
  (주소에 대한 연산이 무의미)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;허상 포인터와 허상 객체는 힙 관리 상의 문제이다. ​
포인터는 변수가 가리킬 수 있는 범위를 확장시킨다는 면에서 goto와 비슷하다. ​
레퍼런스는 포인터의 기능과 유연성을 제공하면서, 위험은 제거한다. ​
포인터와 레퍼런스는 동적 데이터 구조를 위해 프로
그래밍 언어의 필수적인 요소이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl36.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;이 그림에서는 허상 포인터의 예를 보여주고 있다. ​&lt;/p&gt;

&lt;p&gt;프로그램 코드가 이와 같을 때, ​
*q=30은 이미 해제된 메모리가 남아 있다고 착각한다.  ​
Q는 결국 아무것도 가리키지 않는 허상 포인터이다.&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">복잡한 데이터 타입</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">표현식과 대입문</title>
      <link href="https://lee989898.github.io/pl-14" rel="alternate" type="text/html" title="표현식과 대입문" />
      <published>2021-10-14T19:18:00+09:00</published>
      <updated>2021-10-14T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-14</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-14">&lt;h3 id=&quot;표현식과-대입문&quot;&gt;&lt;strong&gt;표현식과 대입문&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;표현식(expression)은 프로그래밍 언어에서 계산을 상술
(상세히 서술)하는 수단이다. ​
대입문은 변수의 값을 변화시키는 문장으로, 모든 명령형 언어의 필수적 요소이다. ​
대입문은 독립적으로 실행 가능한 문장인 반면, ​
표현식은 대입문의 일부분으로서, 독립적으로 실행될 수 있는 문장이 아니다. ​&lt;/p&gt;

&lt;p&gt;대입문과 표현식의 차이를 좀더 살펴 보자.  ​
변수가 메모리의 일정 부분임을 상술하는 수단이라는 것과, ​
대입문의 BNF 형식이 &lt;var&gt;=&lt;expression&gt;임을 알고 있다. ​
BNF의 형식으로부터, ​
표현식(&lt;expression&gt;)은 대입문의 일부분임을 알 수 있고, ​
대입문의 변수(&lt;var&gt;)가 가리키는 메모리에 저장된 값을 ​
표현식의 계산 결과로 변경시킨다는 것을 알 수 있다. ​&lt;/var&gt;&lt;/expression&gt;&lt;/expression&gt;&lt;/var&gt;&lt;/p&gt;

&lt;p&gt;그런데, 표현식의 계산 방식에 따라 계산 결과는 달라질 수 있다.  ​
표현식의 계산 방식을 이해하려면, ​
연산자와 오퍼랜드의 계산 순서에 대한 규칙을 알 필요가 있다.  ​
이들 순서는 결합 법칙과 우선순위 규칙에 의하며, ​
오퍼랜드 계산 순서는 오퍼랜드의 부수효과(부작용)때문에 중요하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;산술식&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;산술식은 연산자, 오퍼랜드, 괄호, 함수 호출로 구성된다. ​
연산자는 단항 연산자, 이진 연산자, 삼항 조건 연산자(?:) 등이 있다. ​&lt;/p&gt;

&lt;p&gt;표현식의 구현은, ​
메모리에서 오퍼랜드를 가지고 와서, ​
그 오퍼랜드에 산술 연산자를 실행한다. ​
산술식 설계시 고려사항 ​
연산자 우선 순위, 결합 법칙 등 ​
오퍼랜드 계산 순서와 부작용(부수효과) ​
연산자 오버로딩 ​
표현식에서 오퍼랜드 타입의 혼합&lt;/p&gt;

&lt;p&gt;연산자 우선순위 규칙은 우선 순위가 다르면서 이웃하는 연산자의
 계산 순서를 정의한다. ​
전형적인 우선순위 규칙은 괄호&amp;gt;단항연산&amp;gt;지수&amp;gt;곱셈과 나눗셈&amp;gt;덧셈과 뺄셈 ​&lt;/p&gt;

&lt;p&gt;연산자 결합 법칙은 우선 순위가 같으면서 이웃하는 연산자의 순서를 정의한다. ​
전형적인 결합법칙은 좌에서 우로(단, 지수는 우에서 좌로) 적용된다.  ​
괄호는 우선순위와 결합 법칙에 앞선다. 
​
C, C++에서 조건 표현식은 삼항 조건 연산자 ?:를 사용한다. ​
average = (count == 0)? 0 : sum / count와 같이 표현한다. ​
이것의 의미는 다음과 같다. ​
if (count == 0), average = 0​
else average = sum / count ​
이 문장을 이해하려면, 대입문의 BNF 형식 &lt;var&gt;=&lt;expr&gt;을 떠올리면 쉽다. ​
그러니까 &lt;var&gt;이 average이고, ​&lt;/var&gt;&lt;/expr&gt;&lt;/var&gt;&lt;/p&gt;
&lt;expr&gt;가 삼항 조건 표현식인 (count==0) ? 0 : sum/count이다. 

표현식에서 오퍼랜드는 어떻게 계산되는지 살펴 보면, ​
변수는 메모리에서 값을 가져온다.  ​
상수는 메모리에서 값을 가져오기도 하지만, 기계 언어에 내재되기도 한다. ​
괄호가 있는 표현식은 괄호속에 있는 모든 오퍼랜드와 연산자를 먼저 
계산하고, 괄호 전체를 계산한다. ​

오퍼랜드가 아무런 부작용(부수효과)가 없을 때, 
오퍼랜드 계산 순서는 결과에 무관하다. ​

그러나 함수가 오퍼랜드일 때, 계산 순서는 다른 결과를 가져온다.  
함수는 다수의 파라미터 또는 글로벌 변수를 변경시킬 수 있고,  ​
이때 함수 부수효과가 발생할 수 있다. ​
이로 인해 표현식의 계산 결과에 영향을 미칠 수 있다. ​


---

 ​&lt;img src=&quot;/assets/built/images/pl/pl37.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;

---

위 그림에서 함수 부수효과 문제의 예를 보자. ​
다음 프로그램에서, ​
Main의 a = a + fun1( )의 값은 ​
먼저 a를 계산하느냐, fun1( )을 먼저 계산하느냐에 따라 달라진다. ​

1. 먼저 a를 계산(메모리에서 가져오는 fetch)하면, ​
a가 5이고, fun1()이 3이므로, 둘을 더하면 a는 8이다. ​

2. 먼저 fun1을 계산하면, ​
fun1은 3이지만 부수효과로서 a가 17이므로, ​
둘을 더하면 a는 20이 된다. 

수학에서 함수는 x에 대응하는 y값을 찾는 것이므로, 부수 효과가 없다.​
함수 언어에서도 마찬가지다. ​
부수효과는 본 뉴만 아키텍처 및
 이에 기반한 명령형 언어의 계산 모형으로 인해 발생한다. ​
본 뉴만 아키텍처 및 이를 그대로 본뜬 명령형 언어의 계산 모형은 ​
계산하여 변화된 값의 상태를 항상 메모리에 
저장하도록 설계되어 있기 때문이다. ​

함수 부수효과의 해결책은 다음 두가지가 있다. ​

+ C, C++ 처럼 함수 부수 효과를 허용하지 않도록 언어를 설계하는 것이다. ​
    함수에서 단일 파라미터만 허용하여, 단일 값을 반환한다. ​
    만일 다수의 파라미터가 필요하면, struct를 사용하여 하나의 파라미터로 만든다. ​
    함수에서 글로벌 변수를 접근 불허한다. ​
    단점은 파라미터 및 글로벌 변수에 융통성이 없다. ​

2. 자바처럼 오퍼랜드 계산 순서를 고정시킨다. ​
    좌에서 우로… ​
    단점은 컴파일러 최적화를 제한한다.  ​

최적화를 위해 표현식을 reordering하기도 하는데 고정 순서는 이를 불허한다. 

---

+ 과적 연산자

기계어에서는 정수의 덧셈 연산자와 부동점 소수의 덧셈 연산자를 구분한다. 
부동점 소수의 덧셈: FADD, ​
정수의 덧셈: ADD ​
프로그래머는 정수의 덧셈과, 부동점 소수의 덧셈에 모두 +를 쓰고 싶어한다.  ​

1. 그러면서, 컴파일러가 알아서 이들을 구분하여 번역하기 바란다. ​
2. 두개의 배열 변수의 덧셈도 +로 간단히 쓰고 싶어 한다.  ​

이와 같이 하나의 연산자를 여러가지 목적으로 사용하는 것을 ​
연산자의 과적(오버로딩)이라고 한다. 

정수와 부동점에 대한 +의 과적은 ​
일상적으로 허용되지만, C와 C++에서는 문제를 일으키기도 한다. 

___

+ 타입 변환

정수와 부동점 소수 간의 덧셈에서, ​
데이터를 어떤 유형으로, 그리고 어떤 포맷으로 변환할 것인가? ​
유형: 정수, 부동점 소수 ​
포맷: 십진수 vs 이진수, 부동점의 (싸인,지수부분,소수부분) 각 몇 비트? 

Narrowing conversion은 ‘원래 유형의 모든 값’을 포함할 수 없
는 유형으로 변환하는 것을 의미한다. ​
예를 들어, 더블 부동점 소수를 싱글 부동점 소수로 변환하는 경우. ​
이때 항상 safe하지는 않다. -&amp;gt; 값의 크기가 바뀐다. 짤린다. ​​

Widening conversion은 원래 유형의 근사값을 포
함하는 유형으로 변환하는 것을 의미한다. ​
예를 들어 정수를 부동점 소수로 변환하는 경우. ​
이때, safe하다. 즉, 근사값으로 바뀌므로 크기가 바뀌지 않는다. ​
다만 포맷(내부 표현 방식)의 차이로 인해 정확하게 같지 않을 경우도 있다.   

오퍼랜드의 타입이 혼합되어 있을 때, ​
명시적이거나 암묵적으로 타입 변환이 필요하다. ​
컴파일러에 의한 암묵적 타입 변환을 코어젼이라고
 한다. -&amp;gt; 대부분의 언어에서…   ​
프로그래머에 의한 명시적 타입 변환을 캐스팅이라고 한다. ​
C에서는 (int) angle과 같이 캐스팅을 괄호로 표시한다.  ​

___

+ 비교 및 부울 표현식

비교 표현식은 두개의 오퍼랜드를 비교하
기 위해 비교 연산자를 사용한다. 

부울 표현식은 부울 연산자 and, or, not를 사용한다. 

표현식의 Short-circuit evaluation에 대해 살펴 본다.
Short-circuit evaluation은 ​
표현식의 결과를 도출하는데 충분한 계산이 완료되면, ​
그 이후의 표현식 계산을 중단한다는 의미이다. ​
따라서, 표현식의 최소 계산이라고 번역하겠다.  

표현식에서 여러 오퍼랜드 중에서 몇 개만 해보고 그 결과를 알 수 있다면 ​
모든 오퍼랜드를 계산할 필요가 없다. ​
이것을 표현식의 최소 계산이라고 한다. ​

간단한 예를 보자. ​
(13 * a) * (b/13–1)에서, a가 0이면, 1
3*a가 0이므로 더 이상 계산할 필요가 없다. ​

만일 최소 계산을 채택하지 않을 경우, ​
다음 프로그램에서 예상치 않은 문제를 발생시킨다. ​

index = 0;​
while ((index &amp;lt; listlen) &amp;amp;&amp;amp; (LIST[index]!= key)) 
index = index + 1; 이고, ​
LIST 배열의 인덱스가 0에서 listlen-1까지 라고 가정하자. ​

index==listlen일 때, (index &amp;lt; listlen)을 만족시키지 못한다. ​
그런데 최소 계산을 채택하지 않기때문에 여기서 중단되지 않고, ​
그 이후의 (LIST[index]!= key))를 계산하게 되며, ​
이때, LIST[index]에서 인덱싱 문제가 발생하게 된다. ​

이와 같이 최소 계산을 채택하지 않을 경우 ​
불필요한 오류를 발생시키기도 한다. 

최소 계산은 표현식의 부작용에 영향을 받을 수도 있다. ​
(a &amp;gt; b) || (b++ / 3)에서 ​
||의 두번째 오퍼랜드를 먼저 계산하면 ​
b가 증가하여 첫째 오퍼랜드의 결과에 영향을 준다.   

---

+ 대입문과 혼합 타입의 대입문

대입문의 일반적 형식은 &lt;var&gt; = &lt;expression&gt;이다. ​
대입 연산자 = 대신에 :=를 쓰기도 한다. ​
= 대신에 :=을 쓰는 이유는 =의 의미가 ‘같다＇의 의미와 혼동되기 때문이다. ​
=를 대입 연산자로 사용하는 경우, ‘같다＇의 연산자로 ==를 사용한다. 

조건 타겟은 조건에 따라 타겟 변수가 결정된다. ​
펄에서 조건 타겟이 포함된 대입문의 예를 보자. ​
대입문 ($flag ? $total : $subtotal) = 0에서 ​
대입 연산자 =의 왼쪽에 조건식이 포함되어 있는데, ​
이 뜻은 만일 ($flag)이 참이면 $total = 0이고, ​
거짓이면 $subtotal = 0이다 ​

복합 대입문 연산자는 대입문의 =과 연산자를 연결한 것이다. 
단항 대입문 연산자는 ++과 같은 것을 의미한다. 

표현식에 대입문을 쓰기도 한다. ​
while ((ch = getchar())!= EOF){…}​
  ch = getchar()
위의 while 문의 조건식에 ch = getchar()라는 대입문이 들어가 있다. ​
이 대입문이 먼저 실행되고 나서, 조건식이 계산된다. ​
그러면 getchar 값이 ch에 할당되고, ​
ch!=eof가 참이면 {…}가 실행된다. ​
a=b+(c=d/b)-1의 경우처럼, ​
표현식에 대입문을 쓰는 것은 대입문의 이해를 어렵게 한다. 
 
​($first, $second, $third) = (20, 30, 4
0)와 같이 다수의 값을 할당할 수도 있고, ​ 
 
Interchange를 ($first, $second) =
($second, $first)와 같이 쓸 수도 있다. 

함수 언어에서 identifier는 값의 이름에 불과하며, ​
변수를 나타내는 것이 아니기때문에 이들의 값은 바뀔 수 없다. ​
val fruit = apples + oranges;에서 ​
이름 fruit는 apples와 oranges의 값을 더해서 나온 결과 값의 이름이다.  ​

대입문에서 혼합 타입이 가능하다. ​
이때 타입 변환이 발생한다. 
​

---
&lt;/expression&gt;&lt;/var&gt;&lt;/expr&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">표현식과 대입문</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">데이터 타입</title>
      <link href="https://lee989898.github.io/pl-12" rel="alternate" type="text/html" title="데이터 타입" />
      <published>2021-10-07T19:18:00+09:00</published>
      <updated>2021-10-07T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-12</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-12">&lt;h3 id=&quot;데이터-타입&quot;&gt;&lt;strong&gt;데이터 타입&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;선언문 int n으로부터 n에 대해 무엇을 알 수 있을까? ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;n이 취할 수 있는 값의 범위는? (모든 정수) ​&lt;/li&gt;
  &lt;li&gt;n에 적용 가능한 연산자는? (닫혀 있는 모든 연산자, +, -, *) ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;데이터 타입의 개념에 대해 살펴 보면, 
특정 타입의 변수를 선언하면,  ​
그 변수가 취할 수 있는 값은 특정 집합이고, ​
그 값들에 적용 가능한 연산자 집합이 존재한다는 의미이다.  ​&lt;/p&gt;

&lt;p&gt;PL 설계자가 마주하는 기본적인 설계 이슈는 ​
목적에 적합한 충분한 데이터 타입으로 구성된 집합을 어떻게 정의할 것인가? ​
무슨 연산자들을 정의하고 이들 연산자를 데이터 타입
에 어떻게 지정(specify)할 것인가?&lt;/p&gt;

&lt;p&gt;데이터 타입은 다음과 같이 진화해 왔다. ​
초기 PL에서는, 많은 데이터 타입으로 다양한 응용을 지원하였다. ​
PL/1이 이러한 예이다. ​&lt;/p&gt;

&lt;p&gt;ALGOL68에서 얻은 지혜: ​
소수의 기본 타입과 이를 위한 소수의 연산자를 정의하고, ​
필요에 따라, 사용자 정의(user-defined) 데이터 타입을 지원하자! ​&lt;/p&gt;

&lt;p&gt;사용자 정의 타입으로부터 추상 데이터 타입으로 발전하였다.​
예를 들어, 스택, 큐, 링크드 리스트 등이 이에 속한다. ​&lt;/p&gt;

&lt;p&gt;타입의 유용성은 다음과 같다.  ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로그램 구조화 및 문서화에 유용​&lt;/li&gt;
  &lt;li&gt;오류 식별 및 방지에 유용​&lt;/li&gt;
  &lt;li&gt;최적화 지원에 유용 ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​먼저 비교적 단순한 형태로서, 원시형, 문자열형, 사용자
 정의 나열형부터 살펴 보자&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;원시 타입&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;원시 타입은 거의 모든 언어가 제공하고 있는 기본적인 데이터 타입으로, ​
다른 데이터 타입을 사용해서 정의되지 않는 데이터 타입이다. ​
Integer, floating-point, Boolean, character ​
원시 타입은 하드웨어 구조를 직접 반영한 것도 있다. ​
부동점 소수는 4바이트의 싱글 프리시전과 8바이트의 더블 프리시전이 있는데, ​
각각의 비트 구성은 ​
싱글 프리시전: 싸인 1비트, 지수부분 8비트, 소수부분 23비트이거나 ​
더블 프리시전: 싸인 1비트, 지수부분 11비트, 소수부분 52비트이다.    ​&lt;/p&gt;

&lt;p&gt;​+ 문자열 형&lt;/p&gt;

&lt;p&gt;문자열 타입의 값은 문자열이다. ​
설계 이슈: ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;원시 타입으로? 아니면 배열의 특수형으로? ​&lt;/li&gt;
  &lt;li&gt;스트링의 길이를 정적으로? 아니면 동적으로?​&lt;/li&gt;
  &lt;li&gt;스트링 연산자는? assignment, copy, comparison, concatenation, substring, pattern matching, etc
문자열을 비교할 때, &amp;gt;의 의미는 사전식 순서의 앞뒤 관계를 의미한다.  ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​C, C++에서 문자열은 원시 타입이 아니라, char 타입을 사용하여 정의한다. 
 이를 위해 라이브러리 함수를 제공한다. ​ 
 C 스트링 라이브러리의 문제는 제공되는 
 함수가 오버플로우를 처리하지 못한다는 것이다. ​
 예를 들어, strcopy (src, dest); 에서 ​
 src가 50바이트이고, dest가 20바이트이면 어떤 일이 일어날까?  ​&lt;/p&gt;

&lt;p&gt;자바의 문자열 타입은 원시 타입으로 String, 
 StringBuffer 클래스를 지원한다.&lt;/p&gt;

&lt;p&gt;문자열 길이 옵션은 3가지(정적, 제한적 동적, 동적) 옵션이 있다.  ​&lt;/p&gt;

&lt;p&gt;먼저 정적 옵션을 보면… ​
COBOL, Java String 클래스는 정적이다. ​
스트링이 생성될 때 길이가 정해진다. ​&lt;/p&gt;

&lt;p&gt;제한적 동적 옵션은… ​
C, C++에서는 동적이나 제한적이다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;길이는 최대 길이까지 가변적이다. ​&lt;/li&gt;
  &lt;li&gt;C에서는 최대 길이로 제한하기 보다, ​
스트링에 특수 문자를 사용하여 스트링의 끝을 나타내기도 한다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;동적 옵션은… Perl, Javascript​&lt;/p&gt;

&lt;p&gt;Ada는 모든 옵션을 지원한다.&lt;/p&gt;

&lt;p&gt;문자열 옵션의 구현 방법은 다음과 같다. ​
정적 옵션의 구현 방법은 컴파일 시에 문자열의 서술을 위해 ​
3개의 필드(타입 이름(static string
), 길이, 첫글자의 주소)를 필요로 한다. ​&lt;/p&gt;

&lt;p&gt;제한적 동적 옵션 구현 방법은 런타임 때 문자열의 서술을 위해 ​
4개의 필드(타입이름(limited dynamic string), 최대 길이, 현재 길이, 첫글자의 주소)를 필요로 한다.  ​&lt;/p&gt;

&lt;p&gt;동적 옵션의 구현 방법은 런타임 때 문자열의 서술을 위해, ​
3개의 필드(타입 이름(dynamic string), 현재길이, 첫글자의 주소)를 필요로 한다. ​
동적 문자열은 문자열의 증가와 감소에 따라 ​
저장 공간을 동적 관리(allocate, deallocate)해야 한다.  &lt;br /&gt;
​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;사용자 정의 서수 타입&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서수 타입은 ‘데이터를 모아 놓은 것인데 순서가 중요
한’ 데이터의 모임이라고 볼 수 있다. ​&lt;/p&gt;

&lt;p&gt;Enumeration(나열형)과 subrange(범위형)가 대표적인 서수 타입이다.&lt;/p&gt;

&lt;p&gt;나열형을 살펴 보면, 속성과 값이 정의되어 있음을 볼 수 있다. ​
Coin은 페니, 니켈, 다임, 쿼터를 각각 1, 5, 10, 25로 정의하고, ​
Escapes는 각 키마다 아스키 코드의 컨트롤 문자가
 대응되어 있음을 볼 수 있다. ​
연산자에 대해, 표현의 특성이 integer면, integer 연산을 수행한다.&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">데이터 타입</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">변수와 시맨틱스</title>
      <link href="https://lee989898.github.io/pl-11" rel="alternate" type="text/html" title="변수와 시맨틱스" />
      <published>2021-09-30T19:18:00+09:00</published>
      <updated>2021-09-30T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-11</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-11">&lt;h3 id=&quot;변수와-시맨틱스&quot;&gt;&lt;strong&gt;변수와 시맨틱스&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;변수는 변수명, 데이터 타입, 값, 메모리 주소 등의 속성을 갖는다. ​
이들 속성을 변수에 결합하는 것을 바인딩이라고 한다. ​
바인딩이 되는 때를 바인딩 타임이라고 하는데, ​
주로 컴파일 할 때, 링크할 때, 메모리에 적재할
때, 실행할 때가 바인딩 타임이다.&lt;/p&gt;

&lt;p&gt;값이 assign될 때(assignment statement) 
타입이 바인딩 되는 것을 동적 바인딩이라고 한다. ​&lt;/p&gt;

&lt;p&gt;정적(static) 바인딩은 변수가 정의되거나 맨처음 
나타날 때 타입이 바인딩된다. ​&lt;/p&gt;

&lt;p&gt;바인딩 타임에 따라 변수의 값, 타입 등 ‘변수의 시맨틱’이 달라진다.  ​
스코프는 해당 변수가 정의 및 언급(reference)된 문장의 범위를 말한다.  ​
프로그램에서 선언(정의)문을 기준으로 하는 방법이 있고, ​
값의 할당문 하는(정해지는 순간을 기준으로 하는 방법이 있다. ​&lt;/p&gt;

&lt;p&gt;전자를 static scope(정적 스코프)라고 하고, ​
후자를 dynamic scope(동적 스코프)라고 한다. ​&lt;/p&gt;

&lt;p&gt;이제 상세히 알아보자&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;변수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;우선 변수의 개념을 살펴 보자.
변수는 이름, 값, 타입, 주소(메모리)를 속성으로 갖는다. ​&lt;/p&gt;

&lt;p&gt;이름은 identifier라고 하며, 언어에 따라 정의
 방법에 제한이 있는 경우도 있다. ​
변수의 값은 변수에 연관된 메모리 위치에 저장된 컨텐트(내용)으로, ​
프로그램 실행시 시시각각으로 바뀐다.&lt;/p&gt;

&lt;p&gt;변수의 타입은 데이터 타입을 말하는 것으로, ​
변수가 취할 수 있는 값의 범위와 이에 대한 연산자 집합을 결정한다. ​
변수의 타입은 선언문에 의해 정의되거나, ​
명명법(naming convention)에 따라 유추 가능하다. ​
타입 시스템을 적용하면, 타입 검사 및 프로그램
모듈화를 통한 오류 탐지가 가능하다. ​
같은 이름의 변수가 서브 프로그램의 스
코프에 따라 다른 타입을 가질 수 있으며,  ​
이종 타입 간의 연산이 가능할 수도 있다.&lt;/p&gt;

&lt;p&gt;변수는 메모리의 지정된 주소에 바인딩된다. ​
변수가 메모리 주소에 바인딩되면, ​
끝날 때까지 그 변수는 살아 있으며(active), ​
프로그램이 종료되면 그 메모리는 더 이상 그 변수에 바인딩되지 않는다. ​
이와 같이 바인딩이 시작되서 끝날 때까지의 시간을 lifetime이라고 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl31.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;—​&lt;/p&gt;

&lt;p&gt;위 그림에서 변수 i는 맨앞과 foo 함수에서 정의되고 있는데,  ​
이들 i는 변수명과 타입이 같으나, 메모리 위치는 서로 다르다. ​
변수 i는 foo 함수와 bar 함수에서 나타나는 변수 i의 메모리 위치는 ​
Foo의 isms foo에 정의된 i를 언급하지만, ​
Bar의 i는 맨앞의 i를 언급한다.  ​
이들 i가 갖는 값은 변수의 스코프 규칙에 따라
다르다.​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;바인딩​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;바인딩은 변수와 주소/타입 간의 매핑을 말한다. ​
이들 바인딩에는 정적 바인딩과 동적 바인딩이 있다. ​
정적 바인딩은 실행 전(컴파일, 링킹)에 바인딩이 완료되며, ​
프로그램 실행 동안에 그 속성이 변경되지 않는다. ​
동적 바인딩은 실행 중에 바인딩이 일어나며, ​
실행 중에 바뀔 수 있다.&lt;/p&gt;

&lt;p&gt;변수가 언급(referenced)되기 전에 그 변수는 데이터 타입에 바인
딩되어야 한다. ​
정적 바인딩에서, 타입 바인딩은 명시적
 선언에 의하거나 암묵적 선언에 의한다. ​
암묵적 선언이란 선언문 또는 정의문에 의한 것이 아니라 ​
변수의 명명법에 의해 타입을 부여하는 것을 말한다. ​
Perl에서 변수명이 시작되는 특수문자에 따라 타입이 결정된다. ​&lt;/p&gt;

&lt;p&gt;$ is a scalar(numeric, character), @ is an array, % is a hash structure ​
정적 타입 바인딩에서, 타입과 변수명은 동시에 변수에 바인딩된다.&lt;/p&gt;

&lt;p&gt;동적 바인딩은 값이 변수에 부여될 때, 값의 타입을 변수에 부여한다. ​
동적 바인딩은 파이썬, 자바 스크립트 등에서 사용된다.  ​
예를 들어, 프로그램에서 다음과 같이 쓸 수 있다.    ​&lt;/p&gt;

&lt;p&gt;List = [2, 4.33, 6, 8];​
List = 17.3;​
이것의 의미는 ​
List = [2, 4.33, 6, 8]; -&amp;gt; 이때는 벡터이고, ​
List = 17.3; -&amp;gt; 이때는 스칼라이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;타입 검사&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;연산자의 오퍼랜드가 서로 호환적인 타입인지 ​
확인하는 행위를 타입 검사라고 한다. ​
호환적인 타입의 의미는 ​
두 오퍼랜드의 타입이 연산자에 적합하거나 ​
타입 변환이 가능한 경우이다.  ​
Int는 real로 자동 변환되는데, 이를 coercion(자동 변환)이라고 한다. ​
정적인 타입 바인딩을 적용하면, 정적 타입 검사를 실시하고, ​
동적인 타입 바인딩을 적용하면 동적 타입 검사를 실시한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;스토리지(메모리) 바인딩은 ​
메모리 풀에서 메모리 셀을 얻어서 변수에 할당하고(allocation), ​
메모리를 다 쓰고 나면, 메모리 풀로 반납한다(deallocation). ​
변수의 Lifetime은 특정 메모리 셀에 바인딩되어 있는 동안의 시간을 말한다. ​
변수가 특정 셀에 바인딩될 때 시작되서, 바인딩이 해제될 때 끝난다.   ​
스칼라 변수는 lifetim에 따라 4가지 종류가 있다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;정적 변수(Static)
  정적 변수는 실행 전에 메모리 셀이 바인딩 되서, 
  실행이 끝날때까지 그대로 차지한다. ​  &lt;br /&gt;
  포트란77, C의 글로벌 및 정적 변수가 이에 해당 ​
  장점은 인스트럭션의 주소 필드가 (데이터가
  저장된) 메모리 위치를 직접 가리킬 수 있어서 ​
  직접 주소 방식(direct addressing)으로
  데이터를 접근할 수 있을 뿐만 아니라, ​
  실행시 allocation으로 인한 오버헤드가 없어서, 효율적이다. ​
  데이터 구조를 동적으로 생성하거나 객체의 크기를 컴파일 
  할 때 미리 알아야 한다.
  정적 메모리 모델은 recursion을 지원할 수 없다.&lt;/li&gt;
  &lt;li&gt;스택 동적 변수(stack dynamic)
  스택 동적 변수는 다음과 같이 바인딩을 수행한다.  ​
    &lt;ul&gt;
      &lt;li&gt;선언문에 정의된 타입은 정적으로 바인딩되지만, ​&lt;/li&gt;
      &lt;li&gt;스토리지 할당과 초기값 할당 등은 선언문에 정의
  된 대로 실행시에 바인딩된다. ​
  이것을 elaboration이라고 함) ​
예를 들어, 스칼라 변수에 대해 주소를
 제외한 모든 속성은 정적으로 바인딩되지만, ​
서브 프로그램의 로컬 변수나 자바의 메소드 등은 ​
런타임 스택으로부터 메모리가 할당되어 동적으로 바인딩된다. ​
장점은 recursion, 서브프로그램 메모리 보존 등이며, ​
단점은 allocation, deallocation으로 인한 오버헤
드, 간접 주소 방식(indirect addressing)에 의한 비효율 등이다.  ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;간접 주소 방식이란 인스트럭션의 주소 필드가 레지스터를 가리키고, ​
그 레지스터 안에 메모리 위치가 저장되어 있어서, ​
레지스터를 거쳐야 원하는 데이터를 접근하게 되는 방식이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;명시적 힙 동적 변수(explicit heap dynamic) 
힙은 가상 주소 공간의 일부분으로 동적 메모리 할당을 위해 예약되어 있다. ​
명시적 연산자 new, delete에 의해 할당되고 해제된다. ​
타입은 정적으로 바인딩되고, ​
스토리지는 실행시 변수가 생성될 때 바인딩된다. ​
힙에 접근할 때에는 힙 포인터나 레퍼런스를 통해서 접근하게 된다.&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Person *p;​
  p=(Person *) malloc(sizeof Person);​
  p-&amp;gt;name = “Mike”; p-&amp;gt;age = 40;​
  free(p);​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 코드는 C++의 명시적 힙 동적 변수의 예를 보여주고 있다. ​
자바 객체는 명시적 힙 동적 변수이다. ​
명시적 힙동적 변수의 장점은 동적인 구조를 생성할 수 있다. ​
단점은 포인터와 레퍼런스 변수를 올바르게 쓰기가 어려워 
프로그램의 신뢰도가 떨어질 수 있고, ​    &lt;br /&gt;
변수에 대한 레퍼런스 비용과 스트로지 관리의 복잡도가 높다.  ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;암묵적 힙 동적 변수(implicit heap dynamic)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;값이 할당될 때, 힙 스토리지에 바인딩된다. ​
장점은 융통성이 높다.  ​
단점은 동적 속성을 유지하기 위한 런타임 비용이 높고, ​
컴파일러에 의한 오류 탐지가 매우 낮다.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;스코프&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;속성이 바인딩된 변수에 대해, ​
그 바인딩이 유효한 또는 영향을
 미치는 프로그램의 범위, 이것을 스코프라고 한다.&lt;/p&gt;

&lt;p&gt;하나의 프로그램을 구성하는 여러 함수에서 ​
  동일한 이름의 변수들을 다른 타입으로 선언할 수 있다. ​
  이때 이들 변수는 각각 다른 타입으로 바인딩된다. ​
  이러한 이유로, 어떤 변수에 언제 어느 타입을 ​
  바인딩하는 것이 옳은지 결정하려면, ​
  어느 타입의 변수가 프로그램의 어디부터 어디까지 유효한지 ​
  구분이 필요하다. ​
  이와 같이 변수의 타입이 유효한 프로그램의 영역을 스코프라고 한다. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl32.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림의 main에서 foo(x)를 호출할 때, ​
  이때 x는 int인가 float인가? (int이다)&lt;/p&gt;

&lt;p&gt;변수의 스코프에 대한 정의를 살펴 보자&lt;br /&gt;
  스코프는 변수가 visible한(나타나는) 문장의 범위이다. ​
  ‘변수가 어떤 문장에서 visible하다(나타난다)’의 의미는 ​
  바인딩된 변수가 그 속성을 그대로 유지한 채, ​
  그 문장에서 언급(reference)되거나 그 변수에 값이 할당된다는 것이다. ​&lt;/p&gt;

&lt;p&gt;스코프를 변수가 영향을 미치는 범위라고 했는데, ​
  좀더 정확히 말하면, ​
  변수가 자신의 속성을 문장의 계산에 반영한다는 의미이다.&lt;/p&gt;

&lt;p&gt;C++이나 자바에서 포인터, 레퍼런스 타입 등을 설명할 때 ​
  Reference란 말이 사용되는데, ​
  여기서 설명하는 refence의 의미와 다르다.&lt;/p&gt;

&lt;p&gt;여기서, ‘문장에 X가 reference된다’는 말은 ‘x가 문장에
   ‘언급된다(씌여있다)’는 것을 의미하고, ​
    레퍼런스 타입의 레퍼런스를 의미하지 않는다
  ​&lt;br /&gt;
  프로그램에서 nonlocal 변수는 ​
    그 변수가 그 프로그램에서 visible하지만 ​
  그 프로그램에서 선언(declaration)되지는 않았다는 뜻이다. ​
  nonlocal 변수의 선언문은,  ​
  프로그램의 공간적 구조(정적 스코프)나 ​
  프로그램 호출의 역순(동적 스코프)으로 찾아가면, ​
  공간적으로 가깝거나 가까운 호출 함수에서 선언문을 찾을 수 있다. ​&lt;/p&gt;

&lt;p&gt;언어의 스코프 규칙은, 같은 이름의 변수가 여러 개 선언되었을 때, ​
  언급된 이름이 어느 선언문에 의한 변수에 관련되어 있는지 결정한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정적 스코프&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정적 스코프는 변수의 스코프를 ​
  프로그램 텍스트 구조에 따라 공간적 개념에 의해 정적으로 결정한다. ​
    언급된 이름을 변수에 매핑하려면, ​
  프로그래머(또는 컴파일러)는 선언문을 찾아야 한다. ​
  먼저 로컬에서 찾은 후, 없으면 스코프를 넓혀가면서, ​
  같은 이름을 정의한 선언문을 찾거나 선언
  문이 더 이상 없을 때까지 찾는다. 
  C에서 블록 스코프는 텍스트 레이아웃에 의한 ​
  공간적 개념으로 결정된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;동적 스코프&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;동적 스코프는 프로그램의 텍스트 레이아웃이 아니라, ​
  컨스트럭트의 호출 순서에 근거하므로, 런타임 때 결정된다. ​
    동적 스코프는 프로그램 실행 중, ​
    변수가 언급될 때마다 그 변수의 선언문을 찾아서 동적으로 매핑한다. ​
    언급된 변수에 대한 선언문이 어느 함수에 있는지 찾기 위해, ​
    함수 호출 순서의 역순으로 해당 변수의 선언문을 찾는다.&lt;/p&gt;

&lt;p&gt;동적 스코프의 장점은 서브 프로그램을 호출할 때 ​
     파라미터를 패스하지 않아도 되니 편리하다. ​ 
   단점은 자주 실행되는 서브 프로그램의 로컬 변수는 ​
      역시 자주 실행되는 다른 서브 프로그램에서 자주 나타나기 때문에 ​
      계산이 잘못될 가능성이 높다. (신뢰성 문제)​
    정적 타입으로 선언된 난로컬 변수의 타입 검사는 불가하여 오류 탐지가 어렵다.  ​
   게다가 읽고 이해하기 어렵다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;라이프 타임&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;라이프타임(수명)은 ​
변수에 메모리가 할당(allocate)되서
 해제(deallocate)될 때까지의 시간을 말한다. ​
라이프타임은 스코프와 밀접한 관계가 있지만, 개념적으로는 다르다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl33.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림 C 프로그램에서 로컬 정적 변수 count를 살펴 보자. ​
Main에서 fun을 1차 호출하면, count는 1이고, ​
2차 호출하면 count는 2이다. ​
count의 스코프만 따지면, ​
count가 로컬 정적변수이기 때문에 1차, 2차 호출 모두 1, 1이어야 한다.  ​
그러나 count의 lifetime이 전체 프로그램의 실행이 끝날 때까지 ​
연장되기 때문에, 1,2가 된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;변수의 개념을 좀더 상세히 알아보면, ​
x=1, x=x+1의 의미를 따져 보자.
여기서 =은 수학의 equal 사인이 아니라, ​
x에 1을 할당(assign)한다는 말이다. ​&lt;/p&gt;

&lt;p&gt;x는 변수의 이름이거나 변수의 위치를 지칭한다. ​
즉, 변수는 메모리 셀의 추상화이다. ​&lt;/p&gt;

&lt;p&gt;따라서, x는 이름(고유식별자)이고, ​
x는 어떤 값이 저장된 위치를 지칭한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Stack&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;함수가 호출되면, 스택 프레임을 스택의 꼭대기에 push 하고, ​
함수 실행이 끝나면, 스택 프레임을 꼭대기로부터 pop한다. ​&lt;/p&gt;

&lt;p&gt;스택 프레임은 호출되는 함수에 넘겨지는 파라미터 값, ​
호출함수가 호출된 함수로부터 값을 넘겨받는 반환 주소, ​
호출된 함수의 로컬 변수를 위한 저장 공간을 포함한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Heap&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;힙은 동적 메모리 할당이 일어나는 메모리의 일부분이다. ​
할당/해제 함수로는 malloc/free(pointer), new(poi
nter)/delete(pointer)가 있다. ​&lt;/p&gt;

&lt;p&gt;힙에 대한 메모리 할당은,    ​
메모리 일부분이 런타임에 동적으로 할당되고, ​
여러 함수에서 언급한 변수는 스코프에 제한이 없다
할당된 메모리 크기가 크다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;명령형 언어는 본뉴만 아키텍처를 흉내낸 것이다.
본뉴만 아키텍처의 주요 구성요소는 메모리와 프로세서이다
메모리는 데이터와 명령어를 저장하고, ​
프로세서는 메모리 컨텐트를 수정하는 연산을 실행한다&lt;/p&gt;

&lt;p&gt;이에 대응되는 명령형 언어의 추상화는 변수와 산술식이다
변수는 메모리셀에 대응하고, 산술식은 CPU 실행에 대응된다.&lt;/p&gt;

&lt;p&gt;컴퓨터에 실재로 존재하는 메모리(이것을 물리
적 메모리 또는 메모리라고 한다)는 ​
때때로 프로그래머의 프로그램을 한꺼번에 메모리에 모두 올려 놓지 않는다.&lt;/p&gt;

&lt;p&gt;그 이유는 다른 프로그램과 메모리를 나누어 쓰기도 하고, ​
프로그램이 메모리 사이즈를 넘어가기도 하기 때문이다.
프로그래머가 제한된 물리적 메모리 공간을 고려하면서 ​
변수나 배열에 메모리 공간을 할당한다는 것은 매우 복잡하고 어렵다. ​&lt;/p&gt;

&lt;p&gt;따라서 프로그램을 전부 저장할 수 있는 가상 메모리를 프로그램에 할당하고, ​
사용 가능한 메모리에 그만큼의 프로그램을 올렸다 내렸다 하면서 프로그램을 
실행한다. ​&lt;/p&gt;

&lt;p&gt;이와 같이 프로그램을 올렸다 내렸다 하는 작업은 OS가 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl29.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;가상 메모리에서,  ​
변수 i와 배열 a[100]은 메모리에 오렌지 색으로 할당된다. ​
함수 foo에서 적용되는 변수 i, j는 연두색으로 할당된다. ​
이중에서 적재 가능한 만큼의 프로그램을 메모리에 올려서, ​
프로세서에서 실행하고, ​
실행이 끝나면, 프로그램의 다음 부분을 올려서 실행하게 된다.&lt;/p&gt;

&lt;p&gt;이때 가상 메모리를 쓰면, ​
전체적인 상대 주소가 변하지 않기 때문에 ​
물리적 메모리에 적재할 때 ​
프로그램의 주소 변환이 매우 간단해 지는 장점이 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl30.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;변수의 타입에 따라 할당되는 메모리 공간이 다르다. ​
개략적으로 설명하면, ​
스택은 프로시져에 대한 정보를 저장하는 공간으로, ​
이들 프로시져에서 사용되는 파라미터, 변수 등의 속성 정보 등을 저장한다. ​
스택은 중첩 프로시져(함수) 호출, 순환 프로시져(함수) 호출 등을 ​
올바르게 처리하기 위한 목적으로 사용된다. ​&lt;/p&gt;

&lt;p&gt;힙은 malloc, free에 의해 명시적으로 메모
리의 동적 할당 및 해제를 위한 메모리 풀(pool)이다.   ​
Static에는 정적, 글로벌 변수가 저장된다.
Code는 프로그램이 저장된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;래퍼런싱 환경&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;문장의 레퍼런싱 환경은 문장에 visible한(나타난) 모든 변수명의 집합이다. ​
정적 스코프 규칙을 적용하는 언어에서, 레퍼런싱 환경은, ​
로컬 변수와 그 안에 공간 구조적으로 포함된 서브 프로그램
에 언급된(나타난) 변수를 합친 것이다. 
​
동적 스코프 규칙을 적용하는 언어에서, 레퍼런싱 환경은, ​
로컬 변수와 그 안에서 호출되어 실행 중인(active) 서브
 프로그램에 언급된(나타난) 변수를 합친 것이다. ​
실행중인 서브 프로그램의 어떤 변수는 레퍼런싱 환
경에서 hidden(숨겨질)일 수 있다. ​&lt;/p&gt;

&lt;p&gt;Hidden이란 active이지만, 나타나지 않는 것을 의미한다. ​
이와 같은 hidden 변수는, ​
동일한 이름의 변수가 여러 함수에서 선언된 상황에서,  ​
앞에서 선언된 같은 이름의 변수가 여전히 active하지만 ​
나중에 선언된 같은 이름의 변수가 나타날 때 발생한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl34.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;실제로 동적 스코프는 현대 프로그래밍 언어에서 일반적이지 않고, ​
C에서도 지원하지 않는다. ​
따라서, 위 그림은 C이지만, ​
동적 스코프를 지원한다고 가정하고 레퍼런싱 환경을 따져 보자. ​
호출되는 순서는 main -&amp;gt; sub2 -&amp;gt; sub1이다. ​
포인트1에서 나타날 수 있는 변수는 main의 d, sub2의 c, sub1의 a와 b, 이다. ​
여기서 main의 c, sub2의 c는 hidden이다. ​
포인트2에서 나타날 수 있는 변수는 main의 d, sub2의 b와 c이다. ​
여기서 main의 c는 hidden 이다. ​
포인트3에서 나타날 수 있는 변수는 main의 c와 d이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;지정 상수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이름 지정 상수는 상수인데, 변수명처럼 이름을 부여한 것을 말한다. 
이렇게 하는 이유는 읽기 쉽고, 수정하기 쉽도록 하기 위한 것이다. ​
스토리지에 바인딩될 때 값이 결정된다.&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">변수와 시맨틱스</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">정적 시맨틱과 동적 시맨틱</title>
      <link href="https://lee989898.github.io/pl-09" rel="alternate" type="text/html" title="정적 시맨틱과 동적 시맨틱" />
      <published>2021-09-23T19:18:00+09:00</published>
      <updated>2021-09-23T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-09</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-09">&lt;h3 id=&quot;정적-시맨틱과-동적-시맨틱&quot;&gt;&lt;strong&gt;정적 시맨틱과 동적 시맨틱&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;시맨틱에는 정적 시맨틱과 동적 시맨틱이 있다.&lt;br /&gt;
정적인 시맨틱은 컴파일 시에 확인할 수 있는 시맨틱 규칙을 말한다.&lt;br /&gt;
이들 시맨틱 규칙은 ​타입 검사, 프로그램에서 변수가 언급되기 전에 이에 대한 정의가 되어 있는지, ​서브 프로그램에서 어느 선언
 이 어느 변수에 적용되어야 하는지, ​서브 프로그램과 메소드가 호출될 때 호출 순서를 올
바르게 지키는지 등을 포함한다.  ​&lt;/p&gt;

&lt;p&gt;동적 시맨틱스는 프로그램이 실행될 때 ​프로그램 컨스트럭트가 
언제 어떤 행태(계산 결과)를 생성해야 하는지 정의하는 것이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;BNF로 시맨틱을 표현할 수 있을까?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;타입 호환성 규칙은 BNF로 서술할 수 있지만, ​
새로운 난터미널 심볼과 규칙을 추가로 요구하기 때문에, ​
문법이 너무 커지고 신택스 애널라이저(구문 해석기)가 비대해져 유용하지 않다. ​&lt;/p&gt;

&lt;p&gt;프로그래밍 언어에 공통적으로 적용되고 있는 ​
‘모든 변수는 언급되기(reference) 이전에 
선언(정의)되어야 한다’는 규칙은 BNF로 서술이 불가하다. ​&lt;/p&gt;

&lt;p&gt;이러한 종류의 규칙을 정적인(static) 시맨틱스라고 부른다.&lt;br /&gt;
정적인 시맨틱스는 프로그램 실행시 프로그램의 의미에 간접적으로
 관련이 있을 뿐이고, 오히려, 프로그램의 올바른 형태(신택
 스)와 직접 관련이 있다. ​&lt;/p&gt;

&lt;p&gt;따라서, 정적인 시맨틱스의 검사는 컴파일 시에 가능하다.&lt;br /&gt;
이 말은 정적인 시맨틱스는 컴파일러의 구현시 고려되어야 한다는 의미이다. ​&lt;/p&gt;

&lt;p&gt;그러면 정적인 시맨틱스를 어떻게 서술할 수 있을까? ​
바로 속성 문법(attribute grammar)으로 서술한다. ​
속성 문법은, ‘프로그래밍 언어가 만족해야 할’ 정적인 시맨틱 규칙을 
서술하고 검사하기 위해 사용되는 ​BNF와 유사한 형태의 문법이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;속성 문법이 단순한 assignment 문장의 타입 검사에 어떻게 사용 될까?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 assignment 문장의 신택스와 정적 시맨틱스는 다음과 같다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;변수명은 A, B, C 뿐이다.​&lt;/li&gt;
  &lt;li&gt;Assignment의 우변은 변수거나 ‘변수 + 변수’의 표현식이다. ​&lt;/li&gt;
  &lt;li&gt;변수의 타입은 int거나 real이다.​&lt;/li&gt;
  &lt;li&gt;우변에 변수 2개가 있을 때, 이들의 타입은 같을 필요가 없다. ​&lt;/li&gt;
  &lt;li&gt;두 오퍼랜드가 같은 타입이 아닐 때 표현식의 타입은 real이다.&lt;br /&gt;
(여기서 표현식의 타입이란 표현식을 계산한 결과값의 타입을 말한다.) ​&lt;/li&gt;
  &lt;li&gt;이들의 타입이 같을 때, 표현식의 타입은 오퍼랜드의 타입과 같다. ​&lt;/li&gt;
  &lt;li&gt;좌변의 타입은 우변의 타입과 같아야 한다. ​&lt;/li&gt;
  &lt;li&gt;그래서, 우변의 오퍼랜드의 타입이 mix될 수 있으나, 우변의 계산 결과값과 좌변의 타겟이 같을 때만 assignment는 타당하다.  ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;속성 문법은 위와 같은 정적 시맨틱 규칙을 명세한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl21.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;간단한 assignment를 속성문법으로 서술하면 위 그림과 같다. ​&lt;/p&gt;

&lt;p&gt;속성 문법에는 신택스 규칙과 함께 데이터 타입에 관한 시맨틱 
규칙, 그리고 판단식이 서술되어 있다.&lt;br /&gt;
룩업 함수는 심볼 테이블에서 변수명을 찾아서 변수의 타입을 반환한다.&lt;br /&gt;
심볼 테이블은 컴파일러가 구문 분석 단계에서 ​
변수에 대한 이름, 타입 등을 저장하기 위해 생성한 ​
테이블 구조를 말한다. ​&lt;/p&gt;

&lt;p&gt;실제 타입은 var, expr의 실제 타입을 말한다.&lt;br /&gt;
실제 타입은 선언되어 있거나 변수명으로부터 유추 가능하다.&lt;br /&gt;
예를 들어, Perl에서 $, @, %는 ​
각각 스칼라(스티링, 숫자), 벡터(배열), 해쉬 구조를 나타낸다.&lt;br /&gt;
이로부터 변수의 타입을 유추할 수 있다. ​&lt;/p&gt;

&lt;p&gt;예상 타입은 expr와 관련된 속성으로부터 상속된 타입으로 ​
좌변의 변수의 실제 타입에 의해 결정된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl22.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;왼쪽 그림은 속성의 흐름, ​
즉 속성이 파스 트리를 따라
 상속(pass up, pass down)되는 흐름을 나타내고 있고, ​&lt;/p&gt;

&lt;p&gt;오른쪽 그림은 속성 문법에 의한 ​
attributed parse tree(속성이 부여된 파스 트리)를 보여준다.  ​&lt;/p&gt;

&lt;p&gt;이와 같이 부여된 속성에 근거하여, 컴파일러는 타입 검사를 할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;동적 시맨틱스를 서술하는 방법은 여러 가지가 있으나, operational semantics에 대해 살펴 보기로 한다. ​&lt;/p&gt;

&lt;p&gt;Operational semantics는 연산의 의미에 의해 
표현식, 문장, 단위 프로그램의 의미를 서술하는 방식이다. ​&lt;/p&gt;

&lt;p&gt;시맨틱스 서술의 중요성을 각 사용자별로 따져 보면 다음과 같다.  ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로그래머는 원하는 프로그램을 짜기 위해 프로그
래밍 언어의 각 문장이 무엇을 하는지 알 필요가 있다. ​&lt;/li&gt;
  &lt;li&gt;컴파일러 개발자는 프로그래밍 언어
에서 각 컨스트럭트의 의미를 정확히 알아야 한다. ​&lt;/li&gt;
  &lt;li&gt;프로그래밍 언어 설계자는 설계 상의 모호성과 불일치를 발견할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Operational semantics는 문장이나 단위 프로그램
을 컴퓨터에서 실행한 효과를 명세하여, ​
문장이나 프로그램의 의미를 서술한다. ​&lt;/p&gt;

&lt;p&gt;Operational semantics는 머신 상태의 일련의 변화로 볼 수 있다.&lt;br /&gt;
여기서 머신의 상태란 프로그램 수행에 따라 변화하는 각 변수 값의 콜
렉션(집합)이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl23.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위의 그림과 같이, operational semantics는 ​
문장에 대한 의미를 intermediate code처럼 정해진 
방식으로 서술한 것으로 볼 수 있다.&lt;br /&gt;
Intermediate 언어는 가상 머신에서 실
행되는 언어 또는 어셈블리 언어를 말한다.&lt;/p&gt;

&lt;p&gt;Operational semantics 서술을 위해 intermediate 언어와 가상 머신을 사용하기도 한다. ​​&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">정적 시맨틱과 동적 시맨틱</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">신택스 분석방법</title>
      <link href="https://lee989898.github.io/pl-10" rel="alternate" type="text/html" title="신택스 분석방법" />
      <published>2021-09-23T19:18:00+09:00</published>
      <updated>2021-09-23T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-10</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-10">&lt;h3 id=&quot;신택스-분석-방법&quot;&gt;&lt;strong&gt;신택스 분석 방법&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;프로그램이 문법에 적합한지 확인하기 위한 신택스 분석 방법에
대해 알아보자.​&lt;/p&gt;

&lt;p&gt;신택스 분석의 목표는 파스 트리(parse tree)를 생성하는 것이다.&lt;br /&gt;
신택스 분석은 프로그램의 각 문장을 토큰으로 쪼개는 일부터 시작한다.&lt;br /&gt;
이렇게 쪼개는 것을 렉시칼 어낼리시스라고 하고, ​
이것을 수행하는 프로그램을 렉시칼 애널라이저 또는 스캐너라고 한다. ​&lt;/p&gt;

&lt;p&gt;이렇게 쪼갠 후에 문법적으로 타당한지 확인하는데, ​
이것을 신택스 어낼리시스라고 하고, ​
이와 같은 일을 수행하는 프로그램을 신택스 애널라이저 또는 파서라고 한다.&lt;/p&gt;

&lt;p&gt;다시 말하지만 렉시칼 어낼리시스와 신택스 어낼리시스
의 궁극적인 목표는 파스 트리를 생성하는 것이다. ​&lt;/p&gt;

&lt;p&gt;파스 트리로부터 중간 코드가 생성되고, 최적화
되어, 최종적으로 코드 생성이 이루어지기 때문에  ​
파스 트리의 생성이 PL 구현 시스템에서 가장 중요한 부분이다. ​&lt;/p&gt;

&lt;p&gt;파스 트리의 생성은 문법에 의존한다.&lt;br /&gt;
즉, 문법에 적합한 프로그램만 파스 트리로 생성된다. 
​
문법은 신택스와 시맨틱스를 표현한 규칙의 집합으로, 프로그램이 PL의 문법에 적합한지 판단하는 기준이 된다. ​&lt;/p&gt;

&lt;p&gt;문장 A=B&lt;em&gt;(A+C)에 대해, 문법(규칙 집합)에 따라 
Leftmost derivation을 하려면, ​
문장 A=B&lt;/em&gt;(A+C)가 문법의 규칙 중에서 어느 규칙에 해당되고, ​
이 문장을 구성하는 A, =, B, (, A, +, C, )가 어
느 규칙의 어느 심볼에 해당되는지 알 수 있어야 한다.
이것을 신택스 어낼리시스라고 한다.&lt;br /&gt;
이를 위해 A=B*(A+C) 문장을 A, =, B, (, A, +, C, )로 잘라내고, ​
이들이 각각 문법이 허용하는 문장 요소 중의 무엇을 나타내는지(연산자, 
변수명, assignment 기호 등) 구별해야 하는데, ​
이것을 렉시칼 어낼리시스라고 한다.&lt;br /&gt;
잘라낸 A, =, B, (, A, +, ) 각각을 토큰이라고 한다.&lt;/p&gt;

&lt;p&gt;언어의 구현은 컴파일러, 인터프리터, 하이브리드 방식, 세가지 중의 하나이다. ​&lt;/p&gt;

&lt;p&gt;이들 모두 lexical analysis와 syntax analysis를 거친다.&lt;br /&gt;
렉시칼 애널라이저는 스캐너라고도 하는데, 소스 프로그램을 인풋으로 받아 토큰으로 잘라낸다.&lt;/p&gt;

&lt;p&gt;신택스 애널라이저는 파서라고도 하는데, 토큰을 인풋
으로 받아 문법에 따라 파스 트리를 만든다.​&lt;/p&gt;

&lt;p&gt;렉시칼 애널라이저는 신택스 애널라이저의 일부분으로 구현된다. ​&lt;/p&gt;

&lt;p&gt;이러한 이유로 모든 토큰을 한꺼번에 생성하지 않고 필요할 
때마다 토큰을 생성하기도 한다.&lt;br /&gt;
토큰 중에는 변수에 대한 변수명, 타입 등의 속성이 있는데, 이들은 심볼 테이블 안에 저장된다.&lt;br /&gt;
이들 정보는 신택스 어낼리시스 동안에 lookup되기도 하고 새로운 속성이 매핑되기도 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lexical analysis&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;렉시칼 애널라이저는 문장에서 각 단어를 추출하고 이들
이 어느 범주(문장에서 허용되는 개념의 범주)에 해당되는지
구별하는 것이다.&lt;br /&gt;
추출된 단어에 대해 범주를 매핑시킨 것을 토큰이라고 한다. ​&lt;/p&gt;

&lt;p&gt;교과서에서는 일반적인 표현보다는 이들 요소를 구분하여 각각 lexe
me, token이라고 하는데, ​
일반적인 표현을 쓰면, 이들은 각각 word, cate
gory이며, 이들을 합친 것을 토큰이라고 한다. ​&lt;/p&gt;

&lt;p&gt;렉시칼 애널라이저는 이와 같은 토큰을 식별하는 패턴 매처로서, ​
주어진 스트링에서, 주어진 패턴에 매치되는 서브스트링을 찾는다. ​&lt;/p&gt;

&lt;p&gt;이 설명은 매우 정확하지만 매우 까다로와서 렉시칼 애널라이저를
 잘못 이해할 수도 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl24.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;소스 프로그램을 위와 같이 1차원 배열로 표현되어 있다고 치자. ​
주어진 스트링에 해당한다. ​&lt;/p&gt;

&lt;p&gt;‘주어진 패턴’이란 identifier, reserved word 등에 해당되는 스트링을 의미한다. ​&lt;/p&gt;

&lt;p&gt;Identifier, reserved word 등은 오른쪽 
아래의 상태 전이 다이어그램으로 정의된다. ​&lt;/p&gt;

&lt;p&gt;렉시칼 어낼리시스가 어떻게 진행되는지 설명하기 전에 ​
먼저 상태 전이 다이어그램에 대해 알아 보자.&lt;/p&gt;

&lt;p&gt;렉시칼 애널라이저를 구현하려면, 상태 전
이 다이어그램을 그리는 것부터 시작한다. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl25.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위의 그림은 상태전이 다이어그램을 나타내고 있다.&lt;br /&gt;
상태전이 다이어그램은 directed graph로, ​노드는 상태를 나타내며 상태명으로 레이블이 붙어 있다.&lt;br /&gt;
아크는 상태 전이를 나타내며, 인풋 문자로 레이블이 붙어 있다.&lt;br /&gt;
아크의 레이블은 상태 전이를 발생시키는 인풋 문자로서, ​
아크의 이전 상태에서 해당 인풋 글자가 들어오면 아
크의 다음 상태로 전이한다는 의미이다.&lt;br /&gt;
아크는 전이가 일어날 때 수행되어야 할 액션을 포함하기도 한다.&lt;br /&gt;
그림에서 아크의 위에 있는 Letter, Digit 등은 상태 전이
를 일으키는 문자를 나타내고, ​
아래쪽의 addChar, getChar 등은 액션을 나타낸다.  ​&lt;/p&gt;

&lt;p&gt;상태 다이어그램을 단순화하기 위해, reserved wor
d나 identifier을 별도로 인식하기보다 함께 인식할 수 있다.&lt;br /&gt;
그림에서 두겹의 타원은 identifier와 integer를 인식하기 위한 상태이다. ​&lt;/p&gt;

&lt;p&gt;identifie가 변수명으로서의 identifi
er인지 reserved word인지 구별하기 위해 ​
심볼 테이블 lookup을 통해 결정한다.&lt;/p&gt;

&lt;p&gt;상태 전이 다이어그램을 규칙으로 표
현할 수도 있는데 이것을 regular grammar라고 한다.&lt;/p&gt;

&lt;p&gt;그렇다면 ‘주어진 패턴’이란 상태 전이 다이어그램으로 정의되는 것이다.
​
그러니까 렉시칼 애널라이저는 input file을 하나의 긴 스트링
으로 간주하고, ​한글자씩 읽어 들여 상태 전이 다이어그램을 따라 가면서, ​
reserved word, identifier 등의 토큰을 긴 스트링 중의 서
브 스트링으로서 인식하는 것이다.&lt;/p&gt;

&lt;p&gt;위 그리에서 Input file을 읽어 들여 코멘트를 무시하고, 
렉시칼 어낼리시스를 하면, ​오른쪽의 토큰들을 얻게 된다.&lt;/p&gt;

&lt;p&gt;정리하면, 주어진 스트링에서, 주어진 패턴에 매치되
는 서브스트링을 찾는 역할을 하는 것이 ​
바로 상태 전이 다이어그램이고, ​
이것을 프로그래밍하면 렉시칼 애널라이저가 된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl26.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;A=B*(A+C)와 같은 간단한 산술식에서 토큰을 추출하는 렉시칼 
애널라이저를 구현하기 위해, ​
먼저 상태 전이 다이어그램을 그리면 위 그림과 같다. ​
unknown은 identifier와 integer 이외의 것을 인식하는데, ​
이들은 주로 산술식을 구성하는 연산자나 괄호 등에 해당된다.​&lt;/p&gt;

&lt;p&gt;이들은 하나의 문자로 구성되어 있기 때문에 싱글 캐릭터 토큰이라고 하는데, ​
이들이 산술식의 연산자나 괄호인지 아닌지 결정하기 위해 심볼 
테이블을 lookup한다.&lt;/p&gt;

&lt;p&gt;아크 아래의 액션을 나타내는 함수의 역할에 대해 알아 보자.&lt;br /&gt;
getChar는 인풋 스트링에서 다음 글자를 가져와서 변수 nextChar에 넣고 ​
그 유형을 판단해서 변수 charClass에 그 유형을 넣는다. ​&lt;/p&gt;

&lt;p&gt;addChar는 nextChar의 글자를 배열 lexeme에 넣는다. ​&lt;/p&gt;

&lt;p&gt;Lookup은 배열 lexeme에 있는 스트링이 reserved word인지 아닌
지 결정한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Syntax Analysis&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;우선 신택스 어낼리시스 즉, 파싱이 뭔지, 파서가 뭘하는지 알아보자.&lt;/p&gt;

&lt;p&gt;파서는 주어진 프로그램에 대해 파스 트리를 생성한다. ​&lt;/p&gt;

&lt;p&gt;파스 트리는 명시적으로 생성되기도 하지만 ​
트리 순회(traversal) 흔적이 생성되기도 한다.&lt;br /&gt;
(이러한 트리 순회 흔적을 유래(파생, derivation)이라고 합니다.) ​&lt;/p&gt;

&lt;p&gt;파스 트리와 유래 모두 컴파일러나 인터프리터가 필
요로 하는 모든 신택스(구문 구조적) 정보를 포함한다. ​&lt;/p&gt;

&lt;p&gt;신택스 어낼리시스의 목표는 인풋 프로그램이 문법적으로 올바른지 검사하고, ​
문법적으로 올바른 인풋에 대한 파스 트리를 생성한다. ​&lt;/p&gt;

&lt;p&gt;도중에 오류가 발견되면 오류 진단 메시지를 생성하고, ​
인풋 프로그램의 신택스 어낼리시스를 계속한다. ​&lt;/p&gt;

&lt;p&gt;물론 신택스 어낼리시스 도중에 오류가 발생하면, ​
신택스 어낼리시스만 계속하면서 문법적으로 잘못된 부분을 식별할 뿐이지, ​
파스 트리를 생성하지는 않는다.&lt;/p&gt;

&lt;p&gt;파싱 방법은 하향식(탑다운)과 상향식(바텀업) 방식이 있다. ​&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Top -down parsing&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;탑다운 파싱은 start 심볼에서 시작하여, 인풋 스트링을 derivation에 어느 BNF 규칙을 적용하는 게 좋을지 따져 보고 ​
규칙을 선택하여 derivation한다.&lt;/p&gt;

&lt;p&gt;이러한 derivation을 트리로 간주하면, 위에서 아래로 내려오면서 ​
반복적으로 규칙을 선택하고 적용하여 ​궁극적으로 인풋 스트링(프로그램)이 생성될 때까지 계속한다. ​&lt;/p&gt;

&lt;p&gt;그래서 이것을 recursive-descent parser(반복적 하강
식 파서)라고 한다. ​&lt;/p&gt;

&lt;p&gt;이와 같은 방식의 파싱 알고리즘을 LL 알고리즘이라고 하는데, ​
인풋을 왼쪽에서 오른쪽으로 스캔하고, ​
Leftmost derivation을 생성한다. ​&lt;/p&gt;

&lt;p&gt;Leftmost derivation이란 sentential form
(문형식)의 가장 왼쪽에 있는 난터미날에 대해, ​
그 난터미날을 LHS로 갖고 있는 규칙을 선정하여, ​
그 규칙의 RHS로 바꾸는 것을 의미한다. ​&lt;/p&gt;

&lt;p&gt;LL의 앞에 있는 L은 ‘왼쪽에서 오른쪽으로’를 나타내고,  ​
뒤의 L은 ‘leftmost derivation’을 나타낸다.&lt;/p&gt;

&lt;p&gt;탑다운 파서의 파싱 결정 문제 ​
Preorder에 의해 파스 트리를 생성한다.&lt;br /&gt;
Preorder 순회는 root, left, right 순서로 트리를 방문한다.
​
좌선 유도 중인 문형식이 주어졌을 때, 파서는 ​
주어진 문형식에서 가장 왼쪽의 난터미날 심볼에 대해, ​
그 난터미날 심볼을 LHS로 갖고 있는 규칙을 찾아서, ​
그 규칙의 오른쪽 부분으로 문형식의 난 터미날 심볼을 교체한다.(이것을 expand라고 함)&lt;br /&gt;
이렇게 하여, 좌선 유도에 의한 다음 문형식을 생성한다.
​
문형식에서 xAa에서, x는 터미날 심볼로 구성된 스트링을, ​
A는 난터미날 심볼을, a는 터미날과 난터미날 심볼의 혼합 스트링을 나타낸다.&lt;br /&gt;
Expand할 때는 적용할 규칙을 선택하여 ​주어진 스트링의 난터미날 심볼을 규칙의 오른쪽으로 교체하여 확장한다.​&lt;/p&gt;

&lt;p&gt;예를 들어 보자. ​
현재 문형식이 xAa이고, ​
A에 적용 가능한 규칙이 A→bB | cBb | a 라고 하면, ​
탑다운 파서는 어느 규칙을 선택하느냐에 따라, ​
다음 문형식으로 xbBa, xcBba, or xaa 중의 하나를 생성한다.&lt;br /&gt;
이것이 바로 탑다운 파서의 파싱 결정 문제이며, ​백트래킹 비용을 수반한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Bottom-up parsing&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;바텀업 파싱은 인풋 스트링을 스캐닝하면서, ​
규칙의 RHS에 해당되는 스트링이 발견되면, ​
이 스트링을 발견된 규칙의 왼쪽 스트링으로 바꾼다. ​&lt;/p&gt;

&lt;p&gt;이러한 과정을 반복해서 인풋 스트링이 ​
궁극적으로 starting 심볼로 바뀌면 파싱이 끝나는 것이다. ​&lt;/p&gt;

&lt;p&gt;이렇게 하려면 탑다운 방식과 달리 스택이라는 자료 구조를
 필요로 하는데, ​
스택에 넣고 빼고 하는 과정을 포함하기 때문에 이것을 shif
t-reduce 파서라고 한다. ​&lt;/p&gt;

&lt;p&gt;Shift는 스택에 심볼을 넣는 것, reduce는
 스택의 서브 스트링을 규칙의 LHS로 바꾸는 것을 말한다. ​  ​&lt;/p&gt;

&lt;p&gt;이러한 알고리즘을 LR 알고리즘이라고 하는데, ​
L은 왼쪽에서 오른쪽으로 인풋을 스캐닝하고, ​
R은 rightmost derivation을 생성한다는 것을 나타낸다.&lt;/p&gt;

&lt;p&gt;바텀업 파싱의 기본 아이디어는 ​
주어진 스트링을 처리할 때, 규칙의 RHS에 해당되는 서브 스트링을 찾아서, ​
그 서브스트링을 규칙의 LHS로 교체하는 과정을,  ​
주어진 스트링이 start 심볼이 될 때까지 반복하는 것이다. ​&lt;/p&gt;

&lt;p&gt;바텀업 파싱의 기술적인 이슈는 ​
어느 규칙을 적용해서 어느 서브스트링을 교체할 것인지, ​
미리 따져보는 것이다.&lt;/p&gt;

&lt;p&gt;쉬프트-리듀스 파싱은 바텀업 파싱의 일종이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl27.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;예를 보면서, 바텀업 파싱을 알아 보자.&lt;br /&gt;
문법과 인풋 스트링이 이와 같을 때, ​
인풋 스트링의 왼쪽에서부터 시작해서, ​
서브스트링에 적용할 수 있는 규칙을 찾아 본다.&lt;br /&gt;
RHS에 b가 있는 규칙 A → b를 적용할 수 있다. ​
빨간색 b에 A-&amp;gt;b를 적용하면,  ​
빨간색 b가 규칙 A-&amp;gt;b의 LHS인 A로 교체되어 ​
aAbcde가 된다.&lt;/p&gt;

&lt;p&gt;다음, 빨간색 Abc가 A-&amp;gt;Abc에 의해 A로 교체되어 ​
aAde가 되고, ​
빨간색 d가 B-&amp;gt;d에 의해, A로 교체되어 ​
aABe가 된다.&lt;/p&gt;

&lt;p&gt;빨간색 aABe가 S-&amp;gt;aABe에 의해 start 심볼 S로 교체되어 ​
파싱이 종료된다.&lt;/p&gt;

&lt;p&gt;위의 그림을 잘 살펴보면, reduce의 의미와 derivar
ion의 의미가 반대임을 알 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;바텀업 파싱은 규칙이 허용하는 바에 따라 인풋 스트링의 서브스트링을 ​
LHS의 난터미날 심볼로 교체한다. ​
이러한 교체는 인풋 스트링이 S로 교체될 때까지 계속된다. ​
여기서 교체되는 서브스트링은 ​
처음에는 터미날 심볼로 구성되지만, ​
점차 터미날 심볼로 구성된 서브스트링이 난터미날로 교체되면서, ​
터미날 심볼과 난터미날 심볼로 구성된다.  ​
LHS로 교체하는 과정을 보면, ​
인풋 스트링의 길이가 점점 줄어들고 있
음(즉, reduce되고 있음)을 볼 수 있다.  ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;탑다운 파싱과 비교를 해 보면, ​
탑다운 파싱은 S에서 인풋 스트링이 생성될 때까지 규칙을 적용해서 ​
가장 왼쪽의(leftmost) 난터미날 심볼을 RHS로 expand한다. ​
이것을 좌선 유도(leftmost derivation)이라고 하는데… ​
위의 파싱 과정을 거꾸로 살펴 보면, ​
가장 오른쪽의 난터미날이 먼저 RHS로 expand됨을 볼 수 있다. ​
즉, 우선 유도(rightmost derivation)가 되고 있는 것이다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;따라서, 탑다운과 바텀업 파싱의 과정을 보면 서로 반대임을 알 수 있다. ​
즉, 바텀업 파싱은 탑다운 우선 유도의 역순과 같다.   ​&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;바텀업 파싱에서는 어느 서브 스트링에 어떤 규칙을 적용하느냐가 중요하다.&lt;br /&gt;
앞의 예에서 abbcde(b에 A-&amp;gt;b를 적용) =&amp;gt; aAbcde(d에 B-&amp;gt;d를 적용) =&amp;gt; a
AbcBe이 생성되면, ​&lt;/p&gt;

&lt;p&gt;이후 어떠한 규칙을 적용해도 S로 리듀스되지 않는다.&lt;br /&gt;
규칙의 LHS로 교체할 수 있는 ‘인풋 스트링 S의 서브스트링 a’를 핸들이라고 한다. ​&lt;/p&gt;

&lt;p&gt;a가 A → a의 RHS에 매치되면, ​
a를 A(규칙의 LHS)로 교체한다.&lt;br /&gt;
이때 이러한 교체 과정은 탑다운 
방식의 우선 유도(rightmost derivation)의 역순으로 나타난다.   ​&lt;/p&gt;

&lt;p&gt;쉬프트-리듀스 파싱에서 리듀스 연산은 핸들에만 적용 가능하다.&lt;/p&gt;

&lt;p&gt;쉬프트-리듀스 파싱의 구현 방법에 대해 알아 보자.&lt;br /&gt;
바텀업 파싱은 쉬프트와 리듀스라는 두개의 액션으로 설명되기 때문에, ​
쉬프트-리듀스 파싱으로 불리며, ​
이를 위한 자료구조로 스택을 사용한다.  ​​&lt;/p&gt;

&lt;p&gt;쉬프트 액션은 다음 인풋 토큰을 스택의 꼭대기에 옮겨 넣는 것을 의미하며, ​
리듀스 액션은 스택의 꼭대기에 있는 핸들(규칙의 RHS)를 규칙의 LHS로 교체
하는 것을 의미한다. ​&lt;/p&gt;

&lt;p&gt;이 과정을 start 심볼로 리듀스 될 때까지 반복한다.&lt;br /&gt;
쉬프트할 때 스택을 사용하면, ​
현재 처리 중인 스트링에서 리듀스 가능한 서브스트
링(핸들)을 찾기 쉬운 경향이 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl28.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 쉬프트-리듀스의 예이다.&lt;/p&gt;

&lt;p&gt;쉬프트와 리듀스 둘다 가능할 때, 쉬프트-리듀스 컨플릭트가 발생한다. ​
스택에 핸들 if E then S가 있을 때, 문법에 의하면 
쉬프트, 리듀스 모두 가능하다. ​&lt;/p&gt;

&lt;p&gt;그러나, 이것은 그 다음에 나오는 심볼이 무엇이냐에 달려 있다. ​
다음에 else가 나온다면 리듀스하면 안되고 쉬프트해야 한다.  ​
반대로 else가 나오지 않는다면 리듀스해도 된다.  ​&lt;/p&gt;

&lt;p&gt;리듀스에 적용할 규칙이 여럿일 때, 리듀스-리듀스 컨플릭트 발생한다.&lt;br /&gt;
스택에 핸들 id(arg)가 있을 때, Stmt로 리듀스할지, Expr로 리듀스할지?  ​
이것 역시 다음에 나오는 심볼에 달려 있다.&lt;/p&gt;

&lt;p&gt;앞에 언급한 문제를 해결하려면, ​
인풋 스트링에서 현재 심볼의 다음에 오는 k개의 심볼을 먼저 본다면 ​
현재 어느 규칙을 써서 무엇을 할지 쉽게 결정할 수 있을 것이다
이것을 LR(k) 파서라고 하고, 여기서 k는 lookahead라고 한다.​&lt;/p&gt;

&lt;p&gt;장점은 일반적인 방법이면서 많은 유형의 문법을 다룰 수 있고, 효율적이라는 것이다
단점은 구현하기 어렵다는 것이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;컴파일러가 각 단게별로 소모하는 처리 비용을 시간의 비율로 나타내
면 다음과 같다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;~ 35-40% of time spent in I/O​&lt;/li&gt;
  &lt;li&gt;~ 30% in lexical analysis​&lt;/li&gt;
  &lt;li&gt;~ 10% in symbol table management​&lt;/li&gt;
  &lt;li&gt;~ 7-15% in parsing and other control​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;가장 많은 비용을 소모하는 것이 바로 IO이다
렉시칼 애널라이저가 그 만큼의 시간을 소모하고, ​
정착 알고리듬 측면에서 가장 복잡한 파싱이 비용소모가 적다. ​&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">신택스 분석 방법</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">프로그래밍 언어의 신택스와 시맨틱스</title>
      <link href="https://lee989898.github.io/pl-08" rel="alternate" type="text/html" title="프로그래밍 언어의 신택스와 시맨틱스" />
      <published>2021-09-16T19:18:00+09:00</published>
      <updated>2021-09-16T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-08</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-08">&lt;h3 id=&quot;프로그래밍-언어의-신택스와-시맨틱스&quot;&gt;&lt;strong&gt;프로그래밍 언어의 신택스와 시맨틱스&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;프로그래밍 언어의 신택스는 산술식, 문, 프로그램 단위의 형태를 말한다.&lt;br /&gt;
문은 statement 또는 sentence를 말한다.   ​&lt;/p&gt;

&lt;p&gt;프로그램 단위는 컨스트럭트(컨트롤 스트럭처)를 말하는데, ​
앞으로 명확한 설명을 위해 프로그램 단위라는 추상적인 말을 쓰지 않고, ​
가급적 컨스트럭스 또는 컨트롤 스트럭처라는 말을 쓰겠다. ​&lt;/p&gt;

&lt;p&gt;시맨틱스는 신택스에 맞게 작성된 표현식, 문, 컨스트럭트의 의미를 말합니다. ​&lt;/p&gt;

&lt;p&gt;자바 while 문에 대해, ​
신택스는 while (Boolean_expr) statement 의 형태를 띄어야 하고, ​
그 시맨틱스는 부울 표현식이 참일 때, statement를 실행하고, ​
컨트롤은 부울 표현식으로 되돌아가서 이 프로세스를 반복하는데, ​
부울 표현식이 거짓이면 ​
while 컨스트럭트의 실행이 끝난다는 의미이다.​&lt;/p&gt;

&lt;p&gt;시맨틱스의 서술 방법은 여러 가지가 있지만, ​
컴퓨터에서 실행되는 ‘연산의 의미’로 시맨틱스를 서술하는 것을 ​
operational semantics라고 하는데, ​
위에 서술된 while문의 시맨틱스는 operational semantics의 예이다.
​
잘 설계된 프로그래밍 언어에서, 시맨틱스는 신택스를 따릅니다. ​
이것은 위에 설명된 자바 while 문의 신택스와 시맨틱스의 예를 
보면 직관적으로 알 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;그럼 신택스를 어떻게 서술하는지 살펴 보자.&lt;/p&gt;

&lt;p&gt;신택스 서술 방법으로 BNF가 널리 사용되고 있다.&lt;br /&gt;
BNF를 메타 언어라고 하는데, 메타 언어란 언어를 
서술하는데 사용되는 언어라는 뜻이다.&lt;/p&gt;

&lt;p&gt;즉, BNF는 프로그래밍 언어의 신택스를 서술하는데 사용되는 메타 언어이다.&lt;br /&gt;
BNF는 신택스 구조를 위한 추상적 개념을 사용하는 규칙 언어이다.&lt;br /&gt;
규칙은 화살표 왼편(LHS)과 오른편(RHS)으로 나누어지는데, ​
문을 생성하면서, 왼편이 오른편으로 대체된다.&lt;/p&gt;

&lt;p&gt;BNF가 사용하는 추상적 개념들에는 무엇이 있는지 ​
자바의 예를 보면서 알아 보자&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl12.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;자바의 assign과 if 문은 다음과 같이 서술된다.​&lt;/p&gt;

&lt;p&gt;assign, var, expression, 화살표(-&amp;gt;), =(이퀄 사인)​
if_stmt, logic_expr, stmt, if, (괄호), |(세로줄, 
or의 뜻) 등을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;화살표를 제외하고, 이들은 각각 BNF를 구성하는 non-terminal/terminal 심볼이다.&lt;br /&gt;
꺽쇠 괄호로 싸여 있는 것이 non-terminal이다.&lt;/p&gt;

&lt;p&gt;하나의 왼편에 대해 여러 개의 규칙을 가질 수 있는데, ​
이때 여러 개의 규칙에 대해 |를 사용하여 각각의 오른편을 구분합니다. ​&lt;/p&gt;

&lt;p&gt;List를 보면, &lt;ident_list&gt;의 오른편에 두개의 규칙이 있음을 알 수 있는데, ​
두번째 규칙은 &lt;ident_list&gt;가 identifier와 &lt;ident_list&gt;로 대체하는 것
입이다. ​&lt;/ident_list&gt;&lt;/ident_list&gt;&lt;/ident_list&gt;&lt;/p&gt;

&lt;p&gt;이 규칙의 오른편을 보면, &lt;ident_list&gt;가 또 들어 있는데,  ​
이러한 규칙을 recursive rule(순환 규칙)이라고 한다.&lt;/ident_list&gt;&lt;/p&gt;

&lt;p&gt;문법은 언어를 정의하기 위한 생성 장치이다.&lt;br /&gt;
문은 문법에 있는 일련의 규칙 적용을 통해 생성되며, ​이러한 일련의 규칙 적용을 유도(derivation)이라고 한다.&lt;br /&gt;
유도에 의해 생성된 결과를 문형식(sentential form)이라고 한다. ​&lt;/p&gt;

&lt;p&gt;문형식(sentential form)에서,  ​
가장 왼쪽의 난터미날을 먼저 대체하는 것을 좌
선유도(leftmost derivation)이라고 하고, ​
그 반대를 우선유도(rightmost derivation)이라고 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl13.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 사례는 덧셈과 뺄셈으로 구성된 산술식을 서술하기 위한 문법과 ​
그 문법에 의한 산술식의 유도(derivation) 과정을 보여주고 있다.&lt;/p&gt;

&lt;p&gt;오른쪽에 나열된 일련의 문형식(sentential form)들은 ​
program이라는 난터미날 심볼에서 시작하여, ​
왼쪽의 문법을 적용하여 좌선유도(Leftmost derivation)된 결과이다.  ​
=&amp;gt;의 오른쪽에 있는 begin stmt_list end, ​
begin stmt ; stmt_list end, 등은 모두 문형식의 예들이다.&lt;br /&gt;
마지막에 있는 begin A = B + C ; B = C end 은 문(sentence)이다.&lt;br /&gt;
그러니까 문과 문형식의 차이는 난터미날 심볼의 유무에 달려 있다. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl14.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 사례는 Assignment 문을 위한 문법과 ​
그 문법에 의한 assignment 문의 유도를 보여주고 있다. ​&lt;/p&gt;

&lt;p&gt;왼쪽 아래는 난터미날 심볼 &lt;assign&gt;에서 시작하여 leftmost
derivation을 보여주고 있고,  ​&lt;/assign&gt;&lt;/p&gt;

&lt;p&gt;이것을 트리로 나타내 보면 오른쪽 그림과 같다. ​
이 트리를 파스(parse) 트리라고 한다. ​&lt;/p&gt;

&lt;p&gt;당연한 말이지만 leftmost derivation을 하면, ​
파스 트리의 가장 왼쪽 노드부터 터미날 심볼로 바뀌
는 것을 볼 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl15.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;이 문법을 가지고 expr에서 시작해서 산술식을 유도할 때, ​
+이 포함된 RHS를 먼저 적용하느냐, &lt;em&gt;이 포함된 RHS를 먼저 적용하느냐에 따라, ​
A=B+C&lt;/em&gt;A를 위한 파스 트리가 두개 생성된다. ​&lt;/p&gt;

&lt;p&gt;이와 같이, 문형식에 문법을 적용할 때, ​
동일한 문형식에 대해 파스 트리가 여러 개 생성되면, ​
이 문법을 모호한 문법이라고 한다. ​&lt;/p&gt;

&lt;p&gt;문법의 모호성은 중대한 문제를 야기한다.&lt;br /&gt;
일반적으로 preorder에 따라 산술식을 계산하는데, ​
이들 트리는 실행 결과가 서로 다르다. ​&lt;/p&gt;

&lt;p&gt;왜냐하면, 왼쪽의 트리는 덧셈이 먼저, 오른쪽의 트리는 곱셈이 
먼저 계산되기 때문이다.&lt;br /&gt;
즉, 동일한 문에 대해 어떤 규칙을 먼저 적
용하였느냐에 따라 파스 트리가 다르고, ​
그 트리의 실행 결과가 항상 같지 않다는 것이다.&lt;br /&gt;
이러한 이유로 문법의 모호성은 제거되어야 한다.&lt;/p&gt;

&lt;p&gt;문의 실행 결과가 항상 같지 않을 수 있기 때문에 모호성은 제거되어야 함을 알게 되었다. ​&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이러한 모호성을 어떻게 제거할 수 있을까?  ​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;연산자에 대한 우선순위를 둔다.
즉, 파스 트리의 가장 아래에 있는 연산자부터 먼저 실행한다.&lt;br /&gt;
따라서, 아래에 있는 연산자가 위의 연산자보다 우선 순위가 높다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;우선순위에 따라 연산자 출현 순서를 지정한다.&lt;br /&gt;
이와 같은 출현 순서의 지정은 별도의 난터미널 심볼을 사용하여 명세할 수 있다.&lt;br /&gt;
난터미널 심볼은 우선순위가 다른 연산자의 오퍼랜드를 표현하기 위해 사용한다. ​&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;모호성 제거 방법을 종합하면, 문법을 서술할 때,  ​
파스 트리에서 낮은 우선순위의 연산자가 ​
높은 우선순위의 연산자보다 위에 나타날 수 있도록, ​
낮은 우선순위의 오른쪽 오퍼랜드를 ​
새로운 난터미널 심볼로 대체한다.  ​&lt;/p&gt;

&lt;p&gt;예를 들어 살펴 보자.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl16.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;+는 *에 비해 트리의 아래에 위치해야 한다.&lt;br /&gt;
따라서, &lt;expr&gt; -&amp;gt; &lt;expr&gt; + &lt;expr&gt;의 RHS에서 ​오른쪽 오퍼랜드 &lt;expr&gt;를 &lt;term&gt;으로 대체한다.  
그러면 이제 &lt;expr&gt; -&amp;gt; &lt;expr&gt; * &lt;expr&gt;는 ​&lt;/expr&gt;&lt;/expr&gt;&lt;/expr&gt;&lt;/term&gt;&lt;/expr&gt;&lt;/expr&gt;&lt;/expr&gt;&lt;/expr&gt;&lt;/p&gt;
&lt;term&gt; -&amp;gt; &lt;term&gt; * &lt;term&gt;으로 잠정적으로 바뀐다.  
이 규칙의 RHS에서 오른쪽 오퍼랜드는 ​곱셈 다음에 &lt;id&gt;나 (괄호속의 식)을 나타날 수 있다.  
(괄호속 식)을 서술할 수 있도록 하기 위해 ​곱셈의 오른쪽 오퍼랜드 &lt;term&gt;을 ​
난터미날 심볼 &lt;factor&gt;를 사용하여 대체한다.  
그러면, 잠정적으로 바뀐 &lt;term&gt; -&amp;gt; &lt;term&gt; * &lt;term&gt;은 ​
&lt;term&gt; -&amp;gt; &lt;term&gt; * &lt;factor&gt;가 된다.

원래 &lt;factor&gt;는 없었는데, ​
곱셈의 오른쪽 오퍼랜드로 (괄호속 식) 또는 &lt;id&gt;를 나타낼 수 있도록 하기 위해 ​
&lt;factor&gt;라는 난터미날을 새로 도입한 것이다. ​

이러한 목적에 의해 &lt;factor&gt;가 (괄호속 식)
 또는 &lt;id&gt;를 생성하는 규칙을 서술해야 한다.  
 이 규칙은 &lt;factor&gt; -&amp;gt; (&lt;expr&gt;) | &lt;id&gt;로 쓸 수 있다.

연산자 우선순위와 연산자 출현 순서의 지정에 의해 모호성을 제거하여 ​
트리를 생성하면 유일하게 생성된다.

그러나 만일 우선순위가 같은 곱셈과 나눗셈이 포함된 산술식을 위한 문법이라면, ​
모호성을 어떻게 제거해야 할까? ​

이와 긑은 문제는 시맨틱 규칙으로 지정해서 해결해야 한다. ​​

A / B * C와 같이 동일한 우선순위를 가진 곱셈과 나눗셈으
로 이루어진 식에서, ​
이들 연산자간의 계산 순서를 정하기 위해 어떤 시맨틱 규칙을 쓸 수 있을까?  

바로 결합 법칙을 이용할 수 있다. ​

그런데 결합 법칙에는, ​
왼쪽부터 결합하는 방식과 오른쪽부터 결합하는 방식, ​
두 가지가 있다.

A / B * C 은 어느 방식을 쓰느냐에 따라 계산 결과가 달라진다.  ​
    
또한 if-else 문법의 모호성 문제도 있다.  ​

---

 ​&lt;img src=&quot;/assets/built/images/pl/pl17.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;

---


if (logic_expr) if (logic_expr) stmt else st
mt에 대해, 위의 문법은 두개의 파스 트리를 생성한다.  
따라서 이 문법은 모호성이 있다.  

---

 ​&lt;img src=&quot;/assets/built/images/pl/pl18.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;

---  

If-else의 모호성 제거는 ‘가장 가까운 then에 else를 매치시킨다’는 규칙으로 해소된다.
If문은 then과 else가 모두 있는 것과 ​
then만 있고 else는 없는 것으로 구분된다. ​

즉 난터미날 &lt;stmt&gt;는 난터미날 &lt;matche d=&quot;&quot;&gt;이거나 &lt;unmatched&gt;로 대체된다.
&lt;matched&gt;는 if… else…를 모두 갖춘 것이고, &lt;unm atched=&quot;&quot;&gt;는 if… 로 구성되어 있다.
&lt;unmatched&gt;는 else 다음에 if… els
e를 허용하기 위해, 규칙에 else &lt;unmatched&gt;를 추가한다. ​

모호성을 제거한 새로운 문법은 오른쪽 아래와 같다.

---

&amp;gt; Extended BNF


 ​&lt;img src=&quot;/assets/built/images/pl/pl19.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;

---

&amp;lt;…&amp;gt;는 난터미날 심볼, x, y, z는 터미날 심볼​
( )는 그룹으로 묶기(일상적인 괄호의 의미), ​
{ }와 [ ]는 일상적인 의미가 아니고, ​
{ }는 0번 이상 반복, ​
[ ]는 생략 가능(이 예제에는 없음), ​
“ ”는 터미날 심볼을 나타내는 규칙의 표현 기호이며, ​
( )는 규칙 표기에 사용되는 기호이기 때문에, ​
산술식의 일부로서 표현되는 소괄호는 “(“  “)”로 표기함  

---

 ​&lt;img src=&quot;/assets/built/images/pl/pl20.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;  
 
---

위 그림에서 왼쪽의 BNF를 EBNF로 나타내면 오른쪽과 같다고 되어 있다.  
그러나 이 문법은 산술식에서 우선순위를 나타낼 때 사용하는 소괄호와
EBNF로 표기법의 소괄호의 의미를 구분하지 못하고 있다.  

이를 바로 잡으면, 오른쪽 아래의 문법과 같다.  
EBNF에서 ( )를 산술식의 괄호로 쓰려면, “(“, “)”로 써야 한다.

---
&lt;/unmatched&gt;&lt;/unmatched&gt;&lt;/unm&gt;&lt;/matched&gt;&lt;/unmatched&gt;&lt;/matche&gt;&lt;/stmt&gt;&lt;/id&gt;&lt;/expr&gt;&lt;/factor&gt;&lt;/id&gt;&lt;/factor&gt;&lt;/factor&gt;&lt;/id&gt;&lt;/factor&gt;&lt;/factor&gt;&lt;/term&gt;&lt;/term&gt;&lt;/term&gt;&lt;/term&gt;&lt;/term&gt;&lt;/factor&gt;&lt;/term&gt;&lt;/id&gt;&lt;/term&gt;&lt;/term&gt;&lt;/term&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">프로그래밍 언어의 신택스와 시맨틱스</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">프로그래밍 언어의 정교화</title>
      <link href="https://lee989898.github.io/pl-07" rel="alternate" type="text/html" title="프로그래밍 언어의 정교화" />
      <published>2021-09-16T19:18:00+09:00</published>
      <updated>2021-09-16T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-07</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-07">&lt;h3 id=&quot;프로그래밍-언어의-정교화&quot;&gt;&lt;strong&gt;프로그래밍 언어의 정교화&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;ALGOL&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;초기 포트란은 IBM 704를 타겟으로 개발되었다.&lt;br /&gt;
마찬가지로, 많은 언어가 특정 하드웨어에 최적화하도록 개발되었고, ​
이들 언어 간의 소통은 불가능했다. ​&lt;/p&gt;

&lt;p&gt;LISP를 포함한 초기의 다른 여러 프로그래밍 언어도 마찬가지였다.&lt;br /&gt;
Lisp의 기본 연산자 CAR(content of the address register)
, CDR(content of decrement register)은 ​
IBM 704 하드웨어 아키텍처와 매치되지는 않지만, 연산자 이름에서 ​
당시의 프로그래밍 언어가 하드웨어 아키텍처와 밀접한 관련성이 있었
다는 흔적임을 알 수 있다. ​&lt;/p&gt;

&lt;p&gt;이러한 문제를 해결하고자, ALGOL을 개발하였다.&lt;br /&gt;
ALGOL은 과학 알고리듬의 표현을 위한, 하드웨어
구조에 독립적인 명령식 언어이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    GO TO 27​
27 IF (A-B) 5,6,7​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;알골 이전의 컨트롤 스트럭처는 go to 하나뿐이었다.&lt;br /&gt;
go to 27은, 위 코드에서 보듯이, 27이라는 레이블이 붙은 문장으로 점프한다.  ​&lt;/p&gt;

&lt;p&gt;Go to는 레이블 중심의 컨트롤을 하기 때문에, 그 레이블이 어디든 점프하게 된다.&lt;br /&gt;
이로 인해 프로그램 코드는 스파게티처럼 꼬이게 되어,디버깅이 매우 어려울 뿐만 아니라, 의도하지 않은 영역으로 점프하는 등
go to는 해로운 컨트롤 스트럭처로 인식되고 있었다. ​&lt;/p&gt;

&lt;p&gt;이를 해결하기 위해, ​절(phrase) 수준의 컨트롤 스트럭처로서 if,
while, switch, for, until 등이 언어에 포함되었다.&lt;br /&gt;
뿐만 아니라, 이들 스트럭처를 사용하기 위한 프로그램 설계 
방법으로 구조적 프로그래밍(structured programming)이 제안되었다. ​&lt;/p&gt;

&lt;p&gt;구조적 프로그램 스타일의 핵심은 위에 언급된 컨트롤
스트럭처를 적재적소에 적용하여, ​
하나의 프로그램을 여러 개의 블록을
나누고 이들 블록간의 컨트롤을 구조적으로 유지하자는 것이다.&lt;br /&gt;
이렇게 하면 프로그램의 디버깅이 쉬울 뿐만 아니라, 프로그
램의 개발, 이해, 수정이 쉬워진다.&lt;/p&gt;

&lt;p&gt;알골 언어는 프로그래밍할 때 기억해야 특별한 제약이 없다.
따라서 포트란에 비해 프로그램 작성시 다음과 같은 면에서 자유롭다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;코딩할 때 고정된 포맷이 없다. 초기의 포트란은 레이블의
 위치 문장의 시작 위치 등이 지정되어 있다&lt;/li&gt;
  &lt;li&gt;변수명의 길이와 배열의 차원 수에 제한이 없다.&lt;br /&gt;
초기의 포트란은 변수명의 길이가 6자 이내이며, 차원수도 3개로 제한되어 있었다.&lt;/li&gt;
  &lt;li&gt;독립성: 기본 개념의 결합에 제한이 없다.&lt;br /&gt;
허용되지 않는 결합 조건 등 특별한 금지 사항을 기억해야 할 필요가 없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;알골은 1958년 이후에 개발된 모든 언어에 영향을 주었
으며, 이들 언어가 사용한 아이디어는 다음과 같다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;특정 포맷이 없는 lexical structure(어휘 구조) ​&lt;/li&gt;
  &lt;li&gt;변수명과 배열 차원의 길이에 제한이 없음 ​&lt;/li&gt;
  &lt;li&gt;BNF에 의한 구문 구조(신택스)​&lt;/li&gt;
  &lt;li&gt;타입 개념​&lt;/li&gt;
  &lt;li&gt;지역 변수의 허용에 의한 블록 구조 ​&lt;/li&gt;
  &lt;li&gt;Begin-end 및 if-then-else의 중첩 허용에 의한 복합 문장 ​&lt;/li&gt;
  &lt;li&gt;실행 시 스택 메모리 기반의 동적 배열 할당 ​&lt;/li&gt;
  &lt;li&gt;Call by value, call by reference, call by name ​&lt;/li&gt;
  &lt;li&gt;Recursion, 조건식(conditional expression) ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Call by value는 함수 호출 시 파라미터의 ‘값’을 넘겨주고, 이
‘값’은 ‘새로운 공간’에 저장되어 호출된 함수에서 사용된다. ​&lt;/p&gt;

&lt;p&gt;Call by reference는 함수 호출시 파라미터의 ‘주소’를 넘겨주고,
되돌려 받을 때도 이 ‘주소’를 이용한다. ​&lt;/p&gt;

&lt;p&gt;Call by name는 함수 호출시 ‘함수’를 파라미터로 넘겨
주면, ‘실제 실행할 때’ 그 ‘함수를 호출’한다. ​&lt;/p&gt;

&lt;p&gt;Call by value와 call by reference는 값을 저장하는
공간을 다루고 있지만,
Call by name은 ‘넘어간 함수의 호출 시점’을 다루고 있다.
Call by name은 함수 프로그래밍에서 사용하는 방법이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/pl/pl10.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;함수 호출시 파라미터를 call by value로 넘겨준다면, ​
그 아웃풋 순서는 hi 다음에 call이지만, ​&lt;/p&gt;

&lt;p&gt;Call by name으로 한다면, ​
그 순서는 call 다음에 hi가 된다. ​
그 이유는 call(x)의 x에 함수 hou()의 name이 매치되고, ​
call(x) 함수 내에서 x()가 실행되어야 비로소 함수 hou()를 실행하기 때문이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;BASIC&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;베이직은 개발 시기에 비해 늦게 대중화된 언어이다.&lt;br /&gt;
MS의 베이직과 같은 언어이다.&lt;br /&gt;
Basic의 특징은 한대의 컴퓨터에 연결된
 다수의 원격 터미날을 통해 다수의 사용자가 시분
 할 방식으로 동시에 접속하여 컴퓨터를 사용할 수 있는 
 개발 환경을 제공하였다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;COBOL&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;코볼은 유니백이 개발한 플로우매틱을 모태로 대음과 같은 특성을 갖는 언어로 개발되었다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;변수명은 하이픈(-) 포함해서 30글자까지 ​&lt;/li&gt;
  &lt;li&gt;산술 연산자를 영어명으로 (산술식 표현이 없음) ​&lt;/li&gt;
  &lt;li&gt;모든 문장은 동사로 시작함 ​&lt;/li&gt;
  &lt;li&gt;계층적 데이터 구조(레코드) 제공​&lt;/li&gt;
  &lt;li&gt;If-then-else의 중첩 ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;미국방부가 주도한 설계 고려사항은 다음과 같다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;영어처럼 단순하게 ​&lt;/li&gt;
  &lt;li&gt;사용하기 쉽게​&lt;/li&gt;
  &lt;li&gt;컴퓨터 사용자의 저변 확대 ​&lt;/li&gt;
  &lt;li&gt;기존 컴파일러 문제의 회피&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;PL/I&lt;/strong&gt;​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;과학 분야의 계산은 포트란으로, 비즈니스 응용 분야에서는 코볼로 프로그래밍을 하였으나, ​
과학분야의 계산과 입출력이 복잡해 지면서 레코드 
형태의 출력 구조를 요구하게 되었고, ​
비즈니스 분야 응용에서도 부동점 계산이나 배열 등을 요구하게 되었다. ​&lt;/p&gt;

&lt;p&gt;IBM은 이러한 요구를 수용할 수 있는 하드웨어와 프로
그래밍 언어를 동시에 개발하였다.&lt;br /&gt;
IBM 360은 이들 응용을 모두 커버할 수 있는 하드웨어였고, ​
PL/1은 이들 분야의 문제 해결을 위한 프로그래밍 언어였다. ​&lt;/p&gt;

&lt;p&gt;IBM은 다중 프로그래밍을 지원하는 시스템이었기 때문
에, 컴퓨팅 및 저장 공간 단위의 동시성 제어, 인터럽
트 처리, 예외 처리, 포인터 등에 대한 관리 메커니즘을 개발하였다. ​&lt;/p&gt;

&lt;p&gt;그러나 이들은 너무 복잡해서 시스템 오버헤드에 문제를 노출시켰다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;여기 부터 언급하는 프로그래밍 언어에서는 데이터 추상화가
프로그래밍 언어의 발전 요인이 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;SIMULA&lt;/strong&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;이번엔 데이터 추상화를 최초로 지원했던 시뮬라를 살펴보자.
시뮬라는 시뮬레이션 프로그램 작성에 편리한 언어로 개발되었다.&lt;br /&gt;
시뮬라의 가장 중요한 특성으로는 클래스와 코루틴을 들 수 있다. ​&lt;/p&gt;

&lt;p&gt;클래스는 데이터 추상화의 기본이 되는 구조로서, 로컬 데이터와 이
에 대한 함수의 정의를 포함한다. ​&lt;/p&gt;

&lt;p&gt;시뮬라의 이와 같은 데이터 추상화는 객체 지향 프로그래밍의 객체와 유사하다.  ​&lt;/p&gt;

&lt;p&gt;코루틴은 서브루틴(서브 프로그램)을 일반화한 것으로, 서브프로
그램 실행의 중단과 재시작을 허용한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/pl/pl11.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;​
코루틴이 서브루틴의 일반화한 것이라고 했는데, 왜 그런지 서브루틴과 코루틴을 비교해 보자.  ​&lt;/p&gt;

&lt;p&gt;위 그림에서 볼 수 있듯이, 서브루틴은 호출(call)될 때마다
 처음부터 실행하여 결과를 (return)돌려준다.&lt;/p&gt;

&lt;p&gt;반면, 코루틴은 여러 루틴들이 시작, 중지 및 양보(yi
eld), 재시작을 반복하면서 동시에 실행되는 것을 말한다.  ​&lt;/p&gt;

&lt;p&gt;이때 재시작은 루틴의 처음부터 시작하는 것이 아니
라, 이전에 양보했던 그 지점에서 재시작한다. ​&lt;/p&gt;

&lt;p&gt;루틴1이 실행되다가, 루틴2에게 양보하고, 
루틴2가 실행되다가 루틴1에게 양보하기를 반복한다. ​&lt;/p&gt;

&lt;p&gt;왼쪽 코드를 보자.&lt;br /&gt;
이 프로그램은 두개의 코루틴 producer, consumer과, main(즉, cal
l producer)으로 구성되어 있다.&lt;/p&gt;

&lt;p&gt;프로듀서는 큐가 풀이 아니면, 새로운 아이템을 생산하여 큐에 넣는다. ​
만일 큐가 풀이면, 컨슈머에게 양보한다. ​
​
컨슈머는 큐가 비어있지 않으면, 큐에서 아이템을 뽑아서 처리한다. ​
만일 큐가 비어 있으면, 프로듀서에게 양보한다. ​&lt;/p&gt;

&lt;p&gt;이 프로그램은 프로듀서를 호출함으로써 시작되고, ​
콜루틴의 조건에 따라 서로 양보하면서 반복적으로 실행된다. ​&lt;/p&gt;

&lt;p&gt;논리적으로 보면 이 프로그램은 끝나지 않는 프로그램이다. ​&lt;/p&gt;

&lt;p&gt;이러한 종류의 프로그램은 일반적인 응용 프로그램보다는
 시스템 소프트웨어에서 많이 볼 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Smalltalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;스몰톡은 최초의 객체지향언어라고 한다.&lt;br /&gt;
앞의 데이터 추상화에서 시뮬라가 최초의 객체지향언어라고 취급하기도 하지만, ​
스몰톡이야말로 객체 지향 언어의 중요한 특성을 구현하였기 때문이다. ​&lt;/p&gt;

&lt;p&gt;그러면 스몰톡 언어의 특성을 살펴보자.&lt;br /&gt;
변수, 상수, 레코드 실행, 클래스 등 모든 것이 객체로 취급된다.&lt;br /&gt;
모든 계산은 객체에 의한 메시지의 전송 및 수신에 의해 수행된다.&lt;br /&gt;
데이터 추상화, 상속, 동적 타입 바인딩 등   ​
스몰톡 언어는 데스크탑 환경을 가정하였는데, 
이러한 데스크탑은 프로그래머가 아닌 사용자에 의해 사용될 것이며,
 따라서 강력한 휴먼 인터페이스를 필요로 할 거라고 가정하였다.&lt;br /&gt;
 이러한 이유로 스몰톡은 GUI 설계를 개척하게 되었던 것이다.&lt;br /&gt;
 이러한 아이디어는 개발되어 Dynabook에 탑재되었다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;C++&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;시뮬라 및 스몰톡의 클래스와 함께, 함수 파라미터 타입 검사 및 컨버전, constructor, 상속된 요소의 접근 통제, 예외 처리 
등을 C에 추가하여 C++를 개발하였다. ​&lt;/p&gt;

&lt;p&gt;절차적(명령형) 프로그래밍과 객체 지향 프로그래밍을 
동시에 지원하면서 C++ 언어는 대단히 복잡해졌다. ​&lt;/p&gt;

&lt;p&gt;C++은 컴파일러의 품질이 좋고 저렴했고 C와 컴패터블했기 때문
에 널리 보급되어 지금도 널리 사용되고 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Java&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;자바는 객체지향 언어로, 명령형 프로그래밍 언어이다.&lt;br /&gt;
자바는 가전제품의 임베디드 소프트웨어 개발에 적합하도록 ​
다음과 같은 요구사항에 초점을 맞춰 설계되었다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;단순성​&lt;/li&gt;
  &lt;li&gt;객체지향 프로그래밍 지원​&lt;/li&gt;
  &lt;li&gt;포인터 대신에 레퍼런스 지원 -&amp;gt; 클래스 정의, 사용자 정의 타입 ​&lt;/li&gt;
  &lt;li&gt;애플릿 및 동시성(동시처리) 지원 ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;C++는 객체지향 프로그래밍을 지원하지만, ​
임베디드 소프트웨어에 부적합하다고 평가되었다.&lt;br /&gt;
그 이유는 절차적 언어를 지원하기 때문에 ​
구현 시스템이 너무 크고 복잡하고, 신뢰도가 낮기 때문이다.   ​&lt;/p&gt;

&lt;p&gt;자바는 순수 객체 지향 언어이다.&lt;br /&gt;
모든 처리로직은 객체의 메소드로 정의되기 때문에 ​
서브 프로그램이 존재하지 않았다.  ​
자바는 복잡도를 줄이기 위해 ​
단일 상속만을 허용하고 동시성 형태도 단순화하였다. ​&lt;/p&gt;

&lt;p&gt;자바의 특징은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자바는 C++에 비해 실행 속도보다 안정성에 중점을 두고 있다. ​
 안전성은 다양한 면에서 언급될 수 있는데, ​
우선 자바 가상 머신을 통한 코드 실행과 배열 범위 검사를 들 수 있다.
자바 가상 머신은 하위 플랫폼을 추상화시키는 결과를 가져 오기 때문에 ​
하드웨어 플랫폼의 차이점으로 인한 오류 발생을 해소한다.
그리고 실행시 배열 범위 검사는 배열 처리 상의  오류를 줄인다.    ​
동시성 지원(병렬 처리): thread, runnable task ​&lt;/li&gt;
  &lt;li&gt;애플릿, GUI, DB access 라이브러리​&lt;/li&gt;
  &lt;li&gt;컴파일러 및 자바 가상 머신에 의한 이식성​&lt;/li&gt;
  &lt;li&gt;웹 프로그래밍에 적용성 ​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Pascal(1971)&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;파스칼은 알골의 후속작으로 구조적 프로그래밍을 가르치기 위해 설계되었다.&lt;br /&gt;
작고 단순하고 전혀 새롭지 않은 언어를 지향하였다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;C&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;C는 시스템 프로그래밍을 위해 개발되었으며, 연산자가 풍부한 반면, 타입 검사가 없는 언어이다.&lt;br /&gt;
유닉스와 함께 보급되었으며, 다양한 응용 분야에서 사용되었다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Ada&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;에이다는 이제까지 언급한 프로그래밍 언어의 개념을 하나의 언어로
설계 및 구현하려는 시도였다. ​&lt;/p&gt;

&lt;p&gt;이 프로젝트를 통해 얻은 것은 다음과 같다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;패키지는 데이터 추상화를 지원​&lt;/li&gt;
  &lt;li&gt;예외 처리를 좀더 정교하게 발전​&lt;/li&gt;
  &lt;li&gt;서브 프로그램이나 패키지를 일반적인 단위 프로그램으로 생성하기때문에, ​
  공통 속성을 갖는 알고리듬에 유용함. ​&lt;/li&gt;
  &lt;li&gt;타스크 간의 소통에 의한 동시성 통제를 통해 병렬 처리를 지원&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이후 새로운 버전으로 에이다95를 설계하였는데, ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;객체지향​&lt;/li&gt;
  &lt;li&gt;공유 변수(shared variable) 컨트롤 메커니즘​&lt;/li&gt;
  &lt;li&gt;사용성을 개선하기 위한 라이브러리 등이 포함되었다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​에이다는 들인 노력에 비해, 대중성에서 실패한 사례로 간주된다.&lt;br /&gt;
비슷한 시기에 나온 C++에 그 자리를 내준 듯 하다. ​&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">프로그래밍 언어의 정교화</summary>
      

      
      
    </entry>
  
</feed>
