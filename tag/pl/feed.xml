<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://lee989898.github.io/tag/pl/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://lee989898.github.io/" rel="alternate" type="text/html" />
  <updated>2022-04-17T09:01:49+09:00</updated>
  <id>https://lee989898.github.io/tag/pl/feed.xml</id>

  
  
  

  
    <title type="html">LEE | </title>
  

  
    <subtitle>공부 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">FPinPython</title>
      <link href="https://lee989898.github.io/pl-21" rel="alternate" type="text/html" title="FPinPython" />
      <published>2021-12-05T19:18:00+09:00</published>
      <updated>2021-12-05T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-21</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-21">&lt;h3 id=&quot;fpinpython&quot;&gt;&lt;strong&gt;FPinPython&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;python-is-not-a-fpl&quot;&gt;&lt;strong&gt;Python is not a FPL&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;What is FP?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;수학적 의미의 순수 함수는 부작용이 없이, 아웃풋 값이 순전히 인풋값에 따르는 함수이다&lt;br /&gt;
함수 프로그래밍에서, 프로그램은 전적으로 순수 함수의 평가(계산의 실행)로 구성된다&lt;br /&gt;
계산은 상태 변화나 데이터의 변경없이, 중첩 함수나 합성 함수의 호출에 의해 진행된다&lt;/p&gt;

&lt;p&gt;명령형 프로그래밍에 대한 함수 프로그래밍의 장점은 다음과 같다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;첫째, 함수 코드는 고수준이다. ​함수는 결과를 얻는데 필요한 절차를 명시적으로 상술하는 것이 아니라, ​얻고자 하는 결과가 무엇인지 서술한다.  즉, how가 아니라 what을 서술한다 ​&lt;/li&gt;
  &lt;li&gt;둘째, 함수 코드는 투명하다. ​함수의 행태는 계산 중에 생성되는 잠정적인 값에 무관하고, 인풋과 아웃풋에만 의존한다. 이것은 부작용의 가능성을 제거하며, 디버깅을 쉽게 한다&lt;/li&gt;
  &lt;li&gt;끝으로, 함수 코드는 병렬성이 있다. ​부작용이 없어서, 프로그램의 루틴들은 더욱 쉽게 병렬 처리할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;함수 프로그래밍은 다음과 같은 특징을 갖는다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;함수는 first class이다. ​파이썬을 비롯한 현대 프로그래밍 언어에서는 ​기본적으로 객체, 클래스 개념을 갖기 때문에, ​함수를 기본적인 객체로 간주한다. ​따라서 ‘Functions are first class’라는 말은 ​’함수는 기본적인 객체이다’라는 의미로 받아 들여도 무방하다. 실제로 파이썬에서는 function을 객체로 간주하여, ​파라미터로 주고 받는다. ​이것은 함수 프로그래밍 언어에서 원하는 바이다&lt;/li&gt;
  &lt;li&gt;함수 프로그래밍에서 리커젼은 기본적인 컨트롤 스트럭처로 사용된다. ​몇몇 언어에서는 리커젼 이외에 순환 처리를 위한 다른 방법(loop)을 지원하지 않는다. 반면, 순수 함수 언어가 아닌 명령형 프로그래밍을 지원하는 언어에서는 loop도 함께 지원한다&lt;/li&gt;
  &lt;li&gt;함수 프로그래밍 언어는 리스트 처리에 초점을 둔다. ​Loop는 ‘리스트에 대한 리커젼 처리’로 대체될 수 있다. ​이와 같이 리스트는 loop의 대체에 필요한 데이터 구조로서 사용된다&lt;/li&gt;
  &lt;li&gt;순수 함수 프로그래밍 언어는 부작용을 피하기 위해, ​변수에 초기값을 할당하거나, 계산 중에 이 변수의 값을 변경하는 것을 모두 금지한다&lt;/li&gt;
  &lt;li&gt;함수 프로그래밍은 문장 단위로 프로그램을 작성하는 것이 아니라, ​함수와 파라미터 단위로 프로그램을 작성한다. ​순수 함수 프로그램에서,프로그램은 하나의 표현식과 이를 지원하는 함수 정의로 구성된다&lt;/li&gt;
  &lt;li&gt;함수 프로그래밍은 어떻게 계산할 것인가가 아니라, ​무엇을 계산할 것인가에 관심을 갖는다​&lt;/li&gt;
  &lt;li&gt;함수 프로그래밍은 고차 함수를 이용한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기서 언급하는 FP의 특징은 지극히 일부분이고 상이한 측면도 보이는데, 이렇게 된 이유는 ​순수 함수 언어가 아닌 현대 프로그래밍 언어를 가지고 ​함수 프로그래밍을 하는 실용적인 개발자(practitioner)의 관점이 반영되어 있기 때문이다&lt;/p&gt;

&lt;p&gt;파이썬은 ‘순수’ 함수 언어가 확실히 아니다. 대부분의 파이썬 프로그램에서 부작용을 흔히 볼 수 있다&lt;br /&gt;
즉, 변수는 자주 재바인딩되고, ​수정 가능한 데이터 컬렉션은 그 내용을 종종 변경하며, ​I/O는 자유롭게 계산과 인터리빙된다 (메모리에 바인딩된다는 의미이다)&lt;/p&gt;

&lt;p&gt;파이썬은 함수 언어 근처에도 못간다. ​파이썬은 멀티 패러다임 언어이다&lt;br /&gt;
파이썬은 필요할 때, 함수 프로그래밍을 쉽게 할 수 있고, ​다른 프로그래밍 스타일과 혼합하기 쉽다&lt;br /&gt;
즉, 명령형 프로그래밍 스타일과 함수 프로그래밍 스타일을 섞어서 쓸 수 있다&lt;br /&gt;
따라서, 멀티 패러다임 언어라는 말은 ​다양한 프로그래밍 스타일을 지원하는 언어라는 의미로 이해하면 될 것이다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;how-well-python-supports-fp&quot;&gt;&lt;strong&gt;How well Python supports FP?​&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;함수 프로그래밍을 지원하려면, ​함수는 다른 함수를 파라미터로 받을 수 있고, ​또 다른 함수를 반환할 수 있어야 한다&lt;br /&gt;
파이썬은 프로그램 내의 모든 것을 객체로 취급하기 때문에, ​두가지를 모두 지원한다&lt;/p&gt;

&lt;p&gt;파이썬에서, 함수는 일등 시민이다. 함수는 값과 동일한 특징을 갖기 때문에, ​함수를 변수에 할당할 수 있고(명령형 언어의 변수와 의미적으로 다름)​
print()를 써서 함수를 콘솔에 디스플레이할 수 있으며, ​함수를 다른 함수에게 파라미터로 패스할 수 있다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;I am function func()!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;am&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;another_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;another_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;am&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드는 func을 another_name에 할당하는 것을 보여주고 있다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;I am funtion func()!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cat&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2123123123&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cat&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2123123123&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;am&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cat&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드는 print(“cat”, func, 42)를 통해, ​&amp;lt; function func at … &amp;gt;을 디스플레이하는 것을 보여주고 있다&lt;br /&gt;
또 print()를 내포하는 함수 func()을 통해, ​함수를 디스플레이하고 있다&lt;br /&gt;
끝으로 d는 키: 값 쌍을 갖는 dictionary인데, ​d[func]은 func의 값 2를 반환한다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;I am function inner()!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;outer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;outer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;an&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드는 inner()가 outer()의 파라미터로 패스되는 것을 보여준다. 이것은 합성 함수의 정의 사례이다&lt;/p&gt;

&lt;p&gt;파이썬에서, 합성 함수는 다음과 같이 실행된다. ​outer(inner) 호출은 inner()를 outer()에게 파라미터로 패스한다&lt;br /&gt;
outer() 내에서 파이썬은 inner()를 파라미터 ‘function’에 바인딩한다. ​그러면, outer()는 ‘function’을 통해 직접 inner()를 호출한다&lt;br /&gt;
함수가 다른 함수에 패스될 때, 패스-인 함수를 콜백이라고 부른다. ​그 이유는 패스-인 함수(앞의 예에서는 inner())의 호출이 ​역으로 outer에 영향을 줄 수 있기 때문이다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ferret&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;vole&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;dog&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;gecko&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sorted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vole&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gecko&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ferret&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드는 sorted()의 파라미터로 len()을 사용하여 ​길이 순으로 정렬하고 있다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ferret&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;vole&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;dog&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;gecko&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sorted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ferret&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gecko&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vole&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reverse_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sorted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reverse_len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ferret&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gecko&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vole&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dog&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드는 길이의 역순으로 정렬한다. 이때 메소드 reverse=True와 함수 -len()에 의한 reverse_len()의 정의를 사용한다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;outer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;I am function inner()!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inner&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;outer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;outer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inner&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x231312312&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;am&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;outer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;am&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;파이썬에서는, 함수를 반환값으로 반환한다. ​파이썬에서는 함수를 다른 함수에게 파라미터로 패스할 수 있고, ​함수를 다른 함수의 반환값으로 반환한다&lt;br /&gt;
예를 들어, 위 코드에서 함수 outer()의 정의를 보자. outer() 내에서 inner()를 정의하고, ​inner를 반환한다&lt;br /&gt;
outer()의 반환값을 변수 function에 할당한다. ​function()는 간접적으로 inner()를 호출한다. ​outer()의 반환값을 이용하여 간접적으로 inner()를 호출한다&lt;br /&gt;
이와 같이, 파이썬은 함수를 파라미터로, 그리고 반환값으로 사용할 수 있다. 이러한 측면에서 파이썬은 함수 프로그래밍을 잘 지원한다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lambda&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x123312512&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;True&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reverse&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;I am a string&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;I am a string&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;파이썬은 람다를 사용하여 익명의 함수를 정의한다. ​람다 표현식은 lambda &lt;param_list&gt;: &amp;lt; expression &amp;gt;의 형식을 갖는다  
&amp;lt; expression &amp;gt;은 파라미터 리스트의 이름을 포함한다  
위 코드는 문자열의 역순을 반환하는 함수 정의를 ​람다 표현식으로 나타낸 것이다  
Callable은 함수 호출이나 메소드인지를 확인하는 함수이다. ​가운데 코드와 같이, 람다 함수의 적용을 통해, ​그리고 람다 함수를 변수에 할당 및 호출을 통해, ​함수를 평가할 수 있다&lt;/param_list&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;applying-function-to-iterable-with-map&quot;&gt;&lt;strong&gt;Applying function to iterable with map()​&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; 
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;I am a string&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cat&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;dog&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hedgehog&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;gecko&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tac&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;god&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;gohefdeh&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;okceg&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tac&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;god&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gohegdeh&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;okceg&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cat&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;dog&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hedgehog&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;gecko&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tac&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;god&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gohegdeh&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;okceg&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이터러블에 대한 함수에 map()을 적용하면, ​리스트 각 요소마다 원하는 함수 f를 적용할 수 있다&lt;br /&gt;
리스트 각 요소마다 reverse를 적용하려면, ​map(reverse, animal)와 같이 하면 된다&lt;br /&gt;
이것은 이터러블 animal의 각 요소에 reverse 함수를 적용한다. ​이것을 for loop을 써서 프린트한다&lt;br /&gt;
이터레이터를 써서 프린트할 수 있다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;111&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;222&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;333&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다수의 이터러블에 map()을 적용하려면, ​그 형식은 map(f, iter1, iter2,… itern)과 같다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;selecting-elements-from-iterable-with-filter&quot;&gt;&lt;strong&gt;Selecting elements from iterable with filter()&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;greater_than_100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;greater_than_100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;111&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;222&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;333&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;111&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;222&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;333&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;111&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;222&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;333&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;111&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;222&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;333&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;함수 filter()를 써서 이터러블로부터 원하는 요소를 선택하려면, ​그 형식은 filter(f, iter)이다&lt;br /&gt;
함수 f가 greater_than_100()이라면, ​표현식 filter(greater_than_100, [1,111,2,222,3,333]))의 결과는​ 111,222,333이다&lt;/p&gt;

&lt;p&gt;—​&lt;/p&gt;

&lt;h2 id=&quot;avoiding-control-flow&quot;&gt;&lt;strong&gt;Avoiding control flow​&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;명령형 파이썬 프로그램에서 코드 블록은 다음과 같이 구성된다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;외부 loop(for 또는 while)​&lt;/li&gt;
  &lt;li&gt;외부 loop 내의 상태 변수의 할당​&lt;/li&gt;
  &lt;li&gt;데이터 구조(dicts, lists, sets 등)의 수정​&lt;/li&gt;
  &lt;li&gt;분기문(if/elif/else 또는 try/except/finally)​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이렇게 하는 것은 자연스럽고 문제를 인식하기 쉬운 듯 보인다. ​그러나 상태 변수와 수정가능한 데이터 구조로 인해 부작용이 발생할 수 있을 뿐만 아니라, ​프로그램의 특정 지점에서 데이터의 상태를 알아내기가 어렵다&lt;br /&gt;
이에 대한 해결책으로 ‘how’가 아니라 ‘what’에 초점을 맞추는 것이 중요하다&lt;br /&gt;
즉, ‘여기 어떤 데이터가 있는데,’ ‘원하는 결과를 생성하기 위해 이 데이터를 어떻게 처리할 것인가?’가 아니라 ​’이 데이터를 가지고(또는 이 데이터에 대해) 내가 처리해야 하는 것이 무엇인가?’를 고민하는 것이다&lt;/p&gt;

&lt;p&gt;플로우 컨트롤을 피하고 함수 프로그래밍을 위해, ​’how’에서 ‘what’으로 어떻게 전환할 것인가?&lt;br /&gt;
캡슐화, 컴프리헨션, 리커젼 등을 잘 활용하는 것이 그 방법이다&lt;br /&gt;
컴프리헨션은 주어진 구조적 데이터에서 새로운 구조적 데이터를 생성하는 간략한 방법으로, ​파이썬 프로그래머는 반복 처리나 조건을 만족하는 리스트, 딕셔너리, 집합을 쉽게 생성할 수 있다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Encapsulation&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;# imperative style​
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;collection&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_initial_state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;state_var&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;datum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data_set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state_var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;state_var&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calculate_from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;datum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;datum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state_var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modify_differently&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;datum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;# work with the data collection​
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thing&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;collection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;# functional style ​
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make_collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data_set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;collection&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_initial_state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;state_var&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;datum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data_set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state_var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;state_var&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;calculate_from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;datum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state_var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;datum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state_var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modify_differently&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;datum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;collection&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;# work with the data collection​
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thing&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make_collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data_set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;캡슐화는 코드를 refactor(재분해)하고, ​데이터 생성을 함수나 메소드 안으로 집어 넣는 것이다&lt;br /&gt;
예를 들어 위 코드는 캡슐화를 써서, ​명령형 스타일의 ‘collection 생성 절차’라는 ‘how’를 함수 프로그래밍 스타일의 ‘make_collection(즉 collection 생성)’이라는 what으로 전환한다&lt;br /&gt;
위 코드는 명령형 절차를 나타내며, ​아래 코드는 함수 프로그램 코드를 나타낸다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;List Comprehension&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;collection&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;datum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data_set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;datum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;datum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;datum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;collection&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;condition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
                 &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data_set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;컴프리핸션은 주어진 이터러블에서 새로운 이터러블을 생성하는 간략한 방법이다&lt;br /&gt;
파이썬의 컴프리헨션에는 리스트, 제너레이터, 딕셔너리, 집합이 있으며, ​이를 위한 문법을 제공한다
리스트 컴프리헨션은 표현식을 […]로 감싼다&lt;/p&gt;

&lt;p&gt;컴프리헨션은 같은 키워드를 사용하면서, ​그 키워드들의 순서를 바꾼 표현식의 형태를 갖는다&lt;br /&gt;
순서를 바꾼 이유는 절차가 아닌 데이터에 초점을 두기 위함이다. 이 말은 컴프리헨션을 이용하여 함수 프로그래밍에 도움이 된다는 뜻이다&lt;/p&gt;

&lt;p&gt;주어진 리스트 data_set으로부터 새로운 리스트 collection을 생성하는 ​프로그램을 코딩하면 위 코드와 같다&lt;br /&gt;
위는 명령형 스타일이고, 아래는 함수형 스타일이다&lt;br /&gt;
위 코드에서, 삼진 연산자 if를, ​같은 키워드를 사용하면서 순서만 바꿔, ​명령형 코드를 함수형 코드로 재구조화한 것을 볼 수 있다&lt;br /&gt;
절차에 초점을 둔 코드는 조건을 만족시키면, append​ 만족시키지 못하면, modify &amp;amp; append​&lt;/p&gt;

&lt;p&gt;반면에 데이터에 초점을 둔 함수 스타일로 표현하면, ​리스트 컴프리헨션이 적절한 형식이고, ​주어진 리스트 data_set에서 조건에 맞는 것만 collection로 생성하면 된다&lt;br /&gt;
리스트 요소를 d로 지칭하여 표현식을 작성하면, ​아래쪽 코드와 같다. Data_set의 각 요소 d에 대해 ​먼저 조건을 만족시키는지 확인하고, 맞으면 bypass 안맞으면 modify&lt;/p&gt;

&lt;p&gt;마치 순서를 바꾼 것처럼 보이지만, 시맨틱을 고려하면 조건을 만족하면 리스트에 남기고(하나씩 append 하지 않고), ​조건을 만족하지 않으면 modify(d)해서 수정된 d를 리스트에 남긴다. 그리고 이와 같이 생성된 새로운 리스트를 collection으로 명명(naming)한다는 의미이다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Generator Comprehension&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;제너레이터 컴프리헨션은 리스트 컴프리헨션과 유사하게 데이터를 생성하나 문법적으로 [ ] 대신에 ( )를 사용한다&lt;br /&gt;
제너레이터 컴프리헨션은 데이터 생성을 위해, ​함수 정의에 ‘데이터 생성 방법’을 서술한다&lt;br /&gt;
이 서술은 그에 대한 반복 처리를 하거나 .next()를 호출할 때까지 실행되지 않는다&lt;br /&gt;
따라서 대규모 시퀀스를 위한 메모리를 절약하고​ 실제로 필요할 때까지 계산을 지연시킨다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;# imperative​
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_log_lines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read_line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
             &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;complex_condition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
             &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read_line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StopIteration&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
                  &lt;span class=&quot;n&quot;&gt;raise&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;log_lines&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_log_lines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;huge_log_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;# functional ​
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetLogLines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;log_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log_file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;log_file&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__iter__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__next__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read_line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;complex_condition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read_line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;log_lines&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetLogLines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;huge_log_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;간단한 예를 들면, 로그 파일에서 로그 라인을 읽어서 ​라인 리스트를 만드는 함수 코드는 위와 같다&lt;br /&gt;
위의 코드는 실제 상황을 고려한 코드로서, ​위쪽 코드는 명령형 프로그래밍 스타일, ​아래쪽 코드는 함수 프로그래밍 스타일을 나타낸다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Dictionary and Set Comprehension&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;65&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'A'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'B'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'C'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'D'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'E'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'F'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;65&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'A'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'B'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'C'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'D'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'E'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'F'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;딕셔너리와 집합 컴프리헨션은 모두 { }을 사용하나, ​그 안의 형식이 {key : value}, {value}로 각기 다르다&lt;br /&gt;
이들의 요소는 loop안에서 .update(), add() 호출을 통해 하나씩 생성되는 것이 아니라, ​모두 ‘한꺼번에’ 생성된다​&lt;br /&gt;
각각의 예는 위와 같다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Recursion&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;# recursive​
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factorialR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factorialR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;# iterative ​
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factorialI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;product&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;product&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;product&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;파이썬은 리커션과 룹에 의한 함수 프로그래밍을 지원한다&lt;br /&gt;
리커션과 while 룹을 이용한 팩토리알 계산 함수는 각각 위와 아래에 있다&lt;br /&gt;
While 룹을 이용한 것은 거의 명령형 코드로 보이지만, ​함수로 정의하는 점과 while 안에서 함수형 코드가 있는 점 등​ 함수 프로그래밍 스타일과 명령형 프로그래밍 스타일이 혼합되어 있다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;# Quicksort over a list-like sequence​
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;quicksort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;pivots&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;small&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;quicksort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;large&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;quicksort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;small&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pivots&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;large&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이러한 혼합 형식은 퀵소트 함수에서도 볼 수 있다. 삼진 연산자 if, [표현식…]은 함수형이지만, ​나열된 문장은 명령형으로 보인다. 즉, 혼합형이다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;# statement-based loop​
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;# map()-based &quot;loop“​
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;고차 함수를 써서 룹을 제거할 수 있다. ​이것은 가독성과 성능 저하를 가져오지만, ​함수 프로그래밍을 위한 좋은 아이디어를 얻을 수 있는 배경 지식으로 중요하다&lt;/p&gt;

&lt;p&gt;우선 for loop을 제거하기 위해 map()을 쓴 경우를 보자. ​위쪽 코드는 for loop에 의한 코드이다. ​반면 아래쪽 코드는 map에 의해 loop이 제거된 코드이다&lt;/p&gt;

&lt;p&gt;함수 map()을 적용할 때, ​다수의 함수를 같은 수의 리스트에 적용하고 싶다면, ​다수의 함수와 같은 수의 리스트를 파라미터로 하여, ​map(do_it, [f1, f2, f3], [l1, l2, l3])와 같이 표현한다&lt;br /&gt;
이때 적용해야 할 함수는 ​do_it = lambda f, &lt;em&gt;args: f(&lt;/em&gt;args)와 같이, ​람다에 의해 정의되어 있어야 한다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bye&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Bye&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;do_it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bye&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;                         &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;David&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;','&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Jane&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mertz&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;','&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Doe&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Hello&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;David&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Mertz&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Bye&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Jane&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Doe&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;do_all_funcs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
                                     &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;do_all_funcs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bye&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
                             &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;David&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;','&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Jane&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mertz&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;','&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Doe&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Hello&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;David&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Mertz&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Hello&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Jane&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Doe&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Bye&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;David&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Mertz&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Bye&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Jane&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Doe&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위쪽 코드는 함수 hello를 [Dav, Jan]에, ​함수 bye를 [Mer, Do]에 적용하는데, ​이들 함수 hello, bye는 각각 ​lambda first, last: print(“Hello”, first, last)와 ​lambda first, last: print(“Bye”, first, last)이다&lt;/p&gt;

&lt;p&gt;만일 모든 함수를 각각의 리스트에 적용하려면, ​함수 map()을 lambda fns, *args: [list(map(fn, *args)) for fn in fns]와 같이 정의한다&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">FPinPython</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">FPLs</title>
      <link href="https://lee989898.github.io/pl-20" rel="alternate" type="text/html" title="FPLs" />
      <published>2021-11-24T19:18:00+09:00</published>
      <updated>2021-11-24T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-20</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-20">&lt;h3 id=&quot;fpls&quot;&gt;&lt;strong&gt;FPLs&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;lisp&quot;&gt;Lisp​&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Lisp은 심볼(문자열) 처리를 위한 언어로 개발되었다&lt;br /&gt;
심볼들을 표현하기 위한 데이터 구조로 리스트, 즉 링크드 리스트를 기본으로 한다&lt;br /&gt;
이러한 이유로 데이터 연산은 자연스레 링크(포인터) 조작을 포함한다&lt;br /&gt;
Lisp이라는 이름은 리스트 프로세싱의 합성어로서, 말 그대로 리스트 처리에 적합하도록 설계되었다&lt;/p&gt;

&lt;p&gt;Lisp의 데이터 타입은 아톰과 리스트, 두 가지이다&lt;br /&gt;
아톰은 식별자처럼 생긴 심볼들이거나 숫자 형태의 상수를 말한다&lt;br /&gt;
아톰에 값이 없을 수 있어서 nil도 가능하다&lt;br /&gt;
리스트는 리스트 요소가 연결되어 있고, 리스트 요소는 두개의 링크(포인터), 데이터 포인터와 넥스트 포인터로 구성된다&lt;br /&gt;
데이터 포인터는 아톰을 가리키거나 중첩리스트를 가리킨다&lt;br /&gt;
넥스트 포인터는 다른 리스트 요소를 가리키거나 nil(리스트의 끝을 나타냄)이다&lt;/p&gt;

&lt;p&gt;Lisp 프로그램에서 리스트는 괄호를 써서 나타내는데, 중첩 리스트는 괄호 안에 괄호를 써서 나타낸다&lt;/p&gt;

&lt;p&gt;ex) (A, B, C, D)&lt;br /&gt;
A,B,C,D는 각각이 아톰이며, (A,B,C,D)는 리스트이다&lt;/p&gt;

&lt;p&gt;산술 연산자로 +, - , incf, decf가 있고, 비교 연산자로 =, /= , &amp;lt;, max, min이 있다&lt;br /&gt;
부울 값에 대한 논리 연산자로 loand,logor 등이 있다&lt;br /&gt;
컨트롤 스트럭처로 selection, recursiong, iteration이 있는데, iteration은 명령형 언어의 특성으로, Lisp이 순수 함수 언어가 아니라는 것을 보여준다&lt;br /&gt;
함수 정의는 (defun 함수명 (파라미터1… 파라미터n)표현식)형식을 따르고, 함수 적용(호출)은 (함수명 파라미터1 … 파라미터n)의 형식을 따른다&lt;/p&gt;

&lt;p&gt;Lisp으로 작성된 팩토리알 함수는&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DEFUN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factorial&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;factorial&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;과 같다&lt;/p&gt;

&lt;p&gt;미리 정의된 함수 중의 몇몇은 실제로는 함수가 아니라 매크로이다&lt;br /&gt;
예를 들어, 두개의 파라미터, 죽 변수와 리스트를 받아들이는 DOLIST는 매크로이다&lt;br /&gt;
DOLIST(x ‘(1 2 3)) (print x))는 리스트 요소 1,2,3,nil로 구성된 리스트를 생성한다&lt;/p&gt;

&lt;p&gt;매크로의 실행은 다음 두 단계로 이루어진다&lt;br /&gt;
우선, 매크로를 미리 정의딘 Lisp 코드로 펼치고, 다음에, 펼친 Lisp 코드를 평가(실행)한다&lt;/p&gt;

&lt;p&gt;사용자는 DEFMACRO를 써서 자신이 원하는 매크로를 정의할 수 있다&lt;/p&gt;

&lt;p&gt;Lisp에서 괄호 앞의 ‘(QUOTE)는 괄호 속의 표현식을 평가(실행)하지 말고, 그 객체(표현식)를 결과로서 반환하라는 뜻이다&lt;br /&gt;
예를 들어 (a(&lt;em&gt;3 4)c)는 (a 12 c)를 결과로 반환한다&lt;br /&gt;
중첩된 괄호 속의 (&lt;/em&gt; 3 4)는 평가한다는 것에 주의하자&lt;/p&gt;

&lt;p&gt;Lisp은 컴파일러가 아닌 인터프리터에 의해 실행된다&lt;br /&gt;
Lisp 프로그램에서는 함수 정의 및 함수 적용(호출)을 “괄호에 의한 리스트 표시 방식”으로 표현된다&lt;br /&gt;
함수 정의는 (함수명(람다 (파라미터1 … 파라미터n) 표현식)) 으로 정의하며, 함수 적용은 (함수명 파라미터1 … 파라미터n)으로 호출한다&lt;br /&gt;
예를 들어, (+ 5 7)은 12이고, (+ 3 4 7 6)은 20이다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;scheme&quot;&gt;Scheme​&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Scheme은 Lisp으로부터 유래되었으나 함수를 일등 시민으로 취급한다&lt;br /&gt;
Scheme에서는 함수가 표현식의 결과 값일 수 있고, 함수가 리스트의 요소로 사용될 수 있으며, 함수가 파라미터로 패스될 수 있고, 함수가 함수의 결과로서 반환될 수 있다&lt;/p&gt;

&lt;p&gt;Scheme은 단순한 신택스와 시맨틱스를 갖는, 타입이 없는 작은 언어이다&lt;/p&gt;

&lt;p&gt;Scheme 인터프리터는 상호작용 모드로 동작하면서, read-evaluate-print 순환(REPL)을 무한으로 반복한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자가 입력한 표현식을 읽어서&lt;/li&gt;
  &lt;li&gt;EVAL 함수에 의해 표현식을 해석하고&lt;/li&gt;
  &lt;li&gt;결과값을 화면에 display한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;EVAL 함수는 다음과 같이 표현식을 평가한다&lt;br /&gt;
리터럴의 평가는 그 자체를 결과로 displaat한다&lt;br /&gt;
원시 함수를 포함하는 표현식의 평가는 다음과 같이 실행한다&lt;br /&gt;
첫째, 특별한 순서 없이, 파라미터 표현식의 각각 평가한다&lt;br /&gt;
둘째, 파라미터 값에 원시 함수의 적용을 평가한다&lt;br /&gt;
끝으로, 결과값을 display한다&lt;/p&gt;

&lt;p&gt;원시 산술 함수는 +,-,*,/,modulo,round,max,min,log,sin,sqrt 등이다&lt;br /&gt;
음수에 대한 sqrt는 허수이다&lt;/p&gt;

&lt;p&gt;함수 정의는 (LAMBDA (x) (&lt;em&gt;x x))의 형식을 가지며, 함수 적용은 ((LAMBDA(x) (&lt;/em&gt; x x)) 7)의 형식을 갖는다&lt;/p&gt;

&lt;p&gt;DEFINE 함수는 이름을 값이나 람다 함수에 바인딩하는 특수한 함수이다&lt;br /&gt;
(DEFINE symbol expression)의 형식을 가지며, 그 예로 (DFINE pi 3.141592), (DEFINE two_pi (* 2 pi))을 들 수 있다&lt;/p&gt;

&lt;p&gt;DEFINE 함수가 이름을 람다 표현식에 바인딩하는 형식은 (DEFINE (function_name parameters) (expression))이다&lt;br /&gt;
예를 들면, 제곱수를 (DEFINE (square number) (* number number))와 같이 정의하고, 직각삼각형의 빗변의 길이를 (DEFINE (hypotenuse side1 side2)(SQRT(+(square side1)(square side2))))와 같이 정의한다&lt;/p&gt;

&lt;p&gt;출력 함수는 EVAL 함수의 적용을 통해 그 결과를 display한다&lt;/p&gt;

&lt;p&gt;논리적 술어(predicate)함수는 부울 값을 반환한다&lt;br /&gt;
Scheme의 논리적 술어 함수는 =, &amp;lt;&amp;gt;, &amp;gt;,&amp;lt;,&amp;gt;=, &amp;lt;=, EVEN?, ODD?, ZERO?가 있다&lt;br /&gt;
리스트가 부울식으로서 해석될 때에는 비어있지 않은 리스트는 참이고, 비어있는 리스트는 거짓이다&lt;/p&gt;

&lt;p&gt;컨트롤 플로우는 택인 컨스트럭트(IF)와 평가 컨트롤(COND)이 있다&lt;br /&gt;
if는 3개의 파라미터(논리적 술어 표현식, then 표현식, else 표현식)를 갖는다&lt;br /&gt;
그 형식은 (IF 논리적 술어 then 표현식 else 표현식)이고, 사용 예를 들면 DEFINE(factorial n)(IF (&amp;lt;+ n 1)1(*n(factorial(-n 1))))이다&lt;/p&gt;

&lt;p&gt;평가 컨트롤은 여럿 중에서 하나 이상이 선택 및 실행되는 COND와 recursion이 있다&lt;br /&gt;
COND의 형식은&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DEFINE&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;leap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;year&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;COND&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ZERO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MODULO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;year&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;400&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ZERO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MODULO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;year&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ELSE&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ZERO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MODULO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;year&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;와 같다&lt;/p&gt;

&lt;p&gt;리스트 함수에는 QUOTE,CAR,CDR,CONS 함수가 있다&lt;br /&gt;
QUOTE는 그 자체를 결과로 반환하며, ‘로 표시한다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;QUOTE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;QUOTE&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CAR 함수는&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAR&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAR&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;an&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;because&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAR&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAR&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;an&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CDR 함수는 ​&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CDR&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CDR&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;an&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CDR&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CDR&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;an&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CONS 함수는 ​&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CONS&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CONS&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CONS&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CONS&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CAR, CDR을 가지고 a_list의 두번째 리스트 요소를 결과값으로 반환하는 함수를 정의하면, (DEFINE (second a_list)(CAR(CDR a_list)))가 된다&lt;br /&gt;
이것은 a_list에서 첫째 요소를 제외한 나머지를 반환하고, 이중에서 첫째 요소를 반환한다는 뜻이다&lt;br /&gt;
리스트를 생성하기 위해 CAR CDR의 연속으로 적용해 보면, (CADDAR ‘((A B (C)D)E)) == (C) 임을 알 수 있다&lt;/p&gt;

&lt;p&gt;리스트 함수는 다수의 파라미터로부터 하나의 리스트를 생성한다&lt;br /&gt;
CONS는 생성할 수도 있으나, List함수가 편리하다&lt;/p&gt;

&lt;p&gt;논리적 술어 함수 중에서 EQ? NULL? LIST?는 심볼 아톰과 리스트에도 적용할 수 있다&lt;br /&gt;
EQV?은 숫자 아톰과 심볼 아톰에 모두 적용할 수 있다&lt;/p&gt;

&lt;p&gt;Scheme에서 함수 정의의 예를 들어 보자&lt;br /&gt;
멤버 함수는 파라미터 간의 소속관계를 평가한다&lt;br /&gt;
리스트의 맨앞 리스트 요소에서부터 차례로 비교하기 위해, COND와 EQ, CAR, CDR을 사용한다&lt;br /&gt;
append 함수는 앞의 파라미터에 뒤의 파라미터를 잇는다&lt;br /&gt;
list1의 리스트 요소를 앞에서부터 하나씩 새로운 리스트에 넣기를 반복한다&lt;br /&gt;
list1의 리스트의 요소를 모두 새로운 리스트에 넣고 나면, 이때 lsit1은 NULL이 되므로, list2의 요소를 새로운 리스트에 넣으면 된다&lt;br /&gt;
이를 위해 COND와 NULL?, CONS, CAR, CDR을 이용한다&lt;/p&gt;

&lt;p&gt;두개의 리스트가 같은지 판단하려면, 각 리스트의 맨앞 요소에서부터 하나씩 같은지 비교하기를 반복한다&lt;br /&gt;
이를 위해 COND, EQ?, CAR, CDR 등을 이용한다&lt;/p&gt;

&lt;p&gt;반복 처리는 모두 recursion을 이용한다&lt;br /&gt;
즉, 이들 모두 recursion으로 프로그래밍 된다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;root1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ac&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ac&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DEFINE&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;quadratic_roots&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LET&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

     &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root_part_over_2a&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

                    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SQRT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;−&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

     &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;minus_b_over_2a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;−&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

         &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LIST&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minus_b_over_2a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root_part_over_2a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

                  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;−&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minus_b_over_2a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root_part_over_2a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;LET 함수는 로컬 변수를 생성한다&lt;br /&gt;
표현을 쉽게 하기 위해 루트 부분과 루트가 없는 부분(이것을 마이너스 부분)으로 나누어, 이들을 각각 로컬 변수 root_part_over_2a, minus_b_over_2a로 언급한다&lt;br /&gt;
LIST 함수에서 이들을 언급하며 근의 공식 함수를 정의한다&lt;/p&gt;

&lt;p&gt;함수의 합성은 두개의 함수를 파리미터로 받아들여 합성 함수를 결과로 반환한다&lt;br /&gt;
합성 함수는 DEFINE (compose f g)(LAMBDA(x) (f(g(x))))로 정의한다&lt;br /&gt;
CADDR을 (DEFINE (third a_list) ((compose CAR (compose CDR CDR)) a_list))와 같이 정의한다&lt;/p&gt;

&lt;p&gt;리스트의 모든 요소에 적용하는 함수로 map 함수를 정의해 보자&lt;br /&gt;
함수 정의의 형식은 (DEFINE (mao fun a_list) 표현식)이며, a-list의 모든 요소에 함수 fun을 적용하라는 의미이다&lt;br /&gt;
즉, 함수 map을 정의하는데 파라미터로서 fun이라는 함수를 쓴다&lt;br /&gt;
따라서 이것은 고차 함수이다&lt;/p&gt;

&lt;p&gt;처리 목적에 맞게 처리하려면, 리스트 요소를 하나씩 반환하는 함수가 필요하며, 이렇게 반환된 리스트 요소에 fun을 적용하기를 반복하면 된다&lt;br /&gt;
위의 map 함수 정의에서 (COND … NULL? … ELSE …) 부분은 리스트 요소를 하나씩 꺼내는 처리 로직을 수행한다&lt;br /&gt;
맵함수 사용 예: (map (LAMBDA(num)(*num num num))’(3 4 2 6))은 (27 64 8 216)를 반환한다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DEFINE&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;adder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;COND&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

          &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

          &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ELSE&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAR&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;adder&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CDR&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;adder&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;adder&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;adder&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;adder&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()))))&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

   &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;리스트에 있는 아톰의 합을 구하는 프로그램을 작성해보면, 코드는 위에서 보듯이 매우 간결하다&lt;br /&gt;
실제 평가 과정을 보면, recursion이 있어 매우 복잡해 보이지만 이것은 인터프리터의 역할이다&lt;/p&gt;

&lt;p&gt;만일 EVAL 함수를 써서 코딩하면, 아래 프로그램이 된다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Alternative&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EVAL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DEFINE&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;adder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;COND&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

        &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ELSE&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EVAL&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CONS&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;adder&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EVAL&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;ml&quot;&gt;ML​&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;ML은 타입 검사를 엄격하게 수행하는 언어이다&lt;br /&gt;
평가 환경은 프로그램에서 명시적 또는 암묵적으로 선언된 모든 변수명을 그 유형(타입)과 함께 테이블을 포함한다&lt;br /&gt;
이 테이블은 컴파일러의 심볼 테이블과 유사하다&lt;br /&gt;
ML 신택스는 Lisp이나 Scheme에 비해 IPL과 더욱 유사하다&lt;br /&gt;
산술 표현식은 인픽스 방식으로 표현된다&lt;/p&gt;

&lt;p&gt;함수 정의는 함수명(파라미터) = 표현식;의 신택스를 갖는다&lt;br /&gt;
예를 들어, fun circumf( r ) = 3.14159&lt;em&gt;r&lt;/em&gt;r;로 정의 되었다면, 함수 circumf는 부동점 파라미터를 받아서 부동점 결과를 생산한다&lt;br /&gt;
이 값의 타입은 표현식의 값으로부터 추론된다&lt;br /&gt;
함수 적용은 circumf(1.3)과 같이 호출된다&lt;/p&gt;

&lt;p&gt;ML의 컨트롤 플로우는 if 표현식 then 표현식1 else 표현식2에 의한다&lt;br /&gt;
ML에서는 주어진 파라미터에 대한 패턴 매칭을 통해 함수의 반환값을 정의하는 특정 표현식을 선택하기도 한다&lt;br /&gt;
예를 들어, 팩토리알을 구할 떄&lt;br /&gt;
fun fact(n : int): int = if n &amp;lt;= 1 then 1 else n *fact(n − 1);로 표현할 수도 있지만, ​fun fact(0) = 1 | fact(1) = 1 | fact(n : int): int = n* fact(n − 1);로 표현할 수도 있다&lt;br /&gt;
후자에서는 Fact(0), Fact(1)의 값을 구할 때, 두개의 식 fun fact(0) = 1, fact(1) = 1에 대한 패턴 매칭을 통해 그 결과값을 선택할 수 있다&lt;/p&gt;

&lt;p&gt;ML에서는 h, t는 각각 헤드와 테일을 나타내며, CAR, CDR과 같다&lt;br /&gt;
그리고 ::는 CONS와 같다&lt;br /&gt;
두개의 리스트를 append하는 함수는&lt;br /&gt;
fun append([], lis2) = lis2 | append(h :: t, lis2) = h :: append(t, lis2);로 정의된다&lt;/p&gt;

&lt;p&gt;주어진 리스트에서 리스트 요소의 개수를 구하는 함수는&lt;br /&gt;
fun length([]) = 0 | length(h :: t) = 1 + length(t);이다&lt;/p&gt;

&lt;p&gt;ML에서 값을 선언하는 방법은 변수명에 값을 바인딩하는 것이다&lt;br /&gt;
그 형식은 val new_name = expression이다&lt;br /&gt;
만일 새로운 값을 바인딩하려면 새로운 변수명에 새로운 값을 바인딩하여 테이블에 새로운 엔트리로 생성해야 한다&lt;br /&gt;
val의 정상적인 사용은 표현식에서 사용하는 변수에 대해, Let안에서 바인딩하는 것이다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;radius&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

      &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;14159&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

   &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;radius&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;radius&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

   &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;예에서 radius와 pi는 표현식에 제한된 변수임을 명확히 선언하고 있다&lt;/p&gt;

&lt;p&gt;많이 쓰이는 고차 함수로 리스트를 필터링하는 filter함수가 있다&lt;br /&gt;
필터는 다음과 같이 동작한다&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;필터는 술어 함수를 파라미터로 받아들여서, 술어 만족 여부에 따라 필터링하는 함수를 반환한다(술어 함수는 종종 fn으로 정의된 람다 표현식으로 주어진다)&lt;/li&gt;
  &lt;li&gt;반환된 필터링 함수는 리스트를 파라미터로 받아들여서 다음과 같이 처리한다&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;각 리스트 요소에 대해 술어함수를 적용하여 술어 조건을 만족시키는지 검사&lt;/li&gt;
  &lt;li&gt;그 결과가 참이면, 리스트 요소를 새로운 리스트(결과 리스트)에 추가한나다&lt;/li&gt;
  &lt;li&gt;참이 아니면, 스킵한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3.이렇게 생성된 새로운 리스트를 결과로 반환한다&lt;/p&gt;

&lt;p&gt;필터의 사용을 보면 Filter(fn(x)) =&amp;gt; x &amp;lt;100, [25, 1, 50, 711, 100, 150, 27, 161, 3]);는 결과로서 100보다 작은 요소만으로 구성된 새로운 리스트 [25, 1, 50, 27, 3]를 반환한다&lt;/p&gt;

&lt;p&gt;많이 쓰이는 다른 함수로 map함수가 있다&lt;br /&gt;
map함수는 파라미터로 함수 (fa)를 받아 들여서 새로운 함수를 만든다&lt;br /&gt;
새로운 함수는 파라미터로 리스트를 받아 들인다&lt;br /&gt;
각 리스트 요소에 파라미터로 받은 함수(fa)를 적용한다&lt;/p&gt;

&lt;p&gt;합성 함수는 val h = g o f로 정의하며, 이것은 h(x) = g(f(x))와 같다&lt;/p&gt;

&lt;p&gt;커링은 하나 이상의 파라미터를 가진 함수를 하나의 파라미터를 가진 함수로 교체하는 것이다&lt;br /&gt;
하나의 파라미터를 가진 함수는 함수를 반환하며, 반환된 이 함수는 초기 함수의 다른 파라미터를 받아 들여 결과를 반환한다&lt;br /&gt;
예를 들어, (DEFINE (add x y)(+ x y))의 커리 함수는 DEFINE (add y) (LAMBDA (x) (+ y x))이며, 이것이 호출되면, 그 결과는 (+ y x)으로 리덕션된다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;haskell&quot;&gt;Haskell​&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Haskell은 순수 함수 언어로 알려져 있다&lt;br /&gt;
연산자는 표시 방식만 다를 뿐 다른 FPL과 거의 같다&lt;/p&gt;

&lt;p&gt;Haskell 역시 앞에서 Scheme에서 본 것과 유사한 let 컨스트럭트를 지원한다&lt;/p&gt;

&lt;p&gt;다른 언어와 다르게 지연 평가를 수행하며, 표현식은 값이 필요할 때에만 평가된다&lt;/p&gt;

&lt;p&gt;이에 비해 이른(eager) 평가에서는 함수가 호출되기 전에 미리 함수에 대한 파라미터를 평가한다&lt;br /&gt;
따라서 엄격한 시맨틱스를 갖는다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;support-fp-in-ipl&quot;&gt;Support FP in IPL&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;자바 스크립트에서는 이름을 가진 함수를 정의할 수 있다&lt;br /&gt;
ex) 함수명 (파라미터 여러개) { 표현식 (블록)}&lt;/p&gt;

&lt;p&gt;여기서 함수명을 빼면 익명의 함수를 정의하게 된다&lt;/p&gt;

&lt;p&gt;파이썬에는 람다 표현식이 가능하다&lt;br /&gt;
즉, lambda a,b: 2*a-b라고 하면, 파라미터 a,b로 이름이 없는 익명의 함수를 정의하는 것이다&lt;br /&gt;
파라미터와 함수 바디를 콜론으로 구분한다&lt;/p&gt;

&lt;p&gt;파이썬에서는 고차 함수 filter와 map를 정의할 수 있다&lt;br /&gt;
이들은 첫째 파라미터로 모두 람다 표현식을 사용하며, 두번째 파라미터로 시퀀스 타입을 사용한다&lt;br /&gt;
두 함수 모두 두번째 파라미터와 동일한 타입의 시퀀스를 결과로 반환한다
예를 들어 map(lambda x : x**3, [2, 4, 6, 8]이라고 하면, 반환 결과는 [8, 64, 216, 512]이다&lt;br /&gt;
이 예에서 첫번째 파라미터는 함수(표현식)임을 기억하라&lt;/p&gt;

&lt;p&gt;이 map은 2004년 구글의 MapReduce의 map과 같은 의미이며, ​병렬 처리의 한 방법으로 유명해졌다&lt;/p&gt;

&lt;p&gt;파이썬은 파라미터의 개수를 제한하고, ​명시적으로 새로운 함수를 정의하고 적용할 수 있도록 partial 함수를 지원한다&lt;br /&gt;
먼저 제한적으로 적용하려는 함수를 임포트하고,​ (여기서 add5는 add a b : a + b에서 파라미터를 ​한 개로 줄여서 add + 5로 정의한 것이다.)​ 명령문 add5=partial (add, 5)은 함수 add+5를 add5로 정의하고, ​함수 add5(15)를 적용(호출)하면 결과는 20이다&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">FPLs</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Lambda Calculus​</title>
      <link href="https://lee989898.github.io/pl-19" rel="alternate" type="text/html" title="Lambda Calculus​" />
      <published>2021-11-17T19:18:00+09:00</published>
      <updated>2021-11-17T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-19</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-19">&lt;h3 id=&quot;lambda-calculus&quot;&gt;&lt;strong&gt;Lambda Calculus​&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;why-functional-programming&quot;&gt;&lt;strong&gt;Why functional programming?​&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;함수 프로그래밍이 왜 필요한가?&lt;br /&gt;
소프트웨어 제품이 신뢰성이 낮고, 관리하기 어려우며, 올바른지 증명하기 하기 어렵다. 그 이유는 다음과 같다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;소프트웨어를 새로 릴리즈할 때마다, 알려진 오류는 수정되나 새로운 오류가 발견된다​&lt;/li&gt;
  &lt;li&gt;소프트웨어의 정밀한 설계는 오랜 기간의 연구 개발을 필요로 하나, 현실적으로 시장 출시 압박이 우선한다 ​&lt;/li&gt;
  &lt;li&gt;하드웨어의 처리 능력이 증가함에 따라 과거에 못하던 복잡한 어플리케이션을 자동화하느라, 소프트웨어의 복잡도가 증가한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 현상을 극복하기 위해, 컴퓨터 과학자들은 두가지 중요한 문제를 풀어야 한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;저비용으로 대규모 소프트웨어의 신뢰성과 사용자 편의성을 개선하는 방법 ​&lt;/li&gt;
  &lt;li&gt;저비용으로 처리 능력을 증가시키는 방법&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 문제에 대한 해결책으로&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;명령형 프로그래밍을 지지하는 측에서는, 소프트웨어 공학, 프로그램 증명 기법, 스펙을 프로그램으로 변환하는 기법, 새로운 (병렬) 컴퓨터 아키텍처 등을 연구해 왔다&lt;/li&gt;
  &lt;li&gt;함수 프로그래밍을 지지하는 측에서는 프로그램으로서의 함수를 대안으로 연구해 왔다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;imperative-and-functional-programming-style&quot;&gt;&lt;strong&gt;Imperative and Functional programming style​&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;계산 모델을 튜링 머신에 기반한 IPL은 기본 개념으로 ​메모리, 변수, 할당문, 반복처리(iteration)을 갖는다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;메모리는 프로그램과 데이터를 저장한다&lt;/li&gt;
  &lt;li&gt;변수는 메모리 셀을 차지하고 있으며, 계산 결과의 변화에 따라 변경 가능한 값을 저장한다 ​&lt;/li&gt;
  &lt;li&gt;할당문은 계산 결과를 메모리에 저장하며, 이를 통해 변수의 값을 변경시킨다&lt;/li&gt;
  &lt;li&gt;Iteration은 값이 변하는 변수를 통해 반복처리를 제어한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;명령형 프로그래밍의 장점은 실행 시스템의 구현이 단순하고 저비용 고효율이다&lt;br /&gt;
명령형 프로그래밍의 단점은 ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Goto는 아무런 조건없이 점프만하기 때문에, ​프로그램의 올바름을 판단하기 어렵게 만든다&lt;/li&gt;
  &lt;li&gt;난로컬 변수와 할당문으로 인해 부작용이 발생하며, ​이로 인해 프로그램의 올바름을 판단하기 어렵게 만든다&lt;/li&gt;
  &lt;li&gt;알고리즘의 어느 부분이 동시 처리 가능한지, ​동시처리하면 안되는지 탐지하기 어려워서, ​알고리즘이 필요 이상으로 순차적이다​&lt;/li&gt;
  &lt;li&gt;최근 들어 많은 연구자들은 소프트웨어 위기와 속도 문제가 ​명령형 언어와 튜링 머신의 계산 모델에 기인한다고 추측하고 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;함수 프로그램에서는&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;함수 파라미터의 실제 ‘값’이 함수 호출의 결과를 유일하게 결정한다 ​&lt;/li&gt;
  &lt;li&gt;할당문이 없어서 함수의 부작용이 발생할 수 없다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;FUNCTION&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;increment&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INTEGER&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INTEGER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;BEGIN&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;increment&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;41&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;increment&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;41&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;함수의 결과는 파라미터의 값에 의해서만 결정되므로, ​어떠한 조건 하에서도 그 결과는 같다. ​이것을 referential ransparenc라고 한다. ​이러한 이유로, 함수 increment의 결과 값은 둘다 42이다&lt;/p&gt;

&lt;p&gt;함수 프로그래밍 언어에서는 함수를 ‘일등 시민’으로 취급한다. 따라서 함수를 파라미터로 주고 받을 수 있다&lt;br /&gt;
명령형 프로그래밍 언어에서는 함수를 파라미터로 주고 받을 수 없다&lt;br /&gt;
함수 프로그래밍 언어는 함수의 일반적인 사용(합성 함수 f(g(x)) 등)을 지원한다. 이것은 종래의 명령형 언어에서 허용되지 않는다&lt;/p&gt;

&lt;p&gt;함수 프로그래밍 언어는 계산 모형을 람다 계산학에 기반하고 있으며, ​기본 개념으로 표현식(expression), 리커젼, 평가, 변수가 있다&lt;br /&gt;
표현식은 수학식을 의미하며, ​리커젼은 재귀 함수에 의한 반복처리로서, iteration과 다르다&lt;br /&gt;
평가는 함수의 실행을 의미하지만, 아무 것도 수정하지 않는다&lt;br /&gt;
변수는 수학적 의미의 변수로서 알려지지 않은 값을 가지며, ​구체적인 값의 추상화일 뿐, 메모리를 차지하지 않는다. 따라서 값의 placeholder 역할을 하며, 수정 불가능하다&lt;br /&gt;
FPL에서는 명령형 언어적 의미의 변수가 없으므로, ​iteration이 불가능하며, ​대신에 반복처리를 위한 리커젼이 있다&lt;/p&gt;

&lt;p&gt;FPL의 장점은 ​IPL의 기본 개념이 없어서, 소프트웨어 신뢰성을 높인다&lt;br /&gt;
프로그래머는 함수를 정의하기만 하고, 인터프리터(실행 시스템)가 계산한다&lt;br /&gt;
할당문이 없고, 변수의 개념이 IPL의 변수와 다르고, 부작용이 없다&lt;br /&gt;
변수는 ‘아직 알려지지 않은 값’을 명명하고 언급한다&lt;br /&gt;
부작용이 없어서, 올바름 증명이 쉽고, 함수의 평가는 순서에 무관하다. 따라서 FPL은 병렬 처리에 적합하다&lt;/p&gt;

&lt;p&gt;FPL의 단점은, ​우선, 실행 속도가 매우 느려서 비효율적이다&lt;br /&gt;
그 이유는 다음과 같다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;머신 아키텍처가 함수 언어에 적합하게 설계되지 않았다 ​&lt;/li&gt;
  &lt;li&gt;함수 호출 비용이 비싸다. 특히 지연 평가시에&lt;/li&gt;
  &lt;li&gt;파괴적 갱신(갱신되면 먼저 값이 없어짐)에 적합하므로, ​효율적인 컴파일 방법을 찾기 어렵고, 어떤 알고리즘에 대해, 시간 및 공간 복잡도가 너무 높다. ​이러한 경우에 효율을 위해 프로그램 변환이 필요하다&lt;/li&gt;
  &lt;li&gt;아직 효율적인 컴파일 방법이 널리 사용 가능하지 않다. 많은 경우에 함수 프로그램의 효율이 받아 들일 수 있는 수준에 있지만, ​컴파일 방법이 매우 복잡하고 연구 수준에 머물어 있다&lt;br /&gt;
명령형 프로그램의 특성이 강한 어플리케이션에 아직 부적합하다&lt;/li&gt;
  &lt;li&gt;상호 작용이 강한 어플리케이션을 함수 프로그래밍 스타일로 표현하는 능력이 아직은 부족하다. 이들 어플리케이션으로는 상호적 프로그램, DBMS, OS, 프로세스 컨트롤 등이다&lt;/li&gt;
  &lt;li&gt;함수 프로그래밍 기술 개발이 필요하다. 함수 스타일로 표현하기 어려운 어플리케이션을 함수 스타일로 표현하는 방법을 개발하는 것이 필요하다.  현재, 윈도우, 다이알로그, 메뉴 등을 사용하는 상호적 프로그램을 함수 언어로 명세화하는 방법이 알려져 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;functions-as-programs-&quot;&gt;&lt;strong&gt;Functions as programs&lt;/strong&gt; ​&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;함수가 프로그램인가?&lt;/p&gt;

&lt;p&gt;팩토리알을 구하는 함수는 프로그램이라고 간주해도 문제가 없다. ​프로그램의 종료 확인 함수(Halting)는 계산 가능하지 않고, 따라서 원하는 결과를 생산하지 못한다&lt;br /&gt;
함수가 임의의 프로그램에 대해 halting 함수를 계산한다고 하자. ​만일 파라미터 프로그램이 종료되지 않는다면 ​Halting 함수는 종료되지 않을 것이고, ​Result 0이 절대로 생산되지 않는다&lt;/p&gt;

&lt;p&gt;이들 예에서 함수는 람다 계산학에 기반한 계산 모델을 사용하여 평가된다. 평가는 IPL의 실행과 유사하지만, IPL의 파괴적 갱신이 없다는 면에서 다르다.​ 람다 계산학은 함수 정의 방식과 변수 대체 규칙(substitution)으로 구성된다&lt;/p&gt;

&lt;p&gt;FPL로 작성된 프로그램은 함수의 모음과 초기 표현식으로 구성된다. ​초기 표현식이란 모든 파라미터가 상수인 (또는 상수로 대체된) 표현식을 말하는데, ​이 식은 평가되어야 한다. -&amp;gt; reduce​&lt;/p&gt;

&lt;p&gt;함수 정의는 표현식 내에서 다음 형태로 구성된다. ​(여기서는 scheme 문법을 차용함)&lt;br /&gt;
define (함수명 파라미터1 … 파라미터n) 표현식)&lt;br /&gt;
이와 같이 함수 프로그램을 정의하는 것은 recursive하다&lt;br /&gt;
표현식은 함수 결과를 명세화하며, 값, 파라미터, 함수 적용(application)을 나타낸다&lt;/p&gt;

&lt;p&gt;함수 적용(application), (f a)는 함수 f를 a에 적용하라는 뜻이다&lt;br /&gt;
초기 표현식은 (+ 2 3), (squareinc 5)과 같이 계산될 수 있는 표현식이다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;evaluation-of-functional-programs&quot;&gt;&lt;strong&gt;Evaluation of functional programs​&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;함수 프로그램의 평가는 실행이나 계산을 의미하는데, 이것은 초기 표현식의 평가와 리덕션(표현식의 축소화)에 의한다&lt;br /&gt;
초기 표현식의 평가는 인터프리터가 수행하며, ​반복적으로 리덕션(또는 rewriting)을 수행한다&lt;/p&gt;

&lt;p&gt;예를 들어 ​&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ident&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;square&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;square&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;squareinc&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;square&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inc&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;square&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;square&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;각 리덕션 단계에서(화살표로 표시)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;함수 적용은 함수의 파라미터를 대응하는 함수 body로 교체하는 것이다. 리덕션 가능한 표현식(redex)은 함수 정의에 따라 rewrite 될 수 있는 서브 표현식을 말한다&lt;/li&gt;
  &lt;li&gt;다음 상황에서 리덕션 과정이 끝난다​&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;더 이상 redex가 남아 있지 않고 ​(즉, 더 이상 어떠한 함수 정의라도 적용할 수 없을 때)​&lt;/li&gt;
  &lt;li&gt;초기 표현식이 가장 단순한 형태(normal form; 상수만 있는 축소화된 표현식)에 있을 때, ​결과를 프린트하고 종료한다​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Order of Evaluation&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;부작용이 없어서, 평가 순서는 무관하다. ​리덕션 가능한 표현식이 다 없어진 후에, ​계산 결과는 항상 같고, 유일하다&lt;br /&gt;
그러나 순서가 완전히 무관한 것은 아니다. ​경우에 따라 리덕션 순서는 결과를 생산하지 못할 뿐더러 종료되지 않을 수 있다&lt;/p&gt;

&lt;p&gt;종료 못하는 리덕션 순서의 예:&lt;br /&gt;
리커젼 함수의 정의가&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;alwaysseven&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만일 앞의 것을 먼저 계산하면, ​(alwaysseven (inf 2)) → (alwaysseven (inf 2)) → … 종료되지 않는다&lt;br /&gt;
그러나 뒤의 것을 먼저 계산하면, ​(alwaysseven (inf 2)) → 7로 종료된다&lt;/p&gt;

&lt;p&gt;리덕션 전략에는 call by value, call by name이 있다&lt;/p&gt;

&lt;p&gt;먼저 리슾, 스킴, 엠엘 등에서 사용되는 call by value를 살펴 보자&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Eager, strict evaluation이라고 한다. ​&lt;/li&gt;
  &lt;li&gt;리덕션 절차에 의해 함수 적용 그 자체가 리덕션 가능한 표현식이라고 간주(확인)되기 전에, ​함수의 파라미터를 항상 리덕션한다 (그것이 초기 표현식일 때) ​&lt;/li&gt;
  &lt;li&gt;파리미터에 대한 함수 적용은 그 파라미터가 값일때만, 리덕션 가능한 표현식이 된다&lt;/li&gt;
  &lt;li&gt;조건 연산자 if의 적용 후에, if의 파라미터를 평가한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하스켈에서 사용되는 Call by name를 살펴 보자&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;lazy evaluation이라고 한다&lt;/li&gt;
  &lt;li&gt;값이 알려져서 초기 표현식이 되고 값을 반환해야 할 때가 되면, ​비로소 리덕션 가능한 서브 표현식의 값이 계산된다​&lt;/li&gt;
  &lt;li&gt;조건 함수의 call by name은 ​첫째 파라미터(if 다음의 부울식)의 평가를 요구한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정리하면, ​Eager는 초기 표현식이 만들어지면 바로 계산하여 리덕션(축소화)하지만, ​Lazy는 초기 표현식이 만들어지더라도 그 식의 값이 필요할(반환해야 할) 때 계산한다&lt;br /&gt;
표현식에 조건함수가 있다면, if 다음의 부울식을 계산해 가면서 표현식을 펼쳐 가면서 리덕션한다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;higher-order-functions&quot;&gt;&lt;strong&gt;Higher-order functions​&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;FPL은 함수의 개념에 대해 일반적인 관점을 갖는다. 함수는 ‘일등 시민’으로 (객체처럼) 취급된다&lt;br /&gt;
함수는 파라미터와 결과로서 함수를 가질(사용할) 수 있다. 고차 함수는 파라미터로 함수를 갖거나 결과로서 함수를 생산한다&lt;br /&gt;
일차 함수는 파라미터와 결과로서 함수가 아닌 값을 갖는다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atzero&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atzero&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inc&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atzero&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;square&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;square&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atzero&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ident&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ident&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;예에서 파라미터로서 함수 f를 갖는다. ​이때 f는 목적에 따라 inc, square, ident 등이 된다. ​이와 같이 파라미터로서 함수를 쓰는 것은 ​동일한 함수를 다른 경우에 적용하는데 유용하다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SG&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;G&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SG&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))))&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PG&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;G&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PG&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))))&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sgen&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sgen&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))))&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pgen&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pgen&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))))&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자연수 n을 인풋으로 받아서 ​sum, product를 구하는 프로그램을 짠다고 하면, ​위와 같다&lt;br /&gt;
위쪽 두개는 함수 파라미터가 없이 ​미리 정의된 함수 G만을 사용하여 계산하는 경우이고, 아래쪽 두개는 함수 파라미터를 갖고 있어서, ​목적에 따라 다양한 함수를 사용하여 계산할 수 있는 경우이다&lt;/p&gt;

&lt;p&gt;파라미터와 결과로서 함수를 갖는 함수의 예로 함수 합성을 들 수 있다&lt;br /&gt;
함수의 합성은 두개의 함수를 인풋으로 받아서, 합성 함수를 반환한다&lt;br /&gt;
​합성 함수를 정의하려면, 함수를 나타내는 표현식을 함수명 없이 쓸 수 있어야 한다. 이와 같은 함수를 익명 함수라고 부르며, 그 신택스는 다음과 같다&lt;br /&gt;
(lambda (파라미터1, … 파라미터n)  body)​ 이것을 이용하여 합성 함수를 정의하면, ​(define (compose f g) (lambda (x) (f (g x))))가 된다​&lt;/p&gt;

&lt;p&gt;파라미터로 주어진 함수와 동일한 유형의 함수와 ​n일 때 갱신된 새로운 값을 반환하는 ​고차 함수의 정의는 다음과 같다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;change&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;at&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기서 람다가 들어가는 이유는 이것이 새로운 함수이기 때문이다&lt;/p&gt;

&lt;p&gt;표현식을 정의하는 신택스는 (define name expr)이다. 표현식의 예는 (define a (+ 3 4)) (* a 2)  결과는 14이다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;data-structures&quot;&gt;&lt;strong&gt;Data structures​&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;FPL의 데이터 구조는 read-only이다&lt;br /&gt;
Overwrite할 수 없고, 글로벌하게 사용하지 못하지만, ​파라미터로서 함수에 패스된다&lt;br /&gt;
리스트는 FPL에서 미리 정의된 자료구조로, recursive하다&lt;/p&gt;

&lt;p&gt;리스트를 구성하는 데 필요한 데이터 컨스트럭터는 다음과 같다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;empty: 엠티 리스트를 나타낸다. ​&lt;/li&gt;
  &lt;li&gt;cons: 값과 리스트를 인풋으로 받아서 v를 첫째 요소로 하는 새로운 리스트를 반환한다. ​&lt;/li&gt;
  &lt;li&gt;여러 값을 리스트로 만들어야 할 때 cons 대신에 list 함수를 사용한다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;리스트의 조작을 위해 미리 정의된 셀렉터는 다음과 같다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;car: 리스트를 인풋으로 받아서 첫째 요소를 반환한다.    ​&lt;/li&gt;
  &lt;li&gt;cdr: 리스트를 인풋으로 받아서 첫째 요소를 제외한 나머지를 반환한다.    ​&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pamuk&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;에서&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;car&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pamuk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;은&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;을&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;반환하고&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cdr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pamuk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;은&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;를&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;반환한다&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;definition-of-lambda-calculus&quot;&gt;&lt;strong&gt;Definition of Lambda calculus&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;람다 계산학은 FPL의 계산 모델이다&lt;/p&gt;

&lt;p&gt;람다 계산학은 하나의 변환 규칙과 하나의 함수 정의 방식(스킴)으로 구성된다&lt;br /&gt;
변환 규칙은 변수 대체로서, 베타 변환이라고도 한다&lt;/p&gt;

&lt;p&gt;표현식은 이름이거나 함수이다
이름은 값을 담고 있는 것의 식별자이고, ​함수는 파라미터의 이름을 표시하기 위해, ​그리스 문자 람다를 사용한다&lt;br /&gt;
함수의 body는 λ&lt;파라미터&gt;의 뒤에 나오는 표현식으로, ​파라미터를 어떻게 재구성할 것인지 명세화한다  
표현식의 (순환적) 정의는 다음 3개의 규칙에 의한다&lt;/파라미터&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;&amp;lt; expression &amp;gt; := &amp;lt; name &amp;gt;&lt;/td&gt;
          &lt;td&gt;&amp;lt; function &amp;gt;&lt;/td&gt;
          &lt;td&gt;&amp;lt; application &amp;gt; ​&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;&amp;lt; function &amp;gt; := λ &amp;lt; name &amp;gt; . &amp;lt; expression &amp;gt; ​&lt;/li&gt;
  &lt;li&gt;&amp;lt; application &amp;gt; := &amp;lt; expression &amp;gt;&amp;lt; expression &amp;gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기서 name은 파라미터명을, application은 함수의 적용을 나타낸다&lt;br /&gt;
함수의 적용은 name과 function이 나열될 수 있다. 앞에서 나온 f a처럼 함수의 body는 &amp;lt; expression &amp;gt; 이다&lt;/p&gt;

&lt;p&gt;합성 표현식은 지속적인 표현식을 적용하여 합성 표현식을 평가한다&lt;br /&gt;
즉, E1E2E3 . . . En ≡  (. . . ((E1E2)E3) . . . En)이다&lt;br /&gt;
여기서 ≡는 동동성(equivalence)를 나타낸다&lt;br /&gt;
모호함을 줄이기 위해, λx.x ≡ (λx.x)와 같이 괄호를 사용한다&lt;/p&gt;

&lt;p&gt;함수는 표현식에 적용될 수 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이러한 경우에 해당되는 단순한 예로, (λx.x)y을 들 수 있다
이것은 y에 identity 함수를 적용하는 것이다&lt;/li&gt;
  &lt;li&gt;이때, 표현식이 모호해 질 수 있으며, 괄호를 써서 모호성을 피한다&lt;/li&gt;
  &lt;li&gt;함수 적용의 평가는 파라미터를 함수 정의의 body로 대체하는 것이다. 위의 예에서, x를 y로 대체하는 것이 함수 적용의 평가이다&lt;br /&gt;
(λx.x)y → [y/x]x → y​에서 [y/x]는 x를 y로 대체하는 것을 나타낸다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;대체하는 것을 베타 리덕션이라고도 한다&lt;br /&gt;
이것을 자세히 들여다 보면, 두 단계로 이루어짐을 알 수 있다​&lt;br /&gt;
파라미터가 표현식을 받아들인다(take in). 이후 표현식으로 body의 파라미터를 교체한다&lt;br /&gt;
리덕션(축소화)은 함수 적용을 통해 ​표현식에 포함된 함수 정의를 줄여 나가는(축소하는) 과정이다&lt;/p&gt;

&lt;p&gt;변수는 자유 변수와 속박 변수로 구분된다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모든 name(변수)는 함수 정의 내에서 로컬이다&lt;/li&gt;
  &lt;li&gt;함수 λx.x에서 body 내의 x는 그 앞에 λx가 있기 때문에 속박 변수이다​. 자유 변수는 name 앞에 λ가 없다​&lt;/li&gt;
  &lt;li&gt;표현식 (λx.x)(λy.yx)에서, 첫째 표현식의 body에 있는 x는 첫째 λ에 속박되어 있다. 두번째 표현식의 body에 있는 y는 두번째 λ에 속박되어 있다.  두번째 표현식의 body에 있는 x는 자유변수이며, 첫번째 표현식의 x와 전적으로 독립적이다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\pl\pl51.png&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 그림은 표현식 (λx.x)(λy.yx)의 베타 리덕션을 보여준다&lt;br /&gt;
앞 표현식의 x가 두번째 표현식을 받아 들여서 ​앞 표현식의 body의 x를 두번째 표현식으로 교체한다. 이와 같이 함수 적용을 통해, 표현식의 함수 정의를 제거함으로써, ​표현식을 축소해 나간다&lt;/p&gt;

&lt;p&gt;베타 리덕션의 조금 복잡한 사례를 살펴 보자&lt;br /&gt;
표현식이 (λx.(λy.xy))y 라고 하자&lt;br /&gt;
대체할 때, 자유 변수와 속박 변수를 혼동하지 않도록 조심해야 한다&lt;br /&gt;
왼쪽의 함수는 속박변수 y를 포함한다. ​오른쪽 표현식의 y는 괄호 밖에 있으며, 따라서 자유 변수이다. ​변수 y는 왼쪽에서는 속박 변수, 오른쪽에서는 자유 변수이다. ​이때 이들을 혼동하면 (λy.yy) 로 잘못 리덕션된다&lt;br /&gt;
혼동을 피하려면, 속박 변수 y를 t로 재명명(rename)하면 된다&lt;/p&gt;

&lt;p&gt;교체했다고 가정하고, ​새로 교체한 변수가 이후의 표현식에서 기존의 바운드 변수로 사용되었다면, ​전혀 다른 두 변수가 동일한 이름을 쓰게 되기 때문에, ​새로 교체한 변수와 기존의 바운드 변수를 구분할 필요가 있다&lt;br /&gt;
이를 위해 기존의 바운드 변수를 재명명(rename)한다&lt;br /&gt;
그러나 (λx.(λt.xt))y 와 같이 끝의 y는 free이므로 rename하지 않는다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;arithmetic-functions&quot;&gt;&lt;strong&gt;Arithmetic functions​&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;≡&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;λ&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;S0&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;≡&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;λ&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;λ&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;λ&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;≡&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;S1&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;≡&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;λ&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;λ&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;→&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;λ&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;≡&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Successor 함수를 이와 같이 정의하자&lt;br /&gt;
여기서 n은 a의 개수이다. 앞에서 정의한 0, 1, 2, 3을 참고하자&lt;/p&gt;

&lt;p&gt;그렇다면 Addition과 Multiplication 함수는 ​Successor 함수를 이용하여 다음과 같이 정의할 수 있다&lt;br /&gt;
2+3은 2S3으로, (λsz.s(sz)))S3 로 정의할 수 있고, 이것을 리덕션하면, ​→S(S3) → · · · → 5 가 된다
3*3은 (λxya.x(ya))33 → (λa.3(3a)) 으로 정의되며, ​이것을 리덕션하면 9가 된다&lt;/p&gt;

&lt;p&gt;—​&lt;/p&gt;

&lt;h2 id=&quot;recursion&quot;&gt;&lt;strong&gt;Recursion&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;리커젼은 순환적으로 정의된 데이터에 대한 함수 정의에 자연스럽게 적용되는 절차이다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Y&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;≡&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;λ&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;λ&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;λ&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;함수 Y를 이와 같이 정의한다&lt;br /&gt;
Y를 함수 R에 적용하면, YR은 이와 같다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;YR&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;≡&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;λ&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;λ&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;  &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이것을 리덕션하면, YR -&amp;gt; R(YR)가 된다. ​람다 계산학에서 리커젼은 이와 같이 표현되며, ​R의 평가(계산)은 YR의 순환 호출을 사용한다&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">Lambda Calculus​</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Concurrency</title>
      <link href="https://lee989898.github.io/pl-18" rel="alternate" type="text/html" title="Concurrency" />
      <published>2021-11-10T19:18:00+09:00</published>
      <updated>2021-11-10T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-18</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-18">&lt;h3 id=&quot;comcurrency&quot;&gt;&lt;strong&gt;Comcurrency&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;동시 실행은 인스트럭션 수준, 문장 수준, 서브프로그램 수준, 프로그램 수준, 이렇게 4개 수준에서 이루어 질 수 있다&lt;/p&gt;

&lt;p&gt;인스트럭션 수준에서는 두개 이상의 머신 인스트럭션을 동시에 실행한다. 문장 수준에서는 두개 이상의 고급언어 문장을 동시에 실행한다. 서브프로그램 수준에서는 두개 이상의 서브프로그램을 동시에 실행한다. 프로그램 수준에서는 두개 이상의 프로그램을 동시에 실행한다&lt;/p&gt;

&lt;p&gt;동시 실행 통제 메커니즘은 프로그래밍의 유연성을 증가시킨다&lt;br /&gt;
동시 실행 통제 메커니즘은 원래 운영체제의 문제를 풀기 위해 발명되었으나, ​다양한 응용 프로그램에서도 요구된다&lt;/p&gt;

&lt;p&gt;프로그램 수준의 동시 실행 사례는 웹에서 볼 수 있다&lt;br /&gt;
웹 브라우저는 다음과 같은 여러가지 기능을 동시에 실행해야 한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;웹 서버에게 데이터를 주고 받기&lt;/li&gt;
  &lt;li&gt;텍스트와 이미지를 스크린에 렌더링하기​&lt;/li&gt;
  &lt;li&gt;마우스와 키보드에 의한 사용자 액션에 대응하기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;IE9는 별도의 코어를 사용하여 클라이언트 측의 스크립트 코드를 인터프러터 방식으로 처리한다.  ​&lt;/p&gt;

&lt;p&gt;문장 수준의 동시 실행은 프로그램 수준의 경우와 매우 다르다&lt;br /&gt;
언어 설계자는 문장 수준의 동시 실행을 위해 다음에 대해 중점을 둔다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;데이터를 다수의 메모리에 어떻게 분산시킬 것인가? ​&lt;/li&gt;
  &lt;li&gt;어느 문장을 동시 실행할 것인가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;동시 실행 알고리즘은 확장성이 있어야 한다&lt;br /&gt;
사용하는 프로세서의 수를 증가시킬수록 실행 속도가 증가하면, 확장성이 있다고 말한다&lt;/p&gt;

&lt;p&gt;알고리즘은 이식성이 있어야 한다&lt;br /&gt;
알고리즘이 다른 아키텍처의 기계에서 효율적으로 실행된다면, ​이 알고리즘은 이식성이 있다고 말한다&lt;br /&gt;
이식성은 하드웨어의 수명이 비교적 짧아지고 있어서, 매우 중요하다&lt;/p&gt;

&lt;p&gt;플린은 컴퓨터를 다음과 같이 분류하였다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SISD는 하나의 인스트럭션이 하나의 데이터를 처리하는 것으로, ​프로세서가 하나인 컴퓨터가 이에 속한다&lt;/li&gt;
  &lt;li&gt;SIMD는 하나의 인스트럭션으로 여러 데이터를 처리한다. ​벡터 프로세서가 이에 속하며, 벡터 프로세서는 벡터 연산자의 여러 오퍼랜드를 저장하는 여러 개의 레지스터를 갖고 있어서, ​이들 여러 오퍼랜드에 대해 하나의 인스트럭션을 실행한다&lt;/li&gt;
  &lt;li&gt;MISD는 하나의 데이터에 대해 다수의 인스트럭션을 차례로 동시 실행한다. ​마치 파이프라인처럼, 파이프라인 컴퓨터가 이에 속한다 ​&lt;/li&gt;
  &lt;li&gt;MIMD는 다수의 인스트럭션이 다수의 데이터를 동시 실행한다. MIMD는 여러 개의 프로세서로 구성되며, 각 프로세서는 자신의 인스트럭션 스트림을 처리한다
    &lt;ul&gt;
      &lt;li&gt;​MIMD 컴퓨터에는 분산형과 공유 메모리형, 두가지 유형이 있다. ​분산 MIMD 머신은 하나의 랙에 구성되거나 각 지역에 분산되어 구성되며, ​각 프로세서는 자신의 고유 메모리를 갖는다&lt;/li&gt;
      &lt;li&gt;공유메모리 MIMD 머신은 여러 프로세서가 하나의 메모리를 공유하며, ​메모리 액세스의 충돌을 방지하기 위한 동기화 수단을 제공해야 한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;플린의 분류에 따라, 각각의 머신을 그림으로 표현하면 이 아래 그림과 같다. PU는 프로세싱 유닛으로 싱글 코어 및 멀티코어 프로세서이다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\pl\pl48.png&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;동시 실행을 필요로 하는 이유는 다음과 같다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램이 하드웨어를 동시에 사용하도록 설계되었다면, ​멀티 프로세서 머신에서 프로그램의 실행 속도는 빠르다&lt;/li&gt;
  &lt;li&gt;프로그램이 컴퓨트 바운드가 아니라면, ​싱글 프로세서 머신에서 실행하더라도, ​동시 실행하도록 짜여진 프로그램은 순차 실행하도록 짜여진 프로그램보다 빠르다&lt;/li&gt;
  &lt;li&gt;동시 실행은 문제 해결책에 대한 다른 방식의 개념화 방법을 제공한다. 문제의 해결책을 설계할 때 Recursion이 자연스러운 방법인 경우가 있는 것처럼, ​동시 실행이 자연스러운 문제가 많이 있다&lt;br /&gt;
예를 들어 시뮬레이션은 여러 개의 엔티티를 포함하고, ​여러 엔티티가 자신에게 주어진 역할을 수행한다. 이때 각 엔티티는 서로 종속되어 있지 않기 때문에 동시 실행이 가능하다. 이와 같이 문제에 따라서 동시 실행이 자연스러운 경우가 있다&lt;/li&gt;
  &lt;li&gt;어플리케이션 프로그램을 여러 머신에 분산시켜야 하는 경우가 있다.  ​이때, 각 머신은 특정 타스크(동시 실행 통제 메커니즘)를 실행하면서, 프로그램 실행을 동기화해야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;semaphore&quot;&gt;&lt;strong&gt;Semaphore&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;프로그램이 여러 서브프로그램으로 구성되어 있을 때, ​동일 프로그램 내의 다른 서브프로그램과 동시 실행되는 서브프로그램을 Task 또는 Process라고 한다&lt;/p&gt;

&lt;p&gt;자바에서는 특정 메소드, 즉 run method가 Task의 역할을 하며, ​이 메소드는 쓰레드라고 불리는 객체 내에서 실행된다&lt;/p&gt;

&lt;p&gt;동시 실행되는 Task들 간에 실행 순서를 통제하는 것을 동기화라고 한다&lt;br /&gt;
협력적 동기화는 Task A가 Task B의 종료를 기다렸다가, Task B의 종료 후 Task A가 실행하는 방식으로, 실행 순서를 통제한다&lt;br /&gt;
경쟁적 동기화는 Task A, B가 공유 변수(데이터 위치) x를 접근할 필요가 있다면, ​Task B가 x를 접근하고 있는 동안, Task A는 Task B가 x의 접근을 종료하기를 기다리는 방식으로 실행 순서를 통제한다&lt;/p&gt;

&lt;p&gt;가장 단순한 형태의 협력적 동기화의 예로 생산자-소비자 문제를 들 수 있다&lt;br /&gt;
하나의 서브 프로그램(생산자)이 데이터를 생산하고, ​다른 서브프로그램(소비자)이 그것을 소비한다. 생산된 데이터는 보통 스토리지 버퍼에 저장된다&lt;/p&gt;

&lt;p&gt;경쟁적 동기화는 두 Task가 정확히 동시에 공유 변수에 대한 접근을 방지해야 한다&lt;/p&gt;

&lt;p&gt;만일 TOTAL이 공유 변수이고, ​Task A가 TOTAL+1, Task B가 TOTAL*2고 Task A, B가 동시에 TOTAL을 변경하고자 한다면, ​이들 간에 공유 변수에 대한 레이스 컨디션이 발생한다&lt;br /&gt;
이를 해결하기 위해 상호배제를 보장해 줘야 하는데, ​이때 데드락이 발생할 수 있다. 따라서 데드락 방지책도 함께 제공해야한다&lt;/p&gt;

&lt;p&gt;동시 실행을 위한 언어 설계 시, 고려사항은 다음과 같다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;경쟁 및 협업 동기화​&lt;/li&gt;
  &lt;li&gt;Task 스케줄링​&lt;/li&gt;
  &lt;li&gt;Task를 언제 어떻게 생성하고, Task의 실행을 언제 어떻게 시작 및 종료시킬 것인가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;세마포어는 Task 동기화에 사용되는 단순한 메커니즘이다&lt;br /&gt;
세마포어는 카운터(정수)와 Task 서술자를 저장하는 큐로 구성되며, ​Task 서술자는 Task 실행 상태에 관한 모든 관련 정보를 저장한다. 연산자는 wait, release가 있다&lt;/p&gt;

&lt;p&gt;협력 동기화를 위한 세마포어 변수는 다음과 같다&lt;br /&gt;
엠티스팟 세마포어는 엠티스팟 카운터와 엠티스팟 큐로 구성되며, ​풀스팟 세마포어는 풀스팟 카운터와 풀스팟 튜로 구성된다&lt;/p&gt;

&lt;p&gt;엠티스팟 카운터는 버퍼의 비어있는 칸의 수를 나타내고,​ 풀 카운터는 버퍼의 채워진 칸의 수를 나타낸다&lt;/p&gt;

&lt;p&gt;엠티스팟 큐는 버퍼에 빈칸이 생기기(즉, 아이템이 나가기)를 기다리는 생산자의 Task를 저장하고, 풀스팟 큐는 버퍼에 아이템이 채워지기를 기다리는 소비자의 Task를 저장한다&lt;/p&gt;

&lt;p&gt;협력 동기화를 위해 필요한 공유 버퍼에 대한 연산자는 ​디파짓과 펫치가 있다&lt;/p&gt;

&lt;p&gt;먼저 디파짓을 살펴 보면, ​디파짓은 공유 버퍼에 데이터를 넣기 위한 생산자의 액션으로 다음과 같이 진행된다​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;버퍼에 빈칸이 있는지 엠티스팟 세마포어를 검사한다​&lt;/li&gt;
  &lt;li&gt;만일 적어도 하나 있으면, 디파짓을 실행하고, 엠티스팟의 카운터를 -1 하고, 풀스팟의 카운터를 +1한다 (버퍼에 채워진 칸이 하나 이상 있다는 것을 나타냄)​&lt;/li&gt;
  &lt;li&gt;만일 버퍼가 꽉차면, 엠티스팟 큐에 생산자의 Task 서술자를 넣고, 버퍼에 빈칸이 생길 때까지 기다린다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음, 펫치를 살펴 보자&lt;br /&gt;
펫치는 버퍼로부터 데이터를 빼내기 위한 소비자의 액션으로 다음과 같이 진행된다&lt;br /&gt;
버퍼가 비어있지 않은지 풀스팟 세마포어를 검사한다. 만일 비어있지 않다면, 펫치를 실행하고(버퍼로부터 데이터를 빼내고), 엠티스팟 카운터를 -1하고, 풀스팟 카운터를 +1한다&lt;br /&gt;
만일 버퍼가 비어있다면, 풀스팟 큐에 소비자의 Task 서술자를 넣고, 데이터가 생길 때까지 기다린다&lt;/p&gt;

&lt;p&gt;앞의 버퍼에 대한 연산에서 보았듯이, 디파짓과 펫치는 ​세마포어의 카운터와 버퍼에 대한 조작(+, -, 디파짓, 펫치)을 수반한다&lt;/p&gt;

&lt;p&gt;디파짓과 펫치는, ​이 연산을 세마포어에 대해 직접 수행할 수 있지만, 세마포어에 대한 ‘연산’을 별도로 정의하고, 이를 통해 세마포어 조작을 간접적으로 수행하기도 한다&lt;/p&gt;

&lt;p&gt;이때 세마포어에 대한 연산은 wait(빨간불)과 release(초록불)이다&lt;br /&gt;
wait에서, 카운터가 0보다 크면 카운터 -1한다. 만일 카운터가 0보다 크지 않으면, 큐에 Task 서술자를 넣고 기다린다​&lt;br /&gt;
release에서, 큐가 비어 있으면, 카운터를 +1한다. 만일 큐가 비어 있지 않으면, 큐에서 Task를 빼서 실행한다&lt;/p&gt;

&lt;p&gt;컴피티션이 언제 어디에서 일어나는가?&lt;br /&gt;
Shared variable을 서로 갱신하겠다고 동시에 요청할 때 발생한다&lt;br /&gt;
이때 shared variable에 대한 mutual exclusion(상호배제)를 위해 ​별도의 세마포어가 필요하다&lt;br /&gt;
그런데 이 세마포어는 카운터가 필요없다. 이러한 이유로 이진 세마포어로 정의한다&lt;br /&gt;
만일 앞의 shared buffer의 협력적 동기화 문제에서, ​한번에 하나의 Task만 버퍼에 접근할 수 있다고 제한한다면, Shared buffer에 대한 별도의 이진 세마포어가 필요하다&lt;/p&gt;

&lt;p&gt;브린치 한센이 세마포어에 대해 말하기를, ​세마포어는 무결점의 프로그래머를 위한 동기화 도구이다&lt;br /&gt;
그러나 이런 프로그래머는 매우 드물다. ​따라서, 세마포어의 사용은 동기화의 신뢰성 문제를 야기한다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;monitor&quot;&gt;&lt;strong&gt;Monitor&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;세마포어의 사용은 동기화의 신뢰성 문제를 야기한다&lt;/p&gt;

&lt;p&gt;모니터는 이와 같이 동기화의 신뢰성 문제를 해결하기 위한 방법으로&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;공유 데이터 구조를 연산자로 캡슐화하여 ​&lt;/li&gt;
  &lt;li&gt;프로그래머로부터 공유 데이터구조의 상세 사항을 숨긴다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이렇게 하여 동기화에 대한 책임을 런타임 시스템으로 돌린다 ​&lt;/p&gt;

&lt;p&gt;모니터는 class로 구현될 수 있다​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;공유 데이터 타입을 갖는 추상 데이터 타입으로 표현 ​&lt;/li&gt;
  &lt;li&gt;이 클래스의 객체에 대한 접근은 액세스 메소드에 동기화 modifier를 추가하여 통제한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;모니터는 concurrent pascal, ada, java 등에서 지원된다&lt;/p&gt;

&lt;p&gt;사용자 프로그램은 모니터를 사용하여 공유 버퍼에 접근한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;공유 데이터는 사용자 프로그램 안에 없고, 모니터 안에 있다 ​&lt;/li&gt;
  &lt;li&gt;액세스 메커니즘은 모니터(런타임 시스템)의 일부분으로, 상호 배제를 보장한다. 즉, 모니터가 바쁠 땐, 모니터에 대한 호출이 block되고 큐에 들어가서 기다린다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\pl\pl49.png&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 모니터를 표현한 것이다. 모니터는 상호배제만을 제공하기 때문에, ​협력 동기화에서 요구되는 프로세스 간의 협력은 프로그래머가 코딩해야 한다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;자바-쓰레드&quot;&gt;&lt;strong&gt;자바 쓰레드&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;쓰레드는 run 메소드를 실행하는 프로세스이다&lt;br /&gt;
즉, run 메소드는 쓰레드에 할당되어야 실행된다. 쓰레드 클라스는 쓰레드가 아닌 다른 클라스의 부모가 될 수 없고, ​쓰레드의 서브 클래스에게 서비스를 제공한다&lt;/p&gt;

&lt;p&gt;Run method는 자바에서 동시 실행 단위로서, ​Run 메소드 코드는 main 메소드, 다른 run 메소드 등과 동시 실행 된다&lt;/p&gt;

&lt;p&gt;Run 메소드로 클라스를 정의하는 방법은 두 가지가 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;첫째 방법은, 쓰레드 클래스의 서브클래스를 정의하여 서브 클라스의 run 메소드로 오버라이드하는 방법이다. 만일 새로운 서브 클래스가 다른 부모를 갖고 있으면, 이 방법은 동작하지 않는다&lt;/li&gt;
  &lt;li&gt;둘째 방법은, 다른 부모로부터 상속된 서브 클래스를 정의하고 runnable 인터페이스를 구현하는 방법이다. Runnable은 run 메소드 프로토콜을 제공하기 때문에, runnable로 구현된 어떤 클래스도 run 메소드를 정의한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정리하면, 쓰레드 클래스는 다른 클라스의 부모가 될 수 없기 때문에, ​어플리케이션 클라스의 메소드를 쓰레드로 실행하려면 runnable로 실행해야 한다&lt;/p&gt;

&lt;p&gt;​쓰레드 클라스는 동시 실행 자바 프로그램을 생성한다. 쓰레드 클라스는 컨스트럭트, 메소드 등으로 구성된다&lt;/p&gt;

&lt;p&gt;쓰레드 클라스의 메소드는 ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Run 메소드는 쓰레드의 액션을 서술한다​&lt;/li&gt;
  &lt;li&gt;Start 메소드는 run 메소드를 호출하여, 그 쓰레드의 동시 실행을 시작한다&lt;/li&gt;
  &lt;li&gt;setPriority 메소드는 쓰레드의 우선순위를 변경하고 ​&lt;/li&gt;
  &lt;li&gt;getPriority 메소드는 쓰레드의 현재 우선순위를 반환한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​아래 코드는 run 메소드로 쓰레드의 액션을 서술하고, ​Start 메소드로 그 쓰레드의 동시 실행을 시작하는 것을 보여준다&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyThread&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myTh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myTh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Yield 메소드는 동시 실행중인 쓰레드로부터 프로세서의 자발적인 포기를 요구한다
이 쓰레드는 즉시 프로세서를 포기하고 ready 큐로 들어 간다
Sleep 메소드는 쓰레드가 지정된 시간이 지난 후에 block되기를 원한다
이 쓰레드는 ready 큐에 들어간다
Join 메소드는 메소드에게, ​다른 쓰레드의 run 메소드가 종료될 때까지, ​실행을 msec 단위로 지연시킬 것을 강요한다
아래 코드는 join 메소드의 사용 예를 보여준다&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myTh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myTh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// do part of the computation of this thread​&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myTh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Wait for myTh to complete​&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// do the rest of the computation of this thread​&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;세마포어 클라스는 카운팅 세마포어를 구현한다&lt;br /&gt;
객체는 카운터만 있고, 큐는 없다. 메소드는 acquire 메소드(wait)와 release(release) 메소드가 있다&lt;br /&gt;
아래 코드는 이들 메소드의 사용 예를 보여주고 있다. 디파짓과 펫치의 앞뒤에 이들 메소드가 있음을 주의하라&lt;br /&gt;
acquire()는 세마포어 -1 한다&lt;br /&gt;
release()는 세마포어 +1 한다&lt;br /&gt;
여기서 세마포어는 fullspot, emptyspot이다&lt;/p&gt;

&lt;p&gt;자바 쓰레드에서 상호배제는 모니터 개념으로 구현한다&lt;br /&gt;
이때 메소드는 synchronize로 지정된다&lt;br /&gt;
ManageBuf에서 디파짓과 펫치를 synchronize로 정의하여, ​동일한 객체에 대해 실행할 때 서로 방해하는 것을 방지한다&lt;br /&gt;
아래 코드는 모니터 개념으로 구현된 ManageBuf에서 메소드가 synchronized로 지정된 예를 보여준다&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ManageBuf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deposit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;모니터는 상호배제를 구현하므로, 프로세스 간의 협력적 동기화를 구현하지 못한다&lt;br /&gt;
따라서 프로세스 간의 협력 동기화의 구현을 위해, ​쓰레드 대기 리스트(wait list of threads)와 wait, notify, notifyAll을 구현한다&lt;br /&gt;
각각의 객체(P-C 문제에서 producer, consumer가 객체)는 쓰레드 대기 리스트를 가지며, ​대기 리스트에 있는 쓰레드들은 이 객체로부터 자신의 실행에 필요한 ​이벤트를 기다리고 있는 것이다&lt;br /&gt;
wait 메소드는 쓰레드를 대기 리스트에 넣고 기다리게 한다&lt;br /&gt;
Notify 메소드는 어떤 대기 쓰레드에게 ‘기다리고 있는 이벤트가 발생했음’을 알린다&lt;br /&gt;
Notify 메소드가 특정 쓰레드를 깨울 수는 없고, ​JVM이 쓰레드 대기 리스트에서 무작위로 하나를 선택한다&lt;br /&gt;
NotifyAll 메소드는 ‘객체에서 발생된 이벤트’를 기다리고 있는 쓰레드를 ​모두 깨워서 task-ready queue에 넣는다&lt;br /&gt;
이렇게 하는 이유는 대기 리스트에 있는 쓰레드들이 기다리고 있는 조건이 ​모두 다를 수 있기 때문이다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;자바 쓰레드: Lock&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;자바 쓰레드는 lock을 지원한다&lt;br /&gt;
자바 쓰레드에 미리 정의된 ReentrantLock 클라스는 ​Lock 인터페이스를 구현하는 데 사용되며, ​lock 인터페이스는 lock, unlock, tryLock 메소드를 선언한다&lt;br /&gt;
lock 메소드는 try 블록을 사용하여 크리티칼 코드(크리티칼 섹션)를 둘러싼다. unlock 메소드의 호출은 finally 절 안에 있어야 하며, lock의 해제를 보장한다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Statement-Level Concurrency&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;고성능 포트란에서 두 개의 리스트에서 ​서로 대응되는 요소 간의 연산을 병렬 처리하고자 할 때 다음과 같은 문장이 추가된다&lt;br /&gt;
PROCESSOR proc(n) -&amp;gt; 배열 처리 문장을 동시 실행(병렬 처리)하기 위해 프로세서 n개를 할당 ​DISTRIBUTE (BLOCK vs. CYCLIC) -&amp;gt; 같은 크기의 블록으로 나누어져 프로세서에 할당, 돌아가면서 하나씩 프로세서에 할당 ​ALIGN array1_elt WITH array2_elt -&amp;gt; 배열1에 배열2를 대응시킴&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">Comcurrency</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">ImplementSubprogram</title>
      <link href="https://lee989898.github.io/pl-17" rel="alternate" type="text/html" title="ImplementSubprogram" />
      <published>2021-11-03T19:18:00+09:00</published>
      <updated>2021-11-03T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-17</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-17">&lt;h3 id=&quot;implementsubprogram&quot;&gt;&lt;strong&gt;ImplementSubprogram&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;서브프로그램 호출과 반환의 구현, 이것을 서브프로그램 링키지(linkage)라고 한다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;semantics-of-calls-and-returns&quot;&gt;&lt;strong&gt;Semantics of Calls and Returns&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;서브프로그램 링키지는 호출과 반환에 관련된 액션들의 실행으로 구성된다. 이러한 액션들을 호출 및 반환 시맨틱이라고 한다&lt;/p&gt;

&lt;p&gt;일반적인 서브프로그램 호출 시맨틱은 다음을 포함한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파라미터 패싱 방법의 구현&lt;/li&gt;
  &lt;li&gt;로컬 변수에 대한 스토리지 할당 및 바인딩 (로컬 변수가 정적 변수가 아닐 경우) ​&lt;/li&gt;
  &lt;li&gt;콜러의 실행 상태 저장: ​
    &lt;ul&gt;
      &lt;li&gt;실행상태는 콜러의 재실행(resume)에 필요한 레지스터 값, CPU 상태 비트, 환경 포인터(EP)를 포함하며​&lt;/li&gt;
      &lt;li&gt;EP는 콜리의 실행 중에, 로컬 변수 및 파라미터를 접근하는데 사용된다  ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;콘트롤을 콜리에게 이전​&lt;/li&gt;
  &lt;li&gt;콜리에 나타나는 난로컬 변수의 접근 메커니즘의 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서브프로그램의 반환 시맨틱은 다음을 포함한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;포말 파라미터의 로컬 값을 액추얼 파라미터에게 인아웃 또는 아웃 모드로 카피​&lt;/li&gt;
  &lt;li&gt;로컬 변수의 스토리지를 해제​&lt;/li&gt;
  &lt;li&gt;콜러 실행 상태의 재저장​&lt;/li&gt;
  &lt;li&gt;콜러에게 콘트롤 이전&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;implementing-simple-subprograms&quot;&gt;&lt;strong&gt;Implementing “Simple” Subprograms&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;단순 서브프로그램의 호출 및 반환을 어떻게 구현하는지 보자&lt;/p&gt;

&lt;p&gt;단순 서브프로그램에서는 ​서브프로그램의 중첩을 허용하지 않고, 모든 로컬 변수가 정적이다. 호출과 반환에 필요한 스토리지는 다음의 데이터를 포함한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;콜러의 상태 정보, 파라미터, 복귀 주소, 함수의 반환값​&lt;br /&gt;
단순 서브프로그램은 서브프로그램 코드와 데이터로 구성되는데 ​데이터 파트는 로컬 변수, 호출과 반환에 필요한 데이터(위에 언급된)를 포함한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;단순 서브프로그램의 호출 시맨틱스(액션과 그 순서)은 다음과 같다&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;현재 수행중인 프로그램(콜러)의 실행 상태를 저장 ​&lt;/li&gt;
  &lt;li&gt;파라미터의 계산 및 패스​&lt;/li&gt;
  &lt;li&gt;콜리에게 복귀 주소를 패스​&lt;/li&gt;
  &lt;li&gt;콜리에게 컨트롤을 이전&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;단순 프로그램의 반환 시맨틱스(액션과 그 순서)는 다음과 같다&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;포말 파라미터의 현재 값을 대응하는 액추얼 파라미터에게 카피 (만일 pass-by-value-result나 pass-by-value라면) ​&lt;/li&gt;
  &lt;li&gt;함수 값을 콜러에게 카피(만일 콜리가 함수라면) ​&lt;/li&gt;
  &lt;li&gt;콜러의 실행 상태를 재저장​&lt;/li&gt;
  &lt;li&gt;콜러에게 컨트롤을 재이전(되돌려줌)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;실행중인 서브프로그램의 데이터 파트를 위한 데이터 구조로 액티베이션 레코드를 정의한다. 액티베이션 레코드는 로컬 변수, 라미터, 복귀 주소로 구성된다&lt;br /&gt;
단순 서브프로그램의 액티베이션 레코드(AR)는 크기가 고정되어 있고, ​정적으로 할당된다. 따라서 스택에 저장되지 않는다. ​이러한 액티베이션 레코드는 recursion을 지원할 수 없다&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\pl\pl41.png&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 단순 서브프로그램의 액티베이션 레코드의 예이다. 예에서 단순 서브프로그램은 A, B, C이고, 이들의 코드와 액티베이션 레코드는 오른쪽 그림과 같이 메모리에 할당된다&lt;br /&gt;
메모리에 할당되는 A, B, C의 코드와 데이터의 위치는 ​정적으로 할당되기 때문에 호출되는 순서와 무관하다&lt;br /&gt;
A, B, C 모두 별개로 컴파일될 수 있으며, ​이 경우 링커에 의해 그림과 같이 모아진다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;implementing-subprograms-with-stack-dynamic-local-variables&quot;&gt;&lt;strong&gt;Implementing Subprograms with Stack-Dynamic Local Variables&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;서브프로그램의 로컬 변수가 스택-동적일 경우, ​서브프로그램의 호출 및 반환 구현에 대해 알아보자&lt;/p&gt;

&lt;p&gt;스택 동적 로컬 변수는 런타임 스택에 할당된다. ​장점은 recursion의 지원이다&lt;/p&gt;

&lt;p&gt;스택-동적 로컬 변수가 있는 서브프로그램의 호출과 반환을 구현하려면 ​액티베이션 레코드가 더욱 복잡해진다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;컴파일러는 ‘스택에서 로컬 변수의 암묵적인 할당과 해제’를 지원하기 위한 코드를 생성해야 한다&lt;/li&gt;
  &lt;li&gt;Recursion은 하나의 서브프로그램에 대해 여러 개의 액티베이션 레코드를 추가할 가능성이 있다. ​즉, 액티베이션 레코드 여러 개가 스택에 생성된다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;AddTwo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 함수를 실행하려면 어떤 데이터가 필요할까?&lt;br /&gt;
파라미터 x, y, 로컬 변수 sum, AddTwo 종료후 복귀할 return address 이와 같이, 액티베이션 레코드는 함수를 한번 실행하는데 필요한 데이터로 구성된다&lt;/p&gt;

&lt;p&gt;위의 코드에서, AddTwo  함수가 호출될 때, 액티베이션 레코드가 생성되고 런타임 스택에 저장된다&lt;/p&gt;

&lt;p&gt;그러면 스택에 저장된 이들 변수를 어떻게 접근할까? ​&lt;br /&gt;
Caller의 스택 포인터를 이용하면 가능한가? 아니다&lt;br /&gt;
SP는 액티베이션 레코드를 스택에 저장하고자 할 때, ​스택 메모리를 할당하고(나중에 해제하는) ‘시스템이 사용하는’ 레지스터이다. 따라서 서브프로그램이 사용할 수 있는 레지스터가 아니다&lt;/p&gt;

&lt;p&gt;​액티베이션 레코드에 저장된 파라미터나 로컬 변수에 접근하려면&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;액티베이션 레코드에 접근할 때, ​BP(베이스 포인터)를 사용한다. BP는 AR의 맨앞의 주소를 말하며, ​서브프로그램의 실행 중에 변경되지 않는다. BP는 지정된 레지스터에 저장되는데, 그림에서 이것을 BP라고 표시하자&lt;/li&gt;
  &lt;li&gt;파라미터나 로컬 변수에 접근하려면, ​BP+옵셋을 계산하여 스택에 저장된 파라미터나 로컬 변수에 접근한다 ​&lt;/li&gt;
  &lt;li&gt;서브프로그램이 종료되어 반환될 때, ​BP는 ‘caller의 액티베이션 레코드의 BP’로 재저장된다&lt;br /&gt;
여기서 return addr는 복귀 주소로, ​서브프로그램의 종료후 되돌아갈 caller의 위치를 나타낸다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;BP는 항상 현재 실행 중인 프로그램의 액티베이션 레코드의 시작 주소를 가리킨다&lt;br /&gt;
서브 프로그램이 호출되면, 현재 BP는 callee의 액티베이션 레코드(dynamic link)에 저장되고 ​BP는 새로 생성된 callee의 액티베이션 레코드의 시작 주소를 가리키도록 새롭게 설정된다&lt;br /&gt;
즉, callee로부터 반환되자마자, BP는 callee의 액티베이션 레코드(dynamic link)의 값으로 재저장된다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\pl\pl42.png&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 코드와 데이터, 서브프로그램 링키지 코드(AddTwo PROC),그리고 액티베이션 레코드가 저장된 스택을 보여준다&lt;br /&gt;
esp, ebp는 각각 스택포인터, 베이스 포인터이며, eax는 반환값을 저장하는 장소이다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\pl\pl43.png&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;AddTwo PROC은 스택에 할당된 액티베이션 레코드에 접근하여, ​스택에 저장된 두 수를 더하여 eax에 저장하여 반환하고, 반환후 5와 6이 저장되었던 8 바이트를 청소하고 종료하는 과정을 보여준다&lt;br /&gt;
이때 EBP, ESP를 caller의 것으로 변경한다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\pl\pl50.png&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;액티베이션 레코드 내에서 로컬 배열의 할당은 위의 그림과 같다&lt;br /&gt;
동적 링크가 있는 것이 특이하다. ​동적 링크는 스택 메모리에 저장되어 있는, ​바로 아래의(caller의) 액티베이션 레코드를 가리킨다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\pl\pl44.png&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Recursion이 없이, 여러 서브프로그램으로 구성된 프로그램에서, ​메인이 B를 호출하고, ​B가 C를 호출하고, ​A가 C를 호출한다고 하자&lt;br /&gt;
그렇게 되면, 위와 같이 액티베이션 레코드가 스택 메모리에 할당된다. 동적 링크는 바로 아래(caller)의 액티베이션 레코드를 가리킨다&lt;/p&gt;

&lt;p&gt;이와 같이, 스택에 스택-동적 액티베이션 레코드가 연속적으로 쌓여진 것을 동적 체인(dynamic chain)이라고 한다&lt;br /&gt;
로컬 변수의 접근은 BP와 옵셋을 계산에 의하며, 이러한 옵셋을 로컬 옵셋이라고 한다. 로컬 변수의 로컬 옵셋은 컴파일러에 의해 컴파일 타임에 결정된다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\pl\pl45.png&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\pl\pl46.png&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\pl\pl47.png&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Recursion이 있을 때, ​액티베이션 레코드는  위의 그림과 같다. 여기서 파라미터는 n이다&lt;br /&gt;
첫째, 둘째, 셋째 recursion을 호출했을 때 function value가 모두 ?&lt;br /&gt;
셋째 recursion을 종료되었을 때 둘째 호출이 종료되었을 때 function value가 모두 ?이 아니다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;nested-subprograms&quot;&gt;&lt;strong&gt;Nested Subprograms&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;중첩 서브프로그램의 호출과 반환 구현 방법을 살펴 보자&lt;/p&gt;

&lt;p&gt;서브프로그램이 그 안에 다른 서브프로그램을 포함하는 경우, 이것을 중첩 서브프로그램이라고 부른다&lt;br /&gt;
중첩 서브프로그램에서, 난로컬 변수에 어떻게 접근할 것인가? 이들 변수는 스택의 액티베이션 레코드에 있다&lt;/p&gt;

&lt;p&gt;난로컬 변수에 접근하려면, ​먼저 스택에서 올바른 액티베이션 레코드를 찾아야 한다&lt;br /&gt;
다음, 액티베이션 레코드 내에서 그 변수의 옵셋을 찾아야 한다&lt;/p&gt;

&lt;p&gt;정적 스코프일 경우​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정적 조상 스코프에 선언된 변수가 나타나고 접근될 수 있다 ​&lt;/li&gt;
  &lt;li&gt;언급된 모든 난로컬 변수는 스택의 다른 액티베이션 레코드에 할당되어 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;올바른 액티베이션 레코드를 찾으려면, ​정적 조상의 액티베이션 레코드를 체인으로 연결하라&lt;/p&gt;

&lt;p&gt;정적 링크는 정적 부모의 시작 주소를 가리키는 포인터이다&lt;br /&gt;
정적 체인은 실행 중인 서브프로그램의 정적 부모를 포함해서 모든 정적 조상을 연결한다&lt;/p&gt;

&lt;p&gt;체인을 따라가면, 올바른 액티베이션 레코드를 찾을 수 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스코프의 중첩은 정적이기 때문에 컴파일 타임에 미리 알려진다 ​&lt;/li&gt;
  &lt;li&gt;따라서 쉽게 찾아갈 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정적 체인을 따라가는데 필요한 정보는&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;static_depth: 정적 스크프의 중첩 깊이​&lt;/li&gt;
  &lt;li&gt;Chain_offset(또는 nesting_depth): 난로컬 변수를 언급한 서브프로그램의 staic_depth 와 난로컬 변수를 선언한 서브프로그램의 static_depth 간의 차이 ​변수의 언급은 (chain_offset, local_offset)으로 표현되며, local_offset 은 액티베이션 레코드 내에서 언급된 변수의 옵셋이다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;호출할 때, 액티베이션 레코드를 생성한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;동적 링크는 스택의 old 탑 포인터이다​&lt;/li&gt;
  &lt;li&gt;정적 링크는 ‘가장 최근의 정적 부모’의 액티베이트 레코드를 가리킨다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;액티베이션 레코드를 생성한 후, 정적 체인을 생성하는 방법은 두가지가 있다  ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;동적 체인을 따라가면서 부모 스코프를 찾는다&lt;/li&gt;
  &lt;li&gt;컴파일러가 서브프로그램 호출을 만나면, 호출된 서브프로그램의 정적 부모를 찾아서 그 부모로부터의 nesting_depth를 기록한다. 그 서브프로그램이 호출될 때, 콜러의 정적 링크에 있는 값과 nesting_depth의 수로부터 callee의 정적 링크를 찾을 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정적 체인은 다음과 같은 문제를 내포하고 있다. 중첩 깊이가 크면, 난로컬 변수에 대한 참조(레퍼런스)가 늦다. 난로컬 참조의 비용 산출이 어렵다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;implementing-dynamic-scoping&quot;&gt;&lt;strong&gt;Implementing Dynamic Scoping&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;동적 스코프 방법의 구현에는, 딥 액세스와 쉘로우 액세스, 두가지 방법이 있다&lt;/p&gt;

&lt;p&gt;딥액세스는 동적 체인에서 액티베이션 레코드를 검색하여 난로컬 참조를 찾는다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;체인의 길이를 정적으로 결정할 수 없다&lt;/li&gt;
  &lt;li&gt;모든 액티베이션 레코드는 검색 과정을 위해 변수명을 가져야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;쉘로우 액세스는 각 변수명마다 하나의 스택을 유지하고, 중앙 테이블에 각 변수명에 대해 하나의 엔트리를 할당한다&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">ImplementSubprogram</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">서브프로그램</title>
      <link href="https://lee989898.github.io/pl-16" rel="alternate" type="text/html" title="서브프로그램" />
      <published>2021-10-29T19:18:00+09:00</published>
      <updated>2021-10-29T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-16</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-16">&lt;h3 id=&quot;서브프로그램&quot;&gt;&lt;strong&gt;서브프로그램&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;fundamentals-of-subprograms&quot;&gt;&lt;strong&gt;Fundamentals of Subprograms&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;서브프로그램이 무엇인지 왜 필요한지 살펴 보자&lt;br /&gt;
동일한 코드 부분(segment)이 프로그램의 여러 곳에서 나타난다고 하면, 이 코드를 여러 곳에 중복해서 코딩하기보다는,​ 한번만 코딩하고, 필요할 때마다 그 코드 부분으로 점프했다가 끝나면 되돌아 오는 방식으로, 프로그램을 짤 수 있다&lt;br /&gt;
이러한 코드 부분을 서브프로그램이라고 한다&lt;br /&gt;
동일한 코드 부분이 프로그램의 여러 곳에 나타나고, ​나타나는 곳마다 사용되는 변수가 다르다고 가정해 보자. 이때 파라미터를 갖는 서브프로그램을 사용할 수 있다. 서브프로그램의 개념은 쓰레드와 같은 것으로 발전하고 있다&lt;/p&gt;

&lt;p&gt;서브프로그램은 다음과 같은 특징을 갖는다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;각 서브 프로그램은 단하나의 진입점을 갖는다&lt;/li&gt;
  &lt;li&gt;호출한 서브프로그램(caller)는 호출된 서브프로그램(callee)의 실행 중에는 중지된다​&lt;/li&gt;
  &lt;li&gt;callee가 종료되면, 컨트롤을 항상 caller에게 되돌려준다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Basic Definitions&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;서브프로그램은 정의부와 선언부로 구성된다&lt;br /&gt;
서브프로그램 정의부는 서브프로그램의 인터페이스와 액션을 서술하고, ​정의부의 맨앞에는 서브프로그램의 헤더가 있다. 헤더는 void adder(parameter) 처럼 서브프로그램 이름, 유형, 포말 파라미터 등을 포함한다&lt;br /&gt;
포말 파라미터의 개수, 순서, 타입을 파라미터의 프로파일(시그니처, 요약)이라고 부른다&lt;/p&gt;

&lt;p&gt;서브프로그램 선언부는 파라미터 프로파일과 반환 타입을 선언한다. 서브프로그램 호출(call)은 서브프로그램으로 점프한다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Parameters&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;서브프로그램에서 데이터에 접근하는 방법은 두가지가 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;난로컬 변수에 직접 접근하는 경우 ​&lt;/li&gt;
  &lt;li&gt;파라미터 패싱을 사용하는 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파라미터 패싱을 사용하여 데이터를 접근할 때에는 ​로컬 변수명을 사용한다. 난로컬 변수에 직접 접근하는 것보다 융통성이 높아 파라미터화에 의한 계산이 가능하다. 난로컬 변수에 대한 광범위한 접근은 부작용으로 인해 신뢰성을 감소시킨다. ​순수 함수 언어는 수정 가능한 데이터를 허용하지 않으며, 메모리 내용을 변경할 수 없도록 제한한다&lt;/p&gt;

&lt;p&gt;포말 파라미터는 callee의 헤더에 있는 파라미터를 말한다&lt;br /&gt;
서브프로그램이 호출될 때만 메모리에 바인딩되고, ​액추얼 파라미터를 통해서 바인딩되기 때문에, ​종종 더미 변수로 취급되기도 한다. 액추얼 파라미터는 caller에서 사용되는 값이나 주소를 나타낸다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Binding Actual to Fromal Parameter&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;액추얼 파라미터를 포말 파라미터에 바인딩하는 방법은 두 가지가 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;위치 파라미터: 파라미터의 순서가 중요&lt;/li&gt;
  &lt;li&gt;키워드 파라미터: 파라미터의 이름이 중요, 순서는 중요하지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파이썬에서 sumer(my_length, list=my_array, sum = my_sum), 포말 파라미터는 length, list, sum이고, 액추얼 파라미터는 my_length, my_array, my_sum 이라면, ​첫번째 파라미터는 위치 파라미터이고, ​두번째 세번째는 키워드 파라미터이다&lt;/p&gt;

&lt;p&gt;키워드 파라미터의 장점은 순서에 얽매이지 않는다는 것이고, ​단점은 사용자가 포말 파라미터의 이름을 알고 있어야 한다는 것이다&lt;/p&gt;

&lt;p&gt;C++, 파이썬 등에서는 액추얼 파라미터가 모두 다 패스되지 않을 경우, ​포말 파라미터는 대응되지 않는 나머지 파라미터에 대해 디폴트 값을 가질 수 있다&lt;br /&gt;
C++에서 파라미터는 위치에 연관되기 때문에 ​디폴트 파라미터는 마지막에 나타나야 하며, 디폴트값은 서브프로그램 헤더에 있다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Two Categories of Subprograms&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;서브프로그램에는 프로시져와 함수가 있다. 프로시져는 파라미터화된 계산을 정의하는 문장의 모음이고, 함수는 프로시져와 구조적으로 닮았으나 ​의미적으로 수학의 함수를 본떠서, 값을 반환한다&lt;br /&gt;
수학적으로 함수는 하나의 값만 반환하기 때문에 부작용이 없으나, ​실제 프로그래밍 언어에서는 부작용이 있다. ​사용자는 새로운 연산자를 함수로 정의할 수 있다&lt;/p&gt;

&lt;p&gt;서브프로그램 내에 정의된 변수는 모두 로컬이며, ​그들의 스코프는 항상 서브프로그램 안이다&lt;br /&gt;
로컬 변수는 정적 또는 스택-동적으로 바인딩된다&lt;/p&gt;

&lt;p&gt;​로컬 변수가 스택-동적이라면, ​서브프로그램의 실행이 시작될 때 메모리에 바인딩되고, 실행이 끝나면 메모리에서 떨어진다&lt;br /&gt;
스택-동적 변수의 장점은&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Recursive 서브프로그램이 스택-동적 로컬 변수를 갖는다 -&amp;gt; recursion 처리가 가능​&lt;/li&gt;
  &lt;li&gt;액티브 서브 프로그램의 로컬 변수가 ​액티브하지 않은 서브프로그램이 해제한 로컬 변수의 메모리를 사용할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;프로그램이 시작되고나서 아직 끝나지 않은 상태에서는 ​자주 호출되는 서브프로그램의 실행이 끝났다고 해도 ​그 서브 프로그램의 변수는 아직 메모리를 차지하고 있을 수 있다. 이때 서브프로그램의 상태를 액티브라고 한다&lt;/p&gt;

&lt;p&gt;현대 언어에서, 서브프로그램의 로컬 변수는 디폴트로서 스택-동적으로 바인딩된다&lt;br /&gt;
C, C++ 함수에서, 로컬 변수는 정적이라고 명시되어 있지 않으면 스택-동적이다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;adder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예에서 sum 변수는 정적이고, count 스택 동적이다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Nested Subprograms&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;서브프로그램이 다른 서브프로그램안에만 있어야 한다면, ​이것을 중첩 서브프로그램이라고 한다&lt;br /&gt;
다른 서브프로그램 안에서 숨어서(hide) 다른 프로그램이 호출할 수 없게 만든다&lt;br /&gt;
서브프로그램의 중첩으로 처리 논리와 스코프의 계층구조를 생성할 수 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정적 스코핑의 사용 ​&lt;/li&gt;
  &lt;li&gt;알골, 파스칼에서 허용 ​&lt;/li&gt;
  &lt;li&gt;C 계열 언어는 서브프로그램의 중첩을 허용하지 않음​&lt;/li&gt;
  &lt;li&gt;자바스크립트, 파이썬 등은 중첩 허용&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;parameter-passing-methods&quot;&gt;&lt;strong&gt;Parameter-Passing Methods&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;파라미터 패싱에 대한 시맨틱 모델은 3가지가 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;포말 파라미터가 대응하는 액추얼 파라미터로부터 데이터를 받는 것이다. 이것을 in mode라고 한다 ​&lt;/li&gt;
  &lt;li&gt;포말 파라미터가 액추얼 파라미터에게 데이터를 보내는 것이다. 이것을 out mode라고 한다&lt;/li&gt;
  &lt;li&gt;포말 파라미터가 대응하는 액추얼 파라미터로부터 데이터를 받고, 액추얼 파라미터에게 데이터를 보내는 것이다. 이것을 inout mode라고 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파라미터간에 데이터를 주고 받는 방법은 두가지가 있다. 실제 값을 카피하여 주고 받는 방법과 액세스 패스(접근 경로)를 주고 받는 방법이다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Implementation Models of Param Passing&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;파라미터 패싱 구현 모델에는 ​pass by value(in mode), pass by result(out mode), ​pass by value result(inout mode), pass by reference(inout mode)가 있다&lt;/p&gt;

&lt;p&gt;Caller의 액추얼 파라미터를 Pass by value 모델로 callee에게 보낼때, 액추얼 파라미터의 값은 copy를 통해, ​대응되는 포말 파라미터의 초기화에 사용된다. 단점은 다음과 같다​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;copy 하면, ​  추가적인 메모리를 필요로하고, 실제 이동 비용이 발생한다&lt;/li&gt;
  &lt;li&gt;만일 접근 경로(access path)에 의한다면, callee에서 쓰기 보호를 해야하는 동시에, ​간접 주소방식에 의한 접근 비용이 추가된다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Callee의 파라미터를 pass by result 모델로 caller에게 보낼 때, ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;대응되는 포말 파라미터는 로컬 변수처럼 행동한다 ​&lt;/li&gt;
  &lt;li&gt;Callee가 종료되어 컨트롤을 caller에게 돌려주면, 포말 파라미터의 값을 caller의 액추얼 파라미터로 전달한다​&lt;/li&gt;
  &lt;li&gt;추가적인 메모리 위치와 copy 연산이 필요하다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pass by result에 내재하는 문제는 다음과 같다&lt;br /&gt;
Caller와 callee가 ​Caller: sub(p1, p1) -&amp;gt; actual parameter p1, p1&lt;br /&gt;
Callee: sub(x, y) -&amp;gt; formal parameter x, y 라고 하자 액추얼 파라미터 두개가 p1으로 같고, ​대응하는 포말 파라미터 두개의 이름이 x, y로 다르다&lt;br /&gt;
Caller가 callee를 호출해서 callee가 실행 후 종료되고, ​Callee가 calle에게 결과값을 반환할 때, ​x, y 중 어느 것이 p1에 마지막으로 copy 되느냐에 따라, ​p1의 값이 달라진다. ​x거나 y이다. 이것이 pass by result에 내재하는 문제이다&lt;/p&gt;

&lt;p&gt;Pass by value result는 ​pass by value와 pass by result의 결합으로 ​pass by copy라고도 부른다&lt;br /&gt;
액추얼 파라미터의 값은 대응하는 포말 파라미터의 초기화에 쓰이고, ​포말 파라미터는 로컬 변수처럼 행동한다&lt;br /&gt;
포말 파라미터의 값은 액추얼 파라미터에게 반환된다. ​단점은 in, out 모두 카피에 의존하는 것이다&lt;/p&gt;

&lt;p&gt;Pass by reference 모델은 접근 통로의 패스를 통해, ​파라미터를 패스한다&lt;br /&gt;
즉, callee에게 caller의 액추얼 파라미터를 접근하도록 허용한다. 따라서 pass by sharing이라고도 한다&lt;br /&gt;
장점은 패싱 프로세스가 효율적이다. ​Copy 연산, 메모리 모두 필요없다&lt;br /&gt;
단점은 느리고, 예기치 않았던 난로컬 변수를 접근할 수도 있다&lt;/p&gt;

&lt;p&gt;대부분 언어에서, 파라미터 패싱의 구현은 런타임 스택을 통해 일어난다&lt;br /&gt;
C에서 파라미터 패싱은 pass by value를 지원한다. 포인터를 사용하면, Pass by reference를 구현할 수 있다&lt;br /&gt;
자바는 모든 파라미터에 대해 pass by value를 지원하며, 객체 파라미터에 대해 pass by reference를 지원한다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Type Checking Parameters&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;파라미터에 대한 타입 검사는 ​액추얼 파라미터와 포말 파라미터 간에 타입의 일관성을 검사하는 것이다&lt;br /&gt;
파라미터의 타입 검사는 소프트웨어의 신뢰성을 위해 매우 중요하다&lt;br /&gt;
포트란 77, 원시 C에는 파라미터 타입 검사가 없다. ANSI C, C++에는 선택적이며, ​파이썬, 루비에서는 변수가 타입을 갖지 않기 때문에 ​파라미터 타입 검사가 없다&lt;/p&gt;

&lt;p&gt;파라미터의 타입이 다차원 배열일 경우, ​서브프로그램이 따로 컴파일되어 있고, ​다차원 배열이 서브프로그램으로 패스된다고 가정하자. 컴파일러는 메모리 매핑을 위해, ​선언된 배열의 크기를 알 필요가 있다&lt;/p&gt;

&lt;p&gt;row-major 매트릭스의 메모리 매핑 함수는&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_columns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;이다&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;즉, 컬럼의 길이만 알면 전체 크기를 알 수 있다&lt;/p&gt;

&lt;p&gt;현대 프로그래밍 언어에서 다차원 배열 파라미터를 어떻게 패스하는지 살펴 보자&lt;/p&gt;

&lt;p&gt;C, C++에서&lt;/p&gt;

&lt;p&gt;1.프로그래머가 액추얼 파라미터의 첫번째 서브스크립트를 제외하고, ​나머지 서브스크립트의 크기를 선언하는 방법&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 프로그램에서 mat은 2차원 배열이고, ​함수 fun(mat)은 mat을 파라미터로 하는 함수이다. 이와 같은 방식은 서브프로그램의 유연성을 불허한다는 것이다&lt;/p&gt;

&lt;p&gt;2.이에 대한 해결책으로, ​배열에 대한 포인터, 차원 크기를 파라미터로 패스하는 방법이 있다&lt;br /&gt;
다만, 배열 처리를 위해 ​사용자는 메모리 매핑 함수를 포함해야 하는 불편함이 있다&lt;/p&gt;

&lt;p&gt;자바에서는 배열을 객체로 취급한다. 이들은 모두 일차원 배열이지만 ​배열의 각 요소가 배열일 수 있어서 ​다차원 배열을 파라미터로 쓸 수 있다. 자바에서 각 배열은 named constant(length와 같은)를 상속받는다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Design Considerations&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;파라미터 패싱 방법의 구현시, 다음 두가지를 고려해야 한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;효율성&lt;/li&gt;
  &lt;li&gt;일방(in, out) 또는 쌍방(inout) 데이터 이동:caller-callee간에&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러나 이들 고려사항은 서로 상충된다. ​프로그래밍을 잘하려면, 변수에 대한 접근을 가능한한 일방(in, out)으로 제한하는 것이 좋다&lt;br /&gt;
pass by reference(inout)는 크기가 큰 데이터 스트럭처를 패스하는데 더욱 효율적인 반면, ​변수에 대한 접근을 제한하는데 문제를 일으킬 수 있다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;parameters-that-are-subprograms&quot;&gt;&lt;strong&gt;Parameters That Are Subprograms&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Subprogram Name as Parameters&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이번엔 서브프로그램 이름을 파라미터로 패스하는 경우를 살펴보자. 종종 서브프로그램 이름을 파라미터로 패스하는 것이 편리할 때도 있다. ​즉, 계산을 서브프로그램으로 패스하는 것이다&lt;/p&gt;

&lt;p&gt;파라미터 타입 검사&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;C, C++ 함수 포인터로 패스함 ​-&amp;gt; 함수 포인터의 타입은 파라미터 타입을 포함하므로 파라미터 타입 검사는 가능함 ​&lt;/li&gt;
  &lt;li&gt;자바는 메소드 이름을 파라미터로 패스하는 것을 불허함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서브프로그램 중첩을 허용하는 언어에서, ​어떤 바인딩 방식에 의한 레퍼런싱 환경을 사용하는가&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;쉘로우 바인딩: 패스된 서브프로그램을 실행시킨 call문(호출문)의 환경 ​&lt;/li&gt;
  &lt;li&gt;딥바인딩: 패스된 서브프로그램에 정의된 환경​&lt;/li&gt;
  &lt;li&gt;즉흥(ad hoc) 바인딩: 서브프로그램을 액추얼 파라미터로 패스한 호출문의 환경&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sub1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sub2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sub3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;sub4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sub2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sub4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;subx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
  &lt;span class=&quot;n&quot;&gt;sub3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Sub4의 sub에 대해​ 쉘로우 바인딩을 했을 경우 ​실행시킨 call문의 환경은 sub4가 되고, ​sub4에서 x는 4이다&lt;br /&gt;
딥 바인딩을 했을 경우​ Sub2가 정의된 환경은 sub2가 되고, Sub2에서 x는 난로컬로서 sub1에 따른다. ​따라서 x는 1이다&lt;br /&gt;
즉흥 바인딩일 경우, ​Sub2를 파라미터로 넘긴 call문의 환경은 sub3가 되고, ​Sub3에서 x는 3이다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;design-issues-for-functions&quot;&gt;&lt;strong&gt;Design Issues for Functions&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;언어 설계시 고려사항은&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;부작용 허용 여부? 부작용을 줄이려면 파라미터는 항상 in mode가 좋다&lt;/li&gt;
  &lt;li&gt;반환 값의 타입은? 대부분의 명령형 언어가 반환값의 타입을 제한함&lt;/li&gt;
  &lt;li&gt;C는 배열과 함수를 제외하고 모든 타입을 허용함&lt;/li&gt;
  &lt;li&gt;C++은 C와 유사하나 사용자 정의 타입을 허용​&lt;/li&gt;
  &lt;li&gt;자바는 모든 타입 허용&lt;/li&gt;
  &lt;li&gt;파이썬, 루비는 반환값 타입으로 객체도 허용&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;coroutines&quot;&gt;&lt;strong&gt;Coroutines&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;코루틴에서 중요한 것은 재시작(resume) 명령&lt;br /&gt;
프로그램 단위의 유사 동시 실행 기능을 제공함. 인터리빙&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\pl\pl38.png&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위그림은 A가 먼저 시작하고, B를 재시작하고나서 스스로 중지했다가, ​B가 A를 재시작하고 나서 스스로 중지했다가, ​번갈아 가며 실행되는 형태를 보여주고 있다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\pl\pl39.png&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 B가 먼저 시작하고, A를 재시작하면서 스스로 중지하고, ​번갈아가며 실행되는 형태를 보이고 있다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\pl\pl40.png&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위그림은 loop에서 서로 중지하고 상대방을 재시작하는 것을 반복하다&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">서브프로그램</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">컨트롤 스트럭처</title>
      <link href="https://lee989898.github.io/pl-15" rel="alternate" type="text/html" title="컨트롤 스트럭처" />
      <published>2021-10-22T19:18:00+09:00</published>
      <updated>2021-10-22T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-15</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-15">&lt;h3 id=&quot;컨트롤-스트럭처&quot;&gt;&lt;strong&gt;컨트롤 스트럭처&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;프로그램의 컨트롤 스트럭처에는 3가지가 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;sequence(begin-end)&lt;/li&gt;
  &lt;li&gt;selection(if-else, case)&lt;/li&gt;
  &lt;li&gt;iteration(loop)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;각 컨트롤 스트럭처는 여러 개의 문장으로 구성된다&lt;/p&gt;

&lt;p&gt;스트럭처는 여러 문장의 묶음으로, ​실행 제어 방법에 따라 각각 키워드(begin, if, while, …)를 포함한다&lt;br /&gt;
여기서 컨트롤 스트럭처의 if, while 문을 제어문이라고 하고, ​제어문의 실행 결과에 따라 실행되는 문장을 실행문이라고 한다&lt;/p&gt;

&lt;p&gt;시퀀스는 순차적으로 실행되는 문장들의 연속을 말하며, ​실행 제어가 순차적이라서 시작과 끝만 명시하면 된다&lt;/p&gt;

&lt;p&gt;Selection은 제어문이 참이냐 거짓이냐에 따라 실행문이 다르며, 하나의 selection 스트럭처에 제어문과 실행문을 여럿 포함하기도 한다&lt;/p&gt;

&lt;p&gt;Iteration도 제어문과 실행문의 반복으로 구성되는데, for, while, repeat 등 목적에 따라 그 신택스와 시맨틱스가 다양하다&lt;/p&gt;

&lt;p&gt;프로그래머는 이들 컨트롤 스트럭처를 사용하여 쉽게 프로그램을 구조화 할 수 있다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Controlling Program Flows&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;프로그램은 나름의 로직을 갖고 있어서, 이에 따른 실행 제어(flow control)가 필요하다&lt;/p&gt;

&lt;p&gt;명령형 프로그램에서 계산은 다음과 같이 진행된다. 변수를 읽고 연산자를 실행하여 표현식을 계산하여, ​변수에 결과 값을 부여한다&lt;br /&gt;
또, 여러 경로 중에서 선택하여 실행을 제어하거나, ​반복 실행한다. 컨트롤 스트럭처는 제어문과 실행문으로 구성된다&lt;br /&gt;
그러나 이 표현은 문제가 있다. 시퀀스는 제어문이 없다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;selection-statements&quot;&gt;&lt;strong&gt;Selection Statements&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Selection문은 2개 이상의 실행 경로 중에서 선택하는 것이다&lt;br /&gt;
두가지 범주가 있는데, 둘 중에 하나 선택하는 것과 여럿 중에 선택하는 것이 있다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If Statements&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If문의 일반적 형식은 if 제어 표현식 then 실행문1 else 실행문2 이다&lt;br /&gt;
제어 표현식은 산술식이거나 부울식이다&lt;br /&gt;
프로그래밍 언어에서 실행문1과 실행문2는 단순문이거나 복합문이다&lt;br /&gt;
C, C++에서 복합문을 { }로 둘러싸고, 펄에서는 모든 실행문을 { }로 구분하고, 파이썬에서는 indentation으로 구분한다&lt;/p&gt;

&lt;p&gt;자바에서는 중첩 if문을 허용한다. dangling else 문제가 발생할 수 있으니 if에 대응되는 else가 어느 것인지 살펴가며 신중하게 써야 한다&lt;br /&gt;
자바를 비롯한 대부분의 언어에서는 else를 가장 가까운 if에 대응시킨다&lt;/p&gt;

&lt;p&gt;C, C++에서는 가장 가까운 if에 else를 대응시키는 것의 대안으로서, {}로 둘러싼 복합문을 사용할 수도 있다&lt;br /&gt;
​복합문 대신에 end를 사용하기도 한다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Switch Statements&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;​Switch는 여러 대안 중에 하나 선택하여 실행할 경우이다&lt;br /&gt;
전형적인 형식은 아래와 같다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Switch&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;표현식&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;상수&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;표현식&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;실행문&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;   &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;…​&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;…&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;이다&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;스위치문의 case는 동시에 상수 표현식을 비교하는 것이 아니라 상수 표현식을 순차적으로 비교하여 끝까지 실행한다&lt;br /&gt;
이것을 피하려면, break 사용해야 한다&lt;/p&gt;

&lt;p&gt;C에서는 스위치문의 제어 표현식으로 정수 타입만 허용한다. 실행문은 시퀀스, 블록, 복합문을 모두 허용한다. 조건이 맞으면 여러 case가 실행가능하다.
디폴트시에, ​If문에 의한 제어가 가능하다&lt;/p&gt;

&lt;p&gt;파이썬에서는 스위치 대신에 if elif를 사용할 수 있다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;iterative-statements&quot;&gt;&lt;strong&gt;Iterative Statements&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Iteration, recursion은 문장이나 복합문의 반복 실행한다&lt;/p&gt;

&lt;p&gt;카운터로 제어하는 counter-controlled loop은 반복문의 실행 횟수를 세는 변수를 갖는다. ​초기값, 종료값, 증분(반복할 때마다 더해지는 값)&lt;br /&gt;
설계할 때 고려사항은 Loop 변수의 유형과 스코프를 정의해야 하며, Loop에서  변화하는 Loop변수의 값이 Loop 제어에 영향을 미치는지 확인해야 한다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;for Statenebts&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;C의 for 반복문을 보면, ​&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expr_1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expr_2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expr_3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;…&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;와&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;같다&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음과 같이 카운터 변수가 여럿일 수 있고, ​부울식을 포함할 수 있다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자바에서 컨트롤 표현식은 부울식이어야 한다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;while Loops&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;​while Loop은 부울식에 의해 제어된다&lt;/p&gt;

&lt;p&gt;ctrl_expr는 부울식으로, Loop의 맨앞에 또는 맨뒤에 위치한다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctrl_expr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;…&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    
&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;loop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctrl_expr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;break 처럼 loop 컨트롤이 loop body의 중간에 위치하기도 한다. 이것을 user-located loop control이라고 부른다. Break 외에도 continue가 있다&lt;/p&gt;

&lt;p&gt;자료구조를 구성하는 요소에 의해 제어되는 반복 처리가 있다. Iterator를 호출하면, 자료구조에서 다음 요소를 반환해준다&lt;br /&gt;
이밖에 for에서도 자료구조에 의한 반복처리를 제어할 수 있다  ​&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Unconditional Branching&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;앞에서 언급했듯이 goto는 가독성 문제를 일으킨다. 자바는 goto가 없다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;guarded-commands&quot;&gt;&lt;strong&gt;Guarded Commands&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;각 문장 앞에 부울식이 있는 것을 Guarded Commands라고 한다&lt;br /&gt;
즉 가디드 코멘드는 ​selection 문장의 각 라인이 ​부울식과 ‘하나의 문장 또는 문장의 시퀀스’로 구성된다. ​이렇게 하는 목적은 ​프로그램 개발 중에도 프로그램의 correctness(올바름)를 증명하기 위한 것으로, ​Concurrent 프로그래밍의 기초가 된다&lt;br /&gt;
기존의 언어는 개발(코딩)을 마치고 테스트를 통해 프로그램의 올바름을 확인한다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Selection Guarded Command&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;selection의 Guarded Commands는 if 안의 각 문장마다 부울식이 있다​&lt;/p&gt;

&lt;p&gt;이 가디드 코멘드의 시맨틱은 다음과 같다. 부울식을 계산해서, ​하나 이상이 참이면, 그 중에 아무거나 선택한다&lt;br /&gt;
아무것도 참이 아니면, 실행 오류로 처리한다&lt;br /&gt;
프로그램의 correctness는 선택된 문장에 종속되지 않는다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fi&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;  
    &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;x, y가 같을 때, 전자는 아무거나 선택되어 수행되나, ​후자는 max=x가 수행된다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Loop Guarded Command&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;statement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;statement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;statement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;od&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Loop Guarded Command에서, ​do 다음에 나오는 모든 문장의 앞에 부울식이 있다&lt;/p&gt;

&lt;p&gt;룹 가디드 코멘드의 시맥틱스는 다음과 같다. 부울식을 계산하고, 하나 이상이 참이면, 아무거나 선택하여 룹을 시작한다&lt;br /&gt;
아무것도 참이 아니면, 룹에서 나온다&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">컨트롤 스트럭처</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">복잡한 데이터 타입</title>
      <link href="https://lee989898.github.io/pl-13" rel="alternate" type="text/html" title="복잡한 데이터 타입" />
      <published>2021-10-14T19:18:00+09:00</published>
      <updated>2021-10-14T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-13</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-13">&lt;h3 id=&quot;복잡한-데이터-타입&quot;&gt;&lt;strong&gt;복잡한 데이터 타입&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;배열과 레코드 타입을 살펴보자&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;배열&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;배열은 동일한 유형의 데이터 요소의 모임으로, ​각 요소의 위치에 의해 지칭된다(식별된다)&lt;br /&gt;
각 요소의 위치를 나타내는 방식은 ​’배열의 맨앞에서 시작하여 각 요소의 상대적 위치를 지칭하는 인덱스(서브스크립트, subscript)’에 의한다&lt;br /&gt;
이와 같이 상대적 위치를 지칭하기 위해서는, ​인덱스와 요소 간의 매핑이 필요한데, ​이러한 매핑을 배열 인덱싱 또는 subscripting이라고 한다&lt;br /&gt;
1차원 배열 인덱싱은 사소한 문제에 불과하지만, 배열의 차원이 증가하고 각 차원의 범위가 다양해지면서 ​배열의 인덱싱 문제는 복잡해진다&lt;/p&gt;

&lt;p&gt;배열 인덱스 유형은 주로 정수형을 사용하나 언어에 따라 약간 다르다&lt;br /&gt;
포트란, C, 자바는 정수형만을 지원하나, ​파스칼은 모든 서수 유형(정수, 부울리언, 글자)을 지원한다&lt;br /&gt;
C, C++, 펄, 포트란은 인덱스에 대해 범위 검사를 하지 않지만,자바, ML, C#은 인덱스의 범위를 검사한다&lt;/p&gt;

&lt;p&gt;배열의 범주를 서브스크립트의 범위와 메모리 할당 시기를 기준으로 나누면, 정적 배열, 고정 스택-동적 배열, 고정 힙-동적 배열,힙-동적 배열로 구분한다&lt;/p&gt;

&lt;p&gt;정적 배열은 서브스크립트의 범위가 정적으로 고정되어 있고, ​런타임 이전에 메모리가 정적으로 할당된다&lt;br /&gt;
장점은 효율적이지만, ​단점은 실행중 필요시마다 동적 할당이 불가능하여 융통성이 없다&lt;br /&gt;
C, C++에서 static modifier를 포함하는 배열은 정적 배열이다&lt;/p&gt;

&lt;p&gt;고정 스택-동적 배열은 서브스크립트의 범위가 정적으로 고정되어 있지만, ​메모리는 미리 할당되지 않고, 선언문 실행 중에 할당된다&lt;br /&gt;
장점은 실행되지 않는 서브프로그램에서 정의된 배열에 대해 ​메모리가 미리 할당되지 않아, 메모리 공간 활용이 효율적이다&lt;br /&gt;
C, C++에서 static modifier를 포함하지 않는 배열은 고정 스택-동적 배열이다&lt;/p&gt;

&lt;p&gt;고정 힙-동적 배열은 스토리지 바인딩이 동적이지만, ​힙에 할당된 후에는 서브스크립트의 범위가 고정된다&lt;br /&gt;
C, C++에서 malloc에 의해 할당된 배열은 고정 힙-동적 배열이다&lt;/p&gt;

&lt;p&gt;힙-동적 배열은 서브스크립트 범위와 스토리지의 바인딩이 ​모두 동적이면서 변경 가능하다​&lt;br /&gt;
장점은 배열이 실행 중에 늘어나거나 줄어 들 수 있어서 융통성이 있다&lt;br /&gt;
C#에서 ArrayList에 의해 정의된 배열은 힙-동적 배열이다&lt;br /&gt;
배열의 요소없이 생성되고 나중에 add를 써서 배열을 늘인다&lt;/p&gt;

&lt;p&gt;C, C++, C#, 자바에서는 ​스토리지 할당시에 배열이 초기화된다&lt;/p&gt;

&lt;p&gt;포트란은 배열에 대한 연산을 지원한다&lt;br /&gt;
두 배열의 합(+)은 위치가 같은 배열의 각 요소들간의 합을 배열로 나타낸 것이다&lt;br /&gt;
A = B + C ——- A, B, C 모두 배열…  ​배열에 대한 연산을 지원하지 않는다면, ​loop을 써서 반복적으로 각 요소마다 합을 구해야 함 (A[i] = B[i] + C[i]에 의해)&lt;/p&gt;

&lt;p&gt;순서를 무시한 데이터 요소의 모임을 associative array라고 하며, ​사용자가 정의한 Key를 인덱스로 사용한다&lt;br /&gt;
따라서, associative array는 키와 값의 쌍을 나열한 것이다. 펄에서 associative array를 다음과 같이 정의하고, ​%hi_temps = (“Mon” =&amp;gt; 77, “Tue” =&amp;gt; 79, “Wed” =&amp;gt; 65, …);​&lt;br /&gt;
다음과 같이 배열에서 값을 찾는다. $hi_temps{“Wed”} = 83; 여기서 Wed가 키이다. ​
다음 명령어는 배열에서 값을 삭제한다. delete $hi_temps{“Tue”};&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;레코드&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;배열은 동일한 유현의 데이터 요소의 모임인 반면, ​레코드는 다른 유형의 데이터 요소의 모임이다&lt;br /&gt;
레코드에서는 그 요소의 이름으로 요소를 식별(지칭, 언급)한다&lt;/p&gt;

&lt;p&gt;레코드 타입에서 각 필드를 지칭(언급)하는 방법은 필드명에 의하며, 서브 필드를 명확히 지칭하기 위해, 코볼에서는 of를 키워드로 하고, ​다른 언어에서는 dot(.)을 쓰기도 한다&lt;br /&gt;
레코드 타입의 연산은 assignment(필드명에 값 할당), ​레코드간의 필드값 카피 등이다&lt;/p&gt;

&lt;p&gt;튜플 타입은 레코드와 유사하나, 각 요소의 이름이 없다는 것이 다르다&lt;br /&gt;
파이썬의 튜플은 튜플의 값을 변경할 수 없다&lt;br /&gt;
만일 변경하고자 한다면, ​List 함수를 써서 튜플을 배열로 변환한 다음에, ​배열의 값을 변경한다&lt;br /&gt;
변경한 후에, tuple 함수를 써서, 튜플로 재변환한다&lt;br /&gt;
myTuple = (3, 5.8, ‘apple’)은 튜플을 생성한다. ​myTuple[1]은 첫째 요소를 가리킨다&lt;br /&gt;
+는 튜플 간의 concatenation을 실행하고, ​del은 튜플을 삭제한다&lt;/p&gt;

&lt;p&gt;리스트 타입은 튜플과 유사하나, ​각 요소의 값을 변경 가능하다는 것이 다르다&lt;br /&gt;
파이썬은 리스트 타입을 지원하며, 배열처럼 취급된다. 배열과 차이점은 각 요소의 값이 어떤 유형이든 상관없다는 것이다&lt;br /&gt;
생성, 지칭, 삭제 연산 등을 보면 튜플과 유사함을 알 수 있다&lt;br /&gt;
리스트 포함(comprehension)은 컨스트럭트에 리스트를 포함시키는 것을 말한다&lt;br /&gt;
이것은 리스트를 필요시 정의할 수 있는 편리한 기능이다&lt;br /&gt;
형식은 [expression for iterate_var in array if condition]을 취한다. 예를 들면, [x*x for x in range(12) if x%3==0]과 같다. ​range(12)는 0에서 12까지의 배열을 생성하는 함수이고, x%3은 x를 3으로 나눈 나머지를 말한다&lt;br /&gt;
이 문장은 0에서 12로 구성된 배열을 생성하고 ​0,3,6,9,12를 제곱하라는 뜻이다&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;포인터와 레퍼런스 타입에 대해 살펴보자&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;포인터&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;포인터 타입 변수가 가질 수 있는 값의 범위는 ​메모리 주소와 영(nil)이다&lt;br /&gt;
포인터는 간접 주소 지정 방식과 동적 메모리 관리 방식을 제공한다&lt;br /&gt;
포인터는 힙에 있는 메모리 위치를 접근할 때 사용된다&lt;/p&gt;

&lt;p&gt;기본적 연산으로 assignment와 dereferencing이 있다&lt;br /&gt;
Assignment는 포인터 변수의 값에 주소를 넣어 두는 것이다&lt;br /&gt;
디레퍼런싱은 포인터의 값이 가리키는 주소에 저장된 값을 산출하는 것이다&lt;br /&gt;
디레퍼런싱은 명시적이거나 암묵적이다&lt;br /&gt;
C, C++에서는 명시적인 디레퍼런싱 연산자로 &lt;em&gt;를 사용한다&lt;br /&gt;
j=&lt;/em&gt;ptr는 ptr의 값이 가리키는 주소에 저장된 값을 변수 j의 메모리 위치에 넣어 두라는 의미이다&lt;br /&gt;
아래 그림은 이것을 그림으로 나타낸 것이다&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\pl\pl35.png&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;포인터 사용할 때 나타나는 문제는 다음의 두가지가 있다&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;허상 포인터(dangling pointer)는 ​힙-동적 변수에 할당된 메모리를 가리키지 않고 있는 포인터를 말한다&lt;br /&gt;
자세히 설명하면, ​힙에 의해 변수에 메모리가 할당되면, ​포인터는 이 메모리를 가리키고 있겠지만, 이후 메모리가 해제되었다면, 이 포인터는 메모리를 가리키지 못하게 된다&lt;br /&gt;
이러한 포인터를 허상 포인터라고 한다. ​즉, 메모리는 없지만 포인터는 남아 있는 경우이다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;memory leakage(기억 상실)​&lt;br /&gt;
힙-동적 변수의 상실은 힙-동적 변수가 이미 메모리에 할당되어 있지만, ​포인터가 상실되어 사용자 프로그램에서 이 동적 변수에 더 이상 접근 가능하지 않은 경우를 말한다&lt;br /&gt;
즉, 포인터는 없지만 할당된 메모리는 남아 있는 경우이다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;포인터는 언제 메모리에 할당되든지 어떤 변수든 가리킬 수 있으며, 동적 스토리지 관리에서 사용된다&lt;br /&gt;
포인터 산술 연산이 가능하고, ​디레퍼런싱과 ‘무엇의 주소’ 연산이 가능하다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stuff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stuff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;equivalent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stuff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;equivalent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stuff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;C, C++에서는 포인터에 대한 산술 연산이 가능하다&lt;br /&gt;
5번째값, i번째값&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;레퍼런스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;레퍼런스는 포인터와 유사하나, ​기본적으로 다른점은&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;포인터는 메모리의 주소를 가리키지만, ​(주소에 대한 연산이 나름의 의미를 갖지만)​&lt;/li&gt;
  &lt;li&gt;레퍼런스는 메모리의 값을 가리킨다. ​(주소에 대한 연산이 무의미)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;허상 포인터와 허상 객체는 힙 관리 상의 문제이다&lt;br /&gt;
포인터는 변수가 가리킬 수 있는 범위를 확장시킨다는 면에서 goto와 비슷하다&lt;br /&gt;
레퍼런스는 포인터의 기능과 유연성을 제공하면서, 위험은 제거한다. ​포인터와 레퍼런스는 동적 데이터 구조를 위해 프로
그래밍 언어의 필수적인 요소이다&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\pl\pl36.png&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;이 그림에서는 허상 포인터의 예를 보여주고 있다&lt;/p&gt;

&lt;p&gt;프로그램 코드가 이와 같을 때, ​*q=30은 이미 해제된 메모리가 남아 있다고 착각한다&lt;br /&gt;
Q는 결국 아무것도 가리키지 않는 허상 포인터이다&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">복잡한 데이터 타입</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">표현식과 대입문</title>
      <link href="https://lee989898.github.io/pl-14" rel="alternate" type="text/html" title="표현식과 대입문" />
      <published>2021-10-14T19:18:00+09:00</published>
      <updated>2021-10-14T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-14</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-14">&lt;h3 id=&quot;표현식과-대입문&quot;&gt;&lt;strong&gt;표현식과 대입문&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;표현식(expression)은 프로그래밍 언어에서 계산을 상세히 서술하는 수단이다&lt;br /&gt;
대입문은 변수의 값을 변화시키는 문장으로, 모든 명령형 언어의 필수적 요소이다&lt;br /&gt;
대입문은 독립적으로 실행 가능한 문장인 반면, ​표현식은 대입문의 일부분으로서, 독립적으로 실행될 수 있는 문장이 아니다​&lt;/p&gt;

&lt;p&gt;대입문과 표현식의 차이를 좀더 살펴 보자&lt;br /&gt;
변수가 메모리의 일정 부분임을 상술하는 수단이라는 것과, 대입문의 BNF 형식이 &amp;lt; var &amp;gt;= &amp;lt; expression &amp;gt;임을 알고 있다&lt;br /&gt;
BNF의 형식으로부터, ​표현식(&amp;lt; expression &amp;gt;)은 대입문의 일부분임을 알 수 있고, ​대입문의 변수(&amp;lt; var &amp;gt;)가 가리키는 메모리에 저장된 값을 ​표현식의 계산 결과로 변경시킨다는 것을 알 수 있다&lt;/p&gt;

&lt;p&gt;그런데, 표현식의 계산 방식에 따라 계산 결과는 달라질 수 있다&lt;br /&gt;
표현식의 계산 방식을 이해하려면, ​연산자와 오퍼랜드의 계산 순서에 대한 규칙을 알 필요가 있다 이들 순서는 결합 법칙과 우선순위 규칙에 의하며, ​오퍼랜드 계산 순서는 오퍼랜드의 부수효과(부작용)때문에 중요하다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;산술식&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;산술식은 연산자, 오퍼랜드, 괄호, 함수 호출로 구성된다&lt;br /&gt;
연산자는 단항 연산자, 이진 연산자, 삼항 조건 연산자(?:) 등이 있다&lt;/p&gt;

&lt;p&gt;표현식의 구현은, ​메모리에서 오퍼랜드를 가지고 와서, 그 오퍼랜드에 산술 연산자를 실행한다&lt;br /&gt;
산술식 설계시 고려사항 ​연산자 우선 순위, 결합 법칙 등&lt;br /&gt;
오퍼랜드 계산 순서와 부작용(부수효과)&lt;br /&gt;
연산자 오버로딩&lt;br /&gt;
표현식에서 오퍼랜드 타입의 혼합&lt;/p&gt;

&lt;p&gt;연산자 우선순위 규칙은 우선 순위가 다르면서 이웃하는 연산자의 계산 순서를 정의한다&lt;br /&gt;
전형적인 우선순위 규칙은 괄호&amp;gt;단항연산&amp;gt;지수&amp;gt;곱셈과 나눗셈&amp;gt;덧셈과 뺄셈&lt;/p&gt;

&lt;p&gt;연산자 결합 법칙은 우선 순위가 같으면서 이웃하는 연산자의 순서를 정의한다&lt;br /&gt;
전형적인 결합법칙은 좌에서 우로(단, 지수는 우에서 좌로) 적용된다&lt;br /&gt;
괄호는 우선순위와 결합 법칙에 앞선다
​
C, C++에서 조건 표현식은 삼항 조건 연산자 ?:를 사용한다&lt;br /&gt;
average = (count == 0)? 0 : sum / count와 같이 표현한다&lt;br /&gt;
이것의 의미는 다음과 같다&lt;br /&gt;
if (count == 0), average = 0​&lt;br /&gt;
else average = sum / count&lt;br /&gt;
이 문장을 이해하려면, 대입문의 BNF 형식 &amp;lt; var &amp;gt; = &amp;lt; expr &amp;gt;을 떠올리면 쉽다&lt;br /&gt;
그러니까 &amp;lt; var &amp;gt;이 average이고, ​&amp;lt; expr &amp;gt;가 삼항 조건 표현식인 (count==0) ? 0 : sum/count이다&lt;/p&gt;

&lt;p&gt;표현식에서 오퍼랜드는 어떻게 계산되는지 살펴 보면, ​변수는 메모리에서 값을 가져온다&lt;br /&gt;
상수는 메모리에서 값을 가져오기도 하지만, 기계 언어에 내재되기도 한다&lt;br /&gt;
괄호가 있는 표현식은 괄호속에 있는 모든 오퍼랜드와 연산자를 먼저 계산하고, 괄호 전체를 계산한다&lt;/p&gt;

&lt;p&gt;오퍼랜드가 아무런 부작용(부수효과)가 없을 때, 오퍼랜드 계산 순서는 결과에 무관하다&lt;/p&gt;

&lt;p&gt;그러나 함수가 오퍼랜드일 때, 계산 순서는 다른 결과를 가져온다&lt;br /&gt;
함수는 다수의 파라미터 또는 글로벌 변수를 변경시킬 수 있고, 이때 함수 부수효과가 발생할 수 있다&lt;br /&gt;
이로 인해 표현식의 계산 결과에 영향을 미칠 수 있다&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\pl\pl37.png&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림에서 함수 부수효과 문제의 예를 보자&lt;br /&gt;
다음 프로그램에서, ​Main의 a = a + fun1( )의 값은 ​먼저 a를 계산하느냐, fun1( )을 먼저 계산하느냐에 따라 달라진다&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;먼저 a를 계산(메모리에서 가져오는 fetch)하면, ​a가 5이고, fun1()이 3이므로, 둘을 더하면 a는 8이다&lt;/li&gt;
  &lt;li&gt;먼저 fun1을 계산하면, ​fun1은 3이지만 부수효과로서 a가 17이므로, ​둘을 더하면 a는 20이 된다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;수학에서 함수는 x에 대응하는 y값을 찾는 것이므로, 부수 효과가 없다&lt;br /&gt;
함수 언어에서도 마찬가지다&lt;br /&gt;
부수효과는 본 뉴만 아키텍처 및 이에 기반한 명령형 언어의 계산 모형으로 인해 발생한다&lt;br /&gt;
본 뉴만 아키텍처 및 이를 그대로 본뜬 명령형 언어의 계산 모형은 계산하여 변화된 값의 상태를 항상 메모리에 저장하도록 설계되어 있기 때문이다&lt;/p&gt;

&lt;p&gt;함수 부수효과의 해결책은 다음 두가지가 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;C, C++ 처럼 함수 부수 효과를 허용하지 않도록 언어를 설계하는 것이다&lt;br /&gt;
함수에서 단일 파라미터만 허용하여, 단일 값을 반환한다. 만일 다수의 파라미터가 필요하면, struct를 사용하여 하나의 파라미터로 만든다&lt;br /&gt;
함수에서 글로벌 변수를 접근 불허한다. 단점은 파라미터 및 글로벌 변수에 융통성이 없다&lt;/li&gt;
  &lt;li&gt;자바처럼 오퍼랜드 계산 순서를 고정시킨다&lt;br /&gt;
좌에서 우로 단점은 컴파일러 최적화를 제한한다&lt;br /&gt;
최적화를 위해 표현식을 reordering하기도 하는데 고정 순서는 이를 불허한다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;과적 연산자&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;기계어에서는 정수의 덧셈 연산자와 부동점 소수의 덧셈 연산자를 구분한다&lt;br /&gt;
부동점 소수의 덧셈: FADD, ​정수의 덧셈: ADD&lt;br /&gt;
프로그래머는 정수의 덧셈과, 부동점 소수의 덧셈에 모두 +를 쓰고 싶어한다&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;그러면서, 컴파일러가 알아서 이들을 구분하여 번역하기 바란다&lt;/li&gt;
  &lt;li&gt;두개의 배열 변수의 덧셈도 +로 간단히 쓰고 싶어 한다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이와 같이 하나의 연산자를 여러가지 목적으로 사용하는 것을 ​연산자의 과적(오버로딩)이라고 한다&lt;/p&gt;

&lt;p&gt;정수와 부동점에 대한 +의 과적은 ​일상적으로 허용되지만, C와 C++에서는 문제를 일으키기도 한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;타입 변환&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정수와 부동점 소수 간의 덧셈에서, ​데이터를 어떤 유형으로, 그리고 어떤 포맷으로 변환할 것인가?&lt;/p&gt;

&lt;p&gt;유형: 정수, 부동점 소수 ​
포맷: 십진수 vs 이진수, 부동점의 (싸인,지수부분,소수부분) 각 몇 비트?&lt;/p&gt;

&lt;p&gt;Narrowing conversion은 ‘원래 유형의 모든 값’을 포함할 수 없는 유형으로 변환하는 것을 의미한다&lt;br /&gt;
예를 들어, 더블 부동점 소수를 싱글 부동점 소수로 변환하는 경우&lt;br /&gt;
이때 항상 safe하지는 않다. -&amp;gt; 값의 크기가 바뀐다. 짤린다&lt;/p&gt;

&lt;p&gt;Widening conversion은 원래 유형의 근사값을 포함하는 유형으로 변환하는 것을 의미한다&lt;br /&gt;
예를 들어 정수를 부동점 소수로 변환하는 경우&lt;br /&gt;
이때, safe하다. 즉, 근사값으로 바뀌므로 크기가 바뀌지 않는다&lt;br /&gt;
다만 포맷(내부 표현 방식)의 차이로 인해 정확하게 같지 않을 경우도 있다&lt;/p&gt;

&lt;p&gt;오퍼랜드의 타입이 혼합되어 있을 때, ​명시적이거나 암묵적으로 타입 변환이 필요하다&lt;br /&gt;
컴파일러에 의한 암묵적 타입 변환을 코어젼이라고 한다 -&amp;gt; 대부분의 언어에서 프로그래머에 의한 명시적 타입 변환을 캐스팅이라고 한다&lt;br /&gt;
C에서는 (int) angle과 같이 캐스팅을 괄호로 표시한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;비교 및 부울 표현식&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;비교 표현식은 두개의 오퍼랜드를 비교하기 위해 비교 연산자를 사용한다&lt;/p&gt;

&lt;p&gt;부울 표현식은 부울 연산자 and, or, not를 사용한다&lt;/p&gt;

&lt;p&gt;표현식의 Short-circuit evaluation에 대해 살펴 본다&lt;br /&gt;
Short-circuit evaluation은 ​표현식의 결과를 도출하는데 충분한 계산이 완료되면, ​그 이후의 표현식 계산을 중단한다는 의미이다&lt;br /&gt;
따라서, 표현식의 최소 계산이라고 번역하겠다&lt;/p&gt;

&lt;p&gt;표현식에서 여러 오퍼랜드 중에서 몇 개만 해보고 그 결과를 알 수 있다면 ​모든 오퍼랜드를 계산할 필요가 없다​&lt;br /&gt;
이것을 표현식의 최소 계산이라고 한다&lt;/p&gt;

&lt;p&gt;간단한 예를 보자&lt;br /&gt;
(13&lt;em&gt;a)&lt;/em&gt;(b/13–1)에서, a가 0이면, 13*a가 0이므로 더 이상 계산할 필요가 없다&lt;/p&gt;

&lt;p&gt;만일 최소 계산을 채택하지 않을 경우, ​다음 프로그램에서 예상치 않은 문제를 발생시킨다&lt;/p&gt;

&lt;p&gt;index = 0;&lt;br /&gt;
​while ((index &amp;lt; listlen) &amp;amp;&amp;amp; (LIST[index]!= key))&lt;br /&gt;
index = index + 1; 이고, ​LIST 배열의 인덱스가 0에서 listlen-1까지 라고 가정하자&lt;/p&gt;

&lt;p&gt;index==listlen일 때, (index &amp;lt; listlen)을 만족시키지 못한다&lt;br /&gt;
그런데 최소 계산을 채택하지 않기때문에 여기서 중단되지 않고, ​그 이후의 (LIST[index]!= key))를 계산하게 되며, ​이때, LIST[index]에서 인덱싱 문제가 발생하게 된다&lt;/p&gt;

&lt;p&gt;이와 같이 최소 계산을 채택하지 않을 경우 불필요한 오류를 발생시키기도 한다&lt;/p&gt;

&lt;p&gt;최소 계산은 표현식의 부작용에 영향을 받을 수도 있다&lt;br /&gt;
(a &amp;gt; b) || (b++ / 3)에서 ​||의 두번째 오퍼랜드를 먼저 계산하면 ​b가 증가하여 첫째 오퍼랜드의 결과에 영향을 준다&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;대입문과 혼합 타입의 대입문&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;대입문의 일반적 형식은 &amp;lt; var &amp;gt; = &amp;lt; expression &amp;gt;이다&lt;br /&gt;
대입 연산자 = 대신에 :=를 쓰기도 한다&lt;br /&gt;
= 대신에 :=을 쓰는 이유는 =의 의미가 ‘같다’의 의미와 혼동되기 때문이다&lt;br /&gt;
= 를 대입 연산자로 사용하는 경우, ‘같다’의 연산자로 ==를 사용한다&lt;/p&gt;

&lt;p&gt;조건 타겟은 조건에 따라 타겟 변수가 결정된다&lt;br /&gt;
펄에서 조건 타겟이 포함된 대입문의 예를 보자&lt;br /&gt;
대입문 ($flag ? $total : $subtotal) = 0에서 ​대입 연산자 =의 왼쪽에 조건식이 포함되어 있는데, ​이 뜻은 만일 ($flag)이 참이면 $total = 0이고, ​거짓이면 $subtotal = 0이다 ​&lt;/p&gt;

&lt;p&gt;복합 대입문 연산자는 대입문의 =과 연산자를 연결한 것이다
단항 대입문 연산자는 ++과 같은 것을 의미한다&lt;/p&gt;

&lt;p&gt;표현식에 대입문을 쓰기도 한다&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EOF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;​&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 while 문의 조건식에 ch = getchar()라는 대입문이 들어가 있다&lt;br /&gt;
이 대입문이 먼저 실행되고 나서, 조건식이 계산된다&lt;br /&gt;
그러면 getchar 값이 ch에 할당되고, ​ch!=eof가 참이면 {…}가 실행된다&lt;br /&gt;
a=b+(c=d/b)-1의 경우처럼, ​표현식에 대입문을 쓰는 것은 대입문의 이해를 어렵게 한다&lt;/p&gt;

&lt;p&gt;​($first, $second, $third) = (20, 30, 40)와 같이 다수의 값을 할당할 수도 있고, Interchange를 ($first, $second) =($second, $first)와 같이 쓸 수도 있다&lt;/p&gt;

&lt;p&gt;함수 언어에서 identifier는 값의 이름에 불과하며, ​변수를 나타내는 것이 아니기때문에 이들의 값은 바뀔 수 없다&lt;br /&gt;
val fruit = apples + oranges;에서 ​이름 fruit는 apples와 oranges의 값을 더해서 나온 결과 값의 이름이다​&lt;br /&gt;
대입문에서 혼합 타입이 가능하다. ​이때 타입 변환이 발생한다&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">표현식과 대입문</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">데이터 타입</title>
      <link href="https://lee989898.github.io/pl-12" rel="alternate" type="text/html" title="데이터 타입" />
      <published>2021-10-07T19:18:00+09:00</published>
      <updated>2021-10-07T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-12</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-12">&lt;h3 id=&quot;데이터-타입&quot;&gt;&lt;strong&gt;데이터 타입&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;선언문 int n으로부터 n에 대해 무엇을 알 수 있을까? ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;n이 취할 수 있는 값의 범위는? (모든 정수) ​&lt;/li&gt;
  &lt;li&gt;n에 적용 가능한 연산자는? (닫혀 있는 모든 연산자, +, -, *) ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;데이터 타입의 개념에 대해 살펴 보면, 특정 타입의 변수를 선언하면, 그 변수가 취할 수 있는 값은 특정 집합이고, ​그 값들에 적용 가능한 연산자 집합이 존재한다는 의미이다&lt;/p&gt;

&lt;p&gt;PL 설계자가 마주하는 기본적인 설계 이슈는 목적에 적합한 충분한 데이터 타입으로 구성된 집합을 어떻게 정의할 것인가? ​
무슨 연산자들을 정의하고 이들 연산자를 데이터 타입에 어떻게 지정(specify)할 것인가?&lt;/p&gt;

&lt;p&gt;데이터 타입은 다음과 같이 진화해 왔다&lt;br /&gt;
초기 PL에서는, 많은 데이터 타입으로 다양한 응용을 지원하였다&lt;br /&gt;
PL/1이 이러한 예이다&lt;/p&gt;

&lt;p&gt;ALGOL68에서 얻은 지혜:&lt;br /&gt;
소수의 기본 타입과 이를 위한 소수의 연산자를 정의하고, ​필요에 따라, 사용자 정의(user-defined) 데이터 타입을 지원하자! ​&lt;/p&gt;

&lt;p&gt;사용자 정의 타입으로부터 추상 데이터 타입으로 발전하였다&lt;br /&gt;
예를 들어, 스택, 큐, 링크드 리스트 등이 이에 속한다&lt;/p&gt;

&lt;p&gt;타입의 유용성은 다음과 같다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램 구조화 및 문서화에 유용​&lt;/li&gt;
  &lt;li&gt;오류 식별 및 방지에 유용​&lt;/li&gt;
  &lt;li&gt;최적화 지원에 유용 ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​먼저 비교적 단순한 형태로서, 원시형, 문자열형, 사용자정의 나열형부터 살펴 보자&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;원시 타입&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;원시 타입은 거의 모든 언어가 제공하고 있는 기본적인 데이터 타입으로, ​다른 데이터 타입을 사용해서 정의되지 않는 데이터 타입이다&lt;/p&gt;

&lt;p&gt;Integer, floating-point, Boolean, character ​원시 타입은 하드웨어 구조를 직접 반영한 것도 있다&lt;br /&gt;
부동점 소수는 4바이트의 싱글 프리시전과 8바이트의 더블 프리시전이 있는데, ​각각의 비트 구성은 싱글 프리시전: 싸인 1비트, 지수부분 8비트, 소수부분 23비트이거나 더블 프리시전: 싸인 1비트, 지수부분 11비트, 소수부분 52비트이다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;문자열 형&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;문자열 타입의 값은 문자열이다
설계 이슈: ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;원시 타입으로? 아니면 배열의 특수형으로? ​&lt;/li&gt;
  &lt;li&gt;스트링의 길이를 정적으로? 아니면 동적으로?​&lt;/li&gt;
  &lt;li&gt;스트링 연산자는? assignment, copy, comparison, concatenation, substring, pattern matching, etc
문자열을 비교할 때, &amp;gt;의 의미는 사전식 순서의 앞뒤 관계를 의미한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​C, C++에서 문자열은 원시 타입이 아니라, char 타입을 사용하여 정의한다&lt;br /&gt;
이를 위해 라이브러리 함수를 제공한다. C 스트링 라이브러리의 문제는 제공되는 함수가 오버플로우를 처리하지 못한다는 것이다&lt;br /&gt;
예를 들어, strcopy (src, dest); 에서 src가 50바이트이고, dest가 20바이트이면 어떤 일이 일어날까?&lt;/p&gt;

&lt;p&gt;자바의 문자열 타입은 원시 타입으로 String, StringBuffer 클래스를 지원한다&lt;/p&gt;

&lt;p&gt;문자열 길이 옵션은 3가지(정적, 제한적 동적, 동적) 옵션이 있다&lt;/p&gt;

&lt;p&gt;먼저 정적 옵션을 보면… ​COBOL, Java String 클래스는 정적이다. ​스트링이 생성될 때 길이가 정해진다​&lt;/p&gt;

&lt;p&gt;제한적 동적 옵션은… ​C, C++에서는 동적이나 제한적이다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;길이는 최대 길이까지 가변적이다. ​&lt;/li&gt;
  &lt;li&gt;C에서는 최대 길이로 제한하기 보다, ​스트링에 특수 문자를 사용하여 스트링의 끝을 나타내기도 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;동적 옵션은… Perl, Javascript​&lt;/p&gt;

&lt;p&gt;Ada는 모든 옵션을 지원한다&lt;/p&gt;

&lt;p&gt;문자열 옵션의 구현 방법은 다음과 같다&lt;br /&gt;
정적 옵션의 구현 방법은 컴파일 시에 문자열의 서술을 위해 ​3개의 필드(타입 이름(static string), 길이, 첫글자의 주소)를 필요로 한다&lt;/p&gt;

&lt;p&gt;제한적 동적 옵션 구현 방법은 런타임 때 문자열의 서술을 위해 ​4개의 필드(타입이름(limited dynamic string), 최대 길이, 현재 길이, 첫글자의 주소)를 필요로 한다&lt;/p&gt;

&lt;p&gt;동적 옵션의 구현 방법은 런타임 때 문자열의 서술을 위해, ​3개의 필드(타입 이름(dynamic string), 현재길이, 첫글자의 주소)를 필요로 한다&lt;br /&gt;
동적 문자열은 문자열의 증가와 감소에 따라 ​저장 공간을 동적 관리(allocate, deallocate)해야 한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자 정의 서수 타입&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서수 타입은 ‘데이터를 모아 놓은 것인데 순서가 중요한’ 데이터의 모임이라고 볼 수 있다&lt;/p&gt;

&lt;p&gt;Enumeration(나열형)과 subrange(범위형)가 대표적인 서수 타입이다&lt;/p&gt;

&lt;p&gt;나열형을 살펴 보면, 속성과 값이 정의되어 있음을 볼 수 있다&lt;br /&gt;
Coin은 페니, 니켈, 다임, 쿼터를 각각 1, 5, 10, 25로 정의하고, ​Escapes는 각 키마다 아스키 코드의 컨트롤 문자가 대응되어 있음을 볼 수 있다&lt;br /&gt;
연산자에 대해, 표현의 특성이 integer면, integer 연산을 수행한다&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">데이터 타입</summary>
      

      
      
    </entry>
  
</feed>
