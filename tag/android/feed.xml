<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://lee989898.github.io/tag/android/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://lee989898.github.io/" rel="alternate" type="text/html" />
  <updated>2022-04-16T12:36:39+09:00</updated>
  <id>https://lee989898.github.io/tag/android/feed.xml</id>

  
  
  

  
    <title type="html">LEE | </title>
  

  
    <subtitle>공부 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">Live Data</title>
      <link href="https://lee989898.github.io/ad" rel="alternate" type="text/html" title="Live Data" />
      <published>2022-04-15T16:07:07+09:00</published>
      <updated>2022-04-15T16:07:07+09:00</updated>
      <id>https://lee989898.github.io/ad</id>
      <content type="html" xml:base="https://lee989898.github.io/ad">&lt;p&gt;View Model에서 데이터를 관찰하기 위해서는 Live Data를 사용하면된다. 시간도 절약하게 해준다&lt;/p&gt;

&lt;p&gt;View Model에서 값을 불러오는 함수를 MainActivity에서 호출하여 값을 얻는 코드를 작성했었는데 더 좋은 방법이 있다&lt;br /&gt;
Live Data로 Activity 또는 Fragment에서 View Model의 데이터를 관찰하는 코드를 작성할 수 있다&lt;br /&gt;
변경 사항이 있는 경우 혹은 해당 데이터에 대한 업데이트가 발생하면 Live Data를 사용하여 Activity 또는 Fragment를 자동으로 업데이트 하는 코드를 작성할 수 있다&lt;/p&gt;

&lt;p&gt;Live Data는 안드로이드 제트팩 아키텍처 구성 요소의 일부이다&lt;br /&gt;
Live Data는 생명주기를 인식하는 관찰 가능한 데이터 홀더 클래스이다&lt;br /&gt;
안드로이드에서 생명주기가 있는 3개의 앱 구성요소는 Activity,Fragment,Service가 있다. 그러므로 Activity, Fragment, Service를 Live Data 개체의 관찰자로 사용할 수 있다&lt;br /&gt;
Live Data는 활성화된 생명 주기 상태의 관찰자만 업데이트 한다. Rx java를 사용할 때 Activity,Fragment,Service가 비활성화일때 처리할 코드를 주의 깊게 작성해야 하는데 Live Data를 사용하면 걱정할 필요가 없다&lt;/p&gt;

&lt;p&gt;Live Data는 앱 데이터가 변경되면 자동으로 UI를 업데이트 한다. 그러므로 Live Data를 사용하면 항상 최신 데이터를 갖게 된다. 그리고 연결된 생명 주기가 파괴되면 스스로 정리한다. 그래서 destroy된 Activity나 Fragment로 인한 메모리 누수나 충돌이 발생하지 않는다&lt;br /&gt;
또한 Live Data를 사용하여 앱의 서로 다른 구성 요소 간에 앱 서비스를 공유할 수 있다&lt;/p&gt;

&lt;p&gt;build.gradle 파일에 LiveData dependenices를 추가해야한다&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// build.gradle&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;dependencies&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lifecycle_version&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;2.4.1&quot;&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// LiveData&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;implementation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;int 유형의 변경 가능한 라이브 데이터를 선언한다&lt;br /&gt;
init에 .value를 활용해 대입한다&lt;br /&gt;
MainActivity에서 관찰해야 하므로 private은 없어야 한다&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// MainActivityViewModel.kt&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MainActivityViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;startingTotal&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MutableLiveData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt;

    &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startingTotal&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setTotal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;total&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;plus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;MutableLiveData와 LiveData의 차이점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;LiveData: 객체의 데이터를 읽을 수만 있다, 데이터를 업데이트 할 수 없다&lt;/li&gt;
  &lt;li&gt;MutableLiveData: MutableLiveData 클래스는 LiveData 클래스의 하위 클래스이다. 데이터를 업데이트 할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;데이터를 관찰할 것이기 때문에 getTotal 같은 함수는 필요가 없다&lt;/p&gt;

&lt;p&gt;MainActivity에서 값을 관찰하는 코드를 작성한다&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// MainActivity.kt&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MainActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lateinit&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;viewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MainActivityViewModel&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DataBindingUtil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;setContentView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activity_main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;viewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;total&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;observe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resultTextView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
        
        &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;지금까지 작성한 Live Data에는 한가지 문제가 있다. private로 되어있지 않아 직접 변수에 엑세스 할 수 있다는 점이다&lt;br /&gt;
데이터를 캡술화 해야한다&lt;br /&gt;
코틀린의 Backing property를 활용해 getter 함수에서 Live Data 객체를 반환할 수 있다&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// MainActivityViewModel.kt&lt;/span&gt;
 &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;totalData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LiveData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// MainActivity.kt&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;viewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;totalData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;observe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Observer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resultTextView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="android" />
      

      
        <summary type="html">View Model에서 데이터를 관찰하기 위해서는 Live Data를 사용하면된다. 시간도 절약하게 해준다</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">View Model</title>
      <link href="https://lee989898.github.io/ad" rel="alternate" type="text/html" title="View Model" />
      <published>2022-04-14T16:07:07+09:00</published>
      <updated>2022-04-14T16:07:07+09:00</updated>
      <id>https://lee989898.github.io/ad</id>
      <content type="html" xml:base="https://lee989898.github.io/ad">&lt;p&gt;Android 앱을 사용할 떄 화면 회전과 같은 구성 변경이 발생하면 destroy 되고 다시 recreate 한다. 그래서 실행 중에 생성된 값은 사라지게 된다&lt;br /&gt;
구성 변경에는 화면회전, 키보드 변경, 언어 변경, 다중 창 모드 활성화 등이 있다&lt;br /&gt;
높은 수준의 안드로이드 앱을 개발할 때 가장 일반적으로 필요한 것 중 하나는 구성 변경이다&lt;/p&gt;

&lt;p&gt;Android jetpack과 함꼐 도입된 View Model 아키텍쳐 컴포넌트는 이에 대해 좋은 솔루션이다&lt;br /&gt;
View Model은 이름에서 알 수 있듯이 뷰의 모델이다. UI 관련 데이터를 저장 및 관리할 수 있도록 설계되었다&lt;br /&gt;
일반적으로 액티비티나 프래그먼트 하나당 하나의 View Model을 만든다. 여러개의 액티비티나 프래그먼트가 하나의 View Model을 공유할 수 있다&lt;br /&gt;
View Model은 메모리에 생성되고 액티비티가 생성되고 액티비티가 지워질 때까지 지속된다. 그래서 View Model은 액티비티에 속하는 값을 보유할 수 있다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ad\ad19.png&quot; alt=&quot;안드로이드&quot; /&gt;&lt;/p&gt;

&lt;p&gt;build.gradle 파일에 View Model dependenices를 추가해야한다&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// build.gradle&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;dependencies&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lifecycle_version&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;2.4.1&quot;&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// ViewModel&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;implementation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;새로운 코틀린 클래스 MainActivityViewModel를 만들어준다&lt;br /&gt;
MainActivityViewModel은 ViewModel을 상속한다. 그리고 필요한 함수들을 만들어준다&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// MainActivityViewModel.kt&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MainActivityViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getCurrentCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getUpdatedCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;메인 액티비티에서 뷰 모델 클래스의 인스턴스를 가져오는 코드를 작성한다. 그러면 이제 뷰 모델을 사용하여 뷰 모델의 기능을 호출할 수 있다&lt;br /&gt;
앱을 실행해보면 이제는 화면을 회전해도 데이터가 남아있는 것을 볼 수 있다&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// MainActivity.kt&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MainActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lateinit&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;viewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MainActivityViewModel&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;viewModel&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewModelProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MainActivityViewModel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;countText&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getCurrentCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;button&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;setOnClickListener&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;countText&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getUpdatedCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ViewModel의 onCleard() 함수는 앱이 백그라운드에 놓이고 시스템 메모리를 확보하기 위해 앱 프로세스가 종료될 때 호출된다&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;기본적인 뷰 모델 클래스 말고 사용자 정의 뷰 모델이 필요한 상황이 있다&lt;br /&gt;
간단한 예로 값을 생성자로 값을 전달해야 하면 뷰 모델 팩토리 클래스를 통해 할 수 있다&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// MainActivityViewModel.kt&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MainActivityViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;startingTotal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;

    &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startingTotal&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getTotal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setTotal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// MainActivityViewModelFactory.kt&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MainActivityViewModelFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;startingTotal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewModelProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Factory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;modelClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;modelClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;isAssignableFrom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MainActivityViewModel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MainActivityViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;startingTotal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Unknown View Model Class&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;팩토리 클래스의 create 함수를 재정의 해야한다&lt;br /&gt;
뷰 모델의 생성자 매개변수를 뷰모델 팩토리 매개변수에도 넣어준다&lt;br /&gt;
위 팩토리 클래스 코드는 거의 모든 뷰 모델 팩토리 클래스에서 사용하는 표준 상용구 코드이다&lt;br /&gt;
새 뷰 모델 팩토리 클래스를 생성할 때마다 이 코드를 복사하여 자신의 뷰모델 팩토리 클래스를 생성할 때 사용자에 맞게 수정할 수 있다&lt;/p&gt;

&lt;p&gt;이제 팩토리 인스턴스를 생성하고 뷰모델프로바이더의 두번 쨰 인수로 전달한다&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// MainActivity.kt&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MainActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   
   &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lateinit&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;viewModelFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MainActivityViewModelFactory&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       
    &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;viewModelFactory&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MainActivityViewModelFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;125&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;viewModel&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewModelProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viewModelFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MainActivityViewModel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;사용자 정의 뷰모델을 사용해야 할 떄 뷰모델팩토리를 사용한다&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="android" />
      

      
        <summary type="html">Android 앱을 사용할 떄 화면 회전과 같은 구성 변경이 발생하면 destroy 되고 다시 recreate 한다. 그래서 실행 중에 생성된 값은 사라지게 된다 구성 변경에는 화면회전, 키보드 변경, 언어 변경, 다중 창 모드 활성화 등이 있다 높은 수준의 안드로이드 앱을 개발할 때 가장 일반적으로 필요한 것 중 하나는 구성 변경이다</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Data Binding</title>
      <link href="https://lee989898.github.io/ad" rel="alternate" type="text/html" title="Data Binding" />
      <published>2022-04-13T16:07:07+09:00</published>
      <updated>2022-04-13T16:07:07+09:00</updated>
      <id>https://lee989898.github.io/ad</id>
      <content type="html" xml:base="https://lee989898.github.io/ad">&lt;p&gt;findViewById() 함수를 사용할 때마다 Android 시스템은 뷰 계층 구조를 만들고 런타임때 찾아서 사용한다&lt;br /&gt;
크기가 큰 안드로이드 앱에는 많은 레이아웃과 수백개의 View가 있다. 그래서 런타임때 뷰 계층 구조를 계속해서 보는 것은 안드로이드 앱의 성능을 감소시킨다&lt;/p&gt;

&lt;p&gt;데이터 바인딩을 사용할 떄 레이아웃의 각 View에 대한 참조를 포함하는 바인딩 객체를 만든다&lt;br /&gt;
바인딩 객체가 생성되면 앱의 모든 구성 요소가 View에 액세스 할 수 있다. 그러면 안드로이드 시스템은 뷰 게층 구조를 반복해서 탐색할 필요가 없어진다. 결과적으로 데이터 바인딩은 앱의 성능을 크게 향상시킨다&lt;br /&gt;
또한 findViewById() 함수를 대체하여 코드를 간결하고 읽기 쉽고 유지 관라하기 쉽게 만든다&lt;br /&gt;
그리고 데이터 바인딩 객체 생성은 컴파일 때 하여 오류가 있는 경우 컴파일 하는 동안 인식한다. 그래서 View 관련된 사용자가 앱과 상호 작용할 때 같은 런타임에서의 에러가 발생하지 않는다&lt;/p&gt;

&lt;p&gt;데이터 바인딩의 장점&lt;/p&gt;

&lt;p&gt;1) 값을 자동으로 업데이트한다(값이 업데이트될 수 있는 모든 방법을 추적할 필요는 없음)
2) UI 테스팅에 매우 효과적이다
3) 더 읽기 쉬운 코드
4) 유지보수가 더 쉬운 코드
5) 더 빠른 개발 시간
6) 더 빠른 실행 시간
7) MVVM 및 MVI 아키텍처에 적합하다
8) 컴파일 시간 동안 오류가 발견될 수 있다&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 데이터 바인딩 활성화&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// build.gradle&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;android&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    
    &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;

    &lt;span class=&quot;nf&quot;&gt;buildFeatures&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;dataBinding&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;바인딩을 생성하려면 xml파일을 layout 태그로 감싸줘야 한다&lt;br /&gt;
안드로이드에서 레이아웃의 네임스페이스 선언은 가장 바깥쪽 태그에 있어야 한다&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// activity_main.xml&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;&amp;lt;?&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xml&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1.0&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xmlns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;xmlns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://schemas.android.com/apk/res-auto&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;xmlns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tools&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://schemas.android.com/tools&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;androidx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constraintlayout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;widget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ConstraintLayout&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@+id/name_text&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout_width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;match_parent&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout_height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;match_parent&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tools&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;.MainActivity&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;

        &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;androidx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constraintlayout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;widget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ConstraintLayout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;안드로이드 데이터 바인딩 라이브러리은 activity_main.xml을 이용하여 ActivityMainBinding이라는 이름으로 바인딩 객체를 만든다&lt;br /&gt;
xml 레이아웃의 각 이름의 첫글자를 대문자로 만들고 밑줄을 제거하고 바인딩을 추가하여 이름을 짓는다&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// MainActivity.kt&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.anushka.bindingdemo1&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;androidx.appcompat.app.AppCompatActivity&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;android.os.Bundle&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;androidx.databinding.DataBindingUtil&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.anushka.bindingdemo1.databinding.ActivityMainBinding&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MainActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lateinit&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ActivityMainBinding&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DataBindingUtil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;setContentView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activity_main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;submitButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;setOnClickListener&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;displayGreeting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;displayGreeting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;greetingTextView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nameEditText&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;setconview 함수는 화면에 레이아웃을 렌더링하는데 도움이 된다. 사용자가 제공한 값을 기준으로 xml 레이아웃 파일에서 뷰는 화면의 측정에 때라 inflated 되고 렌더링 된다&lt;br /&gt;
하지만 데이터 바인딩을 사용하면 이 기능이 필요하지 않다. 바인딩 객체를 사용하여 동일한 작업을 보다 효율적이고 효과적으로 수행할 수 있다&lt;/p&gt;

&lt;p&gt;android id 속성은 카멜 케이스로 밑줄을 제거하고 생성된다&lt;br /&gt;
greeting_text_view -&amp;gt; greetingTextView&lt;/p&gt;

&lt;p&gt;kotlin의 apply scope 기능을 사용하여 데이터 바인딩 이름의 반복을 줄일 수 있다&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;대부분의 앱을 개발하는 경우에서 로컬 데이터베이스 또는 온라인 api 양식으로 데이터를 가져와야 한다&lt;br /&gt;
데이터 바인딩을 사용하여 두 경우 모두 데이터를 객체로 받을 수 있다&lt;br /&gt;
그리고 객체를 레이아웃으로 직접 보내는 코드를 작성할 수 있다. 그러면 코드를 더읽기 쉽게 만들고 코드의 양을 줄여준다&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// data class&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;data class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;getStudent() 함수는 로컬 데이터베이스 또는 web api에서 데이터를 가져오는것을 대신한다&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getStudent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Alex&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;alex@gmail.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;사용법은 먼저 xml 파일에서 레이아웃 상단 밑에 data 태그를 추가한다
그다음 data 태그 내부에 객체 참조를 생성한다. data variable 이름은 매개변수 값으로 하고 type은 클래스의 완전한 이름 패키지 이름을 사용한다&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;

        &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;variable&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;student&quot;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.anushka.bindingdemo3.Student&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&amp;gt;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@{student.name}&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@{student.email}&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그러면 View에서 새로 생성된 student 학생 객체 참조 변수를 참조할 수 있다&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getStudent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이것이 레이아웃에 객체를 직접 전달하고 데이터 바인딩과 함께 사용하는 방법이다&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="android" />
      

      
        <summary type="html">findViewById() 함수를 사용할 때마다 Android 시스템은 뷰 계층 구조를 만들고 런타임때 찾아서 사용한다 크기가 큰 안드로이드 앱에는 많은 레이아웃과 수백개의 View가 있다. 그래서 런타임때 뷰 계층 구조를 계속해서 보는 것은 안드로이드 앱의 성능을 감소시킨다</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">2차 세미나</title>
      <link href="https://lee989898.github.io/ad" rel="alternate" type="text/html" title="2차 세미나" />
      <published>2022-04-13T01:06:00+09:00</published>
      <updated>2022-04-13T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/ad</id>
      <content type="html" xml:base="https://lee989898.github.io/ad">&lt;h2 id=&quot;2차-세미나&quot;&gt;&lt;strong&gt;2차 세미나&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;1차-세미나-확장하기&quot;&gt;&lt;strong&gt;1차 세미나 확장하기&lt;/strong&gt;&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Activity를 만들 떄 어디에 어떤게 추가될까?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;자동으로 Activity를 만들 떄 android studio가 우리가 만드는 Activity를 manifest파일에 추가해준다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ad\ad08.png&quot; alt=&quot;안드로이드&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ad\ad09.png&quot; alt=&quot;안드로이드&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같은 화면의 전환을 담당하는 메시징 객체 Intent&lt;br /&gt;
Intent 객체를 이용해 다른 액티비티를 호출하고 화면의 전환을 할 수 있다&lt;/p&gt;

&lt;p&gt;인텐트에는 명시적 인텐트, 암시적 인텐트 2가지 유형이 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;명시적 인텐트: 내가 시작하려는 구성요소가 무엇인지 명시적으로 지정할때 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ad\ad10.png&quot; alt=&quot;안드로이드&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;암시적 인텐트: 내가 하려는 인텐트의 활동과 데이터를 지정하긴 했는데 호출할 대상이 달라질 수 있는 경우 사용, 쉽게 말하면 어떤 활동과 데이터를 보낼지는 있는데 무엇을 켜야할지 모를때 사용한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ad\ad11.png&quot; alt=&quot;안드로이드&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;백스택이란?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;액티비티들은 실행된 순서대로 스택에 차곡차곡 쌓이는데,  이때 이 스택을 백스택이라고 한다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ad\ad12.png&quot; alt=&quot;안드로이드&quot; /&gt;&lt;/p&gt;

&lt;p&gt;startActivity()는 액티비를 호출하는 함수이고, finish()는 액티비티를 (destroy)종료 하는 함수이다&lt;br /&gt;
startActivity() 함수만 사용해서 Activity를 전환한다면&lt;br /&gt;
ex) 버튼을 클릭해서 화면 전환시 : 로그인 화면 -&amp;gt; 회원가입 화면 -&amp;gt; 로그인 화면&lt;br /&gt;
뒤로가기 버튼 클릭시: 앱꺼짐 &amp;lt;- 로그인 화면 &amp;lt;- 회원가입 화면 &amp;lt;- 로그인 화면&lt;/p&gt;

&lt;p&gt;finish() 함수를 사용할 경우: 스택 관리를 통해 화면전환을 관리할 수 있다&lt;br /&gt;
ex) 버튼을 클릭해서 화면 전환시: 로그인 화면 -&amp;gt; 회원가입 화면, 로그인 화면 &amp;lt;- 회원가입 화면&lt;br /&gt;
뒤로가기 버튼 클릭시: 업꺼짐 &amp;lt;- 로그인 화면&lt;/p&gt;

&lt;h3 id=&quot;fragment&quot;&gt;&lt;strong&gt;Fragment&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;액태비티 만으로 개발을 한다면 윗 부분은 같은 화면이고 아래 부분만 다른 화면을 만들어야 하면 다른 액티비티에 같은 뷰를 또 만들어야 해서 비효율 적이다&lt;br /&gt;
중복되는 화면을 처리하고 싶고 다양한 기기에 적용하고 싶을 때 fragment를 이용한다&lt;br /&gt;
Fragment: fragment UI를 개별적으로 분할할 수 있도록 하여 Acitivty UI에 모듈성과 재사용성을 올려준다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Fragment의 특징&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Fragment는 자체 레이아웃, 자체 생명주기, 자체 이벤트 처리를 가질 수 있다&lt;/li&gt;
  &lt;li&gt;여러 Activity에서 하나의 Fragment를 사용해서 UI 표현 가능 -&amp;gt; 재사용성이 뛰어나다&lt;/li&gt;
  &lt;li&gt;런타임 동안 Acitivty 내에서 Fragment의 추가/교체/삭제 가능&lt;/li&gt;
  &lt;li&gt;Fragment는 독립적으로 존재할 수 없고, 반드시 Activity나 다른 Fragment에 호스팅 되어야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ad\ad13.png&quot; alt=&quot;안드로이드&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Fragment의 생명주기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ad\ad14.png&quot; alt=&quot;안드로이드&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;onCreate(): Fragment가 생성될 때 호출(UI 초기화는 불가능) (Fragment 생성)&lt;/li&gt;
  &lt;li&gt;onCreateView(): Fragment의 뷰를 그리는 시점. 뷰 관련된 초기화가 이루어짐(대부분의 코드는 우선 여기서 작성) (뷰 생성)&lt;/li&gt;
  &lt;li&gt;onViewCreated(): onActivityCreated가 Deprecated되고 추가된 콜백 메소드, View가 만들어지고 난 후이며 이때부터 Fragment가 Activity에 온전히 접근 가능&lt;/li&gt;
  &lt;li&gt;onDestroyView(): Fragment의 뷰가 소멸되는 시점(Fragment가 소멸되는건 아님) (뷰 소멸)&lt;/li&gt;
  &lt;li&gt;onDestroy(): Activity 또는 Fragment가 소멸될 때 호출 (Fragment 소멸)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Fragment&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;return inflater.inflate(R.layout.fragment_sample, container, fasle): xml을 메모리에 객체화 시키는 함수, xml 리소스 정보를 해석하여 View를 생성하고 rootView를 리턴한다&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;만약 ViewGroup이 FramLayout이라면 ConstraintLayout으로 바꾸면 된다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Activity내에서 Fragment를 띄우기 위해서는 xml 파일에 FragmentContainerView를 추가하면 된다&lt;/li&gt;
  &lt;li&gt;android:name=”com.lee989898.soptlee.SampleFragment”처럼 android:name 속성을 통해 xml상에서 바로 Fragment를 inflate 시킬 수도 있지만 유연하지 못하다&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Activity 레이아웃 내의 Fragment UI 위치를 지정할 때는 FragmentContainerView를 사용하길 권장한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Fragment Transaction: 액티비티에서 프래그먼트를 추가,교체,삭제 작업을 수행하기 위해 사용한다
    &lt;ul&gt;
      &lt;li&gt;FragmentManager 클래스에 구현되어 있음&lt;/li&gt;
      &lt;li&gt;수행한 트랜잭션의 상태를 백스택에 저장 가능&lt;/li&gt;
      &lt;li&gt;Fragment 전환 애니메이션 설정 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;실습&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Fragment Transaction을 이용해서 Fragment를 Acitivty에 추가하고 교체하기&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SampleActivity.kt&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.lee989898.soptlee&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;androidx.appcompat.app.AppCompatActivity&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;android.os.Bundle&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.lee989898.soptlee.databinding.ActivitySampleBinding&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SampleActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;companion&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;FIRST_POSITION&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;SECOND_POSITION&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FIRST_POSITION&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lateinit&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ActivitySampleBinding&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ActivitySampleBinding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;inflate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layoutInflater&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;setContentView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;nf&quot;&gt;initTransactionEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initTransactionEvent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;fragment1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SampleFragment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;fragment2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SampleFragment2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;supportFragmentManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;beginTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fragment_main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fragment1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;commit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;btnFragment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;setOnClickListener&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;transaction&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;supportFragmentManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;beginTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;FIRST_POSITION&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fragment_main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fragment2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SECOND_POSITION&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;SECOND_POSITION&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fragment_main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fragment1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FIRST_POSITION&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;commit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;add(): 프래그먼트를 추가&lt;/li&gt;
  &lt;li&gt;replace(): 이전 프래그먼트를 제거 후 추가(교체)&lt;/li&gt;
  &lt;li&gt;SupportFragmentManager로 FragmentManage를 호출&lt;/li&gt;
  &lt;li&gt;beginTransation()을 통해 트랜잭션 작업(추가/교체/삭제)생성&lt;/li&gt;
  &lt;li&gt;commit()을 통해 작업을 수행&lt;/li&gt;
  &lt;li&gt;가독성을 위해 상수 값 선언(자바에서 static final과 유사)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Fragment에서 ViewBinding 사용법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Activiy와 같은 방식으로 만들면 안된다&lt;br /&gt;
Fragment View(화면)의 생명주기가 Fragment 자제의 생명주기보다 짧기 때문에 View는 죽어도 Fragment 자체는 살아있는 상황이 생길 수 있다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ad\ad15.png&quot; alt=&quot;안드로이드&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Fragment를 보유한 Activity가 화면 회전을 할 떄 (화면 회전시 Activity는 OnDestroy()를 호출 했다가 다시 onCreate()를 호출한다)&lt;br /&gt;
Activity는 onDestroy() 되었지만 그 안에 Fragment인 경우 onDestroyView()까지만 호출되고 onDestroy()가 호출되지 않는다&lt;/p&gt;

&lt;p&gt;Binding은 뷰참조를 하기 위해 생성하는 것인데 Fragment는 살아있고 Fragment의 View가 파괴된다면?&lt;br /&gt;
만약 Fragment에서 onDestroy()가 호출되지 않고 onDestroyView()만 호출된다면, Fragment는 계속 살아있으니깐 binding 변수에는 다시 onCreateView()가 호출되기 전까지 이미 죽은 View가 계속 참조될 수 있다. 이럴 경우 분명히 죽어야 되는데 죽지않은 좀비 객체가 생기게 된다. 이러한 좀비 객체의 발생은 휴대폰의 메모리 누수를 유발하게 된다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ad\ad16.png&quot; alt=&quot;안드로이드&quot; /&gt;&lt;/p&gt;

&lt;p&gt;구글 공식문서에서는 Property(filed + getter + setter)을 이용해서 해결한다&lt;br /&gt;
앨비스 연산자를 활용해서 private val binding get() = _binding ?: error(“Binding이 초기화 되지 않았습니다.”)처럼 작성도 가능하다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ad\ad17.png&quot; alt=&quot;안드로이드&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;recyclerview&quot;&gt;&lt;strong&gt;RecyclerView&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;RecyclerView: 앱에서의 List를 표현할 떄 사용하는 뷰&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;가로/세로/격자방향을 지원&lt;/li&gt;
  &lt;li&gt;ItemDecoration을 이용해 동적인 데코레이션 가능&lt;/li&gt;
  &lt;li&gt;ItemAnimator를 이용해 애니메이션을 넣을 수 있다&lt;/li&gt;
  &lt;li&gt;이름 그대로 View를 재사용하기 때문에 효율적&lt;/li&gt;
  &lt;li&gt;ListView보다 유연 -&amp;gt; 커스텀이 편함&lt;/li&gt;
  &lt;li&gt;ViewHolder 패턴이 강제 되기 때문에 스크롤 시 마다 View를 Create하는게 아닌 재활용을 할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ad\ad18.png&quot; alt=&quot;안드로이드&quot; /&gt;&lt;/p&gt;

&lt;p&gt;RecylcerView 작업 순서&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;item 하나의 UI를 확인&lt;/li&gt;
  &lt;li&gt;확인한 하나의 UI Layout 파일 만들기&lt;/li&gt;
  &lt;li&gt;item data class 만들기&lt;/li&gt;
  &lt;li&gt;UI의 요소가 들고있는 ViewHolder 만들기&lt;/li&gt;
  &lt;li&gt;RecyclerView Adapter 만들기&lt;/li&gt;
  &lt;li&gt;RecyclerView 배치&lt;/li&gt;
  &lt;li&gt;RecyclerView item 배치 확인하기 (LayoutManager)&lt;/li&gt;
  &lt;li&gt;RecyclerView Adater 연결하기&lt;/li&gt;
  &lt;li&gt;Adapter 데이터 갱신하기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1.아이템 레이아웃 만들기&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;item_sample_list.xml&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;?&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xml&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1.0&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;androidx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constraintlayout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;widget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ConstraintLayout&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xmlns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;xmlns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://schemas.android.com/apk/res-auto&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;xmlns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tools&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://schemas.android.com/tools&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout_width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;match_parent&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout_height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;paddingVertical&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;10dp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ImageView&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@+id/iv_profile&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout_width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0dp&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout_height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0dp&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@drawable/profile&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout_constraintBottom_toBottomOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;parent&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout_constraintDimensionRatio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1:1&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout_constraintStart_toStartOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;parent&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout_constraintTop_toTopOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;parent&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout_constraintWidth_percent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0.25&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TextView&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@+id/tv_name&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout_width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout_height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout_marginStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;20dp&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;textColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@color/black&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;textSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;20sp&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout_constraintStart_toEndOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@id/iv_profile&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout_constraintTop_toTopOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@id/iv_profile&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tools&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;이름&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TextView&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@+id/tv_introduce&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout_width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout_height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;textColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@color/black&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;textSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;14sp&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout_constraintBottom_toBottomOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;parent&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout_constraintStart_toStartOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@id/tv_name&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout_constraintTop_toBottomOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@id/tv_name&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tools&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;자기 소개 텍스트 입니다&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&amp;gt;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;androidx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constraintlayout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;widget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ConstraintLayout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;tools: 레이아웃 편집기 상에서는 preview에 반영되어 나타나지만 컴파일 시에는 앱에 반영되지 않는 속성(미리보기 속성)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2.데이터 클래스 만들기&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;UserData.kt&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.lee989898.soptlee&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;data class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;introduction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Data ckass: kotlin에서 제공하는 데이터만을 다루는 클래스&lt;br /&gt;
Data들은 어디다 띄워야 할까? -&amp;gt; ViewHolder가 가지고 있는 View(Item Layout)안에 넣어주면 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ViewHolder: RecyclerView의 재활용 되는 Item Layout(View)을 붙잡고 관리하는 역할&lt;br /&gt;
Adapter에서 전달받은 데이터를 Item Layout에 Bind 시켜주는 역할&lt;br /&gt;
한 번 ViewHolder가 생성되고 나면 계속해서 재활용 된다&lt;/p&gt;

&lt;p&gt;Adapter: ViewHolder를 생성하고 ItemLayout을 ViewHolder에 넘겨준다&lt;br /&gt;
리스트로 보여줄 Data를 각 ViewHodelr에 전달해준다&lt;/p&gt;

&lt;p&gt;3.ViewHodelr와 Adapter 만들기&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.lee989898.soptlee&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;android.view.LayoutInflater&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;android.view.ViewGroup&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;androidx.recyclerview.widget.RecyclerView&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.lee989898.soptlee.databinding.ItemSampleListBinding&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FollowerAdapter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RecyclerView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Adapter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;FollowerAdapter&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;FollowerViewHolder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;userList&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutableListOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;UserData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreateViewHolder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewGroup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viewType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FollowerViewHolder&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;binding&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;ItemSampleListBinding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;inflate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;LayoutInflater&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FollowerViewHolder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onBindViewHolder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;holder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FollowerViewHolder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;holder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onBind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getItemCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;userList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;


    &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FollowerViewHolder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ItemSampleListBinding&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RecyclerView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ViewHolder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onBind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tvName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tvIntroduce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;introduction&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;ViewHolder 코드 분석
    &lt;ul&gt;
      &lt;li&gt;class FollwerViewHolder에서 Binding 객체를 생성자로 가지게 만들고, RecyclerView.ViewHolder 클래스 상속 이 때 RecyclerView.ViewHodler 클래스로 생성자로 View를 요구하므로, binding.root(root뷰)를 넘겨준다&lt;/li&gt;
      &lt;li&gt;onBind 함수는 ViewHolder가 가진 View에 Adapter로 부터 전달받은 데이터를 붙여주는 함수(onBindViewHolder 호출 시 실행되는 함수)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Adapter 코드 분석
    &lt;ul&gt;
      &lt;li&gt;RecyclerView.Adapter()를 상속 받는다, &amp;lt;&amp;gt;안에 해당 Adapter가 데이터를 전달할 ViewHolder 클래스 작성&lt;/li&gt;
      &lt;li&gt;getItemCount(): RecyclerView로 보여줄 전체 데이터의 개수 반환&lt;/li&gt;
      &lt;li&gt;onCreateViewHolder: ViewHolder를 생성하고 ItemLayout의 Binding 객체를 만들어 ViewHodler의 생성자로 넘겨주는 함수
        &lt;ul&gt;
          &lt;li&gt;LayoutInflator: xml layout을 코드에서 쓸 수 있도록 하는 과정은 inflate 였다. 이러한 inflate 과정을 통해 뷰를 만들거나 RecylcerView에 ViewHolder에서 뷰를 만들떄 LayoutInflater라는 것을 사용한다. 간단하게 말해서 액티비티, 프래그먼트와 다르게 뷰를 만들어주는 친구의 도움을 받는다고 생각하자&lt;/li&gt;
          &lt;li&gt;.from(): 이렇게 뷰를 만들어주는 LayoutInflater에는 Context가 필요하다. Context란 간단하게 말해서 앱의 흐름이자 정보를 담는 친구이다. 해당 Context라는 친구가 있어야 우리가 만드는 앱의 리소스에도 접근할 수 있다. 간단히 뷰홀더 안에 우리가 사용할 뷰의 참조할 친구를 전달하기 위해서 어떤 layout에 접근해야할지 앱의 흐름이자 정보를 알아야 한다&lt;/li&gt;
          &lt;li&gt;parent에는 뷰그룹이라는 친구가 들어온다. 해당 뷰를 보여줄 뷰그룹을 받아서 해당 뷰그룹은 어떤 흐름(Context)에 생성되야 할지 정보를 가지고 있다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;onBindViewHolder(): 재활용 되는 뷰(ViewHodler의 뷰)가 호출하여 실행되는 함수, ViewHolder와 postion의 데이터를 결합시키는 역할을 하는 함수이다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;4.RecyclerView 배치, RecyclerView item 배치 확인하기 (LayoutManager)&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;?&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xml&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1.0&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;androidx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constraintlayout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;widget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ConstraintLayout&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xmlns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;xmlns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://schemas.android.com/apk/res-auto&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;xmlns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tools&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://schemas.android.com/tools&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout_width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;match_parent&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout_height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;match_parent&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tools&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;.MainActivity&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;androidx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recyclerview&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;widget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;RecyclerView&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@+id/rv_follower&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layoutManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;androidx.recyclerview.widget.LinearLayoutManager&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tools&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;itemCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;4&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tools&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;listitem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@layout/item_sample_list&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout_width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;match_parent&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout_height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;match_parent&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;/&amp;gt;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;androidx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constraintlayout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;widget&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ConstraintLayout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;itemCount: Preview상에서 몇개의 아이템을 띄워줄 것인지 결정&lt;/li&gt;
  &lt;li&gt;listItem: Preview상에서 어떤 listLayout을 리스트에 띄울 지 결정&lt;/li&gt;
  &lt;li&gt;LayoutManager: Item의 배치 규칙을 관리하는 클래스
    &lt;ul&gt;
      &lt;li&gt;LinearLayoutManager: 선형(수평/수직)으로 Item을 보여줄 때 사용&lt;/li&gt;
      &lt;li&gt;GridLayoutManager: 격자식으로 Item을 보여줄 때 사용 코드 또는 xml 상에서 가로로 몇 칸 보여줄 지 설정가능&lt;/li&gt;
      &lt;li&gt;StageredGridLayoutManager: 높이가 불규칙한 형태의 격자식 Item 리스트를 보여줄 때 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;5.RecyclerView Adapter 연결하기, Adapter 데이터 갱신하기&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.lee989898.soptlee&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;androidx.appcompat.app.AppCompatActivity&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;android.os.Bundle&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.lee989898.soptlee.databinding.ActivityMainBinding&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MainActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lateinit&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;followerAdapter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FollowerAdapter&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lateinit&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ActivityMainBinding&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ActivityMainBinding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;inflate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layoutInflater&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;setContentView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;nf&quot;&gt;initAdapter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initAdapter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;followerAdapter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FollowerAdapter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rvFollower&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;adapter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;followerAdapter&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;followerAdapter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;userList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;addAll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;UserData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;이강민&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;안드로이드 파트장&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;UserData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;김태현&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;IOS 파트장&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;UserData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;김두범&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;기획 파트장&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;UserData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;권혁진&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;웹 파트장&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;UserData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;채정아&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;서버 파트장&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;UserData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;박수아&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;디자인 파트장&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;followerAdapter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;notifyDataSetChanged&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;private lateinit var followerAdapter: FollowerAdapter, follwerAdapter = FollowerAdapter() -&amp;gt; Adapter 초기화&lt;/li&gt;
  &lt;li&gt;followerAdapter = FollowerAdapter(): Adapter와 RecyclerView 연동&lt;/li&gt;
  &lt;li&gt;followerAdapter.userList.addAll(): Adapter에 List로 보여줄 데이터를 넣어준다&lt;/li&gt;
  &lt;li&gt;followerAdapter.notifyDataSetChanged(): Adpater에 전체 리스트의 데이터가 갱신되었다고 알려주는 메소드&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="android" />
      

      
        <summary type="html">2차 세미나</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">MVVM</title>
      <link href="https://lee989898.github.io/ad" rel="alternate" type="text/html" title="MVVM" />
      <published>2022-04-11T01:06:00+09:00</published>
      <updated>2022-04-11T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/ad</id>
      <content type="html" xml:base="https://lee989898.github.io/ad">&lt;h2 id=&quot;mvvm&quot;&gt;&lt;strong&gt;MVVM&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;디자인패턴을 쓰는 이유&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;디자인 패턴은 소프트웨어 개발 방법을 문서로 공식화한 것인데, 디자인 패턴이란 한마디로 패턴이다. 기존에 앱을 만들면서 사람들이 여러가지 공법들을 적용해서 문제를 해결해 나갔는데, 이렇게 기존의 많은 개발자들이 쌓아놓은 경험을 통해서 쌓인 정리되어있는 패턴으로 만들면 일정한 규칙에 의해서 문제를 해결해 나가기에 코드의 가독성도 좋아지고 일정한 패턴으로 짜여져있어 테스트도 쉬워지고 타인의 코드를 봐도 이해하는데 쉽다. 또한 유지보수하는데 굉장히 유용하게 된다&lt;/p&gt;

&lt;p&gt;협업을 위해서 어느 위치에 어떤 로직이 들어있나를 미리 정의해 놓으면&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;비슷한 코드를 보고 알아보기 쉬워짐&lt;/li&gt;
  &lt;li&gt;유지보수가 수월해짐&lt;/li&gt;
  &lt;li&gt;코드들의 역할분리가 명확해짐 (객체간의 관심사 분리)&lt;/li&gt;
  &lt;li&gt;의존관계과 분리됨 (변화에 유연함 새로운 기능이나 코드가 좀 바뀌어도 코드가 유지됨)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;아래는 위키피다이의 설명이다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;소프트웨어 개발 방법에서 사용되는 디자인 패턴은, 프로그램 개발에서 자주 나타나는 과제를 해결하기 위한 방법 중 하나로, 과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것이다. 알고리즘과 같이 프로그램 코드로 바로 변환될 수 있는 형태는 아니지만, 특정한 상황에서 구조적인 문제를 해결하는 방식을 설명해준다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;처음 개발할때 안드로이드 개발을 하면 스파게티 코드를 짜서 나중에 봤을떄 답도 없었던 기억이 있는데, 간단한 앱에서는 문제가 없을수 있지만 디자인 패턴없이 복잡한 로직의 앱을 만들다보면 수정사항이 있을 떄마다 화면을 구성하는 코드와 비지니스 로직이 들어간 코드를 매번 동시에 수정해야한다. (ex) xml파일이랑 액티비티 파일)
이 말은 서로간의 의존성이 강하다는 것이다. 의존성이 강해질수록 유지보수가 힘들기에 이러한 의존성을 해결하는 방법으로 model과 view의 관계를 해결하는 mvp, mvvm 같은 여러 패턴을 사용한다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;MVVM&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;MVVM패턴이란 Model, View, ViewModel의 줄임말이다. 하나의 소프트웨어를 최대한 기능적으로 작은 단위로 나누어 테스트가 쉽고 큰 프로젝트도 상대적으로 관리하기가 좋은 구조이다&lt;/p&gt;

&lt;p&gt;MVVM이 나오게 된 과정&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;처음 스파게티 코드&lt;/li&gt;
  &lt;li&gt;mvc 스파게티 코드와 다를 바 없다. 안드로이드 특성상 뷰와 컨트롤러 자체가 모두 액티비티, 프래그먼트에 포함되어 있기 때문이다. 컨트롤러가 코틀린 파일이고 view가 xml이 된다. 모델은 따로 분리되어있지만 어차피 코틀린 파일에서 직접호출하여 결합도는 높다&lt;/li&gt;
  &lt;li&gt;mvp 액티비티/프래그먼트 자체가 뷰이다. 프리젠터는 따로 클래스 자체가 분리된것이다. 뷰는 프리젠터에 일을 시키고 프리젠터는 모델에서 정보를 가져온다. 데이터 프리젠터가 가공해서 뷰에 넘겨준다. (개선점: 뷰량 모델을 완전히 분리하게 됨) (문제점: 프리젠터가 너무 커지고 뷰랑 프리젠터에 양방향 의존성이 생겨 1:1 관계가 만들어져서 재활용이 안된다)&lt;/li&gt;
  &lt;li&gt;그래서 mvvvm이 나왔다. 뷰는 뷰모델을 알지만 뷰모델은 뷰가 뭔지 모름 어디서 쓰이는지 그걸 느슨하게 데이터 바인딩으로 묶어 놓음, 뷰에 대한 상태 같은 것들을 뷰모델에 박아놓음, 뷰는 뷰모델을 관찰하고 있고 변경점이 생기면 뷰가 알아채서 스스로 갱신하는 것이 mvvm이다. 근데 사실 여기에 바인더라는 레이어가 뷰랑 뷰모델 사이에 숨어있다-&amp;gt; 안드로이드에서는 데이터 바인딩으로 지원한다. 데이터 바인딩을 안쓰면 그건 그냥 mvp로 봐도 무방하다. 그리고 Viewmodel은 aac의 뷰모델이 아니다 -&amp;gt; aac뷰모델은 안드로이드 라이프사이클에 종속되고 사실상 가로뷰 세로뷰 다른뷰라고 봐도 무방하다. 다시 정리하자면 뷰와 모델은 이미 mvp에서 분리되었고 뷰랑 뷰모델을 분리시키는 것이 mvvm의 목표이다 결론은 xml로 다 옮기자&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ad\ad07.png&quot; alt=&quot;안드로이드&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기본적인 mvvm구조인데&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;View
    &lt;ul&gt;
      &lt;li&gt;사용자에게 보여지는 UI 부분이다&lt;/li&gt;
      &lt;li&gt;View는 액티비티나 프래그먼트 같은 화면에 표현되는 레이아웃을 정의함&lt;/li&gt;
      &lt;li&gt;View는 기본적으로 데이터를 보여주기만 해야 해서 비즈니스 로직을 포함하지 않지만 UI 변경과 관련된 일부 로직은 포함될 수 있음
(안드로이드는 다른 플랫폼과는 다르게 생명주기라는 특수한 순서를 가지고 있기 때문에 이것을 처리하는 것만으로도 View는 상당히 복잡해지기 때문임)&lt;/li&gt;
      &lt;li&gt;View는 ViewModel을 관찰하고 있다가 상태 변화가 전달되면 화면을 갱신해야함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ViewModel
    &lt;ul&gt;
      &lt;li&gt;View를 표현하기 위해 만든 View를 위한 Model이다. View를 나타내 주기 위한 Model이자 View를 나타내기 위한 데이터 처리를 하는 부분이다&lt;/li&gt;
      &lt;li&gt;View와 Model 사이의 매개체 역할음 함&lt;/li&gt;
      &lt;li&gt;모든 View와 관련된 비즈니스 로직은 이 곳에 들어가게 되며 데이터를 잘 가공해서 View에서 뿌리기 쉬운 Model로 바꾸는 역할을 함&lt;/li&gt;
      &lt;li&gt;View와 ViewModel은 MVP와는 다르게 1:n의 관계를 가질 수 있으며 여러 개의 프래그먼트가 하나의 ViewModel을 가질 수 있음&lt;/li&gt;
      &lt;li&gt;ViewModel은 View가 데이터 바인딩 할 수 있는 속성과 명령으로 구성되어 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Model
    &lt;ul&gt;
      &lt;li&gt;어플리케이션에서 사용되는 데이터와 그 데이터를 처리하는 부분이다&lt;/li&gt;
      &lt;li&gt;MVC의 Model과 역할은 동일하다&lt;/li&gt;
      &lt;li&gt;DataModel이라고도 하며 DB, Network, SharedPreference 등 다양한 데이터 소스로부터 필요한 데이터를 준비함&lt;/li&gt;
      &lt;li&gt;ViewModel에서 데이터를 가져갈 수 있게 데이터를 준비하고 그에 대한 “이벤트”를 보냄&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;동작&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;사용자의 Action들은 View를 통해 들어오게 된다&lt;/li&gt;
  &lt;li&gt;View에 Action이 들어오면, Command 패턴(실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴)으로 View Model에 Action을 전달합니다&lt;/li&gt;
  &lt;li&gt;View Model은 Model에게 데이터를 요청한다&lt;/li&gt;
  &lt;li&gt;Model은 View Model에게 요청받은 데이터를 응답한다&lt;/li&gt;
  &lt;li&gt;View Model은 응답 받은 데이터를 가공하여 저장한다&lt;/li&gt;
  &lt;li&gt;View는 View Model과 Data Binding 하여 화면을 나타낸다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;모든 입력들은 View로  전달되며 ViewModel은 입력에 해당하는 Presentation Logic (말 그대로 보여주기 위한 로직, 화면상의 디자인 구성을 위한 로직, ex) 게시판에서의 표시하기 위한 for문 등의 사용 &amp;lt;-&amp;gt; 비즈니스 로직: 백엔드에서 일어나는 각종 처리를 일컫는 말)을 처리하여 View에 데이터를 전달한다.&lt;br /&gt;
ViewModel은 View를 따로 참조하지 않기 때문에 독립적으로 ViewModel과 View는 1:n의 관계이다. (자유롭다)&lt;/p&gt;

&lt;p&gt;따라서 View는 자신이 이용할 ViewModel을 선택해 데이터를 바인딩하여 업데이트를 받게 된다
그 후 Model이 상태 및 데이터가 변경되면 해당하는 ViewModel을 이용하는 View가 자동으로 업데이트 된다&lt;br /&gt;
마지막으로 ViewModel은 View를 나타내기 위한 Model이자, View의 Presentaition Logic을 처리한다&lt;br /&gt;
MVP와 마찬가지로 M-V 사이의 의존성이 없고, MVP처럼 V-VM이 1:1 관계가 아닌 독립적이기 때문에 이 둘 사이의 의존성도 없다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;결론&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;MVVM 패턴은 Command 패턴과 Data Binding 두 가지 패턴을 사용하여 구현된다&lt;br /&gt;
Command 패턴과 Data Binding을 이용하여 View와 View Model 사이의 의존성을 없앤다&lt;/p&gt;

&lt;p&gt;뷰는 뷰모델을 알지만 뷰모델은 뷰가 뭔지, 어디서 쓰이는지 모른다. 그걸 느슨하게 데이터 바인딩으로 묶어논다&lt;br /&gt;
뷰에 대한 상태 같은 것들을 뷰모델에 저장한다&lt;br /&gt;
뷰는 뷰모델을 관찰하고 있고 변경점이 생기면 뷰가 알아채서 스스로 갱신하는 것이 MVVM이다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;장점&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;각각의 부분은 독립적이기 때문에 모듈화 하여 개발할 수 있다&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;단점&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;View Model의 설계가 쉽지 않다&lt;/li&gt;
  &lt;li&gt;특정 아키텍처로 개발을 시작하면 다른 아키텍쳐로 변환이 거의 불가능하다 -&amp;gt; 프로젝트를 다시 만드는 수준&lt;/li&gt;
  &lt;li&gt;프로젝트에 아키텍쳐별 상성있어서 나중에 프로젝트가 안맞다고 꺠닳으면 늦는다 -&amp;gt; 비효율적인 코드 생성&lt;/li&gt;
  &lt;li&gt;생산속도 엄청나게 느려진다 -&amp;gt; 기능 하나 만들때마다 파일을 엄청 많이 만들어야한다. 레이어 마다 파일들을 만들어야 해서 보일러 플레이트 코드(최소한의 변경으로 여러곳에서 재사용되며, 반복적으로 비슷한 형태를 띄는 코드)가 양산된다&lt;/li&gt;
&lt;/ol&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="android" />
      

      
        <summary type="html">MVVM</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">1차 세미나</title>
      <link href="https://lee989898.github.io/ad" rel="alternate" type="text/html" title="1차 세미나" />
      <published>2022-04-09T01:06:00+09:00</published>
      <updated>2022-04-09T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/ad</id>
      <content type="html" xml:base="https://lee989898.github.io/ad">&lt;h2 id=&quot;1차-세미나&quot;&gt;&lt;strong&gt;1차 세미나&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;android-studio&quot;&gt;&lt;strong&gt;Android Studio&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Androidmanifest.xml: 앱에 대한 기본 정보를 정의&lt;/li&gt;
  &lt;li&gt;java: 프로젝트의 코드가 들어감&lt;/li&gt;
  &lt;li&gt;res: 안드로이드 각종 자료(이미지, 레이아웃, 문자열 등)을 모아 관리하는 곳&lt;/li&gt;
  &lt;li&gt;Gradle Scripts: 안드로이드 프로젝트 빌드 방법을 정의하는 곳&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;minSdk란?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;애플리케이션이 실행하는데 필요한 최소 API 레벨&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;성능을 향상시키는 여러가지 획기적인 기술도입이 있었던 버전21(롤리팝)&lt;/li&gt;
  &lt;li&gt;런타임 퍼미션을 사용하는 버전 23(마시멜로)&lt;/li&gt;
  &lt;li&gt;개인적으로 개발하는 어플이라면 버전26(오레오) (API 26 이전의 백그라운드 실행방식을 고려하지 않아도 되는 장점이 있음!)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ad\ad01.png&quot; alt=&quot;안드로이드&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;__view--viewgroup&quot;&gt;__View &amp;amp; ViewGroup&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;ViewGroup: Layout. 뷰 그룹은 뷰를 담는 그릇&lt;/li&gt;
  &lt;li&gt;View: Widget, 사용자 눈에 보이는 화면의 모든 구성요소(Ex)  TextView, Button, EditText)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ad\ad02.png&quot; alt=&quot;안드로이드&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ViewGroup도 View를 상속받아 만든 class이다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ad\ad03.png&quot; alt=&quot;안드로이드&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;xml&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;xml의 아이템은 이름과 속성을 가진다&lt;/li&gt;
  &lt;li&gt;xml은 부모 자식 관계가 있다&lt;/li&gt;
  &lt;li&gt;layout_width(View의 너비), layout_hegiht(View의 높이)
    &lt;ul&gt;
      &lt;li&gt;match_parent: View의 크기를 부모뷰의 크기만큼 설정&lt;/li&gt;
      &lt;li&gt;wrap_content: View의 크기를 Content 크기만큼 설정&lt;/li&gt;
      &lt;li&gt;정수 dp: 정수만큼의 고정적인 크기를 Content 크기만큼 설정&lt;/li&gt;
      &lt;li&gt;0dp: margin값을 제외한 영역 전체 크기를 차지(match_constraint)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;margin: 해당 뷰를 기준으로 다른 뷰로부터 어느정도 떨어질 것인가?&lt;/li&gt;
  &lt;li&gt;padding: 해당 뷰 내부 Content로부터 얼마나 떨어질 것인가?&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;constraint-layout&quot;&gt;&lt;strong&gt;Constraint Layout&lt;/strong&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;상대적인 제약을 통해 View/ViewGroup을 배치한다&lt;/li&gt;
  &lt;li&gt;Widget의 가로/세로 모두가 제약에 걸려야 한다&lt;/li&gt;
  &lt;li&gt;RelativeLayout에서 확장된 Layout입니다&lt;/li&gt;
  &lt;li&gt;bias: 한쪽으로 치우치게 하기&lt;/li&gt;
  &lt;li&gt;만약 왼쪽 12dp 마진을 제외하고 나머지 오른쪽 빈 공간을 꽉 채우고 싶다면 -&amp;gt; layout_width=0dp(=match_constraint) (match_parent와 다르다)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;__activity와-viewbinding&quot;&gt;__Activity와 ViewBinding&lt;/h3&gt;

&lt;p&gt;UI를 그리는 XML + 각 View의 기능과 동작방식을 정의한 코드 = 어플리케이션&lt;/p&gt;

&lt;p&gt;View의 기능과 동작을 정의하는 코드를 Activity 클래스에 작성한다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Activity란?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;사용자 인터페이스 화면을 구성하는 컴포넌트&lt;/li&gt;
  &lt;li&gt;앱의 상태변화가 일어날 때마다 생명 주기의 특정 단계에 해당하는 특정 콜백 메서드를 호출함&lt;/li&gt;
  &lt;li&gt;xml로 작성된 UI를 그리는 창을 제공함&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;생명주기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ad\ad04.png&quot; alt=&quot;안드로이드&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;생명주기: 컴포넌트가 메모리에 들어가서 소멸되기까지의 과정&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;액티비티 실행전: onCreate() -&amp;gt; onStart() -&amp;gt; onResume()&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;액티비티 종료전: onPause() -&amp;gt; onStop -&amp;gt; onDestroy()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;onCreate(): Activity의 EntryPoint
    &lt;ul&gt;
      &lt;li&gt;onCreate의 경우 반드시 구현되어야 하는 부분으로, Activity를 만들때 단 한번 만 하는 작업을 이곳에서 많이 해준다. 따라서 뷰 초기화나, 리스너 설정 등등을 이 부분에서 하게 되고, 자연스럽게 많은 코드가 onCreate에 작성되곤 한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;onStart(): 화면이 사용자에게 보여질 떄 호출된다&lt;/li&gt;
  &lt;li&gt;onResume(): 화면이 사용자와 상호작용하는 시점에 호출된다&lt;/li&gt;
  &lt;li&gt;onPause(): 팝업이나 다이얼로그로 인해 화면의 일부가 가려졌을 떄 호출된다&lt;/li&gt;
  &lt;li&gt;onStop(): 화면 전환등으로 Activity가 더이상 사용자에게 보여지지 않을 떄 호출된다&lt;/li&gt;
  &lt;li&gt;onDestroy(): Activity가 사용자나 시스템에 의해 완전히 종료될 떄 호출된다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;SetContentView()란?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;레이아웃 xml의 내용을 파싱하여 뷰를 생성하고, 뷰에 정의된 속성을 설정하는 함수&lt;/li&gt;
  &lt;li&gt;우리가 만든 xml의 View를 참조하기 위해선 레이아웃 xml을 메모리에 객체화 시켜야 한다&lt;/li&gt;
  &lt;li&gt;안드로이드에서는 setContentView()라는 함수를 통해 xml을 객체화 시킨다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;ViewBinding이란?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;findViewById()라는 함수는 상당히 무겁다 또한 null값에 상대적으로 안전하지 않다 -&amp;gt; ViewBinding&lt;/li&gt;
  &lt;li&gt;각 XML 레이아웃 파일마다 Binding 클래스(Binding 클래스의 객체에는 상응하는 레이아웃파일의 ID가 있는 모든 뷰의 직접 참조가 포함된다)를 생성하는 기능 (또 ID가 없는 뷰의 경우 참조가 생기지 않아 안전하다)&lt;/li&gt;
  &lt;li&gt;사용하려면 build.gradle module에 아래 코드를 추가해야한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ad\ad05.png&quot; alt=&quot;안드로이드&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ViewBinding 사용하기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\ad\ad06.png&quot; alt=&quot;안드로이드&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;intent를-통한-화면전환&quot;&gt;&lt;strong&gt;Intent를 통한 화면전환&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;화면(Activity)의 전환을 담당하는 메시징 객체 Intent&lt;/li&gt;
  &lt;li&gt;startActivity()에 생성한 Intent 객체를 파리미터 값으로 넣어 호출 (Intent(context, 호출할 액티비티::class.java))&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="android" />
      

      
        <summary type="html">1차 세미나</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">안드로이드 면접 준비</title>
      <link href="https://lee989898.github.io/ad" rel="alternate" type="text/html" title="안드로이드 면접 준비" />
      <published>2022-03-19T01:06:00+09:00</published>
      <updated>2022-03-19T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/ad</id>
      <content type="html" xml:base="https://lee989898.github.io/ad">&lt;h2 id=&quot;안드로이드-면접-준비&quot;&gt;&lt;strong&gt;안드로이드 면접 준비&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;안드로이드-질문&quot;&gt;&lt;strong&gt;안드로이드 질문&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Context 란?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Context는 Application의 글로벌 Infomation에 대한 인터페이스다.&lt;br /&gt;
Context를 이용해서 액티비티를 실행시키거나 인텐트를 broadcasting또는 receiving과 같은 어플리케이션 레벨의 명령을 수행 할 수 있다.&lt;br /&gt;
즉 액티비티나 서비스, 여러 컴포넌트들을 시스템과 연결시키는 역할을 한다.&lt;/p&gt;

&lt;p&gt;어플리케이션 환경에 대한 글로벌 정보를 가진 인터페이스&lt;br /&gt;
안드로이드 시스템에 의해 구현이 제공되는 Abstract class&lt;br /&gt;
어플리케이션에 특화된 리소스와 클래스들에 대한 접근&lt;br /&gt;
launching, 액티비티, 브로드케스팅과 intents 수신 등과 같이 어플리케이션 레벨의 동작에 대한 업콜도 가능&lt;br /&gt;
즉, 안드로이드 시스템이 애플리케이션이나 컴포넌트 등을 관리하기 위한 것이라 생각&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;AAC 란?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;AAC는 Android Architecture Components를 뜻하며 테스트와 유지관리가 쉬운 앱을 디자인하도록 돕는 라이브러리 모음이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Intent 란?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Intent는 다른 앱 구성요소로 부터 작업을 요청하는 메세지 객체이다.&lt;br /&gt;
두가지 종류가 있으며, 명시적 인텐트는 수신하는 컴포넌트가 명시적으로 지정된 인텐트이다.&lt;br /&gt;
암시적 인텐트는 해당 작업을 수행 할 수 있는 컴포넌트를 찾아서 수행을 요청하는 인텐트이다.&lt;br /&gt;
주로 액티비티, 서비스를 시작하거나 브로드 캐스트를 전달할 때 사용된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Parcelable 이란?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Parcelable은 JAVA의 Serializable의 안드로이드 구현체다.&lt;br /&gt;
서로 다른 컴포넌트 사이의 데이터 교환에 사용된다.&lt;br /&gt;
안드로이드는 Intent를 통해서 데이터를 전달할 때 Parcelable을 이용해서 전달하는 것을 권장하고 있다.&lt;br /&gt;
만약 다른 앱이 수신할 수 있는 Intent의 경우 Parcelable을 이용하면 안된다.&lt;br /&gt;
그 이유는 다른 앱에서 Parcelable로 구현된 클래스에 접근하지 못하면 런타임 에러가 발생하기 때문이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;4가지의 앱 구성 요소&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;안드로이드 앱은 컴포넌트로 구성되어 있다.&lt;br /&gt;
각 컴포넌트들은 하나의 독립된 형태로 존재하며, 정해진 역할을 수행한다.&lt;br /&gt;
앱의 필수적인 구성 요소로 시스템 또는 사용자가 앱에 들어올 수 있는 진입점이다.
컴포넌트? = 앱의 구성 단위, 컴포넌트를 조합하여 하나의 앱을 만드는 것을 의미&lt;/p&gt;

&lt;h3 id=&quot;activity&quot;&gt;Activity&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;UI 화면을 담당하는 컴포넌트&lt;/li&gt;
  &lt;li&gt;특징
    &lt;ol&gt;
      &lt;li&gt;안드로이드 어플리케이션은 반드시 하나 이상의 Activity를 가지고 있어야 합니다.&lt;/li&gt;
      &lt;li&gt;두개의 액티비티를 동시에 Display할 수 없습니다.&lt;/li&gt;
      &lt;li&gt;다른 어플리케이션의 액티비티도 불러낼 수 있습니다.&lt;/li&gt;
      &lt;li&gt;액티비티 내에는 프래그먼트(Fragment)를 추가하여 화면을 분할시킬 수 있습니다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;service&quot;&gt;Service&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;화면에 존재하지 않고 백그라운드에서 실행되는 컴포넌트&lt;/li&gt;
  &lt;li&gt;특징
    &lt;ol&gt;
      &lt;li&gt;화면이 없습니다. 그저 백그라운드에서 돌아가는 컴포넌트입니다.&lt;/li&gt;
      &lt;li&gt;한번 시작된 서비스는 어플리케이션이 종료되도 계속해서 백그라운드에서 돌아갑니다.&lt;/li&gt;
      &lt;li&gt;모든 서비스는 Service클래스를 상속받아서 사용합니다.&lt;/li&gt;
      &lt;li&gt;네트워크를 통해서 데이터를 가져올 수 있습니다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서비스에는 크게 3가지로 나뉜다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;포그라운드 서비스 : 알림을 표시해 놓고 사용자와 상호 작용하지 않아도 계속 실행되는 걸 말함&lt;/li&gt;
  &lt;li&gt;백그라운드 서비스 : 사용자가 직접 알지 못하는 작업을 수행할 떄 사용&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;바운드 서비스 : 앱 내에서 서비스를 사용하여 간단한 클라이언트 - 서버 환경을 구성하는 것을 말함(특정 컴포넌트와 서비스간 상호작용)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;startService&lt;br /&gt;
⇒ 단순 서비스를 시작, 종료하게 하는 서비스이다.&lt;br /&gt;
생명주기는 onCreate - onStartCommand - onDestroy&lt;br /&gt;
onStartCommand return result&lt;br /&gt;
START_STICKY : 안드로이드가 서비스를 강제 정지한 경우, null intent를 보내서 재시작한다.&lt;br /&gt;
START_NOT_STICKY : 안드로이드가 서비스를 강제 정지한 경우, 재시작 하지 않는다.&lt;br /&gt;
START_REDELIVER_INTENT : 안드로이드가 서비스를 강제 정지한 경우, 동일한 intent를 보내서 재시작한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;bindService&lt;br /&gt;
⇒ 특정 컴포넌트와 서비스간 상호작용이 있을 때 사용하는 서비스이다.&lt;br /&gt;
생명주기는 onCreate - onBind - onUnbind - onDestroy&lt;/p&gt;

&lt;p&gt;intentService&lt;br /&gt;
⇒ 액티비티와 프래그먼트 LifeCycle에 의존하지 않고 백그라운드에서 처리하고 싶은 경우 사용한다. 이 서비스는 핸들스레드루퍼 + 핸들러를 조합해 구현되어 있다. 콜백메소드를 구현할 필요 없고 onHandleIntent()만 구현하면 되고 요청한 작업이 완료되면 자동적으로 서비스를 중단한다.&lt;/p&gt;

&lt;h3 id=&quot;broadcast-receiver&quot;&gt;Broadcast Receiver&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;단말기에서 발생하는 다양한 이벤트, 정보를 받고 반응하는 컴포넌트&lt;/li&gt;
  &lt;li&gt;안드로이드 단말기에서 발생하는 다양한 이벤트 정보(화면이 켜지거나 꺼짐, 리부팅 등)를 받고 반응하는 컴포넌트&lt;/li&gt;
  &lt;li&gt;특징
    &lt;ol&gt;
      &lt;li&gt;디바이스에서 발생하는 일 중에서 어플리케이션이 알아야 하는 상황이 발생하면 알려줍니다.&lt;/li&gt;
      &lt;li&gt;수신기를 통해 디바이스의 상황을 감지하고 적절한 작업을 수행합니다.&lt;/li&gt;
      &lt;li&gt;대부분 UI가 존재하지 않습니다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정적 리시버: 매니페스트에 등록하여 리시버를 구현하는 형태인데 한 번 등록하면 해제할 수 없는 방식이다.
동적 리시버: 클래스 파일에서 리시버를 등록, 해제할 수 있는 형태이기 때문에 앱에 부하를 줄 일 수 있다. 하지만 해제를 적절히
해주지 않는다면 메모리 락이 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;(❌ 리시버에는 너무 많은 작업, 시간이 오래걸리는 작업을 하면 안된다. 처리 지연시간이 길어진 경우 ANR이 발생하기 떄문에 리시버에는 간단한 일을 처리하도록 하고, 스레드를 별도로 생성해서 처리하도록 해야한다)&lt;/p&gt;

&lt;h3 id=&quot;content-provider&quot;&gt;Content Provider&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;데이터를 저장하고,가져오고, 모든 App에서 접근할 수 있도록 하는 컴포넌트&lt;/li&gt;
  &lt;li&gt;데이터를 관리하고 다른 애플리케이션 데이터를 제공&lt;/li&gt;
  &lt;li&gt;데이터베이스의 데이터를 전달할때 많이 사용&lt;/li&gt;
  &lt;li&gt;콘텐트 제공자는 생명주기를 가지고 있지 않음
    &lt;ol&gt;
      &lt;li&gt;파일 입출력, SQLiteDB, Web 등을 통해서 데이터를 관리&lt;/li&gt;
      &lt;li&gt;콘텐트 제공자를 통하여 다른 어플리케이션의 데이터도 변경 가능&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;RxJava or RxKotlin and RxAndroid&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;rx가-무엇이며-사용한-이유&quot;&gt;Rx가 무엇이며, 사용한 이유&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Rx는 Reactive Programming 을 좀 더 편하게 사용하기 위한 라이브러리&lt;/li&gt;
  &lt;li&gt;Reactive Programming은 반응형 프로그래밍으로, 어떤 데이터를 관찰(Observe)하고 있다가, 데이터가 변경이 되면 반응을 하고, 그 변경된 이벤트를 가지고 관련된 업데이트 로직을 처리하는 것을 뜻함&lt;/li&gt;
  &lt;li&gt;사용 이유는 설명 그대로 데이터 흐름에 관해 중복되는 코드들을 제거하고 간단히 구성하기 위해 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;reactive-programming&quot;&gt;Reactive Programming&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;데이터 흐름과 전달에 관한 프로그래밍 패러다임&lt;/li&gt;
  &lt;li&gt;데이터 흐름을 먼저 정의하고, 그 데이터가 변경 시 연관되는 함수나 수식이 업데이트 될 수 있는 것을 의미&lt;/li&gt;
  &lt;li&gt;메모리 누수를 해결하기 위한 방법
    &lt;ol&gt;
      &lt;li&gt;Disposable Interface를 이용한 명시적 자원해제
   onCreate()에서 subscribe()를 호출하면 onDestroy()에서 메모리 참조를 해제하고 onResume()에서 호출하면 onPause()에서 해제합니다.&lt;/li&gt;
      &lt;li&gt;CompositeDisposable class 사용 시 생성된 모든 Observable을 안드로이드 라이프 사이클에 맞춰서 한 번에 모두 메모리 해제를 할 수 있습니다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;ANR?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Android 앱의 UI 스레드가 너무 오랫동안 차단되면 ‘ANR(Application Not Respoding, 애플리케이션 응답 없음)’ 오류가 트리거&lt;/p&gt;

&lt;h3 id=&quot;정의&quot;&gt;정의&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Application Not Responding 로, Main Thread(UI Thread)가 일정 시간 어떤 Task에 잡힘으로써 발생&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;발생-요인&quot;&gt;발생 요인&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;액티비티가 포그라운드에 있는 동안, 앱이 5초 이내에 입력 이벤트 또는 BroadcastReceiver(예: 키 누름 또는 화면 터치 이벤트)에 응답하지 않을 때&lt;/li&gt;
  &lt;li&gt;포그라운드에 액티비티가 없을 때, BroadcastReceiver가 상당한 시간 내에 실행을 완료하지 못할 때&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;회피-방법&quot;&gt;회피 방법&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;매인 스레드(UI Thread)에서 실행되는 메소드는 가능한 한 적은 작업을 수행해야 합니다. 특히 엑티비티의 onCreate() 그리고 onResume() 에서는 가능한한 최소한의 작업만을 수행해야 함. 네트워크 접근, 데이터 처리 또는 비트맵 리사이징과 같은 잠재적으로 오래 걸리는 작업은 작업 스레드(Worker Thread)에서 처리해야 합니다.&lt;/li&gt;
  &lt;li&gt;UI 변동이 있을 때는 프로그레스와 같은 화면을 띄어 사용자에게 기달릴 것을 명시&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Compile Time? Run Time?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;compiletime&quot;&gt;CompileTime&lt;/h3&gt;

&lt;p&gt;개발자에 의해 작성된 프로그래밍 언어를 컴퓨터가 인식할 수 있는 기계어 코드로 변환되어 실행 가능한 응용 프로그램이 되는 과정&lt;/p&gt;

&lt;p&gt;ex) Compile time error? 소스 코드가 컴파일 되는 과정 중 발생하는 Syntax Error로 파일 참조 오류 등과 같은 문제들로 인해 컴파일이 방해되어 발생하는 오류 형태, 즉, 소스 코드 문제다! 라고 말해주는 시간!&lt;/p&gt;

&lt;h3 id=&quot;runtime&quot;&gt;RunTime&lt;/h3&gt;

&lt;p&gt;컴파일 과정을 마친 응용 프로그램이 사용자에 의해 실행되어 지는 “Time”, 즉 프로그램이 실행되는 동안의 그 time을 의미!&lt;/p&gt;

&lt;p&gt;ex) Run time error? 이미 컴파일이 완료되어 프로그램이 실행 중 임에도 불구하고, 의도치 않은 예외 상황으로 인해 프로그램 실행 중 발생하는 오류 형태&lt;/p&gt;

&lt;p&gt;예를 들어, “0 으로 나눌 때, null 참조”는 RunTime 시 발생하는 error이며, “타입 체크가 잘못 되었을 때 에러”는 CompileTime 시 발생하는 error 이다.&lt;/p&gt;

&lt;파트 기술질문=&quot;&quot;&gt;
이전 협업에서 본인이 어떤 역할을 했는지, 기술적으로 어느 부분을 담당했는지 자세히

객체지향 언어가 무엇인지 알고 있는지?
클래스란 무엇인지?

성공적인 프로젝트를 이뤄내기 위해 팀에 어떤 부분에 기여하여 어떻게 할 것인지?

&amp;gt; FragmentManager vs SupportFragmentManager

fragmentManager : fragment 객체를 관리하기 위한 것

Activity에서의 fragmentManager 와 supportFragmentManager 의 차이는, FragmentManager의 경우 Activity class에서 가져오고 SupportFragmentManager는 FragmentActivity에서 가져오는 것.
FragmentActivity 역시 Activity를 상속받지만, 상속받으면서 androidx로 마이그레이션 된다. 즉, supportFragmentManager는 androidx에서 사용하기 위한 fragmentManager이다.

Fragment에서의 fragmentManager 와 childFragmentManager 의 차이는, fragmentManager는 Activity와 Fragment 둘 다에서 관리가 가능하며, childFragmentManager는 Fragment에서만 관리가 가능하다.

&amp;gt; Android Jetpack

개발자가 고품질 앱을 손쉽게 개발할 수 있게 돕는 라이브러리, 도구, 가이드 모음으로, 플랫폼 API와는 별도로 제공되는 androidx.* 패키지 라이브러리로 구성  
향상된 Android 기능의 이점을 활용하기 위한 일련의 구성 요소인 Support Library 로, 이전 버전까지 호환한다.  
구성요소는 Architecture(아키텍처), Foundation(기초), Behavior(동작), UI로 총 4가지로 나뉜다.  

가장 많이 사용하고 있는 부분은 Architecture Component 이다.  

---

• 실력있는 개발자가 되고 싶다 하였는데 실력있는 개발자란 무엇인지?
• MVC 패턴과 MVVM 패턴의 차이점은?
• Observer 패턴이란?
• 오버로딩과 오버라이딩의 차이점은?
• 멀티 프로세싱과 멀티 스레드의 차이는?
• 최근 카카오와 같은 IT회사에서 주간근무시간을 초과하는 일에 대해 어떻게 생각하는지
정시 퇴근 후 정말 중요한 약속이 잡혔을 때 팀장님께서 추가업무를 부탁하면 어떻게 대처할
지

&amp;gt; Context란?

자신이 어떤 어플리케이션을 나타내고 있는지 알려주는 ID 역할 ActivityManagerService 에 접근 할수 있도록 하는 통로 역할

ANR(Application Not Responding) 이란

메인 스레드가 일정 시간 어떤 TASK 에 잡혀 있으면 발생한다. 시간 소모가 많은 작업은 스레드를 통해 처리해야 함

ViewModel 의 장점

화면 회전시 데이터를 유지할 수 있는 구조로 디자인하였으며 Android Lifecycle 의 onDestroy코드가 동작한다. Lifecycle 을 내부적으로 알아서 호출해주기 때문에 좋다.

ConstraintLayout vs RelativeLayout vs LinearLayout 차이(ConstraintLayout 장점)

LinearLayout 은 orientation 이 있어서 가로 또는 세로로 차곡차곡 쌓여지는 방식이다. RelativeLayout 은 상대적인 기준으로 어떤 위젯의 왼쪽 오른쪽등등의 방향으로 배치 할 수 있게 해주는 레이아웃이다. ConstraintLayout 은 복잡한 레이아웃을 단순한 계층구조를 이용하여 표현할 수 있는 ViewGroup 이다. RelativeLayout과 비슷하지만 더 유연하고 다양하고 강력한 기능을 제공한다.

CustomView 와 Fragment 의 차이점

Fragment 는 자체 생명주기를 따르고 Activity 의 생명주기에 따라 직접적으로 영향을 받는다. Fragment를 사용하려면 Activity 내에서 또는 상위 프래그먼트내에서 사용이 가능하고 다른 액티비티에서 재사용이 가능하다. 여기서 CustomView 는 자체 생명주기는 가지고 있지 않고 Fragment 보다는 더 작은 단위?를 커스터마이징해서 재사용을 할 수 있다.

Android KTX 란 무엇인가?
안드로이드 프레임워크와 서포트 라이브러리를 모두 지원하여 안드로이드를 위한 코틀린(Kotlin) 코드를 간결하고 편하게 사용할 수 있게 설계된 확장 라이브러리이다.

mvp 패턴과 mvvm 패턴의 차이

mvp 와 mvvm 의 차이는 presenter와 viewModel 의 차이가 가장 크다. presenter 는 view의 interface 를 가지고 있고 view 관련 처리를 요청한다. 하지만 viewModel 은 view 의 참조를 하지않고 Rx를 사용하거나 LiveData를 사용해서 데이터가 변경될때 같이 자동으로 변경될수 있게 구조가 되어있다.

LiveData 는 인터럽트방식인가 폴링방식인가

폴링방식은 정해진 시간 또는 순번에 상태를 확인해서 상태 변화가 있는지 없는지 체크 하는 방식이고 인터럽트방식은 main문을 실행 하는 동중 외부에서 정해져 있는 인터럽트 핀에 신호가 들어오면 MCU는 즉각적으로 하고 있는 동작을 멈추고 인터럽트 서비스 루틴을 실행하는 것이다.
LiveData 는 데이터가 변경된 시점에 Observer 가 실행 되기 때문에 인터럽트 방식이라고 볼 수 있다.
옵저버패턴 설명

한객체의 상태가바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다(one-to-many) 의존성을 정의한다.
데이터 전달 방식은 2가지가 있다 주제 객체에서 옵저버로 데이터를 보내는 방식 (푸시방식) 옵저버에서 주제객체의 데이터를 가져가는 방식(풀 방식)
Subject 와 Observer 가 존재하고 Subject에 Observer 를 등록하고 난 뒤 subject 의 데이터가 변경 되면 등록된 Observer 가 호출 되는 방식

어댑터패턴 설명

한 클래스의 인터페이스를 클라이언트에서 사용하고자하는 다른 인터페이스로 변환한다. 어댑터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있다.

프로토콜이란?

통신 프로토콜 또는 통신 규약은 컴퓨터나 원거리 통신 장비 사이에서 메세지를 주고 받는 양식과 규칙의 체계이다. 통신 프로토콜은 신호 체계, 인증 그리고 오류 감지 및 수정기능을 포함할 수 있다. 간단히 말해서 데이터 주고받는 상호간에 미리 약속된 규칙, 규약이다!!

ViewModel 상속받은 클래스에서 ViewModel 상속을 받지 않는다면 달라지는점은?
viewModel 상속을 받지 않는다면 생명주기에 따른 처리,rotate상황 등등을 추가 해주어야한다는 점이 달라진다.

반응형 프로그래밍 - RXJava
리액티브 프로그래밍은 데이터 흐름(data flow)과 변화 전파에 중점을 둔 프로그래밍 패러다임프로그래밍 언어로 정적 또는 동적인 데이터 흐름을 쉽게 표현데이터 흐름을 통해 하부 실행 모델이 자동으로 변화를 전파할 수 있는 것을 의미

Observable
• 데이터 흐름
• 주기적으로 데이터를 처리하고 변화를 방출하며 데이터 흐름을 다른 구성요소에게 전달
Observer
• Observable이 방출한 데이터를 받아서 데이터 흐름의 변화를 관찰
• Observable이 방출한 데이터를 메인 스레드나 UI에 전달하는 역할
• onComplete()Observable이 더 이상 방출할 데이터가 없을 때 호출
• onError(Throwable e)Error 발생 시 호출
• onNext(Object o)새로운 데이터가 방출될 때 호출방출된 데이터는 매개변수에서 찾을 수 있음
Schedulers
• Rx의 핵심은 비동기 처리에 있음
• Observable과 Observer가 어떤 스레드에서 작업을 수행할지 지정
• subscribeOn(Thread)Observable이 실행되어야 하는 스레드 지정
• observeOn(Thread)Observer가 실행되어야 하는 스레드 지정
Manifest file
• 애플리케이션에 관한 정보를 입력하는 파일로 xml 형태
• 패키지 이름, 앱 이름, 앱 설명, 아이콘, 앱이나 구성요서에서 필요한 권한, 앱에서 사용되는 액티비티, 서비스, 브로드캐스트에 대한 정보 등 전반적 앱 정보 저장
Activity
• 화면에 UI를 표시하는 기본요소
• 대부분의 경우 액티비티는 꽉찬 화면을 구성하지만, 예외적으로 floating windows, multi-window mode 처럼 화면의 일부를 차지하게 할수 있다.
• Acitivty 의 종류 중 하나로 FragmentActivity가 있는데, nested fragment는 fragment 안에 다른 fragment가 있는 경우 고려
• AppCompatActivity는 안드로이드 하위버전의 안드로이드를 지원하기 위해 사용
• AppCompatActivity는 FragmentActivity를 상속
Activity Life Cycle
• 재개 (create, start, resume)
• 일시정지 (pause)
• 멈춤 (stop, destroy)
• onCreate (액티비티 생성 직전)onRestart (액티비티가 stop상태에서 재시작될 경우)onStart (액티비티가 화면에 보여지기 직전)onResumed (액티비티가 사용자와 상호작용하기 직전)onPause (액티비티가 부분적으로 가려짐)onStopped (액티비티가 더 이상 보이지 않을때)onDestroy (액티비티가 소멸되기 직전)
Fragment
• 프래그먼트는 액티비티의 부분부분을 동적으로 동작시키기 위해 생긴 개념
• 탭레이아웃의 탭을 눌러서 다른화면으로 전환하는 앱의 경우, 한 액티비티안에서 탭을 눌렀을 때 보여지는 프래그먼트만 변경되며, 프래그먼트는 액티비티와 달리 스택에 쌓이지 않기 때문에 백버튼을 누른다고 해서 이전 프래그먼트로 돌아가지 않는다. (이는 BackStack을 추가하여 직접 구현)
• 프래그먼트의 라이프사이클은 액티비티와 거의 동일한데, onAttach, onCreateView, onDestroyView, onDetach라는 콜백이 추가
Thread &amp;amp; Handler &amp;amp; Looper
Thread
• 안드로이드는 기본적으로 하나의 메인 스레드로 작동
• UI 조작은 메인 스레드만 가능 &amp;gt; 두 개 이상의 스레드가 UI에 동시에 접근 시 의도와 다르게 동작할 가능성이 크기 때문
• 멀티 스레드 환경에서 동기화 이슈를 차단하고 스레드 간 통신을 위해 사용되는 것이 Handler &amp;amp; Looper

1. Java IO에서 제공하는 파이프 이용
2. 스레드 간 공유 메모리를 통한 접근
3. Synchronized를 이용한 시그널링
4. BlockingQueue를 이용한 방법
스레드 통신 메커니즘핸들러 - 루퍼 - 메시지 큐 - 메시지
android.os.Looper - UI 스레드에 하나가 존재하며 소비자 스레드와 연관된 메시지 발송자 (데이터를 읽는 역활)
android.os.Handler - 큐에 메시지를 삽입하는 생산자 스레드를 위한 인터페이스와 소비자 스레드 메시지 처리, 하나의 Looper 객체는 많은 핸들러를 갖지만 모두 같은 큐에 삽입
android.os.MessageQueue - 소비자 스레드에서 처리할 메시지들이 담긴 무제한의 연결 리스트. 모든 루퍼와 스레드는 최대 하나의 메시지 큐를 가진다.
android.os.Message : 소비자 스레드에서 실행하는 메시지
Handler
• 핸들러 생성 시 기본적으로 행들러를 생성한 스레드와 루퍼에 연결
• postDelayed / postAtFrontOfQueue와 같이 메시지 순서나 보내는 시간 조작 함수 보유 &amp;gt; 스케줄링가능
Looper
• MessageQueue의 메시지나 Runnable 객체를 꺼내 핸들러에게 전달
• run() 메소드 내부에 MessageQueue 생성 &amp;gt; Looper.loop()를 통해 메시지 전달 대기
AsyncTask
• 백그라운드에서 작업 수행 뒤 결과를 UI Thread에서 생신할때 주로 사용
• 순차적으로 실행
단점
• 액티비티 종료 시 따로 명시하지 않으면 메모리에 남아 Memory leak 발생
• 한 번만 실행되고 재사용 불가
• 처리 작업의 수가 1개
• Configuration 변경 시 크래쉬 발생
대안으로 java.util.concurrent API / Kotlin coroutine / RxJAVA 사용 권장
Intent
• 구성 요소 실행 &amp;amp; 구성 요소 간 데이터 전달
• putExtra()를 통해 데이터 보관 &amp;gt; getExtra()로 전달 받을 수 있음
CustomView
• 기존에 있는 View (ImageView, TextView 등)로 표현할 수 없는 모양의 View를 구현해야 할때 필요
• View를 상속받는 자손 클래스를 만들어서 구현

1.기존 View 상속
2.onDraw(), onMeasure(), onKeyDown() 처럼 'on'으로 시작하는 슈퍼클래스 메서드를 오버라이드

• onDraw()
• 뷰를 실제 그릴때 사용
• Canvas 객체를 매개변수로 받음
• Canvas 객체는 어떤 도형을 그릴지 설정
• Paint 객체는 도형의 색, 스타일, 글꼴 등을 설정
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)
뷰의 크기 설정 시 사용

Rx관련 질문 :
새로운 스레드를 생성해도 되는데 왜 Schedulers.io() 를 사용하는가? 내부 동작이 어떻게 돌아가는 것인가를 묻는 질문
화면단에서 사용되는 request 가 하나가 아니라 적게는 한자리수 많게는 두세자리수까지 갈수 있는데 이부분에서 Thread를 계속해서 생성,수거 하게 된다면 사용할 때마다 드는 비용을 무시할수 없다. 그렇기 때문에 Thread Pool 이 사용된다. 몇개의 스레드를 생성한뒤 큐에 Task를 넣고 작업하고 있지 않은 Thread에 Task를 할당하는 방식이다. 작업이 끝난 Thread 는 다시 어플리케이션에 결과값을 리턴한다. Thread를 재사용 하기때문에 성능저하를 방지할 수 있다. 하지만 Thread를 너무 많이 만들어 놓게 되면 메모리만 낭비하게 되므로 주의해서 사용해야 한다.

프로가드
코드 축소와 바이트코드를 최적화하고 미사용 코드 명령을 제거하며 남아 있는 클래스,필드 및 메서드를 짧은 이름으로 난독 처리한다. 난독 처리된 코드는 APK 의 리버스 엔지니어링을 어렵게 만들며 보안에 민감한 기능이 앱에 사용되는 경우 특히 유용하다. 64K 참조 제한을 해결하기 위한 유용한 도구 이기도 하다.

코틀린 by lazy
lateinit은 필요할 경우 언제든 초기화가 가능한 Properties 이지만 lazy properties는 생성 후 값을 변경할 수 없는 val 로 되어 있다. by lazy 정의에 의해서 초기화를 진행하고 val 이므로 값을 교체하는 건 불가능하다. lazy를 사용하는 경우 기본 synchronized 로 동작한다.

viewModel rotate 상황에서 파기 왜 안되는지 과정 ?
ViewModelStoreOwner 인터페이스를 가지고 있는 Activity 또는 Fragment 는 viewModelStore를 가지고 있다. rotate 될 때 onDestroy 가 불리게 되는데

```kotlin
      boolean isChangingConfigurations = activity != null &amp;amp;&amp;amp; activity.isChangingConfigurations();
        if (this.mViewModelStore != null &amp;amp;&amp;amp; !isChangingConfigurations) {
            this.mViewModelStore.clear();
        }
```

viewModelStore 가 null 이 아니고 configuration변화가 없을때 clear 를 불러 주기 때문에 rotate상황에서 viewModel이 clear 되지 않는다.

Multi dex
안드로이드 앱을 구성하는 코드는 컴파일 되어 덱스 파일로 만들어 진다. 하나의 덱스 파일에는 64K 메소드참조만 저장할 수 있다. 큰 규모 앱을 작성하다 보면 앞의 메소드 제한을 훌쩍 넘게 되는데 멀티덱스를 사용하면 덱스 파일을 여러 개로 나누어 이러한 문제를 피할 수 있다.

액티비티 생명 주기
onCreate onStart onResume Running onPause onStop onDestroy

프래그먼트 생명 주기
onAttach onCreate onCreateView onActivityCreated onStart onResume Running onPause onStop onDestroyView onDestroy onDetach

서비스 생명 주기 2가지
onCreate onStartCommand() return start_sticky , start_not_sticky, start_redeliver_intent Service Running onDestroy

onCreate onBind onUnbind onDestroy

FLAG_ACTIVITY_CLEAR_TOP 과 FLAG_ACTIVITY_SINGLE_TOP 차이
CLEARTOP 은 A -&amp;gt; B -&amp;gt; A 일 때 최상위 A 만 남고 나머지 다 destroy SINGLETOP 은 A -&amp;gt; B -&amp;gt; B 일때 A -&amp;gt; B 로 B가 하나로 됨.

스레드 통신방법?
스레드가 시작 되면 이 스레드는 루퍼! 핸들러! 메세지 큐! 를 하나씩 가지고 있다. 메세지큐는 외부 스레드로부터 핸들러를 통하여 받은 message 혹은 Task 를 저장하는 역할을 한다. 루퍼는 메세지큐에서 메세지를 순차적으로 꺼내서 핸들러에게 전달하는 역할!! 핸들러는 두가지 기능이 있다.

루퍼에게서 받은 메세지 혹은 Task 를 일정한 시간에 수행하는 기능을 한다.
외부 스레드로부터 받은 메세지를 핸들러를 통하여 Message Queue에 집어 넣는 역할을 한다.
스레드 충돌을 막으려면?
두개 이상의 스레드가 같이 참조 하는 메소드 혹은 블럭구문을 synchronized , synchronized block 사용해서 해결할 수 있다.

Viewholder 패턴에 대해 설명
예전 ListView 를 사용할 때 getView() 를 오버라이드 해서 뷰를 인플레이팅 시키는데 이부분에서 계속해서 생성하고 findviewById 를 불러주게 되면 부담이 많이 가는 작업이 된다. 데이터가 많아 질 수록 버벅거리는 현상이 일어날 확률이 높다. 그래서 viewHolder 패턴이 나오게 되었는데 해당 뷰가 널일때만 view를 인플레이트 시키고 viewHolder 클래스에 findviewById 를 사용해서 viewHolder 는 해당 뷰에 태깅처리해서 다음번 부터는 태그한 viewHolder 를 가져와서 사용한다. 그 이후에 viewHolder 를 강제로 구현하게 나온것이 RecyclerView 이다.

Dangerous permission
시스템 권한은 두가지로 나눠 지는데 정상권한과 위험권한이 있다. 정상권한은 사용자 개인정보를 직접 위험에 빠뜨리지않는다. 앱이 매니페스트에 정산 권한을 나열하는 경우 시스템은 자동으로 권한을 부여. 위험권한은 사용자 기밀 데이터에 대한 액세스를 앱에 부여할 수 있다. 위험권한을 나열하는 경우, 사용자는 앱에 대한 명시적 승인을 제공해야 한다.

Intent service 란?
IntentService 는 Intent를 사용해서 시작되고 하나의 workerThread 가 생성 되고 Queue에 작업이 들어 가게 된다. onHandleIntent() 메소드가 이 스레드 내에서 호출되고 작업이 다 끝나면 알아서 destroy 되는 방식이라 stopSelf를 불러줄 필요가 없다.

Foreground service 사용?
Fragment 사용 장점 ?
Activity를 분할하여 화면의 한 부분을 정의할수 있고 자신의 생명주기를 가진다. 액티비티내에서 실행 중 추가 제거가 가능하고 다른 액티비티에서도 사용 할 수 있어 재사용성이 뛰어나다. 태블릿 지원하게 될 때 용이하게 사용 가능하다.

Parcelable serializable 차이와 성능은?
복잡한 클래스의 객체를 이동시키려고 할 때 Serializable 또는 Parcelable 을 사용해서 직렬화하여 인텐트에 추가합니다. Serializable 은 Java 의 인터페이스이다. 해당 객체에 인터페이스 Serializable 을 사용해주면 되기 때문에 사용하기 쉽다. 하지만 내부에서 Reflection 을 사용하여 직렬화 처리하기 때문에 성능 저하 및 배터리 소모가 발생되게 된다. Parcelable 은 Android SDK 의 인터페이스이다. 직렬화 방법을 사용자가 명시적으로 작성하기 때문에 작동으로 처리하기 위한 reflection이 필요없다. 속도적인 측면에서는 Parcelable 이 10배 이상 빠르다.

하지만 Serializable 을 사용할 때 writeObject 와 readObject 를 구현해 주면 Parcelable 보다 쓰기는 속도가 3배 읽기의 경우 1.6배 더 빠르다. 어떻게 사용하느냐에 따라 속도적인 측면에서 비교할 수 있다.

onSaveInstanceState 와 onRestoreInstanceState
Activity 또는 Fragment 가 종료 될 때 onSaveInstanceState은 onPause 다음 상태에서 불리게 된다. 이때 파라미터로 받은 Bundle에 데이터를 저장하고 onCreate 시점에서 savedInstanceState bundle 을 통해 값을 가져와서 사용할 수 있다. onRestoreInstanceState 은 정상적인 경우는 불리지 않고 메모리 부족한 경우 프로세스 자체에서 Activity 또는 Fragment 를 강제종료할 때 onRestoreInstanceState가 불리게 된다. bundle 통해서 데이터 백업 가능
&lt;/파트&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="android" />
      

      
        <summary type="html">안드로이드 면접 준비</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">코틀린 면접 준비</title>
      <link href="https://lee989898.github.io/ad" rel="alternate" type="text/html" title="코틀린 면접 준비" />
      <published>2022-03-18T01:06:00+09:00</published>
      <updated>2022-03-18T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/ad</id>
      <content type="html" xml:base="https://lee989898.github.io/ad">&lt;h2 id=&quot;코틀린-면접-준비&quot;&gt;&lt;strong&gt;코틀린 면접 준비&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;코틀린-질문&quot;&gt;&lt;strong&gt;코틀린 질문&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;코틀린 사용의 장점&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;널 안전성&lt;/li&gt;
  &lt;li&gt;가변/불변 구분&lt;/li&gt;
  &lt;li&gt;람다 표현식 지원&lt;/li&gt;
  &lt;li&gt;스트림 API 지원&lt;/li&gt;
  &lt;li&gt;완벽한 자바 호환성&lt;/li&gt;
  &lt;li&gt;Java에 비해 훨씬 간결한 코드&lt;/li&gt;
  &lt;li&gt;객체지향이면서 함수형 프로그래밍 언어&lt;/li&gt;
  &lt;li&gt;자바와 상호운용 가능 (자바에서 코틀린으로 작성된 클래스를 부를 수 있으며 반대로도 가능)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;클래스, 객체, 인스턴스&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;클래스: 객체를 만들어 내기 위한 설계도 혹은 툴
객채: 소프트웨어 셰계에 구현할 대상
인스턴스: 설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Array와 List의 차이&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Array의 경우 고전적인 의미의 배열이며, 고정된 사이즈의 연속된 메모리 공간에 할당된다.&lt;br /&gt;
따라서 인덱스를 통해 값을 변경하는 것이 가능하며(mutable), 사이즈를 변경하는 것이 불가능하다.&lt;br /&gt;
List의 경우 크게 List와 MutableList가 있는데, ArrayList또는 LinkedList의 구현체다.
Default로는 ArrayList의 구현체를 따른다.&lt;br /&gt;
이름에서도 볼 수 있듯이 List는 Immutable이며 MutableList는 Mutable이다.
성능이 중요시 되는 부분을 제외하고는 List를 쓰는것이 바람직 하다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Scope Function&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;코틀린에서 제공하는 기본 라이브러리 함수로, 객체를 context내에서 코드 단위 블럭으로 실행하는데 묵적을 가진 함수&lt;br /&gt;
5개의 스코프 함수가 존재: let, run, with, apply, and also&lt;/p&gt;

&lt;p&gt;리시버와 람다 함수&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스코프 함수를 사용할 떄 넘겨주는 두 객체&lt;/li&gt;
  &lt;li&gt;차이점
    &lt;ul&gt;
      &lt;li&gt;객채를 접근하는 방법: this, it
        &lt;ul&gt;
          &lt;li&gt;run, with, apply -&amp;gt; 자기 자신을 블럭(this)으로 넘기고 this를 사용해 객체에 접근&lt;/li&gt;
          &lt;li&gt;let, alse -&amp;gt; 자기 자신을(람다) 인자(it)으로 넘기고 it을 사용해 객체에 접근&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;리턴 값
        &lt;ul&gt;
          &lt;li&gt;apply, also -&amp;gt; 리시버 객체를 마지막에 리턴(자기 자신을 리턴)&lt;/li&gt;
          &lt;li&gt;let, run, with -&amp;gt; 람다 함수의 마지막 결과를 리턴(코드 블럭의 결과를 리턴)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;let : 이 함수를 호출한 객체를 이어지는 함수 블록의 인자로 전달한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;it으로 리시버에 접근하고 람다 함수의 마지막 결과를 리턴&lt;/li&gt;
  &lt;li&gt;리시버의 여러 함수들을 호출할 떄 사용&lt;/li&gt;
  &lt;li&gt;리시버 객체의 확장 함수로 사용 -&amp;gt; val length = str?.let {it.length}&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;getPadding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;은&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;패딩&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;값&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;setPadding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;with : 인자로 받은 객체를 이어지는 함수 블록의 리시버로 전달, block 함수의 결과를 반환&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;this로 리시버에 접근, 람다 함수의 마지막 결과를 리턴(리턴 값을 사용하지 않는 경우에 쓸 것을 권장)&lt;/li&gt;
  &lt;li&gt;리시버 객체의 확장 함수로 사용하지 않음 -&amp;gt; with(리시버 객체) { 람다 함수}&lt;/li&gt;
  &lt;li&gt;run과 동일한 기능&lt;/li&gt;
  &lt;li&gt;인스턴스를 참조연산자 대신 parameter로 받아 사용 ( &amp;lt;-&amp;gt; run과 차이)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nf&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;textView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;textView!!!&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;gravity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Gravity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;CENTER_HORIZONTAL&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;run : 인자가 없는 익명 함수처럼 사용하는 형태와 객체에서 호출하는 형태 제공 함수형 인자 block 을 호출하고 결과반환 또는 호출한 객체를 함수형 인자 block의 리시버로 전달하고 그 결과를 반환한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;this로 리시버에 접근하고, 람다 함수의 마지막 결과를 리턴&lt;/li&gt;
  &lt;li&gt;마지막 구문의 결과 값을 반환한다. ( &amp;lt;-&amp;gt; apply와 차이)&lt;/li&gt;
  &lt;li&gt;with와 동일한 기능&lt;/li&gt;
  &lt;li&gt;리시버의 확장 함수로 사용 -&amp;gt; 리시버.run { 람다 함수 }&lt;/li&gt;
  &lt;li&gt;람다함수에서 여러 값을 초기화하고 리턴 값을 어떤 객체의 초기값으로 사용할 때 사용&lt;/li&gt;
  &lt;li&gt;이미 인스턴스가 만들어진 후에 인스턴스의 함수나 속성을 scope 내에서 사용해야 할 떄 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;AplusB&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;textView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;와&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;비슷하지만&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;textView&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;의&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;널체크를&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;해야&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;하는경우&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;사용하면&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;좋다&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;textView!!!&quot;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;gravity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Gravity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;CENTER_HORIZONTAL&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;apply : 이 함수를 호출한 객체를 이어지는 함수 블록의 리시버로 전달한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;it으로 리시버에 접근하고, 리시버 객체를 리턴&lt;/li&gt;
  &lt;li&gt;리시버 스스로를 리턴하기 때문에 빌더패턴처럼 연속적으로 함수 호출 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1f&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;를&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;리시버로&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;전달&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;받았기&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;때문에&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;이나&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;topMargin&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;바로사용&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;topMargin&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;처리가 끝나면 인스턴스를 반환 : apply, also&lt;/li&gt;
  &lt;li&gt;처리가 끝나면 최종 값을 반환 : run, let, with(?)&lt;/li&gt;
  &lt;li&gt;참조 연산자 없이 인스턴스의 변수와 함수 사용 → apply, run&lt;/li&gt;
  &lt;li&gt;파라미터로 인스턴스를 넘긴 것처럼 it을 통해 인스턴스를 사용 : also, let&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;LiveData 란?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;주어진 lifecycle 내에서 관찰할 수 있는 data holder class.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;get()과 직접 참조(=)의 차이&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MutableLiveData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LiveData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LiveData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;직접 선언하는 것(b)과 get() = … 으로 선언하는 것(c)의 차이점은, 직접 선언하면 b 와 a 는 서로 동일한 객체를 바라보게 되는 것이고, get() 으로 선언할 경우엔 내부적으로 함수가 호출되고, 해당 함수의 결과 값으로 a 객체를 리턴하는 것.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;by lazy vs lateinit&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;쉽게 설명하자면, var에서만 사용 가능한 lateInit, val에서만 사용 가능한 by lazy.&lt;br /&gt;
lateInit은 언제든 null을 제외한 값으로 초기화 값을 변경할 수 있지만, by lazy 는 값을 교체하는게 불가능하다.&lt;br /&gt;
null이 필요할 때를 생각해서 사용해야 한다!&lt;/p&gt;

&lt;h3 id=&quot;by-lazy--initializer-&quot;&gt;by lazy { initializer }&lt;/h3&gt;

&lt;p&gt;지정된 초기화 함수 “initializer” 과 기본 thread-safety 모드인 “LazyThreadSafetyMode.SYNCHRONIZED” 을 사용한 “Lazy” interface의 새 인스턴스를 만든다.
값의 초기화에서 exception이 발생하면, 다음 access에서 값을 재 초기화를 시도한다.&lt;br /&gt;
반환된 인스턴스는 동기화하는데 자기 자신을 사용한다. 반환된 인스턴스의 외부 코드로부터 동기화를 하지 마라. 그건 우연히 deadLock을 야기시킬 수 있다. 또한, 이 행동은 나중에 변경될 수도 있다.&lt;/p&gt;

&lt;p&gt;즉, 기본 쓰레드 세잎 모드를 사용해 initializer 함수에 해당하는 새로운 인스턴스를 만들어 사용하는 것이며, kotlin.jvm 에서 동작한다.
이외 (1)스레드를 컨트롤 할 수 있고, (2)객체를 지정해 동기화할 수도 있다.&lt;/p&gt;

&lt;p&gt;즉, 첫 인스턴스를 생성한 후로는 그 인스턴스의 값 만을 가지고 사용한다.&lt;/p&gt;

&lt;h3 id=&quot;lateinit&quot;&gt;lateInit&lt;/h3&gt;

&lt;p&gt;사용 전 반드시 초기화를 해줘야 한다. 물론 초기화가 되어있는지 확인하는 함수가 있긴 하지만, 초기화 하지 않고 사용할 경우 익셉션이 발생한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;companion object 란?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;properties(속성)과 functions(함수)가 클래스에 연결되어 있지만, 해당 클래스의 인스턴스에는 연결되어 있지 않은 싱글톤 오브젝트이다. 기본적으로 java의 “static” 키워드와 같지만, 꼬임이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ex-1 : 기본 사용법 ( 클릭 )&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Cafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;companion&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;LATTE&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;latte&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bestBeverage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LATTE&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
&lt;span class=&quot;c1&quot;&gt;// all return &quot;latte&quot;&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Cafe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Companion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;LATTE&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Cafe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;LATTE&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Cafe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;bestBeverage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ex-1을 보고 아래와 같이 생각할 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Cafe class의 메소드는 companion object 내에 어떤 프로퍼티든 참조할 수 있다. 마치 프로퍼티가 Cafe class 자체에서 field로 선언된 것 처럼&lt;/li&gt;
  &lt;li&gt;companion object 내 프로퍼티들은 ContainingClass.PROPERTY_IN_COMPANION_OBJECT 처럼 “statically”하게 참조될 수 있다.&lt;/li&gt;
  &lt;li&gt;companion object에 대한 기본 이름은 Companion 이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;ex-2 : companion object 에 이름 붙이기 ( 클릭 )&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Cafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;companion&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Beverage&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;LATTE&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;latte&quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bestBeverage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LATTE&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// all return &quot;latte&quot;&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Cafe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Beverage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;LATTE&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Cafe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;LATTE&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Cafe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;bestBeverage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// this no longer compiles&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Cafe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Companion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;LATTE&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;ex-3 : companion object 내 프로퍼티에 private ( 클릭 )&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Cafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;companion&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Beverage&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;LATTE&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;latte&quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bestBeverage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LATTE&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// both of these will give you an error&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Cafe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Beverage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;LATTE&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Cafe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;LATTE&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// this still evaluates to &quot;latte&quot;&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Cafe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;bestBeverage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;companion object 는 최초 한번만 선언되고 두 개 이상 선언이 되지 않는다. 또한, 인터페이스를 상속받아 작업할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ex-4 : interface 상속 ( 클릭 )&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Drinkable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;drink&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;LATTE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Cafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;companion&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Beverage&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Drinkable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;drink&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;I like coffee&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;LATTE&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;LATTE&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Cafe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;drink&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;가능&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그럼 일반 object 대신 companion object 를 사용하는 이유는 뭘까?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ex-5 : &lt;del&gt;companion&lt;/del&gt; object&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Cafe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Beverage&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;LATTE&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;latte&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bestBeverage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Beverage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;LATTE&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ex-5를 보면 아래와 같은 차이점을 발견할 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Companion 의 기본 이름이 지정된 companion object와 달리, 일반 object 선언은 이름을 지어야만 한다.&lt;/li&gt;
  &lt;li&gt;일반 object 내 fields를 참조하기 위해선 객체 이름을 명시적으로 사용한 포함된 클래스를 요구한다. companion object를 가지고, 간단하게 Cafe.LATTE를 만들 수 있지만, 일반 object를 가지고는, Cafe.Beverage.LATTE를 써야만 한다.&lt;/li&gt;
  &lt;li&gt;Companion object 는 포함된 클래스가 처음 로드될 때 초기화 된다. - 비록 companion object가 사용되지 않더라도. 결과적으로, companion objects는 lazy가 아니다. 위 예제 내 일반 object는 그들이 처름 접근할 때 초기화 된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;그래서-왜-companion-object를-쓰는-걸까&quot;&gt;그래서 왜 companion object를 쓰는 걸까?&lt;/h3&gt;

&lt;p&gt;“static” 프로퍼티/함수에 접근하기 위한 편리한 약칭을 제공하기 때문. 그게 전부다. 뭔 이유가 있다면, 만약 늦은 초기화를 해야 한다면, 일반 object를 대신 사용해라.&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="android" />
      

      
        <summary type="html">코틀린 면접 준비</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">컴퓨터과학 면접 준비</title>
      <link href="https://lee989898.github.io/ad" rel="alternate" type="text/html" title="컴퓨터과학 면접 준비" />
      <published>2022-03-17T01:06:00+09:00</published>
      <updated>2022-03-17T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/ad</id>
      <content type="html" xml:base="https://lee989898.github.io/ad">&lt;h2 id=&quot;컴퓨터과학-면접-준비&quot;&gt;&lt;strong&gt;컴퓨터과학 면접 준비&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;1분자기소개&lt;/p&gt;

&lt;p&gt;안녕하십니까 명지대학교 컴퓨터공학과 4학년 이준경입니다.
일단 면접의 기회를 주셔서 고맙습니다
제가 솝트에 지원하게 된 이유는&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;인성-질문&quot;&gt;&lt;strong&gt;인성 질문&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;자신의 장점과 단점 3가지&lt;/p&gt;

&lt;p&gt;자신의 단점을 극복했던 방법&lt;/p&gt;

&lt;p&gt;협업 중 갈등상황을 겪었던 경험이 있는지, 어떻게 해소했는지&lt;/p&gt;

&lt;p&gt;팀 내에 자기주장이 강한 사람/사기가 없는 사람 이 있을 때 어떻게 해결할 것인가?&lt;/p&gt;

&lt;p&gt;팀 내에 실력적으로 부족한 팀원이 있을 때 어떻게 할 것인가?&lt;/p&gt;

&lt;p&gt;갈등이 일어나지 않게 하기 위해 노력할 부분은 무엇일까?&lt;/p&gt;

&lt;p&gt;협업할 때 지원자와 가장 안 맞는 유형&lt;/p&gt;

&lt;p&gt;협업에서 가장 중요하다고 생각하는 것&lt;/p&gt;

&lt;p&gt;솝트를 통해서 얻고 싶은 3가지&lt;/p&gt;

&lt;p&gt;친구들 사이에서 지원자는 어떤 친구인가?&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;컴퓨터-과학&quot;&gt;&lt;strong&gt;컴퓨터 과학&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;프레임워크와 라이브러리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;자동차의 뼈대(프레임워크)가 있고 이 뼈대를 기초로 승용차, suv등의 자동차를 완성한다. 여기에 추가적인 기능인 네비게이션이나
쿠션, 유리 등(라이브러리)을 가져와 차를 꾸민다.&lt;/p&gt;

&lt;h2 id=&quot;프레임워크-란-&quot;&gt;프레임워크 란 ?&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;기본적인 뼈대가 완성되어 있고, 규칙이 존재하는 개발 환경&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;특징&quot;&gt;특징&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;개발자들이 따라야 할 가이드라인을 가진다.&lt;/li&gt;
  &lt;li&gt;개발할 수 있는 범위가 정해져 있다.&lt;/li&gt;
  &lt;li&gt;개발자를 위한 다양한 도구들이 지원된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;장점&quot;&gt;장점&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;개발 편의성이 오르고 시간을 절약할 수 있다.&lt;/li&gt;
  &lt;li&gt;오류의 폭을 좁힐 수 있다.&lt;/li&gt;
  &lt;li&gt;어느 정도의 코드 품질을 보장한다.&lt;/li&gt;
  &lt;li&gt;유지 보수하기 좋다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;단점&quot;&gt;단점&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;프레임워크의 의존도가 늘어나 개발 능력이 저하될 수 있다.&lt;/li&gt;
  &lt;li&gt;개발자의 자유도가 떨어진다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;라이브러리-란&quot;&gt;라이브러리 란?&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;개발 시 활용 가능한 도구들을 모아 모듈화한 것&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;라이브러리와-api-차이&quot;&gt;라이브러리와 API 차이&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;라이브러리 : 실제로 “실행이 되는 기능”을 담당하는 단편화된 프로그램&lt;/li&gt;
  &lt;li&gt;API(Application Programming Interface) : 다른 목적으로 개발된 프로그램/라이브러리 들의 특정 기능을 “호출”하기 위해서 인터페이스를 노출시킨 것&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;프레임워크와-라이브러리-&quot;&gt;프레임워크와 라이브러리 ?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;프레임워크는 단순히 “라이브러리의 집합”은 아니다!&lt;/li&gt;
  &lt;li&gt;프레임워크는 개발자들의 “환경”을 제한하는 대신 일정 “환경”을 제공&lt;/li&gt;
  &lt;li&gt;라이브러리는 내가 원하는 코드를 원할 때 원하는 곳에 가져다 넣을 수 있다. → 즉, “환경”은 없고 의도와 목적만이 존재&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;큐와 스택&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;큐queue&quot;&gt;큐(Queue)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;FIFO(First In First Out), 즉, 선입선출의 방식으로 동작하며, 프로세스 처리, CPU관리 등에 많이 사용된다.&lt;/li&gt;
  &lt;li&gt;큐에 자료를 한 개 집어 넣는 동작을 인큐(EnQueue)라고 하며, 큐 안에 있는 자료를 한 개 꺼내는 동작을 디큐(DeQueue)라고 한다.&lt;/li&gt;
  &lt;li&gt;리스트를 이용한 큐 구현(Linear Queue(선형 큐)) 에서는 디큐로 맨 앞자리를 날렸을 때 남은 부분이 앞으로 한 칸씩 땡겨져 오다 보니 속도 측면에서 단점이 있다.&lt;/li&gt;
  &lt;li&gt;Linear Queue를 보완하기 위해 Circular Queue(원형 큐)가 등장했고, 이는 디큐로 빼 놓은 자리에 인큐로 넣음으로써 낭비를 막는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ex) 버스 또는 택시 등 줄 서기, 롤에서 “큐를 돌린다” 등의 예가 있다.&lt;/p&gt;

&lt;h3 id=&quot;스택stack&quot;&gt;스택(Stack)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;LIFO(Last In First Out), 즉, 후입선출의 방식으로 동작하며, 문서 작업에서 ctrl+z, 캐시 등에 많이 사용된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ex) 쌓여 있는 접시 또는 책 등&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;쿠키, 세션, 캐시&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP(HyperText Transfer Protocol)은 브라우저 같은 응용 프로그램을 통해 사용자와 서버 사이에 전송하는 프로토콜이며, 이는 연결 상태를 유지하지 않는 비 연결 프로토콜이라는 특징을 가짐&lt;/li&gt;
  &lt;li&gt;사용자의 요청에 따라 서버에 접속해 응답 데이터를 전송한 뒤 연결을 종료시켜 주다 보니, 매 번 재 연결을 해야 했고, 이러한 단점을 해결하기 위해 쿠키나 세션을 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;쿠키cookie&quot;&gt;쿠키(Cookie)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;사용자의 브라우저에 저장되기 때문에 서버의 자원을 사용할 수 없고, 사용자의 컴퓨터만 있으면 누구나 쿠키 안에 데이터를 확인할 수 있기 때문에 보안성이 낮다.&lt;/li&gt;
  &lt;li&gt;Cookie는 인터넷 사용자가 특정 웹서버에 접속할 때, 생성되는 개인 아이디와 비밀번호, 방문한 사이트의 정보를 담은 임시 파일로써, Server가 아닌 Client에 텍스트 파일로 저장되어 다음에 해당 웹서버를 찾을 경우 웹서버에서는 그가 누구인지 어떤 정보를 주로 찾았는지 등을 파악할 때 사용&lt;/li&gt;
  &lt;li&gt;예를 들어, 검색 키워드 정보나 자동 로그인 유지 정보, 팝업 보지 않기, 쇼핑 카트나 위시 리스트 저장, 특정 웹사이트에 방문한 적이 있는지, 또 접속했다면 얼마나 자주 방문했는지 등에 관한 정보들을 담고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;세션session&quot;&gt;세션(Session)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;클라이언트와 웹 서버간에 네트워크 연결이 지속적으로 유지되고 있는 상태&lt;/li&gt;
  &lt;li&gt;서버에 접속하지 않는 이상 데이터를 탈취할 수 어렵기 때문에 중요한 데이터를 저장하는데 주로 사용&lt;/li&gt;
  &lt;li&gt;세션에 관련된 데이터는 서버에 저장 → 쿠키에 비해 보안성이 높음&lt;/li&gt;
  &lt;li&gt;웹 브라우저의 캐시에 저장되어 브라우저가 닫히거나 서버에서 삭제 시 사라짐&lt;/li&gt;
  &lt;li&gt;예를 들어, 로그인 정보 유지에 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;캐시cache&quot;&gt;캐시(Cache)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;데이터나 값을 미리 복사해 임시로 저장해두는 장소를 의미&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Process vs Thread&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;process&quot;&gt;Process&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;운영체제로부터 자원을 할당받는 작업의 단위&lt;/li&gt;
  &lt;li&gt;컴퓨터에서 실행 중인 컴퓨터 프로그램&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;thread&quot;&gt;Thread&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스가 할당받은 자원을 이용하는 실행의 단위&lt;/li&gt;
  &lt;li&gt;하나의 프로세스가 생성되면 하나의 스레드가 같이 생성 → 메인 스레드&lt;/li&gt;
  &lt;li&gt;여러 개의 스레드를 가질 수 있음 → 멀티 스레드&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;컨텍스트 스위칭 오버헤드 정도&lt;/li&gt;
  &lt;li&gt;자원 공유 가능 여부&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;MultiThread 에서 작업할 때 발생하는 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;Thread 란? 위에 설명 했듯, 프로그램의 흐름을 말한다.&lt;/li&gt;
  &lt;li&gt;Multi Thread 란? 프로그램의 흐름이 2개 이상인 것을 말한다. 매우 빠른 시간 간격으로 스위칭 되기 때문에 동시( = concurrent )에 실행되는 것처럼 보인다.&lt;/li&gt;
  &lt;li&gt;Process Synchronization(프로세스 동기화 = Thread Synchronization) 이란? 서로 간에 영향을 주고 받는 데이터들 간에 데이터의 일관성이 유지될 수 있도록 해주는 것!&lt;/li&gt;
  &lt;li&gt;MultiThead 실행 방법&lt;br /&gt;
동시성( Concurrency ) : 멀티 작업을 위해 1개의 코어로 스레드마다 돌아가면서 실행하지만, 너무 빨라 독립적으로 돌아가는 것 처럼 보임&lt;br /&gt;
병렬성( Parallelism ) : 스레드마다 독립적인 core가 할당되어 독립적인 core에서 작업이 이뤄지는 것을 말함&lt;br /&gt;
코어 &amp;gt; 쓰레드 → 병렬성 보장&lt;br /&gt;
코어 &amp;lt; 쓰레드 → 병렬설 보장 x, 동시성 보장을 위해 우선순위를 매겨줌 → 쓰레드 스케쥴링&lt;/li&gt;
  &lt;li&gt;쓰레드 스케쥴링 방식&lt;br /&gt;
우선 순위( Priority ) 방식 : 우선 순위가 높은( 1 : 낮음, 10 : 높음 ) 쓰레드가 실행을 더 많이 하도록 스케줄링하는 방법&lt;br /&gt;
순환 할당( Round-Robin ) 방식 : 시간 할당량을 정해 쓰레드를 정해진 시간 만큼만 실행하는 방법으로, JVM 안에서 이루어 지기 떄문에 개발자가 제어할 수 없음&lt;/li&gt;
  &lt;li&gt;Multi Thread(Thread 2개)에서 하나의 공통된 값을 가져다 쓰면서 변경해, 그럴 경우 값을 유지하는 방법은?&lt;br /&gt;
3번에서 얘기한 대로, 동기화를 이용하면 된다. 동기화 방법으로 동기화 메소드와 동기화 블록 방법 등이 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hash 란?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Hash 함수 ? Hash 알고리즘을 구현하여 원본 데이터만 넣으면 Hash 값을 내보내 주는 함수&lt;br /&gt;
Hash 알고리즘 ? 가변적인 데이터의 길이를 고정적인 데이터 길이로 변환해 주는 알고리즘&lt;/p&gt;

&lt;p&gt;Hash 값의 특징 ?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Hash 값은 원본으로 되돌릴 수 없음( 계산을 통해 원본을 얻어내기 어렵다 → 원본을 알아낼 수 없게 암호화하는 단방향 암호화에 많이 사용 )&lt;/li&gt;
  &lt;li&gt;원본 데이터가 같으면 Hash 값도 일정( 정해진 알고리즘을 통해 원본 데이터를 규칙에 맞게 변경하므로 원본 데이터가 같으면 Hash도 같다  )&lt;/li&gt;
  &lt;li&gt;충돌 가능성이 존재( Hash 값은 정해진 길이(길이는 알고리즘마다 다르게 정해짐)의 값 이기 때문에 원본이 다르다고 무조건 다른 값을 만들 순 없다 → 확률이 적다 )&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Hash 알고리즘의 용도 ?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;무결성의 확인 ?&lt;br /&gt;
무결성이란 데이터가 변했는지 변하지 않았는지의 여부&lt;br /&gt;
Hash 알고리즘을 사용하면 원본이 같으면 같은 Hash 값 나오기 때문에, 원본과 Hash 값을 직접 비교할 수 있다는 장점이 있다.&lt;br /&gt;
아무리 큰 데이터여도 고정된 길이의 Hash 값으로 바꿀 수 있기 때문에 비교 속다가 빠르다는 장점이 있다.&lt;/li&gt;
  &lt;li&gt;검색 속도를 높이는 용도로 사용 ?&lt;br /&gt;
예를 들어, 많은 데이터를 가진 DB에서 “chu”를 찾기 위해선 한 글자씩 찾아야 한다. → 퍼포먼스 떨어짐 → Hash 함수를 통해 DB의 데이터를 고정된 크기의 Hash 값을 가진 공간(Bucket)을 만들어 저장하고 원본에 링크해 놓는 다면, 검색 값인 “chu”를 Hash 함수를 거친 Hash 값으로 bucket과 매칭시킨다면, 바로 링크된 원본을 찾아낼 수 있다. → bucket을 만드는 공간이 소요되지만, 검색이 굉장히 빨라지는 장점이 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;질문!&lt;br /&gt;
Hash 값으로 변경되더라도 하나씩 비교해줘야 하는거 같은데, 왜 빠르지?&lt;br /&gt;
해시 검색을 위해서는 검색에 효율적인 이진 트리 방식을 사용한다. 이를 사용하기 위해서는 모든 값이 같은 크기의 공간에 담을 수 있는 서로 비교 가능한 숫자여야 하기 때문에 &lt;em&gt;Hash 함수를 통해 정수 값으로 만든 후 이진 트리 형태로 정렬하여 검색에 사용&lt;/em&gt;하는 것.&lt;br /&gt;
Hash 함수는 Hash 형식에 따라 특정 길이(128비트, 256비트, 512비트 등)로 정해져 있다. 이는 해당 길이 만큼의 정수 값으로 변환 시켜주는 것. 따라서 구조적으로 가변적인 길이의 문자열을 1바이트씩 직접 비교하는 것보다 빠릅니다.&lt;/p&gt;

&lt;p&gt;Hash 함수 사용 시 주의점 ?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Salt 의 사용?&lt;br /&gt;
보안 목적으로 사용 시 반드시 사용 → 원본 데이터에 첨가(salt)해서 Hash 알고리즘을 통해 salt를 첨가한 Hash 값을 보낸다.&lt;br /&gt;
→ 즉, 원본 데이터에 salt를 첨가해 Hash 값을 다르게 만들기 위해 사용한다.&lt;br /&gt;
→ 왜 다르게 하지? → Hash 값을 통해 원본을 알아낼 수 있는 방법이 있다!? → Brute-Forca Attack( 무작위로 문자열을 대입하는 해킹 방법 ) 으로 가능하며, 이는 Hash 함수에 무작위 값을 넣어 나온 Hash 값을 해킹해 낸 Hash 값과 대조하여 원본을 알아내는 것이다.&lt;br /&gt;
따라서, 아래와 같은 사항을 따르는게 좋다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1) Salt를 첨가하여 Hash 값을 다르게 한다.&lt;br /&gt;
2) Salt의 길이를 허용하는 한 길게 함&lt;br /&gt;
3) Salt를 안전하게 보관함&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Key stretching 의 사용?&lt;br /&gt;
Hash 함수를 여러 번 통과시키는데 사용 → 이는 Hash 함수를 거쳐 나온 Hash 값을 다른 Hash 함수에 거치는 작업을 반복함으로써 어렵게 하는 방식이다.&lt;/li&gt;
  &lt;li&gt;충돌의 회피 ?&lt;br /&gt;
데이터 저장의 목적으로 사용 시 사용 → 단점인 서로 다른 값 이더라도 Hash 값이 같을 확률이 존재! → 보안에도, 데이터 저장에도 큰 문제!! → 이를 위해 아래와 같은 사항이 추가된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1) 리스트로 데이터를 관리하는 Chaining&lt;br /&gt;
2) 위치를 조정하는 Open Addressing&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;RestFul Api ?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;REpresentational State Transfer, 즉, 서버로 자원을 전달 시, 대표적인 “상태”를 함께 주고 그 상태에 맞는 응답을 서버에서 받는 것을 의미한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;rest-&quot;&gt;REST ?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 방식으로 동작&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;rest-api-&quot;&gt;REST API ?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;REST 기반으로 서비스 API를 구현한 것&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;http-method&quot;&gt;HTTP Method&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;POST : URI 요청 시 리소스 생성을 위해 설계되었기 때문에 body에 데이터를 담아 보내기 때문에 url에 보이지 않는다. 즉, 정보를 생성하기 위해 만들어짐.&lt;/li&gt;
  &lt;li&gt;GET : 해당 리소스를 조회하게 설계되었기 때문에, 원하는 값을 url에 보여준다. 즉, 정보를 조회하기 위해 만들어짐.&lt;/li&gt;
  &lt;li&gt;PUT or PATCH or UPDATE : 해당 리소스를 수정&lt;/li&gt;
  &lt;li&gt;DELETE : 해당 리소스를 삭제&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="android" />
      

      
        <summary type="html">컴퓨터과학 면접 준비</summary>
      

      
      
    </entry>
  
</feed>
