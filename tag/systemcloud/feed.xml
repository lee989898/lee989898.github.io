<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://lee989898.github.io/tag/systemcloud/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://lee989898.github.io/" rel="alternate" type="text/html" />
  <updated>2022-04-22T22:37:16+09:00</updated>
  <id>https://lee989898.github.io/tag/systemcloud/feed.xml</id>

  
  
  

  
    <title type="html">LEE | </title>
  

  
    <subtitle>공부 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">환경변수와 공격들</title>
      <link href="https://lee989898.github.io/sc2-05" rel="alternate" type="text/html" title="환경변수와 공격들" />
      <published>2022-04-11T01:06:00+09:00</published>
      <updated>2022-04-11T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc2-05</id>
      <content type="html" xml:base="https://lee989898.github.io/sc2-05">&lt;blockquote&gt;
  &lt;p&gt;Environment Variables&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;동적으로 이름지어진 값의 집합&lt;/li&gt;
  &lt;li&gt;프로세스가 진행되는 운영 환경의 일부&lt;/li&gt;
  &lt;li&gt;실행 중인 프로세스가 동작하는 방식에 영향&lt;/li&gt;
  &lt;li&gt;Unix에 도입되었으며 Microsoft Windows에서도 채택됨&lt;/li&gt;
  &lt;li&gt;ex) PATH 변수
    &lt;ul&gt;
      &lt;li&gt;프로그램이 실행될 때 쉘 프로세스는 환경을 사용한다. 전체 경로가 제공되지 않은 경우 변수를 사용하여 프로그램이 있는 위치를 찾는다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;환경 변수에 접근하는 방법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;방법 1: 메인 함수에서&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc54.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;p&gt;방법 2: 전역 변수를 사용하여&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc55.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로세스는 어떻게 환경 변수를 얻을까?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;프로세스는 두가지 방법으로 환경 변수를 가져온다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;fokr() 시스템 호출을 사용하여 새 프로세스가 생성되면 자식 프로세스는 부모 프로세스의 환경 변수를 상속한다&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로세스가 자체적으로 새 프로그램을 실행하는 경우 일반적으로 execve 시스템 호출을 사용한다. 이경우 메모리 공간을 덮어쓰고 모든 이전 환경 변수가 사라진다. execve()는 전달하기 위해 특별한 방식으로 호출 될 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;execve() 호출 시 환경 변수 전달:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc56.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;execve()와 환경변수&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;프로그램은 새로운 프로그램 /usr/bin/env, 현재 프로세스의 환경 변수를 출력한다&lt;br /&gt;
새로운 변수 newenv를 3번째로 사용&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc57.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;
&lt;img src=&quot;\assets\built\images\sc2\sc58.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;환경 변수의 메모리 위치&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc59.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;envp 및 환경은 처음에는 같은 장소를 가리킨다&lt;/li&gt;
  &lt;li&gt;envp는 내부에서 메인 함수에서 액세스할 수 있다. Environ은 전역 변수&lt;/li&gt;
  &lt;li&gt;환경 변수에 변경 사항이 있을 때(예: 새로 추가됨), 환경변수의 저장 위치는 힙으로 바뀔 수 있다, 그래서 environ은 변경될 것이다(envp는 바뀌지 않는다)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;셸 변수 및 환경 변수&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;사람들은 종종 쉘 변수와 환경 변수를 똑같다고 착각한다&lt;/li&gt;
  &lt;li&gt;쉘 변수
    &lt;ul&gt;
      &lt;li&gt;쉘에서 사용하는 내부 변수&lt;/li&gt;
      &lt;li&gt;쉘은 사용자가 쉘을 생성, 할당 및 삭제할 수 있도록 내장 명령을 제공한다&lt;/li&gt;
      &lt;li&gt;예제에서는 FOO라는 쉘 변수를 생성한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;쉘 프로그램이 시작될 때 환경 변수를 자체 쉘에 복사합니다. 자체 쉘 변수에 대한 변경 사항은 반영되지 않는다, 아래 그림은 그 예이다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc61.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc60.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;아래 사진은 쉘 변수가 자식 프로세스의 환경 변수에 영향을 미치는 방법을 보여준다&lt;/li&gt;
  &lt;li&gt;또한 부모 쉘의 환경 변수가 자식 프로세스의 환경 변수가 되는 것을 보여준다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc62.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;p&gt;쉘 프롬프트에 env를 입력하면 쉘은 자식 프로세스를 생성한다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc63.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;/proc 파일 시스템에 대한 참고 사항&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;/proc은 Linux의 가상 파일 시스템이다.프로세스 ID를 디렉터리 이름으로 사용 하여 디렉토리를 포함한다&lt;/li&gt;
  &lt;li&gt;각 프로세스 디렉토리에는 Environ이라는 가상 파일이 포함되어 있다. 프로세스의 환경
    &lt;ul&gt;
      &lt;li&gt;예를 들어 가상 파일 /proc/932/environ은 다음과 같은 환경 변수를 포함한다. 프로세스 932&lt;/li&gt;
      &lt;li&gt;“strings /proc/\(/environ&quot; 명령은 현재 프로세스의 환경변수를 출력한다. (셸은\)를 자체 프로세스 ID로 대체함)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;env 프로그램은 bash 셸에서 호출될 때 자식 프로세스에서 실행된다. 따라서 자기 것이 아닌 쉘의 자식 환경 변수를 출력한다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;환경 변수에 대한 공격&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;환경변수를 숨은 의도로 사용하면 매우 위험하다&lt;/li&gt;
  &lt;li&gt;사용자가 환경 변수를 설정할 수 있기 때문에 그것들은 Set-UId 프로그램 공격의 일부가 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc64.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Dynamic Linker를 통한 공격&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Linking은 프로그램에서 참조하는 외부 라이브러리 코드를 찾는 것이다&lt;/li&gt;
  &lt;li&gt;링크는 런타임 또는 컴파일 시간 동안 수행할 수 있다
    &lt;ul&gt;
      &lt;li&gt;Dynamic Linking: 환경 변수를 사용하며, 공격 surface의 일부가 된다&lt;/li&gt;
      &lt;li&gt;Static Linking&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 예를 사용하여 정적 및 동적을 구별한다. 연결:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc65.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Static Linking
    &lt;ul&gt;
      &lt;li&gt;링커는 프로그램 코드와 라이브러리 코드를 결합한다. printf() 함수를 포함하여&lt;/li&gt;
      &lt;li&gt;정적 컴파일된 프로그램의 크기가 100배임을 알 수 있다. 동적 프로그램보다 크다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc66.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Dynamic Linking
    &lt;ul&gt;
      &lt;li&gt;Linking은 런타임 중에 수행된다
        &lt;ul&gt;
          &lt;li&gt;공유 라이브러리(Windows의 DLL)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;동적 연결로 컴파일된 프로그램이 실행되기 전에 해당 실행 파일이 메모리에 먼저 로드됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc67.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“ldd” 명령을 사용하여 어떤 공유 라이브러리가 의존하는 지 확인할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc68.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="systemcloud" />
      

      
        <summary type="html">Environment Variables</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Set-UID Privileged Programs</title>
      <link href="https://lee989898.github.io/sc2-04" rel="alternate" type="text/html" title="Set-UID Privileged Programs" />
      <published>2022-04-06T01:06:00+09:00</published>
      <updated>2022-04-06T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc2-04</id>
      <content type="html" xml:base="https://lee989898.github.io/sc2-04">&lt;h2 id=&quot;set-uid-privileged-programs&quot;&gt;&lt;strong&gt;Set-UID Privileged Programs&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;권한 있는 프로그램의 필요성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;비밀번호 딜레마
    &lt;ul&gt;
      &lt;li&gt;/etc/shadow 파일의 권한: &lt;img src=&quot;\assets\built\images\sc2\sc40.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;일반 사용자는 비밀번호를 어떻게 변경할까? &lt;img src=&quot;\assets\built\images\sc2\sc41.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Two-Tier 접근&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;세분화된 액세스 구현 운영 체제의 제어가 OS를 만든다 -&amp;gt; 너무 복잡하다&lt;/li&gt;
  &lt;li&gt;OS는 extension에 의존하여 세분화된 액세스 제어한다&lt;/li&gt;
  &lt;li&gt;권한 있는 프로그램은 그러한 extension이다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc42.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Privileged 프로그램의 종류&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Daemons
    &lt;ul&gt;
      &lt;li&gt;백그라운드에서 실행되는 컴퓨터 프로그램&lt;/li&gt;
      &lt;li&gt;루트 또는 기타 권한이 있는 사용자로 실행해야 한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Set-UID Programs
    &lt;ul&gt;
      &lt;li&gt;UNIX 시스템에서 널리 사용&lt;/li&gt;
      &lt;li&gt;특수 비트로 표시된 프로그램&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;슈퍼맨 이야기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Power Suit
    &lt;ul&gt;
      &lt;li&gt;슈퍼피플: 그들에게 직접 힘을 준다&lt;/li&gt;
      &lt;li&gt;이슈: 나쁜 슈퍼피플&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Power Suit 2.0
    &lt;ul&gt;
      &lt;li&gt;컴퓨터 칩&lt;/li&gt;
      &lt;li&gt;특정 작업&lt;/li&gt;
      &lt;li&gt;사전 프로그래밍된 작업에서 벗어날 방법 없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Set-UID 매커니즘 : 파워 슈트 메커니즘 리눅스 OS에서 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Set-UID Concept&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;사용자가 프로그램 소유자의 권한으로 프로그램을 실행할 수 있도록 허용한다&lt;/li&gt;
  &lt;li&gt;사용자가 일시적으로 상승된 권한으로 프로그램을 실행할 수 있도록 허용&lt;/li&gt;
  &lt;li&gt;Example: the passwd program&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;passwd&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rwsr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;41284&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sep&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2012&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;passwd&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;모든 프로세스에는 두 개의 사용자 ID가 있다&lt;/li&gt;
  &lt;li&gt;Real UID (RUID): 프로세스의 실제 소유자 식별&lt;/li&gt;
  &lt;li&gt;Effective UID (EUID): 프로세스의 권한을 식별
    &lt;ul&gt;
      &lt;li&gt;액세스 제어는 EUD를 기반으로 한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;일반 프로그램이 실행될 때 RUID = EUID,프로그램을 실행하는 사용자의 ID로 둘 다 동일하다&lt;/li&gt;
  &lt;li&gt;Set-UID가 실행되면 RUID ≠ EUID. RUID는 여전히 같다. 사용자 ID이지만 EUID는 프로그램 소유자 ID와 동일하다
    &lt;ul&gt;
      &lt;li&gt;프로그램이 root에 의해 소유된 경우 프로그램은 root 권한으로 실행된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로그램을 Set-UID로 전환&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;소유자 변경 -&amp;gt; root에 대한 파일로 &lt;img src=&quot;\assets\built\images\sc2\sc43.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;활성화하기 전에 Set-UID 비트 &lt;img src=&quot;\assets\built\images\sc2\sc44.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;활성화 후 Set-UID 비트 &lt;img src=&quot;\assets\built\images\sc2\sc45.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;작동 원리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Set-UID 프로그램은 Set-UID 비트라고 하는 단일 비트인 특수 마킹을 제외하고는 다른 프로그램과 같다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc46.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;
&lt;img src=&quot;\assets\built\images\sc2\sc47.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;UID 설정 예&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;privileged program 아님&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc48.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;p&gt;privileged program 임&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc49.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;p&gt;privileged program 이지만 root privilege는 아님&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc50.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Set-UID는 어떻게 안전한가?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;일반 사용자가 권한을 에스컬레이션할 수 있다
    &lt;ul&gt;
      &lt;li&gt;권한을 직접 부여하는 것과는 다르다(sudo 명령)&lt;/li&gt;
      &lt;li&gt;제한된 행동 – 슈퍼맨이 디자인한 컴퓨터 칩과 유사&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모든 프로그램을 Set-UID로 전환하는 것은 안전하지 않다
    &lt;ul&gt;
      &lt;li&gt;예: /bin/sh&lt;/li&gt;
      &lt;li&gt;예: vi&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;슈퍼맨에 대한 공격&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;사용자가 코딩된 작업만 수행할 수 있다고 가정할 수 없음
    &lt;ul&gt;
      &lt;li&gt;개발자의 코딩 결함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;슈퍼맨 말로이
    &lt;ul&gt;
      &lt;li&gt;북쪽으로 비행한 다음 좌회전&lt;/li&gt;
      &lt;li&gt;이 코드를 어떻게 악용하는가?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;슈퍼맨 말로리
    &lt;ul&gt;
      &lt;li&gt;북쪽으로 날아 서쪽으로 회전&lt;/li&gt;
      &lt;li&gt;이 코드를 어떻게 악용하는가?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc51.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Set-UID 프로그램의 표면 공격&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc52.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;사용자 Input을 통한 공격&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;사용자 Input: 명시적 입력&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;버퍼 오버 플로우
    &lt;ul&gt;
      &lt;li&gt;악성코드 실행을 위한 버퍼 오버플로우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;형식 문자열 취약점
    &lt;ul&gt;
      &lt;li&gt;사용자 입력을 형식 문자열로 사용하여 프로그램 동작 변경&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CHSH – 쉘 변경
    &lt;ul&gt;
      &lt;li&gt;기본 셸 프로그램을 변경할 수 있는 Set-UID 프로그램&lt;/li&gt;
      &lt;li&gt;쉘 프로그램은 /etc/passwd 파일에 저장된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;문제
    &lt;ul&gt;
      &lt;li&gt;사용자 입력 삭제 실패&lt;/li&gt;
      &lt;li&gt;공격자가 새 루트 계정을 만들 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;공격
&lt;img src=&quot;\assets\built\images\sc2\sc53.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;시스템 Input을 통한 공격&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;경쟁 조건
    &lt;ul&gt;
      &lt;li&gt;권한이 없는 파일에서 권한 있는 파일에 대한 심볼릭 링크&lt;/li&gt;
      &lt;li&gt;인플루언서 프로그램&lt;/li&gt;
      &lt;li&gt;world writable 폴더 내부에 쓰기&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;환경변수를 통한 공격&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;동작은 내부에 표시되지 않는 입력의 영향을 받을 수 있다&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;환경 변수 : 사용자가 실행하기 전에 설정할 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;PATH 환경 변수
    &lt;ul&gt;
      &lt;li&gt;사용자가 명령의 전체 경로 제공하지 않은 경우 쉘 프로그램에서 명령을 찾는 데 사용한다&lt;/li&gt;
      &lt;li&gt;system(): /bin/sh를 먼저 호출한다&lt;/li&gt;
      &lt;li&gt;system(“ls”)
        &lt;ul&gt;
          &lt;li&gt;/bin/sh는 PATH 환경 변수를 사용하여 “ls”를 찾는다&lt;/li&gt;
          &lt;li&gt;공격자는 PATH 변수를 조작하고 “ls” 명령을 찾는 방법을 제어할 수 있다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Capability Leaking&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;몇몇 경우에 권한 있는 프로그램은 실행중에 스스로 다운그레이드 한다&lt;/li&gt;
  &lt;li&gt;예: su 프로그램
    &lt;ul&gt;
      &lt;li&gt;권한이 있는 Set-UID 프로그램이다&lt;/li&gt;
      &lt;li&gt;한 사용자가 다른 사용자로 전환할 수 있다(예: user1에서 user2로)&lt;/li&gt;
      &lt;li&gt;프로그램은 루트로 EUID를, user1로 RUID로 시작한다&lt;/li&gt;
      &lt;li&gt;비밀번호 확인 후, EUID와 RUID는 모두 user2가 됩니다(권한을 통해 다운그레이드)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이러한 프로그램은 기능 누출로 이어질 수 있다
    &lt;ul&gt;
      &lt;li&gt;프로그램은 다운그레이드하기 전에 권한 있는 기능을 정리하지 못할 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Capability Leaking을 통한 공격: 예&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;sudo chown root ./prog
sudo chmod 4755 ./prog&lt;/p&gt;

&lt;p&gt;운영체제에서 실행 중인 프로세스에대해서 접근제어를 적용할대는 EUID를 기준으로 이 프로세스가 현쟈 하고자 하는 오퍼레이션을 허용할지 말지를 결정한다&lt;br /&gt;
EUID를 기준으로 시스템의 접근제어가 이루어진다&lt;/p&gt;

&lt;p&gt;set-uid를 통해 공격이 들어오기 때문에 Set-UID 비트를 해제한다. 공격의 예로는 시스템 인풋, 유저 인풋, 환경 변수가 있다&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="systemcloud" />
      

      
        <summary type="html">Set-UID Privileged Programs</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">리눅스 사용자 계정과 권한 체계, 쉘 기본</title>
      <link href="https://lee989898.github.io/sc2-03" rel="alternate" type="text/html" title="리눅스 사용자 계정과 권한 체계, 쉘 기본" />
      <published>2022-03-21T01:06:00+09:00</published>
      <updated>2022-03-21T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc2-03</id>
      <content type="html" xml:base="https://lee989898.github.io/sc2-03">&lt;h2 id=&quot;리눅스-사용자-계정과-권한-체계-쉘-기본&quot;&gt;&lt;strong&gt;리눅스: 사용자 계정과 권한 체계, 쉘 기본&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;리눅스유닉스-파일-시스템&quot;&gt;&lt;strong&gt;리눅스/유닉스 파일 시스템&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;리눅스/유닉스 파일 시스템은 디렉토리와 파일로 구성&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;디렉토리&lt;/th&gt;
      &lt;th&gt;내용&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;/&lt;/td&gt;
      &lt;td&gt;파일 시스템 트리 구조의 최상위 디렉토리이다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/etc&lt;/td&gt;
      &lt;td&gt;시스템의 환경 설정 및 주요 설정 파일을 담고있다 (passwd, shadow 등)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;dev&lt;/td&gt;
      &lt;td&gt;프린터 같은 물리적인 장치를 다루기 위한 특수 파일을 담고있다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/usr/bin&lt;/td&gt;
      &lt;td&gt;쉘 명령어 실행 파일 등 기본적으로 실행 가능한 파일을 담고 있다 (ls, mv, cp, pwd 등)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/usr/include&lt;/td&gt;
      &lt;td&gt;주요 라이브러리 헤더파일이 저장되는 디렉토리이다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/usr/lib&lt;/td&gt;
      &lt;td&gt;라이브러리에 대한 shared object 파일(.so)이 저장되는 디렉토리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/usr/sbin&lt;/td&gt;
      &lt;td&gt;시스템 관리 명령어가 저장되는 디렉터리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/home&lt;/td&gt;
      &lt;td&gt;사용자 홈 디렉터리가 저장되는 디렉터리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tmp&lt;/td&gt;
      &lt;td&gt;프로그램 실행 및 설치 시 생성되는 임시 파일을 담고있다. 이 디렉터리에 파일을 저장하면 재부팅 시 임의로 삭제될 수 있다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/var&lt;/td&gt;
      &lt;td&gt;시스템 로그가 저장되는 디렉터리이다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc&lt;/td&gt;
      &lt;td&gt;실행중인 프로세스 정보를 담고 있는 파일들이 저장됨. 실행 중인 각 프로세스 id마다 파일이 존재&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;리눅스유닉스의-계정과-권한-체계&quot;&gt;&lt;strong&gt;리눅스/유닉스의 계정과 권한 체계&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;로그인: 아이디와 패스워드 입력을 통해 자신이 누군지 밝히고, 그에 따른 권한을 부여 받아 시스템 사용을 허가 받는 과정&lt;/li&gt;
  &lt;li&gt;리눅스 시스템의 계정과 권한 체계: root라고 불리는 관리자와 일반 사용자 계정으로 구분. 모든 계정 정보가 /etc/passwd 파일에 저장됨&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;vi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;etc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;passwd&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc3.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;/etc/passwd 파일&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc4.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;사용자 계정명&lt;/li&gt;
  &lt;li&gt;패스워드가 암호화되어 /etc/shadow 파일에 저장되어 있음을 나타냄&lt;/li&gt;
  &lt;li&gt;사용자 번호(UID, User ID)&lt;/li&gt;
  &lt;li&gt;그룹 번호(GID, Group ID)&lt;/li&gt;
  &lt;li&gt;사용자의 이름이다&lt;/li&gt;
  &lt;li&gt;사용자의 홈 디렉터리 나타냄
    &lt;ul&gt;
      &lt;li&gt;관리자의 홈 디렉터리는 /root이다&lt;/li&gt;
      &lt;li&gt;일반 사용자의 홈 디렉터리는 /hoom/seed 같이 /home 디렉터리 하위에 위치한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자 계정 로그인 쉘을 지정. 기본 설정은 /bin/bash 쉘&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;리눅스에서 관리자는 UID를 0번으로 부여받고 일반 사용자는 그 외의 번호를 부여 받는데 보통 500번 또는 1000번 이상을 부여 받는다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;/etc/shadow 파일&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;각 사용자 계정의 패스워드가 암호화 된 상태로 저장되어 있음&lt;/li&gt;
  &lt;li&gt;사용자 계정 seed에 대한 정보 예&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc5.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;주요 필드&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;사용자 계정명&lt;/td&gt;
      &lt;td&gt;첫번째 필드는 사용자 계정명을 나타냄&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;암호화된 패스워드&lt;/td&gt;
      &lt;td&gt;두번째 필드는 암호화된 패스워드를 나타냄. $로 아래와 같이 추가 구분 &amp;lt;/br&amp;gt; $algoritihm_id$salt$hash_value_of_password &amp;lt;/br&amp;gt; &amp;gt; algorithm_id: 패스워드 해쉬값 계산에 사용된 암호학적 해쉬 함수 종류를 나타냄(MD5, BlowFish, SHA-256, SHA-512 등) &amp;lt;/br&amp;gt; &amp;gt; salt 패스워드 해쉬값 계산에 사용된 랜덤값 &amp;lt;/br&amp;gt; hash_value_of_password: 사용자 패스워드 및 salt를 입력으로 해쉬 함수를 통해 계산된 값 &amp;lt;/br&amp;gt; 패스워드 필드에 *, ! 등이 설정될 수도 있음 &amp;lt;/br&amp;gt; *: 패스워드가 잠긴 상태로 일반적인 방식의 로그인은 불가하지만 별도의 인증 방식을 사용하여 로그인을 하루 수는 있음 &amp;lt;/br&amp;gt; !: 패스워드가 잠긴 상태로 일반적인 방식의 로그인은 불가함. 또는 사용자 계정을 생성하고 패스워드를 설정하지 않은 상태이기도 함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;마지막 변경&lt;/td&gt;
      &lt;td&gt;마지막으로 패스워드를 변경한 날을 1970년 1월1일 기준으로 일수로 표시함. 위 예에서는 마지막으로 패스워드를 변경한 날은 1970년 1월1일 이후 18950일이 지났음을 의미&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;패스워드 최소 사용기간&lt;/td&gt;
      &lt;td&gt;패스워드를 변경한 이후 최소 이 정도의 기간은 사용해야함을 의미&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;패스워드 최대 사용기간&lt;/td&gt;
      &lt;td&gt;패스워드를 변경한 이후 만료되는 일수를 나타냄. 보안을 위해 주기적으로 패스워드 변경이 필요한 경우 활용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;경고&lt;/td&gt;
      &lt;td&gt;패스워드 만료일 몇일 전에 경고 알림할건지를 설정&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;비활성화&lt;/td&gt;
      &lt;td&gt;패스워드가 만료된 이후에 계정이 잠기기 전까지 비활성 일수를 나타냄. 해당 비활성 기간 동안 패스워드를 변경해야 계정이 잠기지 않음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;만료일&lt;/td&gt;
      &lt;td&gt;계정이 만료되는 날짜를 1970년 1월1일 기준으로 일수로 표시&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;패스워드 해쉬값 계산 과정&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc36.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자 로그인 시 패스워드 검증 과정(/etc/shadow 파일에서 사용자 패스워드 해쉬값, 해쉬 함수 ID, salt 값을 읽어 온다)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc37.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;만약 salt 없이 패스워드만을 입력으로 해쉬값을 계산한다면?
    &lt;ul&gt;
      &lt;li&gt;패스워드가 동일하면 그 해쉬값도 동일하다&lt;/li&gt;
      &lt;li&gt;공격자는 shadow 파일에 해쉬값들을 비교하는 것만으로 동일한 패스워드가 사용된 사용자 계정을 알아낼 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;패스워드 크래킹 공격 비용을 높이는 효과
    &lt;ul&gt;
      &lt;li&gt;레인보우 테이블을 이용한 패스워드 크래킹 공격: 일반적으로 많이 사용되는 패턴의 패스워드에 대한 해쉬값을 미리 계산해두는 방식&lt;/li&gt;
      &lt;li&gt;만약 salt가 사용되지 않는다면 공격자는 모든 고려 대상 패스워드 각각에 대한 해쉬값을 게산하면 됨&lt;/li&gt;
      &lt;li&gt;salt가 사용되면 모든 고려 대상 패스워드 및 모든 가능한 salt 값에 대해 미리 해쉬값을 계산해두어야 함 -&amp;gt; 공격 비용이 훨씬 높아짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;al&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;etc&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc38.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc39.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;파일 속성&lt;/th&gt;
      &lt;th&gt;파일 소유자&lt;/th&gt;
      &lt;th&gt;권한 그룹 권한&lt;/th&gt;
      &lt;th&gt;일반(Others)권한&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;d&lt;/td&gt;
      &lt;td&gt;rwx&lt;/td&gt;
      &lt;td&gt;r-x&lt;/td&gt;
      &lt;td&gt;r-x&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;문자&lt;/th&gt;
      &lt;th&gt;파일 속성&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;d&lt;/td&gt;
      &lt;td&gt;디렉터리 파일(Dirctory File)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;일반 정규 파일(Regular File)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;l&lt;/td&gt;
      &lt;td&gt;링크되어 있는 파일(Symbolic Link File)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;c&lt;/td&gt;
      &lt;td&gt;버퍼에 저장되지 않은 특수 파일(Character File)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;b&lt;/td&gt;
      &lt;td&gt;버퍼링된 특수 파일(Block File)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;s&lt;/td&gt;
      &lt;td&gt;소켓 기능을 하는 파일(Socket File)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;p&lt;/td&gt;
      &lt;td&gt;파이프 기능을 수행하는 파일(Pipe File)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;파일의 소유자에게 허용되는 권한
    &lt;ul&gt;
      &lt;li&gt;rwx는 파일의 소유자에 대한 접근 권한&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파일 소유자와 같은 그룹에 속한 사용자에게 허용되는 권한
    &lt;ul&gt;
      &lt;li&gt;r-x는 그룹에 대한 접근 권한&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;일반(Others) 권한
    &lt;ul&gt;
      &lt;li&gt;r-x는 파일 소유자 및 그룹에 속하지 않는 사용자들(others)에 대한 접근 권한&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;rwx의 r,w,x는 각각 읽기(Read), 쓰기(Write), 실행하기(eXecution)가 해당 사용자에게 허용됨을 의미
    &lt;ul&gt;
      &lt;li&gt;read, write, execution 각각에 대해 허용할지 말지를 3개의 플래그 비트로 표현&lt;/li&gt;
      &lt;li&gt;r: 4(2진수 100)&lt;/li&gt;
      &lt;li&gt;w: 2(2진수 10)&lt;/li&gt;
      &lt;li&gt;x: 1(2진수 1)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;rwx = (2진수 111) = (10진수 7)
    &lt;ul&gt;
      &lt;li&gt;read, write, execution 권한이 모두 허용됨을 의미&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;rwxrwxrwx = (2진수 111111111) = (10진수 777)
    &lt;ul&gt;
      &lt;li&gt;파일의 소유자, 그룹, others 모두에 대해 해당 파일에 대한 읽기, 쓰기, 실행 권한이 허용됨을 의미&lt;/li&gt;
      &lt;li&gt;할 수 있으며, 권한을 777이라고 읽음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;rwxr-x-r-x = (2진수 111101001) = (10진수 755)
    &lt;ul&gt;
      &lt;li&gt;파일 소유자에게 읽기, 쓰기, 실행 권한 모두 허용됨&lt;/li&gt;
      &lt;li&gt;그룹 &amp;amp; others에게는 읽기, 실행 권한만 혀용되며, 쓰기 권한은 허용안됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;rwxr-x–x = (2진수 111101001) = (10진수 751)
    &lt;ul&gt;
      &lt;li&gt;파일 소유자에게는 읽기, 쓰기, 실행 권한 모두 허용됨&lt;/li&gt;
      &lt;li&gt;그룹에게는 읽기, 실행 권한만 허용되며, 쓰기 권한은 허용안됨&lt;/li&gt;
      &lt;li&gt;Others에게는 실행 권한만 허용되며, 읽기, 쓰기는 허용안됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;쉘shell&quot;&gt;&lt;strong&gt;쉘(shell)&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;사용자와 운영체제 간 상호 작용을 위한 command line interface를 제공하는 프로그램&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용자 입력 명령어 처리기(command line interpreter)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;쉘 종류
    &lt;ul&gt;
      &lt;li&gt;Windows PowerShell&lt;/li&gt;
      &lt;li&gt;Linux/Unix sh, csh, bash, ksh etc.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;쉘(shell): 기본 명령어&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;pwd: print working directory&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc6.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cd: change directory&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc7.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ls: 현재 디렉터리에 속한 파일 및 서브 디렉터리를 나열해서 보여줌
    &lt;ul&gt;
      &lt;li&gt;ls -l: 퍼미션, 소유자, 그룹, 파일크기 등 파일에 대한 자세한 내용을 출력&lt;/li&gt;
      &lt;li&gt;ls -a: 숨겨진 파일이나 디렉터리도 보여줌&lt;/li&gt;
      &lt;li&gt;ls -al 같이 둘 이상의 옵션을 복합적으로 줄 수도 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc8.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;mv: “move”의 약자로 파일이나 디렉토리를 원하는 곳으로 옮기거나, 이름을 변경할 떄 사용할 수 있는 명령어&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc9.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cp: “copy”의 약자로 파일이나 디렉토리를 원하는 곳에 원하는 이름으로 복사하기 위한 명령어&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc10.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;echo: 인수로 주어진 문자열이나 환경변수 값을 출력해주는 명령어&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc11.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cat: 하나 이상의 파일을 연결해서 출력해주는 명령어&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc12.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;tail: 파일의 마지막 행을 기준으로 지정한 행까지의 파일 내용 일부를 출력해준다. 아무 옵션을 주지 않으면 기본적으로 10개 행을 출력&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc13.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;mkdir: “make directory”의 약자로 새로운 디렉토리를 만들 수 있는 명령어&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc14.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;touch &lt;파일명&gt; : 현재 디렉토리에 주어진 &lt;파일명&gt;의 새로운 파일을 생성해주는 명령어&lt;/파일명&gt;&lt;/파일명&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;rm: remove의 약자로 파일과 디렉토리 삭제에 사용되는 명령어&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc15.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;clear: 쉘 창에 있는 기록을 모두 지워주는 명령어&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;chown: 파일이나 디렉토리의 소유권자 및 그룹식별자를 바꾸는 명령어&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc16.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;chmod: “change mode” 약자로 파일이나 디렉토리의 퍼미션을 수정하기 위한 명령어&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc17.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;sudo: 일반 사용자가 root 권한을 잠시 빌려 명령을 실행할 수 있도록 하는 명령어이다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc18.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;umask: 파일이나 디렉터리 생성 시 기본 접근권한을 설정할떄 사용하는 명령어
    &lt;ul&gt;
      &lt;li&gt;기본 파일 생성 시 최고 권한이 666이며, 디렉터리의 생성 시 최고 권한은 777이다&lt;/li&gt;
      &lt;li&gt;파일 및 디렉터리 생성 시 기본 권한은 가능한 최고 권한에서 umask 값을 빼준 값이다&lt;/li&gt;
      &lt;li&gt;기본 파일은 660-002=664가, 디렉터리는 777-002=775가 된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc19.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;id: 현재 실행중인 쉘에 로그인 된 사용자 ID, 그룹 ID 등을 출력해주는 명령어
    &lt;ul&gt;
      &lt;li&gt;일반 사용자 계정으로 로그인한 경우
&lt;img src=&quot;\assets\built\images\sc2\sc20.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;root 사용자로 로그인한 경우
&lt;img src=&quot;\assets\built\images\sc2\sc21.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;grep: 특정 파일 내에서 지정한 패턴을 가진 문자열을 찾은 후, 해당 문자열을 출력해주는 명령어. 패턴에는 정규표현식의 패턴을 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc22.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;find: 파일 시스템에서 인자로 주어진 파일 및 디렉토리를 찾는 명령어
    &lt;ul&gt;
      &lt;li&gt;파일명으로 찾기(-name)
        &lt;ul&gt;
          &lt;li&gt;find . -name “*txt” 현재 디렉터리(모든 하위 디렉터리 포함)에서 확장자가 .txt인 파일 모두 찾음&lt;/li&gt;
          &lt;li&gt;find . -name “*txt” -delete 현재 디렉터리에서 확장자가 .txt인 파일 모두 찾은 다음 삭제&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;타입으로 찾기(-type)
        &lt;ul&gt;
          &lt;li&gt;find . -name “*test” -type d 현재 디렉터리에서 이름에 test가 포함된 모든 디렉터리 찾기&lt;/li&gt;
          &lt;li&gt;find . -type f 현재 디렉터리에서 모든 파일 찾기&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;파일 크기로 찾기(-empth, -size)
        &lt;ul&gt;
          &lt;li&gt;find . -empty 현재 디렉터리에서 빈 디렉터리 또는 크기가 0인 파일 찾ㄱ기&lt;/li&gt;
          &lt;li&gt;find . -size + 1024c 현재 디렉터리에서 1024byte 보다 큰 파일 찾기&lt;/li&gt;
          &lt;li&gt;find . -size + 1k -size -10k 1kb 보다 크고 10kb 보다 작은 파일 찾기&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;man: 명령어를 어떻게 쓰는지 설명해주는 내용을 출력해주는 명령어
    &lt;ul&gt;
      &lt;li&gt;main ls 실행 결과로 보여지는 내용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc23.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Redirection: &amp;gt;, »를 사용해서 주어진 명령 실행 결과로 출력되는 내용이 파일에 쓰여지도록 할 수 있다
    &lt;ul&gt;
      &lt;li&gt;&amp;gt;: overwrite, »: append&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc27.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;Pipeline: 첫번쨰 명령 (&lt;/td&gt;
          &lt;td&gt;기호 왼쪽) 실행 결과가 두번째 명령 (&lt;/td&gt;
          &lt;td&gt;기호 오른쪽)으로 넘겨지도록 한다&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc28.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;심볼릭링크 생성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;심볼릭링크 생성 명령어&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-ㅊ&quot;&gt;ln -s 우너본 링크파일
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;원본 파일 확인&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc24.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;심볼릭 링크 설정 및 확인&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc25.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;하드링크와 차이&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc26.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;하드 링크 파일의 inode number는 원본과 같다&lt;/li&gt;
  &lt;li&gt;디스크 상에서 근본적으로 같은 파일이라 할 수 있다&lt;/li&gt;
  &lt;li&gt;반면 심볼릭 링크는 디스크 상에서 다른 파일이며, 바로가기 파일이라 할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;쉘 스크립트&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;파일에 쉘 명령어들을 나열해서 순차적으로 실행되도록 하는 것&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;쉘 스크립트 예시
    &lt;ul&gt;
      &lt;li&gt;#!/bin/sh: 파일에 작성된 내용은 쉘 스크립트라는 것을 시스템에 알려주는 역할
&lt;img src=&quot;\assets\built\images\sc2\sc29.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;아래 두가지 방법 중 하나로 쉘 스크립트 실행
&lt;img src=&quot;\assets\built\images\sc2\sc30.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;
&lt;img src=&quot;\assets\built\images\sc2\sc31.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;read로 입력, echo로 출력&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc32.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;변수 활용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc33.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;특별한 변수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc34.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;배열&lt;/li&gt;
  &lt;li&gt;조건문: if elif else if, case문&lt;/li&gt;
  &lt;li&gt;반목문: for, while, until&lt;/li&gt;
  &lt;li&gt;함수&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;sudo 명령어&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;다른 사용자 권한, 보통은 root 사용자 권한으로 프로그램을 실행할 수 있도록 하는 명령어이다&lt;/li&gt;
  &lt;li&gt;sudo 명령어를 사용하면 일반 사용자가 root 사용자 자격으로 프로그램을 실행할 수 있기 때문에 보안에 대한 고려가 반드시 필요&lt;/li&gt;
  &lt;li&gt;/etc/sudoers 파일: 어느 사용자/그룹에게 어떤 프로그램 실행에 대해서 sudo 사용을 허용할 것인지에 대한 룰을 설정&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="systemcloud" />
      

      
        <summary type="html">리눅스: 사용자 계정과 권한 체계, 쉘 기본</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">정보보안 기본 3원칙</title>
      <link href="https://lee989898.github.io/sc2-02" rel="alternate" type="text/html" title="정보보안 기본 3원칙" />
      <published>2022-03-17T01:06:00+09:00</published>
      <updated>2022-03-17T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc2-02</id>
      <content type="html" xml:base="https://lee989898.github.io/sc2-02">&lt;h2 id=&quot;정보보안-기본-3원칙&quot;&gt;&lt;strong&gt;정보보안 기본 3원칙&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;정보보안이란&quot;&gt;&lt;strong&gt;정보보안이란?&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;정보보안의 목적&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;정보시스템을 내, 외부에 존재하는 위협으로부터 안전하게 보호&lt;/li&gt;
  &lt;li&gt;정보가 생성되어 소멸되기까지 그 처리 및 유통의 생명 주기 전반(정보의 수집, 가공, 저장, 검색, 송신, 수신 등)에 정보의
훼손, 변조, 유출 등을 방지하기 위한 관리적, 기술적 수단을 강구&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;정보보안의 기본 3원칙&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;다음의 3가지 기본 원칙이 보장되어야 정보시스템을 내,외부에 존재하는 위협으로부터 안전하게 보호 가능&lt;/li&gt;
  &lt;li&gt;기밀성, 무결성, 가용성&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;정보보안의-기본-3원칙-기밀성confidentiality&quot;&gt;&lt;strong&gt;정보보안의 기본 3원칙: 기밀성(Confidentiality)&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;기밀성(Confidentiality)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;오직 인가된 사용자, 인가된 프로세스, 인가된 시스템만이 알 필요성에 근거하여 주어진 정보/시스템에 접근이 허용되어야 한다는 원칙&lt;/li&gt;
  &lt;li&gt;기밀성은 데이터 처리의 모든 접속점에서 필요한 수준의 비밀 엄수가 강제되도록 하고, 허가받지 않은 정보 유출을 방지하는 것을 보장&lt;/li&gt;
  &lt;li&gt;이러한 수준의 기밀성은 데이터가 네트워크 내의 시스템과 장비에 보관되어 있을 때나 데이터가 전송될 떄 그리고 데이터가 목적지에 도달한 이후에도 유지되어야 함&lt;/li&gt;
  &lt;li&gt;기밀성을 보장하기 위한 보안 기술에는 암호화, 접근 제어 등이 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;기밀성을 위협하는 공격&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;스누핑(Snooping)
    &lt;ul&gt;
      &lt;li&gt;사전적 의미는 “기웃거리다, 캐 묻다”&lt;/li&gt;
      &lt;li&gt;정보에 대한 비인가 접근 또는 정보의 도청(획득)을 의미&lt;/li&gt;
      &lt;li&gt;전송 중인 정보를 도청하여 공격자의 이익을 위해 사용하는 것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;트래픽 분석(Traffic Analysis)
    &lt;ul&gt;
      &lt;li&gt;전송 중인 정보(메시지)는 암호화를 통해 내용을 숨길 수 있다&lt;/li&gt;
      &lt;li&gt;공격자는 IP주소, 라우팅 경로 등을 통해 통신자의 위치와 실체, 정보 전송의 횟수와 길이 등을 통해 정보 내용을 추측할 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;__정보보안의-기본-3원칙-무결성integrity&quot;&gt;__정보보안의 기본 3원칙: 무결성(Integrity)&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;무결성(Integrity)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;인가 받지 않은 사용자에 의해 정보의 내용이 불법적으로 위변조되지 않도록 보호되어야 하는 성질
    &lt;ul&gt;
      &lt;li&gt;네트워크를 통하여 송수신되는 정보의 무결성 볼호&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;무결성 왜곡이 항상 악의적인 행동의 결과로 나타나는 것은 아니다. 전력 차단과 같은 시스템 중단이 정보에 예상치 못한 변형 가능&lt;/li&gt;
  &lt;li&gt;무결성을 보장하기 위한 보안 기술에는 접근 제어, 메시지 인증 등이 있으며, 정보가 이미 변경되었거나 변경 위험이 있을 때에는 이러한 변경을 탐지하여 복구할 수 있는 침입 탐지, 백업 등의 기술이 필요&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;무결성을 위협하는 공격&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;정보수정(Modification)
    &lt;ul&gt;
      &lt;li&gt;공격자는 정보를 가로챈 후, 자신에게 유리하도록 정보를 변경&lt;/li&gt;
      &lt;li&gt;고객이 은행으로 송긍 메시지를 전송할 때 공격자는 메시지를 가로채어 자신의 계좌로 입금되도록 변경&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;재전송
    &lt;ul&gt;
      &lt;li&gt;공격자는 정보(메시지)를 획득한 후, 나중에 그 메시지를 다시 사용&lt;/li&gt;
      &lt;li&gt;고객이 은행에게 자신의 계좌에서 공격자에게 지불하도록 요청하는 메시지를 전송하고, 은행을 이를 수행할 때,&lt;/li&gt;
      &lt;li&gt;공격자는 지불요청 메시지를 가로채어 보관한 후, 나중에 다시 지불요청 메시지를 은행으로 보내어 부당하게 입금을 재차 요구&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;__정보보안의-기본-3원칙-가용성availability&quot;&gt;__정보보안의 기본 3원칙: 가용성(Availability)&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;가용성(Availability)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;합법적인 사용자가 필요로 하는 시점에 정보나 시스템 서비스가 지체 없이 즉각적으로 제공될 수 있도록 하는 것&lt;/li&gt;
  &lt;li&gt;예. 인터넷 뱅킹 서비스 가용성
    &lt;ul&gt;
      &lt;li&gt;고객이 요청하는 시점에 정상적인 뱅킹 서비스가 이루어져야 함&lt;/li&gt;
      &lt;li&gt;가용성이 깨질 경우 고객의 금전적 피해 및 인터넷 뱅킹 사업의 손실 초래&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;가용성을 확보하기 위해서는 데이터의 백업, 중복성의 유지, 물리적 위협 요소로부터의 보호 등의 보안기술을 적용&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;가용성을 위협하는 공격&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;서비스 거부(Denial of Service: DoS)
    &lt;ul&gt;
      &lt;li&gt;시스템이나 네트워크가 정상적으로 사용되지 못하도록 방해&lt;/li&gt;
      &lt;li&gt;예) 공격자가 특정 목적지로 향하는 정보(메시지)를 막거나, 과다 전송으로 시스템이나 네트워크를 마비&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;랜섬웨어(Ransomeware)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;__정보보안의-기본-5원칙-인증성authenticity&quot;&gt;__정보보안의 기본 5원칙: 인증성(Authenticity)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;인증성(Authenticity) or 보증(Assurance)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;진짜라는 성질을 확인할 수 있고, 확인 및 신뢰할 수 있다는 것을 의미한다. 그리고 전송 메시지 출저 유효성에 대한 확신 보장&lt;/li&gt;
  &lt;li&gt;사용자가 정말 그 사용자인지와 시스템에 도착한 메시지가 정말로 신뢰할 수 있는 출저에서부터 온 것인지를 확인할 수 있는 것을 의미&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;정보보안의-기본-5원칙-인증성authenticity&quot;&gt;&lt;strong&gt;정보보안의 기본 5원칙: 인증성(Authenticity)&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;인증성(Authenticity) or 보증(Assurance)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;진짜라는 성질을 확인할 수 있고, 확인 및 신뢰할 수 있다는 것을 의믜한다. 그리고 전송 메시지 출처 유효성에 대한 확신 보장&lt;/li&gt;
  &lt;li&gt;사용자가 정말 그 사용자인지와 시스템에 도착한 메시지가 정말로 신뢰할 수 있는 출처에서부터 온 것인지를 확인할 수 있는 것을 의미&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;인증성을 위협하는 공격&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;신분위장
    &lt;ul&gt;
      &lt;li&gt;공격자는 다른 사람의 실체로 위장하여 정보를 획득&lt;/li&gt;
      &lt;li&gt;사용자가 은행에 접속하려고 할 떄, 공격자의 fake 은행 사이트에 접속하도록 유도해서, 사용자의 금융정보(계좌번호, 비밀번호 등)를 탈취&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;__정보보안의-기본-5원칙-책임성accountability&quot;&gt;__정보보안의 기본 5원칙: 책임성(Accountability)&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;책임성(Accountability)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;보안 목적에는 개체의 행동을 유일하게 추적해서 찾아낼 수 있어야 한다는 사항이 포함되어야 한다. 여기에는 부인 방지(메시지의 송수신이나 교환 후, 또는 통신이나 처리가 실행된 후에 그 사실을 사후에 증명함으로써 사실 부인을 방지하는 보안 기술), 억제, 결함분리, 침입탐지예방, 사후복구와 법적인 조치 등이 포함된다&lt;/li&gt;
  &lt;li&gt;진정으로 안전한 시스템을 만든다는 것은 불가능하기 때문에, 보안 침해에 대한 책임 소재를 추적할 수 있어야만 한다&lt;/li&gt;
  &lt;li&gt;시스템은 반드시 이들의 활동 상황을 기록하고, 나중에 포렌식 분석을 통해 보안 침해를 추적할 수 있거나 전송과 관련된 분쟁을 해결할 수 있도록 해야한다&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="systemcloud" />
      

      
        <summary type="html">정보보안 기본 3원칙</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">정보보호 동향</title>
      <link href="https://lee989898.github.io/sc2-01" rel="alternate" type="text/html" title="정보보호 동향" />
      <published>2022-03-09T01:06:00+09:00</published>
      <updated>2022-03-09T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc2-01</id>
      <content type="html" xml:base="https://lee989898.github.io/sc2-01">&lt;h2 id=&quot;정보보호-동향해킹과-보안&quot;&gt;&lt;strong&gt;정보보호 동향(해킹과 보안)&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;해킹과-보안의-역사&quot;&gt;&lt;strong&gt;해킹과 보안의 역사&lt;/strong&gt;&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;해킹이란&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;국어사전: 컴퓨터 시스템에 무단으로 침입/파괴/탈취 하는 행위&lt;br /&gt;
영영사전: 디자이너가 의도하지 않았던 방법으로 시스템의 특성이나 규칙을 이용한 창조적인 사용법을 찾는 것&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1950년대 이전&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;암호화 기계: 에니그마(Enigma)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1918년에 폴란드의 암호 보안 전문가들이 개발&lt;/li&gt;
  &lt;li&gt;평문 메시지를 암호화된 메시지로 변환하는 전기/기계 장치&lt;/li&gt;
  &lt;li&gt;처음에는 은행에서 통신 보안 강화를 위해 개발되었지만, 제2차 세계대전에서 독일군에 의해 군사통신 보안용으로 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;1960년대&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;전화망 침입을 통한 무료 전화 해킹&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1969년에 존 인그레이시아는 특정 주파수 대의 휘파람을 불면 장거리 전화를 무료로 쓸 수 있다는 사실을 알아냄&lt;/li&gt;
  &lt;li&gt;존 드레이퍼는 베트남 전쟁 참전 중에 군용 식량으로 지급되는 ‘캡앤크런치’라는 시리얼에 들어 있던 장난감 호루라기를 불면
2600Hz의 소리를 낼 수 있고, 이를 통해 무료 통화가 가능하다는 사실을 발견&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;1980년대&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;컴퓨터 해킹의 시작&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;미국 밀워키의 ‘414 Private’이라는 해커 그룹이 로스앨러모스국립 연구소와 암센터 등의 60개 컴퓨터 시스템에 침입하여 실수로 중요 파일을 지워 몇 년간의 연구 결과를 날림&lt;/li&gt;
  &lt;li&gt;이언 머피(Ian Murph)가 AT&amp;amp;T의 컴퓨터 시스템에 침입해 전화 요금과 관련된 시계를 바꾸어 낮은 가격의 심야 요금이 대낮에 적용 되도록 조작&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정보 권리 논쟁의 시작&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1981년에 독일의 전설적인 해커 그룹인 카오스 컴퓨터 클럽 결성&lt;/li&gt;
  &lt;li&gt;소식지 창간호에 다음과 같은 설립 목표를 규정함
    &lt;ul&gt;
      &lt;li&gt;정보 사회로 발전하려면 전세계와 자유로운 커뮤니케이션을 가능케하는 새로운 인권이 필요하다. 인간 사회 및 개인에게 기술적 영향을 미치는 정보 교류에게 국경이 사라져야 한다. 우리는 지식과 정보의 창조에 이바지할 것이다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GNU (GNU is Not Unix)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1983년 리처드 스톨망에 의해 GNU 계획 발표&lt;/li&gt;
  &lt;li&gt;GNU는 유닉스와 완벽하게 호환하는 소프트웨어 시스템으로 모든 사람이 무료로 사용하도록 작성&lt;/li&gt;
  &lt;li&gt;소프트웨어 저작권 개념에 처음부터 함정이 있으면 Copylef를 주장&lt;/li&gt;
  &lt;li&gt;GNU의 자유 소프트웨어에 대한 4가지 자유
    &lt;ul&gt;
      &lt;li&gt;자유 0: 어떠한 목적을 위해서건 프로그램을 실행할 수 있는 자유&lt;/li&gt;
      &lt;li&gt;자유 1: 프로그램의 작동 원리를 연구하고 이를 자신의 필요에 맞게 변경할 수 있는 자유&lt;/li&gt;
      &lt;li&gt;자유 2: 이웃을 돕기 위해 프로그램을 복제하고 배포할 수 있는 자유&lt;/li&gt;
      &lt;li&gt;자유 3: 프로그램을 향상하고 공동체 전체의 이익을 위해 다시 환원 할 수 있는 자유&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;해커의 등장&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;로버트 모리스의 웜 바이러스
    &lt;ul&gt;
      &lt;li&gt;미국 전역의 컴퓨터가 정체불명의 바이러스에 감염되어 사용자들이 인터넷 연결을 끊는 사건이 발생&lt;/li&gt;
      &lt;li&gt;미국 국방부는 카네기멜론대학에 컴퓨터 비상 대응팀 설립&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;구 소련 KGB요원에 매수된 서독 해커들이 전 세계 3백여 기관에 불법적인 접근을 시도하고 군사 기밀 정보를 탈취한다는 사실을 알게됨&lt;/li&gt;
  &lt;li&gt;1985, 미국 소년이 뉴저지의 국방부 컴퓨터에 침입, 통신위성 위치를 변경하는 코드를 비롯해 극비 군사 통신 데이터를 빼낸 사건 발생&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;1990년대&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;아메리카온라인 해킹&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1997년네 AOL 침입만을 목적으로 고안된 무료 해킹 툴인 AOHell이 공개&lt;/li&gt;
  &lt;li&gt;이후 며칠 동안 초보 해커들이 악용하여 미국 내 수백만 미국 온라인 사용자가 대용량 메일 폭탄 공격을 받음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;트로이 목마, 백 오리피스&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1998년에 cDc라는 해킹 그룹의 Sir Dystic이 트로이 목마 프로그램인 백 오리피스를 발표&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;데프콘 해킹 대회&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1990년애 최초의 해킹 대회인 데프콘이 라스베이거스에서 개최&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;2000년대&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;분산 서비스 거부 공격 (DDoS)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2000년 2월에 인터넷에서 소통량이 많은 몇 개 사이트에 분산 서비스 거부 공격이 가해짐&lt;/li&gt;
  &lt;li&gt;이로 인해 야후, CNN, 아마존 등의 사이트가 ICMP 패킷을 이용한 스머프 공격으로 몇 시간 동안 마비됨&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;웜과 바이러스&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2000년에 러브 버그 바이러스가 등장행 87억 5000만 달러의 경제적 손실 발생시킴&lt;/li&gt;
  &lt;li&gt;2003년 1월 25일 오후 2시 30분부터 약 2일 동안 마이크로소프트의 MS-SQL 2000 서버를 공격하는 슬래머 웜이 전국 네트워크를 마비시킴&lt;/li&gt;
  &lt;li&gt;2004년에 베이글 웜, 마이둠 웜, 넷스카이 웜이라는 웜 삼총사가 등장&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;개인 정보 유출과 도용&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2005년 10월부터 2006년 2월 사이에 한국에서 주민등록번호 수십만 개가 유출되어 인터넷 게임 사이트 가입에 사용되는 등 개인 정보 무단 도용 사건 발생&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;전자상거래 교란&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2006년 7월에 안심클릭의 허점을 이용한 해킹 사기 사건 발생&lt;/li&gt;
  &lt;li&gt;2006년 3월에 검색 클릭 수를 자동 증가시키는 방법으로, 국내 대형 포털 사이트의 정보 검색 순위를 조작한 인터넷 광고 대행업체의 대표 이 씨가 업무 방해 등의 혐의로 불구속 입건&lt;/li&gt;
  &lt;li&gt;2007년 2월 8일에 공인인증서 유출로 인한 시중 은행 불법 인출 사건 발생&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;2020년대&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2021년 보안 위협&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;국가 지원 해킹 조직의 활동&lt;/li&gt;
  &lt;li&gt;타깃형 랜섬웨어 공격과 피해 규모 증가&lt;/li&gt;
  &lt;li&gt;업그레이드된 문서형 악성코드 다수 유포&lt;/li&gt;
  &lt;li&gt;사회적 이슈를 활용한 사회공학적 공격 활동&lt;/li&gt;
  &lt;li&gt;금융 모바일 악성 앱의 지속적인 변화 시도&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;개인에서-국가로-사이버-전&quot;&gt;&lt;strong&gt;개인에서 국가로: 사이버 전&lt;/strong&gt;&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;사이버 보안: 유형&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;사이버 스파이
    &lt;ul&gt;
      &lt;li&gt;인터넷 등의 사이버 공간에서 특정 회사나 국가의 정보를 빼내서 그것을 필요로 하는 회사나 국가에 제공하는 활동&lt;/li&gt;
      &lt;li&gt;사이버 스파이의 첫 사례는 1985년 독일의 ‘데이터 여행자 사건’ 마르쿠스 헤스를 포함한 5명의 해커가 유럽우주기구ESA, 미국항공우주국, 버지니아 주 군수 산업체, 일본 쓰쿠바연구소 등에서 4년에 걸쳐 빼낸 산업-과학정보를 구소련의 KGB에 팔아넘긴 사건&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;‘Red October’ 라는 작전명을 가진 대규모 사이버 스파이는 각국 정부 및 외교기관, 연구 기관 등에 악성 프로그램을 유포하여 정보를 빼냄&lt;/li&gt;
  &lt;li&gt;1000여 명에 달하는 전문 직업 해커로 구성된 ‘중국  인민해방군 제3국 제2청 61398 해커 부대’는 2006년 무렵부터 최소 150건 이상의 기밀 정보 유출 공격을 감행&lt;/li&gt;
  &lt;li&gt;2009년 유엔(UN)에서는 만약 3차 세계대전이 시작된다면 사이버 전쟁이 될 것이라고 예측&lt;/li&gt;
  &lt;li&gt;대표적인 사이버 전쟁: 2007년 에스토니아 사이버 분쟁, 2008년 러시아와 조지아 간의 사이버 전쟁, 2010년 미국과 이란의 사이버 분쟁 등&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;\assets\built\images\sc2\sc1.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;
&lt;img src=&quot;\assets\built\images\sc2\sc2.png&quot; alt=&quot;시스템클라우드보안&quot; /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="systemcloud" />
      

      
        <summary type="html">정보보호 동향(해킹과 보안)</summary>
      

      
      
    </entry>
  
</feed>
