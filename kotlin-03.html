<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>클래스, 객체, 인터페이스</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />
    <!-- highlight.js -->

    <!-- custom.css -->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css" />

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- 웹 폰트 -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!-- syntax.css -->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="공부 블로그" />
    <link rel="shortcut icon" href="https://lee989898.github.io/assets/built/images/favicon.jpg" type="image/png" />
    <link rel="canonical" href="https://lee989898.github.io/kotlin-03" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

    


     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="LEE" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="클래스, 객체, 인터페이스" />
    <meta property="og:description" content="코틀린 테이블 코틀린 기초 함수 정의와 호출 클래스, 객체, 인터페이스 람다로 프로그래밍 코틀린 타입 시스템 연산자 오버로딩과 기타 관례 고차 함수: 파라미터와 반환 값으로 람다 사용 제네릭스 애노테이션과 리플렉션 DSL 만들기 클래스 계층 정의 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언 컴파일러가 생성한 메서드 : 데이터 클래스와 클래스 위임 object" />
    <meta property="og:url" content="https://lee989898.github.io/kotlin-03" />
    <meta property="og:image" content="https://lee989898.github.io/assets/built/images/kotlin-logo.png" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta property="article:author" content="https://www.facebook.com/" />
    <meta property="article:published_time" content="2021-08-05T01:07:00+09:00" />
    <meta property="article:modified_time" content="2021-08-05T01:07:00+09:00" />
    <meta property="article:tag" content="Kotlin" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="클래스, 객체, 인터페이스" />
    <meta name="twitter:description" content="코틀린 테이블 코틀린 기초 함수 정의와 호출 클래스, 객체, 인터페이스 람다로 프로그래밍 코틀린 타입 시스템 연산자 오버로딩과 기타 관례 고차 함수: 파라미터와 반환 값으로 람다 사용 제네릭스 애노테이션과 리플렉션 DSL 만들기 클래스 계층 정의 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언 컴파일러가 생성한 메서드 : 데이터 클래스와 클래스 위임 object" />
    <meta name="twitter:url" content="https://lee989898.github.io/" />
    <meta name="twitter:image" content="https://lee989898.github.io/assets/built/images/kotlin-logo.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="LEE" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="Kotlin" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="1400" />
    <meta property="og:image:height" content="933" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "LEE",
        "logo": "https://lee989898.github.io/"
    },
    "url": "https://lee989898.github.io/kotlin-03",
    "image": {
        "@type": "ImageObject",
        "url": "https://lee989898.github.io/assets/built/images/kotlin-logo.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://lee989898.github.io/kotlin-03"
    },
    "description": "코틀린 테이블 코틀린 기초 함수 정의와 호출 클래스, 객체, 인터페이스 람다로 프로그래밍 코틀린 타입 시스템 연산자 오버로딩과 기타 관례 고차 함수: 파라미터와 반환 값으로 람다 사용 제네릭스 애노테이션과 리플렉션 DSL 만들기 클래스 계층 정의 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언 컴파일러가 생성한 메서드 : 데이터 클래스와 클래스 위임 object"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="클래스, 객체, 인터페이스" href="/feed.xml" />


</head>
<body class="post-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://lee989898.github.io/">LEE</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-kotlin" role="menuitem"><a href="/tag/kotlin/">코틀린</a></li>
    <li class="nav-algorithm" role="menuitem"><a href="/tag/algorithm/">알고리즘</a></li>
    <li class="nav-pl" role="menuitem"><a href="/tag/pl/">프로그래밍언어</a></li>
    <li class="nav-android" role="menuitem"><a href="/tag/android/">안드로이드</a></li>
    <li class="nav-security" role="menuitem"><a href="/tag/security/">컴퓨터보안</a></li>
    <li class="nav-system" role="menuitem"><a href="/tag/system/">시스템프로그래밍</a></li>
    <li class="nav-systemcloud" role="menuitem"><a href="/tag/systemcloud/">시스템클라우드보안</a></li>
    <li class="nav-blockchain" role="menuitem"><a href="/tag/blockchain/">블록체인</a></li>
    <li class="nav-archive" role="menuitem">
        
        <a href="/archive.html">All Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag별 Posts</a>
    </li>


</ul>



        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  tag-kotlin post tag-kotlin ">

            <header class="post-full-header">
                <section class="post-full-meta">
                    <time class="post-full-meta-date" datetime=" 5 August 2021"> 5 August 2021</time>
                    
                        <span class="date-divider">/</span>
                        
                            
                               <a href='/tag/kotlin/'>KOTLIN</a>
                            
                        
                    
                </section>
                <h1 class="post-full-title">클래스, 객체, 인터페이스</h1>
            </header>

            <!--
            
            <figure class="post-full-image" style="background-image: url(/assets/built/images/kotlin-logo.png)">
            </figure>
            
            -->
            <section class="post-full-content">
                <div class="kg-card-markdown">
                    <p><span class="table-of-contents-list">코틀린 테이블</span></p>
<ul class="table-of-contents-list">
    <li><a href="./kotlin-01">코틀린 기초</a></li>
    <li><a href="./kotlin-02">함수 정의와 호출</a></li>
    <li><a href="./kotlin-03">클래스, 객체, 인터페이스</a></li>
    <li><a href="./kotlin-04">람다로 프로그래밍</a></li>
    <li><a href="./kotlin-05">코틀린 타입 시스템</a></li>
    <li><a href="./kotlin-06">연산자 오버로딩과 기타 관례</a></li>
    <li><a href="./kotlin-07">고차 함수: 파라미터와 반환 값으로 람다 사용</a></li>
    <li><a href="./kotlin-08">제네릭스</a></li>
    <li><a href="./kotlin-09">애노테이션과 리플렉션</a></li>
    <li><a href="./kotlin-10">DSL 만들기</a></li>
</ul>

<hr />

<ul>
  <li><a href="#클래스-계층-정의">클래스 계층 정의</a></li>
  <li><a href="#뻔하지-않은-생성자와-프로퍼티를-갖는-클래스-선언">뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언</a></li>
  <li><a href="#컴파일러가-생성한-메서드--데이터-클래스와-클래스-위임">컴파일러가 생성한 메서드 : 데이터 클래스와 클래스 위임</a></li>
  <li><a href="#object-키워드--클래스-선언과-인스턴스-생성">object 키워드 : 클래스 선언과 인스턴스 생성</a></li>
</ul>

<hr />

<h2 id="클래스-계층-정의">클래스 계층 정의</h2>

<blockquote>
  <blockquote>
    <p>코틀린 인터페이스</p>
  </blockquote>
</blockquote>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 간단한 인터페이스 선언하기</span>
<span class="kd">interface</span> <span class="nc">Clickable</span><span class="p">{</span>
    <span class="k">fun</span> <span class="nf">click</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>코틀린 인터페이스 안에는 추상 메소드뿐 아니라 구현이 있는 메소드도 정의할 수 있다<br />
그러나 인터페이스에는 아무런 상태도 들어갈 수 없다<br />
위 인터페이스를 구현하는 모든 비추상 클래스는 click에 대한 구현을 제공해야 한다<br />
다음은 인터페이스를 구현하는 방법이다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 단순한 인터페이스 구현하기</span>
<span class="kd">class</span> <span class="nc">Button</span> <span class="p">:</span> <span class="nc">Clickable</span><span class="p">{</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">click</span><span class="p">()</span> <span class="p">=</span> <span class="nf">println</span><span class="p">(</span><span class="s">"I was clicked"</span><span class="p">)</span>
<span class="p">}</span>

<span class="p">&gt;&gt;&gt;</span> <span class="nc">Button</span><span class="p">.</span><span class="nf">click</span><span class="p">()</span>
<span class="nc">I</span> <span class="n">was</span> <span class="n">clicked</span>
</code></pre></div></div>

<p>자바와 마찬가지로 클래스는 인터페이스를 원하는 만큼 개수 제한 없이 마음대로 구현할 수 있지만, 클래스는 오직 하나만 확장할 수 있다<br />
코틀린에서는 override 변경자를 꼭 사용해야 한다. overrid 변경자는 실수로 상위 클래스의 메소드를 오버라이드 하는 경우를 방지해준다<br />
인터페이스 메소드도 디폴트 구현을 제공할 수 있다. 그런 경우 메소드 앞에 default를 붙여야 하는 자바와 달리 코틀린에서는 메소드를 특별한 키워드로 꾸밀 필요가 없이 메소드 본문을 메소드 시그니처 뒤에 추가하면 된다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 인터페이스 안에 본문이 있는 메소드 정의하기</span>
<span class="kd">interface</span> <span class="nc">Clickable</span><span class="p">{</span>
    <span class="k">fun</span> <span class="nf">click</span><span class="p">()</span>
    <span class="k">fun</span> <span class="nf">showOff</span><span class="p">()</span> <span class="p">=</span> <span class="nf">println</span><span class="p">(</span><span class="s">"I'm clickable!"</span><span class="p">)</span> <span class="c1">// 디폴트 구현이 있는 메소드</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위 인터페이스를 구현하는 클래스는 showOff 메소드의 새로운 동작을 정의할 수도 있고, 그냥 정의를 생략해서 디폴트 구현을 사용할 수도 있다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 동일한 메소드를 구현하는 다른 인터페이스 정의</span>
<span class="kd">interface</span> <span class="nc">Focusable</span><span class="p">{</span>
    <span class="k">fun</span> <span class="nf">setFocus</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="nc">Boolean</span><span class="p">)</span> <span class="p">=</span> 
        <span class="nf">println</span><span class="p">(</span><span class="s">"I ${if (b) "</span><span class="n">got</span><span class="s">" else "</span><span class="n">lost</span><span class="s">"} focus."</span><span class="p">)</span>
    <span class="k">fun</span> <span class="nf">showOff</span><span class="p">()</span> <span class="p">=</span> <span class="nf">println</span><span class="p">(</span><span class="s">"I'm focusable!"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>한 클래스에서 모두 디폴트 구현이 들어있는 두 인터페이스를 함께 구현하면 어느쪽 showOff메소드도 선택되지 않는다<br />
코틀린 컴파일러는 두 메소드를 아우르는 구현을 하위 클래스에 직접 구현하게 강제한다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 상속한 인터페이스의 메소드 구현 호출하기</span>
<span class="kd">class</span> <span class="nc">Button</span> <span class="p">:</span> <span class="nc">Clickable</span><span class="p">,</span> <span class="nc">Focusable</span><span class="p">{</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">click</span><span class="p">()</span> <span class="p">=</span> <span class="nf">println</span><span class="p">(</span><span class="s">"I was clicked"</span><span class="p">)</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">showOff</span><span class="p">(){</span> <span class="c1">// 인터페이스를 구현하는 하위 클래스에서 명시적으로 새로운 구현을 제공해야 한다</span>
        <span class="k">super</span><span class="p">&lt;</span><span class="nc">Clickable</span><span class="p">&gt;.</span><span class="nf">showOff</span><span class="p">()</span>
        <span class="k">super</span><span class="p">&lt;</span><span class="nc">Focusable</span><span class="p">&gt;.</span><span class="nf">showOff</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="nc">Array</span><span class="p">&lt;</span><span class="nc">String</span><span class="p">&gt;){</span>
    <span class="kd">val</span> <span class="py">button</span> <span class="p">=</span> <span class="nc">Button</span><span class="p">()</span>
    <span class="n">button</span><span class="p">.</span><span class="nf">showOff</span><span class="p">()</span>
    <span class="n">button</span><span class="p">.</span><span class="nf">setFocus</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
    <span class="n">button</span><span class="p">.</span><span class="nf">click</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <blockquote>
    <p>open, final, abstract 변경자: 기본적으로 final</p>
  </blockquote>
</blockquote>

<p>기본적으로 상속이 가능하면 취약한 기반 클래스라는 문제가 발생한다<br />
이펙티브 자바를 쓴 조슈아 블로크는 상속을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 상속을 금지하라는 조언을 했다<br />
코틀린도 이러한 조언을 따른다. 코틀린의 클래스와 메소드는 기본적으로 final이다<br />
클래스의 상속을 허용하려면 클래스 앞에 open 변경자를 붙여야 한다<br />
오버라이드를 허용하고 싶은 메소드나 프로퍼티의 앞에도 open 변경자를 붙여야 한다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 열린 메소드를 포함하는 열린 클래스 정의하기</span>
<span class="k">open</span> <span class="kd">class</span> <span class="nc">RichButton</span> <span class="p">:</span> <span class="nc">Clickable</span> <span class="p">{</span> <span class="c1">// 이 클래스는 열려있다</span>
    <span class="k">fun</span> <span class="nf">disable</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// 이 함수는 파이널이다</span>
    <span class="k">open</span> <span class="k">fun</span> <span class="nf">animate</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// 이 함수는 열려있다</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">click</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// 이 함수는 열려있는 메소드를 오버라이드한다</span>
<span class="p">}</span>
</code></pre></div></div>

<p>기반 클래스나 인터페이스의 멤버를 오버라이드하는 경우 메소드는 기본적으로 열려있다<br />
오버라이드하는 메소드의 구현을 하위 클래스에서 오버라이드 하지 못하게 금지하려면 오버라이드 하는 메소드 앞에 final을 명시해야 한다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 오버라이드 금지하기</span>
<span class="k">open</span> <span class="kd">class</span> <span class="nc">RichButton</span> <span class="p">:</span> <span class="nc">Clickable</span><span class="p">{</span>
    <span class="k">final</span> <span class="k">override</span> <span class="k">fun</span> <span class="nf">click</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// 이 final은 쓸데 없이 붙은 중복이 아니다. final이 없는 override 메소드나 프로퍼티는 기본적으로 열려있다</span>
<span class="p">}</span>
</code></pre></div></div>

<p>클래스의 기본적인 상속 가능 사태를 final로 함으로써 얻을 수 있는 큰 이익은 다양한 경우에 스마트 캐스트가 가능하다는 점이다. 스마트 캐스트는 타입 검사 뒤에 변경될 수 없는 변수에만 적용 가능하다</p>

<p>코틀린에서도 클래스를 abstract로 선언할 수 있다. abstract로 선언한 추상 클래스는 인스턴스화 할 수 없다<br />
추상 멤버는 항상 열려있다. 따라서 추상 멤버 앞에 open 변경자를 명시할 필요가 없다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 추상 클래스 정의하기</span>
<span class="k">abstract</span> <span class="kd">class</span> <span class="nc">Animated</span><span class="p">{</span> 
    <span class="k">abstract</span> <span class="k">fun</span> <span class="nf">animate</span><span class="p">()</span> <span class="c1">// 추상 함수다. 구현이 없다. 하위 클래스에서 이 함수를 반드시 오버라이드 해야 한다</span>

    <span class="k">open</span> <span class="k">fun</span> <span class="nf">stopAnimation</span><span class="p">(){</span> <span class="c1">/// 추상 클래스에 속했더라도 비추상 함수는 기본적으로 파이널이지만 원한다면 open으로 오버라이드를 허용할 수 있다</span>

    <span class="p">}</span>

    <span class="k">fun</span> <span class="nf">animateTwice</span><span class="p">(){</span>

    <span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p>인터페이스 멤버의 경우 final, open, abstract를 사용하지 않는다. 인터페이스 멤버는 항상 열려 있으면 final로 변경할 수 없다. 인터페이스 멤버에게 본문이 없으면 자동으로 추상 멤버가 되지만, 따로 멤버 선언 앞에 abstract 키워드를 덧붙일 필요가 없다</p>

<p>final: 오버라이드 할 수 없음, 클래스 멤버의 기본 변경자다<br />
open: 오버라이드 할 수 있음, 반드시 open을 명시해야 오버라이드 할 수 있다<br />
abstract: 반드시 오버라이드해야 함, 추상 클래스의 멤버에만 이 변경자를 붙일 수 있다. 추상 멤버에는 구현이 있으면 안 된다<br />
override: 상위 클래스나 상위 인스턴스의 멤버를 오버라이드 하는 중, 오버라이드하는 멤버는 기본적으로 열려있다. 하위 클래스의 오버라이드를 금지하려면 final을 명시해야 한다</p>

<blockquote>
  <blockquote>
    <p>가시성 변경자: 기본적으로 공개</p>
  </blockquote>
</blockquote>

<p>가시성 변경자는 코드 기반에 있는 선언에 대한 클래스 외부 접근을 제어한다. 어떤 클래스의 구현에 대한 접근을 제한함으로써 그 클래스에 의존하는 외부 코드를 깨지 않고도 클래스 내부 구현을 변경할 수 있다</p>

<p>아무 변경자도 없는 경우 선언은 모두 공개 된다. 자바의 기본 가시성인 패키지 전용은 코틀린에 없다. 코틀린을 패키지를 네임스페이스를 관리하기 위한 용도로만 사용한다<br />
패키지 전용 가시성에 대한 대안으로 코틀린에는 intrenal이라는 새로운 가시성 변경자를 도입했다. internel은 모듈 내부에서만 볼 수 있음이라는 뜻이다. 모듈은 한 번에 한꺼번에 컴파일되는 코틀린 파일들을 의미한다<br />
코틀린은 최상위 선언에 대해 private 가시성을 허용한다</p>

<p>public: (클래스 멤버)모든 곳에서 볼 수 있다, (최상위 선언)모든 곳에서 볼 수 있다<br />
internal: (클래스 멤버)같은 모듈 안에서만 볼 수 있다, (최상위 선언) 같은 모듈 안에서만 볼 수 있다
protected: (클래스 멤버) 하위 클래스 안에서만 볼 수 있다, (최상위 선언) (최상위 선언에 적용할 수 없음)
private: (클래스 멤버) 같은 클래스 안에서만 볼 수 있다, (최상위 선언) 같은 파일 안에서만 볼 수 있다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">internal</span> <span class="k">open</span> <span class="kd">class</span> <span class="nc">TalkativeButton</span> <span class="p">:</span> <span class="nc">Focusable</span><span class="p">{</span>
    <span class="k">private</span> <span class="k">fun</span> <span class="nf">yell</span><span class="p">()</span> <span class="p">=</span> <span class="nf">println</span><span class="p">(</span><span class="s">"Hey!"</span><span class="p">)</span>
    <span class="k">protected</span> <span class="k">fun</span> <span class="nf">whisper</span><span class="p">()</span> <span class="p">=</span> <span class="nf">println</span><span class="p">(</span><span class="s">"Let's talk!"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nc">TalkativeButton</span><span class="p">.</span><span class="nf">giveSpeech</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 오류: public 멤버가 자신의 internal 수신타입인 TalkativeButton을 노출함</span>
    <span class="nf">yell</span><span class="p">()</span> <span class="c1">// 오류: yell에 접근할 수 없음</span>
    <span class="nf">whisper</span><span class="p">()</span> <span class="c1">// 오류: whisper에 접근할 수 없음</span>
<span class="p">}</span>
</code></pre></div></div>

<p>어떤 클래스의 기반 타입 목록에 들어있는 타입이나 제네릭 클래스의 타입 파라미터에 들어있는 타입의 가시성은 그 클래스 자신의 가시성과 같거나 더 높아야 하고, 메소드의 시그니처에 사용된 모든 타입의 가시성은 그 메소드의 가시성과 같거나 더 높아야 한다<br />
자바에서는 같은 패키지 안에서 protected멤버에 접근할 수 있지만, 코틀린에서는 그렇지 않다. protected 멤버는 오직 어떤 클래스나 그 클래스를 상속한 클래스 안에서만 보인다. 클래스를 확장한 함수는 그 클래스의 private이나 protected 멤버에 접근할 수 없다</p>

<p>코틀린에서는 외부 클래스가 내부 클래스나 중첩된 클래스의 private 멤버에 접근할 수 없다</p>

<blockquote>
  <blockquote>
    <p>내부 클래스와 중첩된 클래스: 기본적으로 중첩 클래스</p>
  </blockquote>
</blockquote>

<p>코틀린의 중첩 클래스는 명시적으로 요청하지 않는 한 바깥쪽 클래스 인스턴스에 대한 접근 권한이 없다는 점이다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 직렬화할 수 있는 상태가 있는 뷰 선언</span>
<span class="kd">interface</span> <span class="nc">State</span><span class="p">:</span> <span class="nc">Serializable</span>

<span class="kd">interface</span> <span class="nc">View</span><span class="p">{</span>
    <span class="k">fun</span> <span class="nf">getCurrentState</span><span class="p">():</span> <span class="nc">State</span>
    <span class="k">fun</span> <span class="nf">restoreState</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="nc">State</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 중첩 클래스를 사용해 코틀린에서 View 구현하기</span>
<span class="kd">class</span> <span class="nc">Button</span> <span class="p">:</span> <span class="nc">View</span><span class="p">{</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">getCurrentState</span><span class="p">():</span> <span class="nc">State</span> <span class="p">=</span> <span class="nc">ButtonState</span><span class="p">()</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="nf">restoreState</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="nc">State</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="kd">class</span> <span class="nc">ButtonState</span><span class="p">:</span> <span class="nc">State</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>코틀린 중첩 클래스에 아무런 변경자가 붙지 않으면 자바 static 중첩 클래스와 같다. 이를 내부 클래스로 변경해서 바깥쪽 클래스에 대한 참조를 포함하게 만들고 싶다면 inner 변경자를 붙여야 한다</p>

<p>중첩 클래스: class A<br />
내부 클래스: inner class a</p>

<p>코틀린에서 바깥쪽 클래스의 인스턴스를 가리키는 참조를 표기하는 방법은 내부 클래스 Inner 안에서 바깥쪽 클래스 Outer의 참조에 접근하려면  this@Outer 라고 써야 한다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Outer</span><span class="p">{</span>
    <span class="k">inner</span> <span class="n">classs</span> <span class="nc">Inner</span><span class="p">{</span>
        <span class="k">fun</span> <span class="nf">getOuterReference</span><span class="p">():</span> <span class="nc">Outer</span> <span class="p">=</span> <span class="k">this</span><span class="nd">@Outer</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <blockquote>
    <p>봉인된 클래스: 클래스 계층 정의 시 계층 확장 제한</p>
  </blockquote>
</blockquote>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 인터페이스 구현을 통해 식 표현하기</span>
<span class="kd">interface</span> <span class="nc">Expr</span>
<span class="kd">class</span> <span class="nc">Num</span><span class="p">(</span><span class="kd">val</span> <span class="py">value</span><span class="p">:</span> <span class="nc">Int</span><span class="p">)</span> <span class="p">:</span> <span class="nc">Expr</span>
<span class="kd">class</span> <span class="nc">Sum</span><span class="p">(</span><span class="kd">val</span> <span class="py">left</span><span class="p">:</span> <span class="nc">Expr</span><span class="p">,</span> <span class="kd">val</span> <span class="py">right</span><span class="p">:</span> <span class="nc">Expr</span><span class="p">)</span> <span class="p">:</span> <span class="nc">Expr</span>

<span class="k">fun</span> <span class="nf">eval</span> <span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="nc">Expr</span><span class="p">):</span> <span class="nc">Int</span> <span class="p">=</span> 
    <span class="k">when</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">is</span> <span class="nc">Num</span> <span class="p">-&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">value</span>
        <span class="k">is</span> <span class="nc">Sum</span> <span class="p">-&gt;</span> <span class="nf">eval</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="p">+</span> <span class="nf">eval</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">else</span> <span class="p">-&gt;</span> <span class="c1">// else 분기가 꼭 있어야 한다</span>
            <span class="k">throw</span> <span class="nc">IllegalArgumentException</span><span class="p">(</span><span class="s">"Unknown expression"</span><span class="p">)</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>항상 디폴트 분기를 추가하는 게 편하지 않다. 실수로 새로운 클래스 처리를 잊어버렸더라도 디폴트 분기가 선택되기 때문에 심각한 버그가 발생할 수 있다<br />
코틀린에서는 sealed 클래스로 이런 문제를 해결한다. 상위 클래스에 sealed 변경자를 붙이면 그 상위 클래스를 상속한 하위 클래스 정의를 제한할 수 있다<br />
sealed 클래스의 하위 클래스를 정의할 때는 반드시 상위 클래스 안에 중첩시켜야 한다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// sealed 클래스로 식 표현하기</span>
<span class="k">sealed</span> <span class="kd">class</span> <span class="nc">Expr</span><span class="p">{</span> <span class="c1">// 기반 클래스를 sealed로 봉인한다</span>
    <span class="kd">class</span> <span class="nc">Num</span><span class="p">(</span><span class="kd">val</span> <span class="py">value</span><span class="p">:</span> <span class="nc">Int</span><span class="p">)</span> <span class="p">:</span> <span class="nc">Expr</span><span class="p">()</span> <span class="c1">// 기반 클래스의 모든 하위 클래스를 중첩 클래스로 나열한다</span>
    <span class="kd">class</span> <span class="nc">Sum</span><span class="p">(</span><span class="kd">val</span> <span class="py">left</span><span class="p">:</span> <span class="nc">Expr</span><span class="p">,</span> <span class="kd">val</span> <span class="py">right</span><span class="p">:</span> <span class="nc">Expr</span><span class="p">)</span> <span class="p">:</span> <span class="nc">Expr</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">eval</span><span class="p">(</span><span class="n">e</span> <span class="p">:</span> <span class="nc">Expr</span><span class="p">):</span> <span class="nc">Int</span> <span class="p">=</span>
    <span class="k">when</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// when 식이 모든 하위 클래스를 검사하므로 별도의 else 분기가 없어도 된다</span>
        <span class="k">is</span> <span class="nc">Expr</span><span class="p">.</span><span class="nc">Num</span> <span class="p">-&gt;</span> <span class="n">e</span><span class="p">.</span><span class="n">value</span>
        <span class="k">is</span> <span class="nc">Expr</span><span class="p">.</span><span class="nc">Sum</span> <span class="p">-&gt;</span> <span class="nf">eval</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="p">+</span> <span class="nf">eval</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>sealed로 표시된 클래스는 자동으로 open이다. 나중에 sealed 클래스의 상속 계층에 새로운 하위 클래스를 추가해도 when식이 컴파일 되지 않는다. 따라서 when식을 고쳐야 한다는 사실을 쉽게 알 수 있다</p>

<hr />

<h2 id="뻔하지-않은-생성자와-프로퍼티를-갖는-클래스-선언">뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언</h2>

<p>코틀린에서는 주생성자와 부생성자를 구분한다. 또한 초기화 블록을 통해 초기화 로직을 추가할 수 있다</p>

<blockquote>
  <blockquote>
    <p>클래스 초기화: 주 생성자와 초기화 블록</p>
  </blockquote>
</blockquote>

<p>클래스 이름 뒤에 오는 괄호로 둘러싸인 코드를 주 생성자라고 부른다. 주 생성자는 생성자 파라미터를 지정하고 그 생성자 파라미터에 의해 초기화되는 프로퍼티를 정의하는 두 가지 목적에 쓰인다<br />
class User(val nickname: String) 선언을 같은 목적을 달성할 수 있는 가장 명시적인 선언으로 풀어서 보자</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">User</span> <span class="k">constructor</span><span class="p">(</span><span class="n">_nickname</span><span class="p">:</span> <span class="nc">String</span><span class="p">){</span>
    <span class="kd">val</span> <span class="py">nickname</span><span class="p">:</span> <span class="nc">String</span>
    <span class="nf">init</span> <span class="p">{</span>
        <span class="n">nickname</span> <span class="p">=</span> <span class="n">_nickname</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>constructor 키워드는 주 생성자나 부 생성자 정의를 시작할 때 사용한다<br />
init 키워드는 초기화 블록을 시작한다. 초기화 블록에는 클래스의 객체가 만들어질 때 실행될 초기화 코드가 들어간다</p>

<p>class User(val nickname: String) // val은 이 파라미터에 사응하는 프로퍼티가 생성된다는 뜻이다<br />
함수 파라미터와 마찬가지로 생성자 파라미터에도 디폴트 값을 정의할 수 있다<br />
class User(val nickname: String, val isSubscribed: Boolean = true)</p>

<p>클래스의 인스턴스를 만들려면 new 키워드 없이 생성자를 직접 호출하면 된다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&gt;&gt;&gt;</span> <span class="kd">val</span> <span class="py">hyun</span> <span class="p">=</span> <span class="nc">User</span><span class="p">(</span><span class="s">"현석"</span><span class="p">)</span>
<span class="p">&gt;&gt;&gt;</span> <span class="nf">println</span><span class="p">(</span><span class="n">hyun</span><span class="p">.</span><span class="n">isSubscribed</span><span class="p">)</span>
<span class="k">true</span>
<span class="p">&gt;&gt;&gt;</span> <span class="kd">val</span> <span class="py">gye</span> <span class="p">=</span> <span class="nc">User</span><span class="p">(</span><span class="s">"계영"</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span> <span class="c1">// 모든 인자를 파라미터 선언 순서대로 지정할 수도 있다</span>
<span class="p">&gt;&gt;&gt;</span> <span class="nf">println</span><span class="p">(</span><span class="n">gye</span><span class="p">.</span><span class="n">isSubscribed</span><span class="p">)</span>
<span class="k">false</span>
<span class="p">&gt;&gt;&gt;</span> <span class="kd">val</span> <span class="py">hey</span> <span class="p">=</span> <span class="nc">User</span><span class="p">(</span><span class="s">"혜원"</span><span class="p">,</span> <span class="n">isSubscirbed</span> <span class="p">=</span> <span class="k">false</span><span class="p">)</span> <span class="c1">// 생성자 인자 중 일부에 대해 이름을 지정할 수도 있다</span>
<span class="p">&gt;&gt;&gt;</span> <span class="nf">println</span><span class="p">(</span><span class="n">hey</span><span class="p">.</span><span class="n">isSubscribed</span><span class="p">)</span>
<span class="k">false</span>
</code></pre></div></div>

<p>클래스에 기반 클래스가 있다면 주 생성자에서 기반 클래스의 생성자를 호출해야 할 필요가 있다. 기반 클래스를 초기화하려면 기반 클래스 이름 뒤에 괄호를 치고 생성자 인자를 넘긴다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">open</span> <span class="kd">class</span> <span class="nc">User</span><span class="p">(</span><span class="kd">val</span> <span class="py">nickname</span><span class="p">:</span> <span class="nc">String</span><span class="p">)</span> <span class="p">{}</span>
<span class="kd">class</span> <span class="nc">TwitterUSer</span><span class="p">(</span><span class="n">nickname</span><span class="p">:</span> <span class="nc">String</span><span class="p">)</span> <span class="p">:</span> <span class="nc">User</span><span class="p">(</span><span class="n">nickname</span><span class="p">)</span>
</code></pre></div></div>

<p>클래스를 정의할 때 별도로 성성자를 정의하지 않으면 컴파일러가 자동으로 아무 일도 하지 않는 인자가 없는 디폴트 생성자를 만들어준다<br />
open class Button // 인자가 없는 디폴트 생성자가 만들어진다<br />
Button의 생성자는 아무 인자도 받지 않지만, Button 클래스를 상속한 하위 클래스는 반드시 Button 클래스의 생성자를 호출해야 한다<br />
class RadioButton: Button()<br />
이 규칙으로 인해 기반 클래스의 이름 뒤에는 꼭 빈 괄호가 들어간다. 반면 인터페이스는 생성자가 없기 때문에 어떤 클래스가 인터페이스를 구현하는 경우 그 클래스의 상위 클래스 목록에 있는 인터페이스 이름뒤에는 아무 괄호도 없다</p>

<p>class Secretive private construtor(){ } // 이 클래스의 유일한 주 생성자는 비공개이다<br />
Secretive 클래스 안에는 주 생성자밖에 없고 그 주 생성자는 비공개이므로 외부에서는 Secretive를 인스턴스화할 수 없다</p>

<blockquote>
  <blockquote>
    <p>부 생성자: 상위 클래스를 다른 방식으로 초기화</p>
  </blockquote>
</blockquote>

<p>부 생성자는 constructor 키워드로 시작한다. 필요에 따라 얼마든지 부 생성자를 많이 선언해도 된다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">open</span> <span class="kd">class</span> <span class="nc">View</span><span class="p">{</span>
    <span class="k">constructor</span><span class="p">(</span><span class="n">ctx</span><span class="p">:</span> <span class="nc">Context</span><span class="p">){</span>

    <span class="p">}</span>
    <span class="k">constructor</span><span class="p">(</span><span class="n">ctx</span><span class="p">:</span> <span class="nc">Context</span><span class="p">,</span> <span class="n">attr</span><span class="p">:</span> <span class="nc">AttributeSet</span><span class="p">){</span>

    <span class="p">}</span>

<span class="p">}</span>

<span class="kd">class</span> <span class="nc">MyButton</span> <span class="p">:</span> <span class="nc">View</span><span class="p">{</span>
    <span class="k">constructor</span><span class="p">(</span><span class="n">ctx</span><span class="p">:</span> <span class="nc">Context</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">super</span><span class="p">(</span><span class="n">ctx</span><span class="p">){</span>

    <span class="p">}</span>
    <span class="k">constructor</span><span class="p">(</span><span class="n">ctx</span><span class="p">:</span> <span class="nc">Contexgt</span><span class="p">,</span> <span class="n">attr</span><span class="p">:</span> <span class="nc">AttributeSet</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">super</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">attr</span><span class="p">){</span>

        <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위에서 두 부 생성자는 super() 키워드를 통해 자신에 대응하는 상위 클래스 생성자를 호출한다. this()를 통해 클래스 자신의 다른 생성자를 호출할 수 도 있다</p>

<p>클래스에 주 생성자가 없다면 모든 부 생성자는 반드시 상위 클래스를 초기화하거나 다른 생성자에게 생성을 위임해야 한다</p>

<blockquote>
  <blockquote>
    <p>인터페이스에 선언된 프로퍼티 구현</p>
  </blockquote>
</blockquote>

<p>코틀린에서는 인터페이스에 추상 프로퍼티 선언을 넣을 수 있다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">User</span><span class="p">{</span>
    <span class="kd">val</span> <span class="py">nickname</span><span class="p">:</span> <span class="nc">String</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이는 User 인터페이스를 구현하는 클래스가 nickname의 값을 얻을 수 있는 방법을 제공해야 한다는 뜻이다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 인터페이스의 프로퍼티 구현하기  </span>
<span class="kd">class</span> <span class="nc">PrivateUser</span><span class="p">(</span><span class="k">override</span> <span class="kd">val</span> <span class="py">nickname</span><span class="p">:</span> <span class="nc">String</span><span class="p">)</span> <span class="p">:</span> <span class="nc">User</span> <span class="c1">// 주 생성자에 있는 프로퍼티</span>

<span class="kd">class</span> <span class="nc">SubscribingUser</span><span class="p">(</span><span class="kd">val</span> <span class="py">email</span><span class="p">:</span> <span class="nc">String</span><span class="p">)</span> <span class="p">:</span> <span class="nc">User</span> <span class="p">{</span> 
    <span class="k">override</span> <span class="kd">val</span> <span class="py">nickname</span><span class="p">:</span> <span class="nc">Stirng</span>
        <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="n">email</span><span class="p">.</span><span class="nf">substringBefore</span><span class="p">(</span><span class="err">'</span> <span class="err">@</span> <span class="err">'</span><span class="p">)</span> <span class="c1">// 커스텀 게터</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">FacebookUser</span><span class="p">(</span><span class="kd">val</span> <span class="py">accountId</span><span class="p">:</span> <span class="nc">Int</span><span class="p">)</span> <span class="p">:</span> <span class="nc">User</span> <span class="p">{</span>
    <span class="k">override</span> <span class="kd">val</span> <span class="py">nickname</span> <span class="p">=</span> <span class="nf">getFacebookName</span><span class="p">(</span><span class="n">accountId</span><span class="p">)</span> <span class="c1">// 프로퍼티 초기화 식</span>
<span class="p">}</span>

<span class="p">&gt;&gt;&gt;</span> <span class="nf">println</span><span class="p">(</span><span class="nc">PrivateUer</span><span class="p">(</span><span class="s">"test@Kotlinlang.org"</span><span class="p">).</span><span class="n">nickname</span><span class="p">)</span>
<span class="nd">test@</span><span class="nc">Kotlinlang</span><span class="p">.</span><span class="n">org</span>
<span class="p">&gt;&gt;&gt;</span> <span class="nf">println</span><span class="p">(</span><span class="nc">SubscribingUser</span><span class="p">(</span><span class="s">"test@Kotlinlang.org"</span><span class="p">).</span><span class="n">nickname</span><span class="p">)</span>
<span class="n">test</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">User</span><span class="p">{</span>
    <span class="kd">val</span> <span class="py">email</span><span class="p">:</span> <span class="nc">String</span>
    <span class="kd">val</span> <span class="py">nickname</span><span class="p">:</span> <span class="nc">String</span>
        <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="n">email</span><span class="p">.</span><span class="nf">substringBefore</span><span class="p">(</span><span class="err">'</span> <span class="err">@</span> <span class="err">'</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>하위 클래스는 추상 프로퍼티인 email을 반드시 오버라이드 해야 한다. 반면 nickname은 오바라이드하지 않고 상속할 수 있다</p>

<blockquote>
  <blockquote>
    <p>게터와 세터에서 뒷받침하는 필드에 접근</p>
  </blockquote>
</blockquote>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 세터에서 뒷받침하는 필드 접근하기</span>
<span class="kd">class</span> <span class="nc">User</span><span class="p">(</span><span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="nc">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="py">address</span><span class="p">:</span> <span class="nc">String</span> <span class="p">=</span> <span class="s">"unspecified"</span>
      <span class="k">set</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nc">String</span><span class="p">){</span>
          <span class="nf">println</span><span class="p">(</span><span class="s">"""
              Address was changed for $name: 
              $field" -&gt; "$value"."""</span><span class="p">.</span><span class="nf">trimIndent</span><span class="p">())</span> <span class="c1">// 뒷받침하는 필드 값 읽기</span>
        <span class="n">field</span> <span class="p">=</span> <span class="n">value</span> <span class="c1">// 뒷받침하는 필드 값 변경하기</span>
      <span class="p">}</span>
<span class="p">}</span>

<span class="p">&gt;&gt;&gt;</span> <span class="kd">val</span> <span class="py">user</span> <span class="p">=</span> <span class="nc">User</span><span class="p">(</span><span class="s">"Alice"</span><span class="p">)</span>
<span class="p">&gt;&gt;&gt;</span> <span class="n">user</span><span class="p">.</span><span class="n">address</span> <span class="p">=</span> <span class="s">"Elsenheimerstrasse 47, 80687 Muenchen"</span>
<span class="nc">Address</span> <span class="n">was</span> <span class="n">changed</span> <span class="k">for</span> <span class="nc">Alice</span><span class="p">:</span>
<span class="s">"unspecified"</span> <span class="p">-&gt;</span> <span class="s">"Elsenheimerstrasse 47, 80687 Muenchen"</span>
</code></pre></div></div>

<p>코틀린에서 프로퍼티의 값을 바꿀때는 user.address = “new value” 처럼 필드 설정 구문을 사용한다. 이 구문은 내부적으로는 address의 세터를 호출한다</p>

<blockquote>
  <blockquote>
    <p>접근자의 가시성 변경</p>
  </blockquote>
</blockquote>

<p>접근자의 가시성은 기본적으로는 프로퍼티의 가시성과 같다. 하지만 원한다면 get이나 set앞에 가시성 변경자를 추가해서 접근자의 가시성을 변경할 수 있다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 비공개 세터가 있는 프로퍼티 선언하기</span>
<span class="kd">class</span> <span class="nc">LengthCounter</span><span class="p">{</span>
    <span class="kd">var</span> <span class="py">counter</span><span class="p">:</span> <span class="nc">Int</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="k">private</span> <span class="k">set</span> <span class="c1">// 이 클래스 밖에서 이 프로퍼티의 값을 바꿀 수 없다</span>
    
    <span class="k">fun</span> <span class="nf">addWord</span><span class="p">(</span><span class="n">word</span><span class="p">:</span> <span class="nc">String</span><span class="p">){</span>
        <span class="n">counter</span> <span class="p">+=</span> <span class="n">word</span><span class="p">.</span><span class="n">length</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">&gt;&gt;&gt;</span> <span class="kd">val</span> <span class="py">lengthCounter</span> <span class="p">=</span> <span class="nc">LengthCounter</span><span class="p">()</span>
<span class="p">&gt;&gt;&gt;</span> <span class="n">lengthCounter</span><span class="p">.</span><span class="nf">addWord</span><span class="p">(</span><span class="s">"Hi!"</span><span class="p">)</span>
<span class="p">&gt;&gt;&gt;</span> <span class="nf">println</span><span class="p">(</span><span class="n">lengthCounter</span><span class="p">.</span><span class="n">counter</span><span class="p">)</span>
<span class="mi">3</span>
</code></pre></div></div>

<hr />

<h2 id="컴파일러가-생성한-메서드--데이터-클래스와-클래스-위임">컴파일러가 생성한 메서드 : 데이터 클래스와 클래스 위임</h2>

<blockquote>
  <blockquote>
    <p>모든 클래스가 정의해야 하는 메소드</p>
  </blockquote>
</blockquote>

<p>코틀린 클래스도 toString, equals, hashCode 등을 오버라이드 할 수 있다. 코틀린은 이런 메소드 구현을 자동으로 생성해줄 수 있다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Client 클래스의 초기 정의</span>
<span class="kd">class</span> <span class="nc">Client</span><span class="p">(</span><span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span> <span class="kd">val</span> <span class="py">postalCode</span><span class="p">:</span> <span class="nc">Int</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p>문자열 표현 : toString()</p>
</blockquote>

<p>기본 구현을 바꾸려면 toString 메소드를 오버라이드 해야 한다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Client에 toString() 구현하기</span>
<span class="kd">class</span> <span class="nc">Client</span><span class="p">(</span><span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span> <span class="kd">val</span> <span class="py">postalCode</span><span class="p">:</span> <span class="nc">Int</span><span class="p">){</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">toString</span><span class="p">()</span> <span class="p">=</span> <span class="s">"Client(name=$name, postalCode=$postalCode)"</span>
<span class="p">}</span>

<span class="p">&gt;&gt;&gt;</span> <span class="kd">val</span> <span class="py">client1</span> <span class="p">=</span> <span class="nc">Client</span><span class="p">(</span><span class="s">"오현석"</span><span class="p">,</span> <span class="mi">4122</span><span class="p">)</span>
<span class="p">&gt;&gt;&gt;</span> <span class="nf">println</span><span class="p">(</span><span class="n">client1</span><span class="p">)</span>
<span class="nc">Client</span><span class="p">(</span><span class="n">name</span><span class="p">=</span><span class="err">오현석</span><span class="p">,</span> <span class="n">postalCode</span><span class="p">=</span><span class="mi">4122</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <p>객체의 동등성 : equals()</p>
</blockquote>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&gt;&gt;&gt;</span> <span class="kd">val</span> <span class="py">client1</span> <span class="p">=</span> <span class="nc">Client</span><span class="p">(</span><span class="s">"오현석"</span><span class="p">,</span> <span class="mi">4122</span><span class="p">)</span>
<span class="p">&gt;&gt;&gt;</span> <span class="kd">val</span> <span class="py">client2</span> <span class="p">=</span> <span class="nc">Client</span><span class="p">(</span><span class="s">"오현석"</span><span class="p">,</span> <span class="mi">4122</span><span class="p">)</span>
<span class="p">&gt;&gt;&gt;</span> <span class="nf">println</span><span class="p">(</span><span class="n">client1</span> <span class="p">==</span> <span class="n">client2</span><span class="p">)</span>
<span class="k">false</span> <span class="c1">// 코틀린에서 == 연산자는 참조 동일성을 검사하지 않고 객체의 동등성을 검사한다. 따라서 == 연산은 equals를 호출하는 식으로 컴파일된다</span>
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Client에 equals() 구현하기</span>
<span class="n">classs</span> <span class="nc">Clinet</span><span class="p">(</span><span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span> <span class="kd">val</span> <span class="py">postalCode</span><span class="p">:</span> <span class="nc">Int</span><span class="p">){</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">equals</span><span class="p">(</span><span class="n">other</span><span class="p">:</span> <span class="nc">Any</span><span class="p">?):</span> <span class="nc">Boolean</span><span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">other</span> <span class="p">==</span> <span class="k">null</span> <span class="p">||</span> <span class="n">other</span> <span class="p">!</span><span class="k">is</span> <span class="nc">Clinet</span><span class="p">)</span>
            <span class="k">return</span> <span class="k">false</span>
        <span class="k">return</span> <span class="n">name</span> <span class="p">==</span> <span class="n">other</span><span class="p">.</span><span class="n">name</span> <span class="p">&amp;&amp;</span> <span class="n">postalCode</span> <span class="p">==</span> <span class="n">other</span><span class="p">.</span><span class="n">postalCode</span>
    <span class="p">}</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">toString</span><span class="p">()</span> <span class="p">=</span> <span class="s">"Client(name=$name, postalCode=$postalCode)"</span>
<span class="p">}</span>
</code></pre></div></div>

<p>클래스 Cllinet로 더 복잡한 작업을 수행해보면 제대로 작동하지 않는 경우가 있다. 이유는 hashCode가 없다는 점이다</p>

<blockquote>
  <p>해시 컨테이너: hashCode()</p>
</blockquote>

<p>원소가 오현석이라는 고객 하나뿐인 집합을 만들자. 그 후 새로 원래의 오현석과 똑같은 프로퍼티를 포함하는 새로운 Client 인스턴스를 만들어서 그 인스턴스가 집합안에 들어있는지 검사해보자</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&gt;&gt;&gt;</span> <span class="kd">val</span> <span class="py">processed</span> <span class="p">=</span> <span class="nf">hashSetOf</span><span class="p">(</span><span class="nc">Clinet</span><span class="p">(</span><span class="s">"오현석"</span><span class="p">,</span> <span class="mi">4122</span><span class="p">))</span>
<span class="p">&gt;&gt;&gt;</span> <span class="nf">println</span><span class="p">(</span><span class="n">processed</span><span class="p">.</span><span class="nf">contains</span><span class="p">(</span><span class="nc">Client</span><span class="p">(</span><span class="s">"오현석"</span><span class="p">,</span> <span class="mi">4122</span><span class="p">)))</span>
<span class="k">false</span>
</code></pre></div></div>

<p>위 같은 결과는 Client 클래스가 hashCode 메소드를 정의하지 않았기 떄문이다. hashCode가 지켜야 하는 equals()가 true를 반환하는 두 객체는 반드시 같은 hashCode()를 반환해야 한다라는 제약이 있는데 Client는 이를 어기고 있다<br />
HashSet은 원소를 비교할 때 비용을 줄이기 위해 먼저 객체의 해시 코드를 비교하고 해시 코드가 같은 경우에만 실제 값을 비교한다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Client에 hashCode 구현하기</span>
<span class="kd">class</span> <span class="nc">Client</span><span class="p">(</span><span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span> <span class="kd">val</span> <span class="py">postalCode</span><span class="p">:</span> <span class="nc">Int</span><span class="p">){</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="nf">hashCode</span><span class="p">():</span> <span class="nc">Int</span> <span class="p">=</span> <span class="n">name</span><span class="p">.</span><span class="nf">hashCode</span><span class="p">()</span> <span class="p">*</span> <span class="mi">31</span> <span class="p">+</span> <span class="n">postalCode</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <blockquote>
    <p>데이터 클래스 : 모든 클래스가 정의해야 하는 메소드 자동 생성</p>
  </blockquote>
</blockquote>

<p>data라는 변경자를 클래스 앞에 붙이면 필요한 메소드를 컴파일러가 자동으로 만들어준다. data 변경자가 붙은 클래스를 데이터 클래스라고 부른다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Client를 데이터 클래스로 선언하기</span>
<span class="kd">data class</span> <span class="nc">Client</span><span class="p">(</span><span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span> <span class="kd">val</span> <span class="py">postalCode</span><span class="p">:</span> <span class="nc">Int</span><span class="p">)</span>
</code></pre></div></div>

<p>이제 Client 클래스는 자바에서 요구하는 모든 메소드를 포함한다</p>

<ol>
  <li>인스턴스 간 비교를 위한 equals</li>
  <li>HashMap과 같은 해시 기반 컨테이너에서 키로 사용할 수 있는 hashCode</li>
  <li>클래스의 각 필드를 선언 순서대로 표시하는 문자열 표현을 만들어주는 toString</li>
</ol>

<p>equals와 hashCode는 주 생성자에 나열된 모든 프로퍼티를 고려해 만들어진다<br />
이때 주 생성자 밖에 정의된 프로퍼티는 equals나 hashCode를 계산할 때 고려의 대상이 아니라는 사실에 유의하라<br />
코틀린 컴파일러는 몇 가지 유용한 메소드를 더 생성해준다</p>

<blockquote>
  <p>데이터 클래스와 불변성 : copy() 메소드</p>
</blockquote>

<p>데이터 클래스의 프로퍼티가 꼭 val일 필요는 없다/ 그러나 HashMap 등의 컨테니어에 데이터 클래스를 담는 경우엔 불변성이 필수적이다. 게다가 불변 객체를 사용하면 프로그램에 대해 훨씬 쉽게 추론할 수 있다</p>

<p>객체를 복사하면서 일부 프로퍼티를 바굴 수 있게 해주는 copy메소드로 데이터 클래스 인스턴스를 불변 객체로 더 쉽게 활용할 수 있다<br />
객체를 메모리상에서 직접 바꾸는 대신 복사본을 만드는 편이 더 낫다. 복사본은 원본과 다른 생명주기를 가지며, 복사를 하면서 일부 프로퍼티 값을 바꾸거나 복사본을 제거해도 프로그램에서 원본을 참조하는 다른 부분에 전혀 영향을 끼치지 않는다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&gt;&gt;&gt;</span> <span class="kd">val</span> <span class="py">lee</span> <span class="p">=</span> <span class="nc">Client</span><span class="p">(</span><span class="s">"이계영"</span><span class="p">,</span> <span class="mi">4122</span><span class="p">)</span>
<span class="p">&gt;&gt;&gt;</span> <span class="nf">println</span><span class="p">(</span><span class="n">lee</span><span class="p">.</span><span class="nf">copy</span><span class="p">(</span><span class="n">postalCode</span> <span class="p">=</span> <span class="mi">4000</span><span class="p">))</span>
<span class="nc">Client</span><span class="p">(</span><span class="n">name</span> <span class="p">=</span> <span class="err">이계영</span><span class="p">,</span> <span class="n">postalCode</span> <span class="p">=</span> <span class="mi">4000</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <blockquote>
    <p>클래스 위임 : by 키워드 사용</p>
  </blockquote>
</blockquote>

<p>종종 상속을 허용하지 않는 클래스에 새로운 동작을 추가해야 할 때가 잇따. 이럴 때 사용하는 일반적인 방법이 데코레이터 패턴이다<br />
이 패턴의 핵심은 상속을 허용하지 않는 클래스 대신 사용할 수 있는 새로운 클래스를 만들되 기존 클래스와 같은 인터페이스를 데코레이터가 제공하게 만들고, 기존 클래스를 데코레이터 내부에 필드로 유지하는 것이다<br />
이때 새로 정의해야 하는 기능은 데코레이터의 메소드에 새로 정의하고 기존 기능이 그대로 필요한 부분은 데코레이터의 메소드가 기존 클래스의 메소드에게 요청을 전달한다<br />
이런 접근 방법의 단점은 준비 코드가 상당히 많이 필요하다는 점이다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">DelegatingCollection</span><span class="p">&lt;</span><span class="nc">T</span><span class="p">&gt;(</span>
    <span class="n">innerList</span><span class="p">:</span> <span class="nc">Collection</span><span class="p">&lt;</span><span class="nc">T</span><span class="p">&gt;</span> <span class="p">=</span> <span class="nc">ArrayList</span><span class="p">&lt;</span><span class="nc">T</span><span class="p">&gt;()</span>
<span class="p">)</span> <span class="p">:</span> <span class="nc">Collection</span><span class="p">&lt;</span><span class="nc">T</span><span class="p">&gt;</span> <span class="k">by</span> <span class="nf">innerList</span><span class="p">{}</span> 
</code></pre></div></div>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 클래스 위임 사용하기</span>
<span class="kd">class</span> <span class="nc">CountingSet</span><span class="p">&lt;</span><span class="nc">T</span><span class="p">&gt;(</span>
    <span class="kd">val</span> <span class="py">innerSet</span><span class="p">:</span> <span class="nc">MutableCollection</span><span class="p">&lt;</span><span class="nc">T</span><span class="p">&gt;</span> <span class="p">=</span> <span class="nc">HashSet</span><span class="p">&lt;</span><span class="nc">T</span><span class="p">&gt;()</span>
<span class="p">)</span> <span class="p">:</span> <span class="nc">MutableCollection</span><span class="p">&lt;</span><span class="nc">T</span><span class="p">&gt;</span> <span class="k">by</span> <span class="nf">innerSet</span> <span class="p">{</span> <span class="c1">// MutableCollectiom의 구현을 innerSet에게 위임한다</span>
    <span class="kd">var</span> <span class="py">objectsAdded</span> <span class="p">=</span> <span class="mi">0</span>
    
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">add</span><span class="p">(</span><span class="n">element</span><span class="p">:</span> <span class="nc">T</span><span class="p">):</span> <span class="nc">Boolean</span><span class="p">{</span> <span class="c1">// 이 메소드는 위임하지 않고 새로운 구현을 제공한다</span>
        <span class="n">objectsAdded</span><span class="p">++</span> 
        <span class="k">return</span> <span class="n">innerSet</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="nf">addAll</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="nc">Collection</span><span class="p">&lt;</span><span class="nc">T</span><span class="p">&gt;:</span> <span class="nc">Boolean</span><span class="p">){</span> <span class="c1">// 이 메소드는 위임하지 않고 새로운 구현을 제공한다</span>
        <span class="n">objectsAdded</span> <span class="p">+=</span> <span class="n">c</span><span class="p">.</span><span class="n">size</span> 
        <span class="k">return</span> <span class="n">innerSet</span><span class="p">.</span><span class="nf">addAll</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">&gt;&gt;&gt;</span> <span class="kd">val</span> <span class="py">cset</span> <span class="p">=</span> <span class="nc">CountingSet</span><span class="p">&lt;</span><span class="nc">Int</span><span class="p">&gt;()</span>
<span class="p">&gt;&gt;&gt;</span> <span class="n">cset</span><span class="p">.</span><span class="nf">addAll</span><span class="p">(</span><span class="nf">listOf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="p">&gt;&gt;&gt;</span> <span class="nf">println</span><span class="p">(</span><span class="s">"${cset.objectsAdded} objects were added, ${cset.size} remain"</span><span class="p">)</span>
<span class="mi">3</span> <span class="n">objects</span> <span class="n">were</span> <span class="n">added</span><span class="p">,</span> <span class="mi">2</span> <span class="n">reamin</span>
</code></pre></div></div>

<p>이때 CountinSet에 MutableCollection의 구현 방식에 대한 의존관계가 생기지 않는다</p>

<hr />

<h2 id="object-키워드--클래스-선언과-인스턴스-생성">object 키워드 : 클래스 선언과 인스턴스 생성</h2>

<p>코틀린에서는 object 키워드를 다양한 상황에서 사용하지만 모든 경우 클래스를 정의하면서 동시에 인스턴스를 생성한다는 공통점이 있다</p>

<ol>
  <li>객체 선언은 싱글턴을 정의하는 방법 중 하나다</li>
  <li>동반 객체는 인스턴스 메소드는 아니지만 어떤 클래스와 관련 있는 메소드와 팩토리 메소드를 담을 때 쓰인다. 동반 객체 메소드에 접근할 때는 동반 객체가 포함된 클래스의 이름을 사용할 수 있다</li>
  <li>객체 식은 자바의 무명 내부 클래스 대신 쓰인다</li>
</ol>

<blockquote>
  <blockquote>
    <p>객체 선언 : 싱글턴을 쉽게 만들기</p>
  </blockquote>
</blockquote>

<p>객체지향 시스템을 설계하다 보면 인스턴스가 하나만 필요한 클래스가 유용한 경우가 많다
객체 선언은 object 키워드로 시작한다. 객체 선언은 클래스를 정의하고 그 클래스의 인스턴스를 만들어서 변수에 저장하는 모든 작업을 단 한 문장으로 처리한다<br />
클래스와 마찬가지로 객체 선언 안에도 프로퍼티, 메소드, 초기화 블록 등이 들어갈 수 있다. 하지만 생성자는 객체 선언에 쓸 수 없다<br />
싱글턴 객체는 객체 선언문이 있는 위치에서 생성자 호출 없이 즉시 만들어진다<br />
변수와 마찬가지로 객체 선언에 사용한 이름 뒤에 마침표를 붙이면 객체에 속한 메소드나 프로퍼티에 접근할 수 있다<br />
객체 선언도 클래스나 인터페이스를 상속할 수 있다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 객체 선언을 사용해 Comparator 구현하기</span>
<span class="kd">object</span> <span class="nc">CaseInsensitiveFileComparator</span> <span class="p">:</span> <span class="nc">Comparator</span><span class="p">&lt;</span><span class="nc">File</span><span class="p">&gt;{</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">compare</span><span class="p">(</span><span class="n">file1</span><span class="p">:</span> <span class="nc">File</span><span class="p">,</span> <span class="n">file2</span><span class="p">:</span> <span class="nc">File</span><span class="p">):</span> <span class="nc">Int</span><span class="p">{</span>
        <span class="k">return</span> <span class="n">file1</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">compareTo</span><span class="p">(</span><span class="n">file2</span><span class="p">.</span><span class="n">path</span><span class="p">,</span> <span class="n">ignroeCase</span> <span class="p">=</span> <span class="k">true</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">&gt;&gt;&gt;</span> <span class="nf">println</span><span class="p">(</span><span class="nc">CaseInsenstiveFileComparator</span><span class="p">.</span><span class="nf">compare</span><span class="p">(</span> <span class="o">..</span><span class="p">.</span> <span class="nc">File</span><span class="p">(</span><span class="s">"/User"</span><span class="p">),</span> <span class="nc">File</span><span class="p">(</span><span class="s">"/user"</span><span class="p">)))</span>
</code></pre></div></div>

<p>일반 객체를 사용할 수 있는 곳에서는 항상 싱글턴 객체를 사용할 수 있다</p>

<p>클래스 안에서 객체를 선언할 수도 있다. 그런 객체도 인스턴스는 단 하나뿐이다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 중첩 객체를 사용해 Comparator 구현하기</span>
<span class="kd">data class</span> <span class="nc">Person</span><span class="p">(</span><span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="nc">String</span><span class="p">){</span>
    <span class="kd">object</span> <span class="nc">NameComparator</span> <span class="p">:</span> <span class="nc">Comparator</span><span class="p">&lt;</span><span class="nc">Person</span><span class="p">&gt;{</span>
        <span class="k">override</span> <span class="k">fun</span> <span class="nf">compare</span><span class="p">(</span><span class="n">p1</span><span class="p">:</span> <span class="nc">Person</span><span class="p">,</span> <span class="n">p2</span><span class="p">:</span> <span class="nc">Person</span><span class="p">):</span> <span class="nc">Int</span> <span class="p">=</span>
            <span class="n">p1</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="nf">compareTo</span><span class="p">(</span><span class="n">p2</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">&gt;&gt;&gt;</span> <span class="kd">val</span> <span class="py">persons</span> <span class="p">=</span> <span class="nf">listOF</span><span class="p">(</span><span class="nc">Person</span><span class="p">(</span><span class="s">"Bob"</span><span class="p">),</span> <span class="nc">Person</span><span class="p">(</span><span class="s">"Alice"</span><span class="p">))</span>
<span class="p">&gt;&gt;&gt;</span> <span class="nf">println</span><span class="p">(</span><span class="n">persons</span><span class="p">.</span><span class="nf">sortedWith</span><span class="p">(</span><span class="nc">Person</span><span class="p">.</span><span class="nc">NameComparator</span><span class="p">))</span>
<span class="na">[Person(name = Alice), Person(name = Bob)]</span>
</code></pre></div></div>

<blockquote>
  <blockquote>
    <p>동반 객체 : 팩토리 메소드와 정적 멤버가 들어갈 장소</p>
  </blockquote>
</blockquote>

<p>코틀린 클래스 안에는 정적인 멤버가 없다. static 키워드를 지원하지 않는다. 그 대신 코틀린에서는 패키지 수준의 최상위 함수와 객체 선언을 활용한다<br />
대부분의 경우 최상위 함수를 활용하는 편을 더 권장한다. 하지만 최상위 함수는 private으로 표시된 클래스 비공개 멤버에 접근할 수 없다</p>

<p>클래스 안에 정의된 객체 중 하나에 companion이라는 특별한 표시를 붙이면 그 클래스의 동반 객체로 만들 수 있다. 동반 객체의 프로퍼티나 메소드에 접근하려면 그 동반 객체가 정의된 클래스 이름을 사용한다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">A</span><span class="p">{</span>
    <span class="k">companion</span> <span class="k">object</span> <span class="p">{</span>
        <span class="k">fun</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">println</span><span class="p">(</span><span class="s">"Companion object called"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">&gt;&gt;&gt;</span> <span class="nc">A</span><span class="p">.</span><span class="nf">bar</span><span class="p">()</span>
<span class="nc">Companion</span> <span class="kd">object</span> <span class="err">called
</span></code></pre></div></div>

<p>동반 객체는 자신을 둘러싼 클래스의 모든 private 멤버에 접근할 수 있다. 따라서 동반 객체는 바깥쪽 클래스의 private 생성자도 호출할 수 있다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 부 생성자가 여럿 있는 클래스 정의하기</span>
<span class="kd">class</span> <span class="nc">User</span><span class="p">{</span>
    <span class="kd">val</span> <span class="py">nickname</span> <span class="p">:</span> <span class="nc">String</span>
    <span class="k">constructor</span><span class="p">(</span><span class="n">email</span><span class="p">:</span> <span class="nc">String</span><span class="p">){</span>
        <span class="n">nickname</span> <span class="p">=</span> <span class="n">email</span><span class="p">.</span><span class="nf">substringBefore</span><span class="p">(</span><span class="err">'@</span> <span class="err">'</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">constructor</span><span class="p">(</span><span class="n">facebookAccountId</span><span class="p">:</span> <span class="nc">Int</span><span class="p">){</span>
        <span class="n">nickname</span> <span class="p">=</span> <span class="nf">getFacebookName</span><span class="p">(</span><span class="n">facebookAccountId</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이런 로직을 표현하는 더 유용한 방법으로 클래스의 인스턴스를 생성하는 팩토리 메소드가 있다<br />
아래 구현에서는 생성자를 통해 User 인스턴스를 만들 수 없고 팩토리 메소드를 통해야만 한다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 부 생성자를 팩토리 메소드로 대신하기</span>
<span class="kd">class</span> <span class="nc">User</span> <span class="k">private</span> <span class="k">constructor</span><span class="p">(</span><span class="kd">val</span> <span class="py">nickname</span><span class="p">:</span> <span class="nc">String</span><span class="p">){</span> <span class="c1">// 주 생성자를 비공개로 만든다</span>
    <span class="k">companion</span> <span class="k">object</span><span class="p">{</span>
        <span class="k">fun</span> <span class="nf">newSubscribingUser</span><span class="p">(</span><span class="n">email</span><span class="p">:</span> <span class="nc">String</span><span class="p">)</span> <span class="p">=</span> <span class="nc">User</span><span class="p">(</span><span class="n">email</span><span class="p">.</span><span class="nf">substringBefore</span><span class="p">(</span><span class="err">'@</span> <span class="err">'</span><span class="p">))</span>
        <span class="k">fun</span> <span class="nf">newFacebookUser</span><span class="p">(</span><span class="n">accountId</span> <span class="p">:</span> <span class="nc">Int</span><span class="p">)</span> <span class="p">=</span> <span class="nc">User</span><span class="p">(</span><span class="nf">getFacebookName</span><span class="p">(</span><span class="n">accountId</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">&gt;&gt;&gt;</span> <span class="kd">val</span> <span class="py">subscribingUser</span> <span class="p">=</span> <span class="nc">User</span><span class="p">.</span><span class="nf">newSubscribingUser</span><span class="p">(</span><span class="s">"bob@gmail.com"</span><span class="p">)</span>
<span class="p">&gt;&gt;&gt;</span> <span class="kd">val</span> <span class="py">facebookUser</span> <span class="p">=</span> <span class="nc">User</span><span class="p">.</span><span class="nf">newFacebookUser</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="p">&gt;&gt;&gt;</span> <span class="nf">println</span><span class="p">(</span><span class="n">subscribingUser</span><span class="p">.</span><span class="n">nickname</span><span class="p">)</span>
<span class="n">bob</span>
</code></pre></div></div>

<blockquote>
  <blockquote>
    <p>동반 객체를 일반 객체처럼 사용</p>
  </blockquote>
</blockquote>

<p>동반 객체는 클래스 안에 정의된 일반 객체다. 이름을 붙이거나, 동반 객체가 인터페이스를 상속하거나, 동반 객체 안에 확장 함수와 프로퍼티를 정의 할 수 있다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 동반 객체에 이름 붙이기</span>
<span class="kd">class</span> <span class="nc">Person</span><span class="p">(</span><span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="nc">String</span><span class="p">){</span>
    <span class="k">companion</span> <span class="k">object</span> <span class="nc">Loader</span><span class="p">{</span> <span class="c1">// 동반 객체에 이름을 붙인다</span>
        <span class="k">fun</span> <span class="nf">fromJSON</span><span class="p">(</span><span class="n">jsonText</span><span class="p">:</span> <span class="nc">String</span><span class="p">):</span> <span class="nc">Person</span> <span class="p">=</span> <span class="o">..</span><span class="p">.</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">&gt;&gt;&gt;</span> <span class="n">person</span> <span class="p">=</span> <span class="nc">Person</span><span class="p">.</span><span class="nc">Loader</span><span class="p">.</span><span class="nf">fromJSON</span><span class="p">(</span><span class="s">"{name: 'Dmitry'}"</span><span class="p">)</span>
<span class="p">&gt;&gt;&gt;</span> <span class="n">person</span><span class="p">.</span><span class="n">name</span>
<span class="nc">Dmitry</span>
<span class="p">&gt;&gt;&gt;</span> <span class="n">person2</span> <span class="p">=</span> <span class="nc">Person</span><span class="p">.</span><span class="nf">fromJSON</span><span class="p">(</span><span class="s">"{name: 'Brent'}"</span><span class="p">)</span>
<span class="p">&gt;&gt;&gt;</span> <span class="n">person2</span><span class="p">.</span><span class="n">name</span>
<span class="nc">Brent</span>
</code></pre></div></div>

<blockquote>
  <p>동반 객체에서 인터페이스 구현</p>
</blockquote>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 동반 객체에서 인터페이스 구현하기</span>
<span class="kd">interface</span> <span class="nc">JSONfactory</span><span class="p">&lt;</span><span class="nc">T</span><span class="p">&gt;{</span>
    <span class="k">fun</span> <span class="nf">fromJSON</span><span class="p">(</span><span class="n">jsonText</span><span class="p">:</span> <span class="nc">String</span><span class="p">):</span> <span class="nc">T</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Person</span><span class="p">(</span><span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="nc">String</span><span class="p">){</span>
    <span class="k">companion</span> <span class="k">object</span> <span class="p">:</span> <span class="nc">JSONfactory</span><span class="p">&lt;</span><span class="nc">Person</span><span class="p">&gt;{</span>
        <span class="k">override</span> <span class="k">fun</span> <span class="nf">fromJSON</span><span class="p">(</span><span class="n">jsonText</span><span class="p">:</span> <span class="nc">String</span><span class="p">):</span> <span class="nc">Person</span> <span class="p">=</span> <span class="o">..</span><span class="p">.</span> <span class="c1">// 동반 객체가 인터페이스를 구현한다</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <blockquote>
    <p>동반 객체 확장</p>
  </blockquote>
</blockquote>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 동반 객체에 대한 확장 함수 정의하기</span>
<span class="kd">class</span> <span class="nc">Person</span><span class="p">(</span><span class="kd">val</span> <span class="py">firstName</span><span class="p">:</span> <span class="nc">String</span><span class="p">,</span> <span class="kd">val</span> <span class="py">lastName</span><span class="p">:</span> <span class="nc">String</span><span class="p">){</span>
    <span class="k">companion</span> <span class="k">object</span><span class="p">{</span> <span class="c1">// 비어 있는 동반 객체 선언</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nc">Person</span><span class="p">.</span><span class="nc">Companion</span><span class="p">.</span><span class="nf">fromJSON</span><span class="p">(</span><span class="n">json</span><span class="p">:</span> <span class="nc">String</span><span class="p">):</span> <span class="nc">Person</span><span class="p">{</span>

<span class="p">}</span>

<span class="kd">val</span> <span class="py">p</span> <span class="p">=</span> <span class="nc">Person</span><span class="p">.</span><span class="nf">fromJSON</span><span class="p">(</span><span class="n">json</span><span class="p">)</span>
</code></pre></div></div>

<blockquote>
  <blockquote>
    <p>객체 식 : 무명 내부 클래스르 다른 방식으로 작성</p>
  </blockquote>
</blockquote>

<p>무명 객체를 정의할 때도 object 키워드를 쓴다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 무명 객체로 이벤트 리스너 구현하기</span>
<span class="n">window</span><span class="p">.</span><span class="nf">addMouseListenr</span><span class="p">(</span>
    <span class="kd">object</span> <span class="err">: </span><span class="nc">MouseAdapter</span><span class="p">(){</span>
        <span class="k">override</span> <span class="k">fun</span> <span class="nf">mouseClicked</span><span class="p">(</span><span class="n">e</span> <span class="p">:</span> <span class="nc">MouseEvent</span><span class="p">){</span>

        <span class="p">}</span>

        <span class="k">override</span> <span class="k">fun</span> <span class="nf">mouseEntered</span><span class="p">(</span><span class="n">e</span> <span class="p">:</span> <span class="nc">MouseEvent</span><span class="p">){</span>

        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">)</span>
</code></pre></div></div>

<p>객체에 이름을 붙여야 한다면 변수에 무명 객체를 대입하면 된다<br />
객체 선언과 달리 무명 객체는 싱글턴이 아니다. 객체 식이 쓰일 때마다 새로운 인스턴스가 생성된다<br />
final이 아닌 변수도 객체 식 안에서 사용할 수 있다. 따라서 객체 식 안에서 그 변수의 값을 변경할 수 있다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 무명 객체 안에서 로컬 변수 사용하기</span>
<span class="k">fun</span> <span class="nf">countClicks</span><span class="p">(</span><span class="n">window</span><span class="p">:</span> <span class="nc">Window</span><span class="p">){</span>
    <span class="kd">var</span> <span class="py">clickCount</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// 로컬 변수</span>
    
    <span class="n">window</span><span class="p">.</span><span class="nf">addMouseListener</span><span class="p">(</span><span class="k">object</span><span class="p">:</span> <span class="nc">MouseAdapter</span><span class="p">(){</span>
        <span class="k">override</span> <span class="n">fin</span> <span class="nf">mouseClicked</span><span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="nc">MouseEvent</span><span class="p">){</span>
            <span class="n">clickCount</span><span class="p">++</span> <span class="c1">// 로컬 변수의 값 변경</span>
        <span class="p">}</span>
    <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div>

                </div>
            </section>

            <!-- Email subscribe form at the bottom of the page -->
            <!--
            
                <section class="subscribe-form">
                    <h3 class="subscribe-form-title">Subscribe to LEE</h3>
                    <p>Get the latest posts delivered right to your inbox</p>
                    <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()"
               id="searchtext" type="text" name="searchtext"
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
                </section>
            
            -->


            <footer class="post-full-footer">
                <!-- Everything inside the #author tags pulls data from the author -->
                <!-- #author-->
                
                    
                        <section class="author-card">
                            
                                <img class="author-profile-image" src="/assets/built/images/author-logo.jpg" alt="lee989898" />
                            
                            <section class="author-card-content">
                                <h4 class="author-card-name"><a href="/author/lee989898">lee989898</a></h4>
                                
                                    <p><a href="https://github.com/lee989898">깃허브</a></p>
                                
                            </section>
                        </section>
                        <div class="post-full-footer-right">
                            <a class="author-card-button" href="/author/lee989898">Read More</a>
                        </div>
                    
                
                <!-- /author  -->
            </footer>

            <!-- If you use Disqus comments, just uncomment this block.
            The only thing you need to change is "test-apkdzgmqhj" - which
            should be replaced with your own Disqus site-id. -->
            
                <section class="post-full-comments">
                    <div id="disqus_thread"></div>
                    <script>
                        var disqus_config = function () {
                            var this_page_url = 'https://lee989898.github.io/kotlin-03';
                            var this_page_identifier = '/kotlin-03';
                            var this_page_title = '클래스, 객체, 인터페이스';
                        };
                        (function() {
                            var d = document, s = d.createElement('script');
                            s.src = 'https://xxxxxxxx.disqus.com/embed.js';
                            s.setAttribute('data-timestamp', +new Date());
                            (d.head || d.body).appendChild(s);
                        })();
                    </script>
                </section>
            

        </article>

    </div>
</main>

<!-- Links to Previous/Next posts -->
<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            
                
                
                
                
                    <article class="read-next-card"
                        
                            style="background-image: url(/assets/built/images/blog-cover1.png)"
                        
                    >
                        <header class="read-next-card-header">
                            <small class="read-next-card-header-sitetitle">&mdash; LEE &mdash;</small>
                            
                                <h3 class="read-next-card-header-title"><a href="/tag/kotlin/">Kotlin</a></h3>
                            
                        </header>
                        <div class="read-next-divider"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"/></svg>
</div>
                        <div class="read-next-card-content">
                            <ul>
                                
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                    
                                        
                                        
                                            <li><a href="/kotlin-10">DSL 만들기</a></li>
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                            <li><a href="/kotlin-09">애노테이션과 리플렉션</a></li>
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                            <li><a href="/kotlin-08">제네릭스</a></li>
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                            </ul>
                        </div>
                        <footer class="read-next-card-footer">
                            <a href="/tag/kotlin/">
                                
                                    See all 9 posts  →
                                
                            </a>
                        </footer>
                    </article>
                
            

            <!-- If there's a next post, display it using the same markup included from - partials/post-card.hbs -->
            
                

    <article class="post-card post-template">
        
            <a class="post-card-image-link" href="/kotlin-04">
                <div class="post-card-image" style="background-image: url(/assets/built/images/kotlin-logo.png)"></div>
            </a>
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/kotlin-04">
                <header class="post-card-header">
                    
                        
                            
                                <span class="post-card-tags">Kotlin</span>
                            
                        
                    

                    <h2 class="post-card-title">람다로 프로그래밍</h2>
                </header>
                <section class="post-card-excerpt">
                    
                        <p>코틀린 테이블

    코틀린 기초
    함수 정의와 호출
    클래스, 객체, 인터페이스
    람다로 프로그래밍
    코틀린 타입 시스템
    연산자 오버로딩과 기타 관례
    고차 함수: 파라미터와 반환 값으로 람다 사용
    제네릭스
    애노테이션과 리플렉션
    DSL 만들기


</p>
                    
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                        
                        <img class="author-profile-image" src="/assets/built/images/author-logo.jpg" alt="lee989898" />
                        
                        <span class="post-card-author">
                            <a href="/author/lee989898/">lee989898</a>
                        </span>
                    
                
                <span class="reading-time">
                    
                    
                      10 min read
                    
                </span>
            </footer>
        </div>
    </article>

            

            <!-- If there's a previous post, display it using the same markup included from - partials/post-card.hbs -->
            
                

    <article class="post-card post-template">
        
            <a class="post-card-image-link" href="/kotlin-02">
                <div class="post-card-image" style="background-image: url(/assets/built/images/kotlin-logo.png)"></div>
            </a>
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/kotlin-02">
                <header class="post-card-header">
                    
                        
                            
                                <span class="post-card-tags">Kotlin</span>
                            
                        
                    

                    <h2 class="post-card-title">함수 정의와 호출</h2>
                </header>
                <section class="post-card-excerpt">
                    
                        <p>코틀린 테이블

    코틀린 기초
    함수 정의와 호출
    클래스, 객체, 인터페이스
    람다로 프로그래밍
    코틀린 타입 시스템
    연산자 오버로딩과 기타 관례
    고차 함수: 파라미터와 반환 값으로 람다 사용
    제네릭스
    애노테이션과 리플렉션
    DSL 만들기


</p>
                    
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                        
                        <img class="author-profile-image" src="/assets/built/images/author-logo.jpg" alt="lee989898" />
                        
                        <span class="post-card-author">
                            <a href="/author/lee989898/">lee989898</a>
                        </span>
                    
                
                <span class="reading-time">
                    
                    
                      8 min read
                    
                </span>
            </footer>
        </div>
    </article>

            

        </div>
    </div>
</aside>

<!-- Floating header which appears on-scroll, included from includes/floating-header.hbs -->
<div class="floating-header">
    <div class="floating-header-logo">
        <a href="https://lee989898.github.io/">
            
            <span>LEE</span>
        </a>
    </div>
    <span class="floating-header-divider">&mdash;</span>
    <div class="floating-header-title">클래스, 객체, 인터페이스</div>
    <div class="floating-header-share">
        <div class="floating-header-share-label">Share this <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path d="M7.5 15.5V4a1.5 1.5 0 1 1 3 0v4.5h2a1 1 0 0 1 1 1h2a1 1 0 0 1 1 1H18a1.5 1.5 0 0 1 1.5 1.5v3.099c0 .929-.13 1.854-.385 2.748L17.5 23.5h-9c-1.5-2-5.417-8.673-5.417-8.673a1.2 1.2 0 0 1 1.76-1.605L7.5 15.5zm6-6v2m-3-3.5v3.5m6-1v2"/>
</svg>
</div>
        <a class="floating-header-share-tw" href="https://twitter.com/share?text=%ED%81%B4%EB%9E%98%EC%8A%A4%2C+%EA%B0%9D%EC%B2%B4%2C+%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4&amp;url=https://lee989898.github.io/kotlin-03"
            onclick="window.open(this.href, 'share-twitter', 'width=550,height=235');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>

        </a>
        <a class="floating-header-share-fb" href="https://www.facebook.com/sharer/sharer.php?u=https://lee989898.github.io/kotlin-03"
            onclick="window.open(this.href, 'share-facebook','width=580,height=296');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>

        </a>
    </div>
    <progress class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>


<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->


        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://lee989898.github.io/">LEE</a> &copy; 2022</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
        <div class="subscribe-overlay-content">
            
            <h1 class="subscribe-overlay-title">Search LEE</h1>
            <p class="subscribe-overlay-description">
                lunr.js를 이용한 posts 검색 </p>
            <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()"
               id="searchtext" type="text" name="searchtext"
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
        </div>
    </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
