<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />
    <!-- highlight.js -->

    <!-- custom.css -->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css" />

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- 웹 폰트 -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!-- syntax.css -->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="공부 블로그" />
    <link rel="shortcut icon" href="https://lee989898.github.io/assets/built/images/favicon.jpg" type="image/png" />
    <link rel="canonical" href="https://lee989898.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

    


     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="LEE" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="공부 블로그" />
    <meta property="og:url" content="https://lee989898.github.io/search" />
    <meta property="og:image" content="https://lee989898.github.io/assets/built/images/blog-cover1.png" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="공부 블로그" />
    <meta name="twitter:url" content="https://lee989898.github.io/" />
    <meta name="twitter:image" content="https://lee989898.github.io/assets/built/images/blog-cover1.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="LEE" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "LEE",
        "logo": "https://lee989898.github.io/"
    },
    "url": "https://lee989898.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://lee989898.github.io/assets/built/images/blog-cover1.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://lee989898.github.io/search"
    },
    "description": "공부 블로그"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://lee989898.github.io/">LEE</a>
            
        
        
            
<ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-android" role="menuitem"><a href="/tag/android/">안드로이드</a></li>
    <li class="nav-kotlin" role="menuitem"><a href="/tag/kotlin/">코틀린</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/python/">파이썬</a></li>
    <li class="nav-algorithm" role="menuitem"><a href="/tag/algorithm/">알고리즘</a></li>
    <li class="nav-pl" role="menuitem"><a href="/tag/pl/">프로그래밍언어</a></li>
    <li class="nav-security" role="menuitem"><a href="/tag/security/">컴퓨터보안</a></li>
    <li class="nav-system" role="menuitem"><a href="/tag/system/">시스템프로그래밍</a></li>
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">All Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag별 Posts</a>
    </li>


</ul>



        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>


    </div>

</header>




<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "pl-21": {
        "title": "FPinPython",
            "author": "lee989898",
            "category": "",
            "content": "FPinPythonPython is not a FPL  What is FP?수학적 의미의 순수 함수는 부작용이 없이, 아웃풋 값이 순전히 인풋값에 따르는 함수이다함수 프로그래밍에서, 프로그램은 전적으로 순수 함수의 평가(계산의 실행)로 구성된다계산은 상태 변화나 데이터의 변경없이, 중첩 함수나 합성 함수의 호출에 의해 진행된다명령형 프로그래밍에 대한 함수 프로그래밍의 장점은 다음과 같다  첫째, 함수 코드는 고수준이다. ​함수는 결과를 얻는데 필요한 절차를 명시적으로 상술하는 것이 아니라, ​얻고자 하는 결과가 무엇인지 서술한다.  즉, how가 아니라 what을 서술한다 ​  둘째, 함수 코드는 투명하다. ​함수의 행태는 계산 중에 생성되는 잠정적인 값에 무관하고, 인풋과 아웃풋에만 의존한다. 이것은 부작용의 가능성을 제거하며, 디버깅을 쉽게 한다  끝으로, 함수 코드는 병렬성이 있다. ​부작용이 없어서, 프로그램의 루틴들은 더욱 쉽게 병렬 처리할 수 있다함수 프로그래밍은 다음과 같은 특징을 갖는다  함수는 first class이다. ​파이썬을 비롯한 현대 프로그래밍 언어에서는 ​기본적으로 객체, 클래스 개념을 갖기 때문에, ​함수를 기본적인 객체로 간주한다. ​따라서 ‘Functions are first class’라는 말은 ​’함수는 기본적인 객체이다’라는 의미로 받아 들여도 무방하다. 실제로 파이썬에서는 function을 객체로 간주하여, ​파라미터로 주고 받는다. ​이것은 함수 프로그래밍 언어에서 원하는 바이다  함수 프로그래밍에서 리커젼은 기본적인 컨트롤 스트럭처로 사용된다. ​몇몇 언어에서는 리커젼 이외에 순환 처리를 위한 다른 방법(loop)을 지원하지 않는다. 반면, 순수 함수 언어가 아닌 명령형 프로그래밍을 지원하는 언어에서는 loop도 함께 지원한다  함수 프로그래밍 언어는 리스트 처리에 초점을 둔다. ​Loop는 ‘리스트에 대한 리커젼 처리’로 대체될 수 있다. ​이와 같이 리스트는 loop의 대체에 필요한 데이터 구조로서 사용된다  순수 함수 프로그래밍 언어는 부작용을 피하기 위해, ​변수에 초기값을 할당하거나, 계산 중에 이 변수의 값을 변경하는 것을 모두 금지한다  함수 프로그래밍은 문장 단위로 프로그램을 작성하는 것이 아니라, ​함수와 파라미터 단위로 프로그램을 작성한다. ​순수 함수 프로그램에서,프로그램은 하나의 표현식과 이를 지원하는 함수 정의로 구성된다  함수 프로그래밍은 어떻게 계산할 것인가가 아니라, ​무엇을 계산할 것인가에 관심을 갖는다​  함수 프로그래밍은 고차 함수를 이용한다여기서 언급하는 FP의 특징은 지극히 일부분이고 상이한 측면도 보이는데, 이렇게 된 이유는 ​순수 함수 언어가 아닌 현대 프로그래밍 언어를 가지고 ​함수 프로그래밍을 하는 실용적인 개발자(practitioner)의 관점이 반영되어 있기 때문이다파이썬은 ‘순수’ 함수 언어가 확실히 아니다. 대부분의 파이썬 프로그램에서 부작용을 흔히 볼 수 있다즉, 변수는 자주 재바인딩되고, ​수정 가능한 데이터 컬렉션은 그 내용을 종종 변경하며, ​I/O는 자유롭게 계산과 인터리빙된다 (메모리에 바인딩된다는 의미이다)파이썬은 함수 언어 근처에도 못간다. ​파이썬은 멀티 패러다임 언어이다파이썬은 필요할 때, 함수 프로그래밍을 쉽게 할 수 있고, ​다른 프로그래밍 스타일과 혼합하기 쉽다즉, 명령형 프로그래밍 스타일과 함수 프로그래밍 스타일을 섞어서 쓸 수 있다따라서, 멀티 패러다임 언어라는 말은 ​다양한 프로그래밍 스타일을 지원하는 언어라는 의미로 이해하면 될 것이다How well Python supports FP?​함수 프로그래밍을 지원하려면, ​함수는 다른 함수를 파라미터로 받을 수 있고, ​또 다른 함수를 반환할 수 있어야 한다파이썬은 프로그램 내의 모든 것을 객체로 취급하기 때문에, ​두가지를 모두 지원한다파이썬에서, 함수는 일등 시민이다. 함수는 값과 동일한 특징을 갖기 때문에, ​함수를 변수에 할당할 수 있고(명령형 언어의 변수와 의미적으로 다름)​print()를 써서 함수를 콘솔에 디스플레이할 수 있으며, ​함수를 다른 함수에게 파라미터로 패스할 수 있다​&gt;&gt;&gt; def func():        printf(\"I am function func()!\")&gt;&gt;&gt; func()I am function func()!&gt;&gt;&gt; another_name = func&gt;&gt;&gt; another_name()I am function func()!위 코드는 func을 another_name에 할당하는 것을 보여주고 있다&gt;&gt;&gt; def func():        printf(\"I am funtion func()!\")&gt;&gt;&gt; print(\"cat\", func, 42)cat &lt;function func at 0x2123123123&gt; 42&gt;&gt;&gt; objects = [\"cat\", func, 42]&gt;&gt;&gt; objects[1]&lt;function func at 0x2123123123&gt;&gt;&gt;&gt; objects[1]()I am function func()!&gt;&gt;&gt; d = {\"cat\": 1, func: 2, 42: 3}&gt;&gt;&gt; d[func]2위 코드는 print(“cat”, func, 42)를 통해, ​&lt;function func at …&gt;을 디스플레이하는 것을 보여주고 있다또 print()를 내포하는 함수 func()을 통해, ​함수를 디스플레이하고 있다끝으로 d는 키: 값 쌍을 갖는 dictionary인데, ​d[func]은 func의 값 2를 반환한다​&gt;&gt;&gt; def inner():        printf(\"I am function inner()!\")&gt;&gt;&gt; def outer(function):        function()&gt;&gt;&gt; outer(inner)I an function inner()!위 코드는 inner()가 outer()의 파라미터로 패스되는 것을 보여준다. 이것은 합성 함수의 정의 사례이다파이썬에서, 합성 함수는 다음과 같이 실행된다. ​outer(inner) 호출은 inner()를 outer()에게 파라미터로 패스한다outer() 내에서 파이썬은 inner()를 파라미터 ‘function’에 바인딩한다. ​그러면, outer()는 ‘function’을 통해 직접 inner()를 호출한다함수가 다른 함수에 패스될 때, 패스-인 함수를 콜백이라고 부른다. ​그 이유는 패스-인 함수(앞의 예에서는 inner())의 호출이 ​역으로 outer에 영향을 줄 수 있기 때문이다&gt;&gt;&gt; animals = [\"ferret\", \"vole\", \"dog\", \"gecko\"]&gt;&gt;&gt; sorted(animals, key=len)['dog', 'vole', 'gecko', 'ferret']위 코드는 sorted()의 파라미터로 len()을 사용하여 ​길이 순으로 정렬하고 있다&gt;&gt;&gt; animals = [\"ferret\", \"vole\", \"dog\", \"gecko\"]&gt;&gt;&gt; sorted(animals, key=len, reverse=True)['ferret', 'gecko', 'vole', 'dog']&gt;&gt;&gt; def reverse_len(s):        return -len(s)&gt;&gt;&gt; sorted(animals, key=reverse_len)['ferret', 'gecko', 'vole', 'dog']위 코드는 길이의 역순으로 정렬한다. 이때 메소드 reverse=True와 함수 -len()에 의한 reverse_len()의 정의를 사용한다&gt;&gt;&gt; def outer():        def inner():                print(\"I am function inner()!\")        return inner&gt;&gt;&gt; function = outer()&gt;&gt;&gt; function&lt;function outer.&lt;locals&gt;.inner at 0x231312312&gt;&gt;&gt;&gt; function()I am function inner()!&gt;&gt;&gt; outer()()I am function inner()!파이썬에서는, 함수를 반환값으로 반환한다. ​파이썬에서는 함수를 다른 함수에게 파라미터로 패스할 수 있고, ​함수를 다른 함수의 반환값으로 반환한다예를 들어, 위 코드에서 함수 outer()의 정의를 보자. outer() 내에서 inner()를 정의하고, ​inner를 반환한다outer()의 반환값을 변수 function에 할당한다. ​function()는 간접적으로 inner()를 호출한다. ​outer()의 반환값을 이용하여 간접적으로 inner()를 호출한다이와 같이, 파이썬은 함수를 파라미터로, 그리고 반환값으로 사용할 수 있다. 이러한 측면에서 파이썬은 함수 프로그래밍을 잘 지원한다&gt;&gt;&gt; lambda s: s[::-1]&lt;function &lt;lambda&gt; at 0x123312512&gt;&gt;&gt;&gt; callable(lambda s: s[:: 1])True&gt;&gt;&gt; reverse = lambda s: s[:: -1]&gt;&gt;&gt; reverse(\"I am a string\")&gt;&gt;&gt; (lambda s: s[::-1])(\"I am a string\")파이썬은 람다를 사용하여 익명의 함수를 정의한다. ​람다 표현식은 lambda : 의 형식을 갖는다은 파라미터 리스트의 이름을 포함한다  위 코드는 문자열의 역순을 반환하는 함수 정의를 ​람다 표현식으로 나타낸 것이다  Callable은 함수 호출이나 메소드인지를 확인하는 함수이다. ​가운데 코드와 같이, 람다 함수의 적용을 통해, ​그리고 람다 함수를 변수에 할당 및 호출을 통해, ​함수를 평가할 수 있다  ---## __Applying function to iterable with map()​__---```&gt;&gt;&gt; def reverse(s):             return s[::-1]&gt;&gt;&gt; reverse(\"I am a string\")&gt;&gt;&gt; animals = [\"cat\", \"dog\", \"hedgehog\", \"gecko\"]&gt;&gt;&gt; iterator = map(reverse, animals)&gt;&gt;&gt; for i in iterator:        print(i)tacgodgohefdehokceg&gt;&gt;&gt; list(iterator)['tac', 'god', 'gohegdeh', 'okceg']&gt;&gt;&gt; list(map(lambda s: s[::-1], [\"cat\", \"dog\", \"hedgehog\", \"gecko\"]))['tac', 'god', 'gohegdeh', 'okceg']```이터러블에 대한 함수에 map()을 적용하면, ​리스트 각 요소마다 원하는 함수 f를 적용할 수 있다  리스트 각 요소마다 reverse를 적용하려면, ​map(reverse, animal)와 같이 하면 된다  이것은 이터러블 animal의 각 요소에 reverse 함수를 적용한다. ​이것을 for loop을 써서 프린트한다  이터레이터를 써서 프린트할 수 있다 ```&gt;&gt;&gt; def f(a,b,c):        return a + b + c&gt;&gt;&gt; list(map(f,[1,2,3], [10,20,30], [100, 200, 300]))[111, 222, 333]```다수의 이터러블에 map()을 적용하려면, ​그 형식은 map(f, iter1, iter2,… itern)과 같다  ---## __Selecting elements from iterable with filter()__---```&gt;&gt;&gt; def greater_than_100(x):        return x &gt; 100&gt;&gt;&gt; list(filter(greater_than_100, [1, 111, 2, 222, 3, 333]))[111, 222, 333]&gt;&gt;&gt; list(filter(lambda x: x &gt; 100, [1, 111, 2, 222, 3, 333]))[111, 222, 333]```함수 filter()를 써서 이터러블로부터 원하는 요소를 선택하려면, ​그 형식은 filter(f, iter)이다  함수 f가 greater_than_100()이라면, ​표현식 filter(greater_than_100, [1,111,2,222,3,333]))의 결과는​ 111,222,333이다  ---​## __Avoiding control flow​__명령형 파이썬 프로그램에서 코드 블록은 다음과 같이 구성된다+ 외부 loop(for 또는 while)​+ 외부 loop 내의 상태 변수의 할당​+ 데이터 구조(dicts, lists, sets 등)의 수정​+ 분기문(if/elif/else 또는 try/except/finally)​  이렇게 하는 것은 자연스럽고 문제를 인식하기 쉬운 듯 보인다. ​그러나 상태 변수와 수정가능한 데이터 구조로 인해 부작용이 발생할 수 있을 뿐만 아니라, ​프로그램의 특정 지점에서 데이터의 상태를 알아내기가 어렵다  이에 대한 해결책으로 'how'가 아니라 'what'에 초점을 맞추는 것이 중요하다  즉, '여기 어떤 데이터가 있는데,' '원하는 결과를 생성하기 위해 이 데이터를 어떻게 처리할 것인가?'가 아니라 ​'이 데이터를 가지고(또는 이 데이터에 대해) 내가 처리해야 하는 것이 무엇인가?'를 고민하는 것이다  플로우 컨트롤을 피하고 함수 프로그래밍을 위해, ​'how'에서 'what'으로 어떻게 전환할 것인가?  캡슐화, 컴프리헨션, 리커젼 등을 잘 활용하는 것이 그 방법이다  컴프리헨션은 주어진 구조적 데이터에서 새로운 구조적 데이터를 생성하는 간략한 방법으로, ​파이썬 프로그래머는 반복 처리나 조건을 만족하는 리스트, 딕셔너리, 집합을 쉽게 생성할 수 있다&gt; Encapsulation```# imperative style​collection = get_initial_state()​state_var = None​for datum in data_set:​     if condition(state_var):​          state_var = calculate_from(datum)​          new = modify(datum, state_var)​          collection.add_to(new)​     else:​          new = modify_differently(datum)​          collection.add_to(new)​# work with the data collection​for thing in collection:​    process(thing)# functional style ​def make_collection(data_set):​     collection = get_initial_state()​     state_var = None​     for datum in data_set:​          if condition(state_var):​                state_var = calculate_from(datum, state_var)​                new = modify(datum, state_var)​                collection.add_to(new)​          else:​                new = modify_differently(datum)​                collection.add_to(new)​     return collection​# work with the data collection​for thing in make_collection(data_set):​     process(thing)```캡슐화는 코드를 refactor(재분해)하고, ​데이터 생성을 함수나 메소드 안으로 집어 넣는 것이다  예를 들어 위 코드는 캡슐화를 써서, ​명령형 스타일의 'collection 생성 절차'라는 'how'를 함수 프로그래밍 스타일의 'make_collection(즉 collection 생성)'이라는 what으로 전환한다  위 코드는 명령형 절차를 나타내며, ​아래 코드는 함수 프로그램 코드를 나타낸다&gt; List Comprehension```collection = list()​for datum in data_set:​     if condition(datum):​          collection.append(datum)​     else:​          new = modify(datum)​          collection.append(new)collection = [d if condition(d) else modify(d)​                 for d in data_set]```컴프리핸션은 주어진 이터러블에서 새로운 이터러블을 생성하는 간략한 방법이다  파이썬의 컴프리헨션에는 리스트, 제너레이터, 딕셔너리, 집합이 있으며, ​이를 위한 문법을 제공한다리스트 컴프리헨션은 표현식을 […]로 감싼다  컴프리헨션은 같은 키워드를 사용하면서, ​그 키워드들의 순서를 바꾼 표현식의 형태를 갖는다  순서를 바꾼 이유는 절차가 아닌 데이터에 초점을 두기 위함이다. 이 말은 컴프리헨션을 이용하여 함수 프로그래밍에 도움이 된다는 뜻이다  주어진 리스트 data_set으로부터 새로운 리스트 collection을 생성하는 ​프로그램을 코딩하면 위 코드와 같다  위는 명령형 스타일이고, 아래는 함수형 스타일이다  위 코드에서, 삼진 연산자 if를, ​같은 키워드를 사용하면서 순서만 바꿔, ​명령형 코드를 함수형 코드로 재구조화한 것을 볼 수 있다  절차에 초점을 둔 코드는 조건을 만족시키면, append​ 만족시키지 못하면, modify &amp; append​  반면에 데이터에 초점을 둔 함수 스타일로 표현하면, ​리스트 컴프리헨션이 적절한 형식이고, ​주어진 리스트 data_set에서 조건에 맞는 것만 collection로 생성하면 된다  리스트 요소를 d로 지칭하여 표현식을 작성하면, ​아래쪽 코드와 같다. Data_set의 각 요소 d에 대해 ​먼저 조건을 만족시키는지 확인하고, 맞으면 bypass 안맞으면 modify  마치 순서를 바꾼 것처럼 보이지만, 시맨틱을 고려하면 조건을 만족하면 리스트에 남기고(하나씩 append 하지 않고), ​조건을 만족하지 않으면 modify(d)해서 수정된 d를 리스트에 남긴다. 그리고 이와 같이 생성된 새로운 리스트를 collection으로 명명(naming)한다는 의미이다  &gt; Generator Comprehension  제너레이터 컴프리헨션은 리스트 컴프리헨션과 유사하게 데이터를 생성하나 문법적으로 [ ] 대신에 ( )를 사용한다  제너레이터 컴프리헨션은 데이터 생성을 위해, ​함수 정의에 '데이터 생성 방법'을 서술한다  이 서술은 그에 대한 반복 처리를 하거나 .next()를 호출할 때까지 실행되지 않는다  따라서 대규모 시퀀스를 위한 메모리를 절약하고​ 실제로 필요할 때까지 계산을 지연시킨다  ```# imperative​def get_log_lines(log_file):​     line = read_line(log_file)​     while True:​          try:​             if complex_condition(line):​                  yield line​             line = read_line(log_file)​          except StopIteration:​                  raise​log_lines = get_log_lines(huge_log_file)​# functional ​class GetLogLines(object):​     def __init__(self, log_file):​          self.log_file = log_file​          self.line = None​     def __iter__(self):​          return self​     def __next__(self):​          if self.line is None:​               self.line = read_line(log_file)​          while not complex_condition(self.line):​               self.line = read_line(self.log_file)​          return self.line​log_lines = GetLogLines(huge_log_file)​```간단한 예를 들면, 로그 파일에서 로그 라인을 읽어서 ​라인 리스트를 만드는 함수 코드는 위와 같다  위의 코드는 실제 상황을 고려한 코드로서, ​위쪽 코드는 명령형 프로그래밍 스타일, ​아래쪽 코드는 함수 프로그래밍 스타일을 나타낸다  &gt; Dictionary and Set Comprehension  ```&gt;&gt;&gt; {i:chr(65+i) for i in range(6)}​{0: 'A', 1: 'B', 2: 'C', 3: 'D', 4: 'E', 5: 'F'}​&gt;&gt;&gt; {chr(65+i) for i in range(6)}​{'A', 'B', 'C', 'D', 'E', 'F'}​```딕셔너리와 집합 컴프리헨션은 모두 { }을 사용하나, ​그 안의 형식이 {key : value}, {value}로 각기 다르다  이들의 요소는 loop안에서 .update(), add() 호출을 통해 하나씩 생성되는 것이 아니라, ​모두 '한꺼번에' 생성된다​  각각의 예는 위와 같다. &gt; Recursion```# recursive​def factorialR(N):​     assert isinstance(N, int) and N &gt;= 1​     return 1 if N &lt;= 1 else N * factorialR(N-1)# iterative ​def factorialI(N):​     assert isinstance(N, int) and N &gt;= 1​     product = 1​     while N &gt;= 1:​          product *= N​          N -= 1​     return product```파이썬은 리커션과 룹에 의한 함수 프로그래밍을 지원한다  리커션과 while 룹을 이용한 팩토리알 계산 함수는 각각 위와 아래에 있다  While 룹을 이용한 것은 거의 명령형 코드로 보이지만, ​함수로 정의하는 점과 while 안에서 함수형 코드가 있는 점 등​ 함수 프로그래밍 스타일과 명령형 프로그래밍 스타일이 혼합되어 있다  ```# Quicksort over a list-like sequence​def quicksort(lst):​     if len(lst) == 0:​         return lst​     pivot = lst[0]​     pivots = [x for x in lst if x == pivot]​     small = quicksort([x for x in lst if x &lt; pivot])​     large = quicksort([x for x in lst if x &gt; pivot])​     return small + pivots + large```이러한 혼합 형식은 퀵소트 함수에서도 볼 수 있다. 삼진 연산자 if, [표현식…]은 함수형이지만, ​나열된 문장은 명령형으로 보인다. 즉, 혼합형이다  ```# statement-based loop​for e in it: ​     func(e)​# map()-based \"loop“​map(func, it) ​```고차 함수를 써서 룹을 제거할 수 있다. ​이것은 가독성과 성능 저하를 가져오지만, ​함수 프로그래밍을 위한 좋은 아이디어를 얻을 수 있는 배경 지식으로 중요하다  우선 for loop을 제거하기 위해 map()을 쓴 경우를 보자. ​위쪽 코드는 for loop에 의한 코드이다. ​반면 아래쪽 코드는 map에 의해 loop이 제거된 코드이다  함수 map()을 적용할 때, ​다수의 함수를 같은 수의 리스트에 적용하고 싶다면, ​다수의 함수와 같은 수의 리스트를 파라미터로 하여, ​map(do_it, [f1, f2, f3], [l1, l2, l3])와 같이 표현한다  이때 적용해야 할 함수는 ​do_it = lambda f, *args: f(*args)와 같이, ​람다에 의해 정의되어 있어야 한다```&gt;&gt;&gt; hello = lambda first, last: print(\"Hello\", first, last)​&gt;&gt;&gt; bye = lambda first, last: print(\"Bye\", first, last)​&gt;&gt;&gt; _ = list(map(do_it, [hello, bye],​&gt;&gt;&gt;                         ['David','Jane'], ['Mertz','Doe']))​Hello David Mertz​Bye Jane Doe​&gt;&gt;&gt; do_all_funcs = lambda fns, *args: [​                                     list(map(fn, *args)) for fn in fns]​&gt;&gt;&gt; _ = do_all_funcs([hello, bye],​                             ['David','Jane'], ['Mertz','Doe'])​Hello David Mertz​Hello Jane Doe​Bye David Mertz​Bye Jane Doe```위쪽 코드는 함수 hello를 [Dav, Jan]에, ​함수 bye를 [Mer, Do]에 적용하는데, ​이들 함수 hello, bye는 각각 ​lambda first, last: print(\"Hello\", first, last)와 ​lambda first, last: print(\"Bye\", first, last)이다  만일 모든 함수를 각각의 리스트에 적용하려면, ​함수 map()을 lambda fns, *args: [list(map(fn, *args)) for fn in fns]와 같이 정의한다  ---",
        "url": "/pl-21"
    }
    ,
    
    "sc-21": {
        "title": "__IPSEC__",
            "author": "lee989898",
            "category": "",
            "content": "IPSEC  IPSEC  IP 주소 위장 방지(출발지 인증)​  IP 데이터그램의 변경 및 재전송 방지​  IP 데이터 그램을 위한 기밀성, 무결성 제공​  보안  프로토콜 선택(시스템들이 필요로 하는)​  암호 알고리즘 선택(선택된 프로토콜에서 사용되도록)​  암호키 생성,분배(요청된 서비스의 제공에 필요) ​  Application​          VPN (virtual Private Network): 가상 전용회선​        IPSEC 구성  IPsec AH(인증 헤더) 프로토콜​          데이터 근원 인증,비연결형 무결성 제공 ​        캡슐화 보안페이로드 (ESP ) – 데이터기밀성, 제한된 트래칙 흐름 기밀성, 비연결형 무결성, 데이터 근원인증, 재전송공격 방지 제공​  IKE 프로토콜 ​          통신당사자간 키관리 프로토콜​      암호알고리즘 선택협상, 키분배 위해 사용​        Transport and Tunnel Modes  Transport mode​          End to end between hosts​      관련 hosts들이 IPSec을 지원해야​      IP 상위 프로토콜 (TCP, Application) 안전하게 전송​      IP header에 IPSec header정보 추가​        Tunnel mode​          터널내의 모든 IP 트래픽 보호​      터널의 시작,종류 지점에 IPSec gateway​      터널 시작 gateway에서 새 IP header와 Ipsec header 추가하고, 종료 gateway에서 제거​      라우터가 내부 패킷을 검사하지 않음      소스 및 목적지 주소가 다를 수 있음      방화벽에서 구현 가능      ",
        "url": "/sc-21"
    }
    ,
    
    "sc-20": {
        "title": "__SSL/TLS__",
            "author": "lee989898",
            "category": "",
            "content": "SSL/TLS  Secure sockets layer (SSL)​  1996, Netscape​  1999, TLS로​  웹기반 전자상거래를 위해 TCP layer에서 메시지와 무결성과 비밀성 제공​  Web-server와 web-browser간 보안​  HTTPS – 현재 대부분 서버에서 사용​  Handshake (암호spec, session관리), record (암호,무결성등 보안서비스) protocols로 나뉜다​  인증수행-&gt;세션키분배-&gt;암호화 메시지 송수신 순서​  지원하는 보안서비스 ​          Server/client authentication, confidentiality, integrity        부인방지기능은 제공안됨 – 전자서명 사용해야​  단순히 web-server와 web-browser간의 모든 data를 암호화하면 안전? No, replay attack (관찰된 통신내용을 동일하게 재생하면 같은 결과를 얻을 수 있다.)  Secure sockets layer (SSL) 표준​  User authentication​  Confidentiality​  Integrity​​  TLS/SSL Protocol 구성​  Handshake protocol​          Client, server 간 인증, 암호 알고리즘 합의, 키교환 등 수행​        Record protocol​          데이터를 인증, 암호화처리하고 메시지 송수신​        Change cipher spec​          암호 spec을 변경담당​        Alter protocol​          에러처리​        Handshake Protocol  핸드셰이크는 서버를 확인하고 데이터가 전송되기 전에 클라이언트와 서버가 암호화 세트에 동의하도록 한다  Record protocol의 의한 data송수신보다 먼저 수행되어 다음의 session정보를 생성, 관리​          Session ID​      Certification​      Cipher spec: 압축, MAC algorithm​      Compression method: 암호화 이전 압축 algorithm​      Master secret key: 48bit        Handshake Protocol  3개의 필드로 이루어진 메시지 교환          type: 메시지 종류 명시      length: 메시지 길이      content: 메시지 종류에 따른 값들        4단계 진행          1단계: Security capability establish​      2단계: Server authentication &amp; key exchange​      3단계: Client authentication &amp; key exchange​      4단계: Change cipher specs​        1단계: Security capability establish​          1~3​      Hello 메시지 교환으로 session ID, 키교환알고리즘, 인증 알고리즘, 암호알고리즘, 압축 알고리즘 결정        Server authentication &amp; key exchange​          4~6​      4: 서버의 인증서와 검증위한 인증서체인, 공개키전송​      5: client 인증서 요구(opt)​      6: 2단계 종료메시지        3단계: Client authentication &amp; key exchange​          7~9​      7: client 인증서전송​      8: 48byte premaster secrete 전송​      9: client 인증서 검증        4단계: Change cipher specs​          10~11​      암호사양변경 메시지 교환을 통해 다음 세션에 적용될 암호 spec 결정        Record Protocol  메시지를 최대 16KB 단위로 fragment​  MAC 사용  1: 메시지를 최대 16KB 단위로 fragment​  2: 압축 (opt)​  3: MAC 추가​  4: Encryption​  5: SSL reacord header 추가  Changes from SSL 3.0 to TLS  Transport Layer Security [RFC2246]​  Additional Alerts added​  Modification to hash calculations​  Protocol version 3.1 in ClientHello, ServerHello",
        "url": "/sc-20"
    }
    ,
    
    "sc-19": {
        "title": "__Dos​__",
            "author": "lee989898",
            "category": "",
            "content": "Dos​  Dos (Denial of Service)  서비스 거부​  시스템 자원(cpu, memory, network, storage 등)을 고갈시켜 정상적인 접근에 대한 서비스를 제공할 수 없도록 만드는 행위​  Dos attack type​  Error trigger Dos attack​  OS,application의 약점에 attack packet 전송해서 system error 유발 (slammer worm)​  Ping of death, Land, Teardrop​  Flooding Dos attack​  packet, traffic을 과중하게 발생하여 server, network resource 고갈​  TCP syn flooding​  TCP syn flooding​  TCP 3-way handshaking의 취약점 이용​  공격자가 src IP 주소를 위조해서 TCP SYN를  동시에 대량전송​  서버는 TCP ACK를 보내고, 자원할당 후 응답 기다림​  정상적인 접근방해+엉뚱한 피해자​  DDoS Attack​  Distributed Denial of Service​  다수의 pc가 동시에 Dos 공격​  BotNet?  Bot(=zombie): 악성sw에 감염되어 자신도 모르게 해커의 조종을 받는 컴퓨터​  BotNet: 명령제어서버(C&amp;C,command and control)를 통해 원격제어되는 악성코드에 감염된 컴퓨터(bot)들의 네트워크 ​  대부분 사어버테러의 주요 원인  DDos 종류  Standard DoS: 알려진 취약점 집중공격​  Tool을 이용한 DoS: TFN, TFN2K, Trinoo, Loki, Stacheldraht, Jolt, Land, teardrop…​  Traffic anomalie 공격: bandwidth점유, ICMP, TCP, UDP flooding​  Spoofed SYN flooding: spoof된 source IP로 TCP syn보냄​  Connection Per Second(CPS) flood: zombie로 부터 connection flooding​  Established Connection flood: zombie로 부터 established connection flood​  Why DDos?  Simple​  Easy: just use tools​  Effective​  공격자추적이 어렵다​​",
        "url": "/sc-19"
    }
    ,
    
    "sc-18": {
        "title": "__Kerberos​__",
            "author": "lee989898",
            "category": "",
            "content": "Kerberos​  Kerberos?  Symmetric key 기반 분산 인증 시스템​  사용자가 서버의 서비스에 액세스하려는 경우 (예, 프린터서버, 네트워크 디스크 등)​  세 가지 위협 존재:​          사용자가 다른 사용자로 가장​      사용자가 워크스테이션의 네트워크 주소를 변경      사용자는 교환을 도청하고 재생 공격을 사용​        Client들이 원격으로 서버에 자원, 서비스 요청시마다 인증반복​  매번 passwd 입력 안해도 되며, 각 서버가 사용자들의 비번을 저장할 필요없다​  경쟁자: SSL  ​Kerberos Design 요구사항​  사용자는 워크스테이션 세션(로그인 세션)이 시작될 때 한 번 자신을 식별해야 한다  암호는 네트워크를 통해 일반 텍스트로 전송되지 않습니다(또는 메모리에 저장)  각 서버가 사용자들의 비번을 저장할 필요없어야 ​함  System Components​  Server, User​  AS(Authentication Server)​          모든 user/server 들의 password 안다​      TGS 에 제시할 ticket 발급​        TGS(Ticket Granting Server)​          서버는 ticket만 받는다​      서비스 요청시, 한 user는 한 server에 한 ticket제시​      Server에 제시할 ticket 발급역할​        시스템 구성도  Protocol​  User/TGS는 AS에, server는 TGS에 등록(passwd)되어 있다  (or PKI사용)​  User가 서비스 필요​  서비스 제공할 server 찾는다​  해당 server 관리하는 TGS 찾는다​  AS에 TGS에 보낼 ticket요청  User는 AS에게  UserID, TGS이름을 $K_{user-AS}$로 암호화하여 보낸다  AS는 User와 TGS간의 통신을 위한 세션키1 $K_{user-TGS}$ 를 생성​ 세션키1, UserID 를 $K_{AS-TGS}$로 암호화하여 User에게 발급할 Ticket을 생성​ 세션키1과 Ticket을 $K_{user-AS}$로 암호화하여 보낸다​  받은 2를 $K_{user-AS}$복호화해서 세션키1 $K_{user-TGS}$ 와 Ticket을 얻는다. ​UserID를 세션키1로 암호화해서 Ticket과 함께 TGS로 보낸다​  받은 3을 $K_{user-TGS}$와 $K_{AS-TGS}$ 로 복호화해서 User정보와 요구내용 확인, ​TGS는 User와 Server간의 통신을 위한 세션키2 $K_{user-server}$ 생성 ​세션키2, UserID 를 $K_{TGS-server}$로 암호화하여 User에게 발급할 Ticket을 생성​ 세션키2와 Ticket을 $K_{user-TGS}$로 암호화하여 보낸다​  받은 4를 $K_{user-TGS}$로 복호화해서 세션키2 $K_{user-server}$와 Ticket(user, Server)를 얻는다. Server에게 $K_{user-server}$로 암호화한 UserID와 Ticket을 전송한다​  Server는 받는 5의 Ticket을 $K_{TGS-server}$로 복호화 하여 세션키2 $K_{user-server}$을 얻는다. 이걸로 UserID를 복호화해서  사용자확인을 한다.​  Drawbacks of Kerberos  단일 실패 지점: 중앙 서버의 지속적인 가용성이 필요. Kerberos 서버가 다운되면 아무도 로그인할 수 없다  Kerberos에는 엄격한 시간 요구 사항이 있으므로 관련된 호스트의 시계가 구성된 제한 내에서 동기화되어야 함  관리 프로토콜은 표준화되지 않았으며 서버 구현에 따라 다르다  모든 인증은 중앙 집중식 KDC에 의해 제어되므로 이 인증 인프라가 손상되면 공격자가 모든 사용자를 가장할 수 있음  다른 호스트 이름이 필요한 각 네트워크 서비스에는 고유한 Kerberos 키 세트가 필요합니다. 이는 가상 호스팅 및 클러스터를 복잡하게 만든다",
        "url": "/sc-18"
    }
    ,
    
    "algorithm-09": {
        "title": "근사 알고리즘",
            "author": "lee989898",
            "category": "",
            "content": "근사 알고리즘근사 알고리즘  NP-완전 문제 해결 방법  문제의 크기가 작다면 완전 탐색 알고리즘 사용  문제의 특별한 경우(들)에는 다항 시간 알고리즘을 찾으려고 노력  문제의 최적해에 매우 근사한 해를 구하는 것이 허용된다면 비교적 빠른 근사 알고리즘을 찾으려고 노력  근사 알고리즘  NP-완전 문제와 같이 지금까지 알려진 실용적인 다항 시간 알고리즘이 없거나 최적의 해를 반드시 찾을 필요가 없을 때 사용  대부분의 근사 알고리즘은 특정 문제에만 적용되는 휴리스틱에 기초  휴리스틱은 경험을 통해 얻는 상식적인 접근법  근사 비율  근사해의 값과 최적해의 값의 비율  정의: 근사 비율 p          f: 목적 함수      $S_a$: 근사해      $S^*$: 최적해      $S_a$는 다음 부등식을 만족시켜야 한다                  최소화 문제: $\\frac{f(S_a)} {f(S^*)}$&lt;= p          최대화 문제: $\\frac{f(S^*)} {f(S_a)}$&lt;= p                      p-근사 알고리즘: 근사비율이 p인 알고리즘  1에 가까울수록 정확도가 높은 알고리즘  근사 비율은 보통 2를 사용  대부분의 경우에 목적 함수의 최적 값인 $f(S^*)$를 알 수 없기 때문에 근사 비율 계산 불가  $f(S^*)$를 대신할 수 있는 $f(S_a)$의 상한을 구하여 근사 비율을 계산  정점 커버 찾기  무방향 그래프에서 각 간선의 양쪽 끝의 두 정점들 중에서 적어도 1개의 정점을 포함하는 정점들의 집합  크기 = 정점 커버내에 있는 정점들의 수      그래프는 여러 개의 정점 커버들을 가질 수 있다    무방향 그래프내에 있는 최소 크기의 정점 커버를 찾아라          정점 지향 전략      간선 지향 전략        정점 지향 전략  그래프의 모든 정점들을 차수(한 정점에 인접한 정점들의 수) 기준으로 내림차순으로 정렬한다  차수가 가장 큰 정점을 선택한다  선택된 정점에 인접한 모든 간선을 제거한다  남은 그래프에서 과정 2와 3을 반복한다  간선 지향 전략  그래프의 한 간선 (u, v)를 임의로 선택한다  u와 v를 정점 커버에 포함시키고 u와 v에 인접한 간선들은 모두 그래프에서 제거한다  남은 간선들 중 임의로 한 간선을 선택하고 같은 과정을 반복한다. 선택할 간선들이 더 이상 남아 있지 않으면 종료한다  근사 정점 커버 알고리즘Approx_Vertex_Cover(G)// 입력: 그래프 G = (V, E)// 출력: C - 정점 커버1 C = $\\emptyset$2 $E^$ = E  3 while ( $E^$ $\\neq$  $\\emptyset$){4   $E^$에서 임의로 간선 (u,v)를 선택한다  5   C = C {u} {v}  6   $E^$에서 정점 u나 v에 인접한 모든 간선들을 제거한다    }7 return C                              시간 복잡도: O(          E          )                      해밀토니안 회로  해밀토니안 회로: 그래프의 한 정점에서 출발하여 다른 모든 정점을 1번씩만 방문하고 출발 정점으로 돌아오는 경로  완전 그래프에는 반드시 해밀토니안 회로가 있다  외판원 문제  가중 완전 그래프의 최단 거리 해밀토니안 회로를 찾아라  NP-완전 문제  다음 조건들을 만족시켜야 한다  가중치가 있는 완전 무방향 그래프 G = (V, E)의 각 간선 (u, v) $\\in$ E는 음이 아닌 가중치 c(u, v)를 가진다  모든 정점 u,v,w $\\in$ V에 대해서 거리 함수 c가 다음과 같은 삼각 부등식을 만족한다          c(u,v) &lt;= c(u, w) + c(w, v)        근사 외판원 알고리즘  아이디어  프림의 최소 비용 신장 트리 알고리즘을 이용하여 주어진 그래프에서 최소 비용 신장 트리를 찾는다  이 트리에 깊이 우선 탐색을 하여 정점들의 방문 순서를 구한다  이 순서를 따라 정점들을 방문하면서 다시 방문하는 정점을 순서에서 제거하여 외판원 문제의 근사해를 구한다Approx_MST_TSP(G, c)// 입력: G = (V, E) - 가중 완전 그래프, c - G의 간선들의 가중치(삼각 부등식을 만족)// 출력: 해밀토니안 회로 H  임의의 정점 r $\\in$ V를 출발 정점으로 선택한다  Prim의 최소 비용 신장 트리 알고리즘을 이용하여 r이 루트 노드인 그래프 G의 최소 비용 신장 트리 T를 구한다  트리 T의 루트 노드에서 시작하여 깊이 우선 탐색을 하면서 노드들을 방문한 순서대로 나열한 목록 H를 구한다  목록 H에 있는 정점들을 출발 정점을 제외하고 처음부터 순서대로 스캔하면서 중복하여 나타나는 정점들을 H에서 제거한다  return H  시간복잡도: O($n^2$)",
        "url": "/algorithm-09"
    }
    ,
    
    "pl-20": {
        "title": "FPLs",
            "author": "lee989898",
            "category": "",
            "content": "FPLsLisp​Lisp은 심볼(문자열) 처리를 위한 언어로 개발되었다심볼들을 표현하기 위한 데이터 구조로 리스트, 즉 링크드 리스트를 기본으로 한다이러한 이유로 데이터 연산은 자연스레 링크(포인터) 조작을 포함한다Lisp이라는 이름은 리스트 프로세싱의 합성어로서, 말 그대로 리스트 처리에 적합하도록 설계되었다Lisp의 데이터 타입은 아톰과 리스트, 두 가지이다아톰은 식별자처럼 생긴 심볼들이거나 숫자 형태의 상수를 말한다아톰에 값이 없을 수 있어서 nil도 가능하다리스트는 리스트 요소가 연결되어 있고, 리스트 요소는 두개의 링크(포인터), 데이터 포인터와 넥스트 포인터로 구성된다데이터 포인터는 아톰을 가리키거나 중첩리스트를 가리킨다넥스트 포인터는 다른 리스트 요소를 가리키거나 nil(리스트의 끝을 나타냄)이다Lisp 프로그램에서 리스트는 괄호를 써서 나타내는데, 중첩 리스트는 괄호 안에 괄호를 써서 나타낸다ex) (A, B, C, D)A,B,C,D는 각각이 아톰이며, (A,B,C,D)는 리스트이다산술 연산자로 +, - , incf, decf가 있고, 비교 연산자로 =, /= , &lt;, max, min이 있다부울 값에 대한 논리 연산자로 loand,logor 등이 있다컨트롤 스트럭처로 selection, recursiong, iteration이 있는데, iteration은 명령형 언어의 특성으로, Lisp이 순수 함수 언어가 아니라는 것을 보여준다함수 정의는 (defun 함수명 (파라미터1… 파라미터n)표현식)형식을 따르고, 함수 적용(호출)은 (함수명 파라미터1 … 파라미터n)의 형식을 따른다Lisp으로 작성된 팩토리알 함수는(DEFUN factorial (X))    (IF &lt;= n 1)            1            (* n factorial (-n 1))))과 같다미리 정의된 함수 중의 몇몇은 실제로는 함수가 아니라 매크로이다예를 들어, 두개의 파라미터, 죽 변수와 리스트를 받아들이는 DOLIST는 매크로이다DOLIST(x ‘(1 2 3)) (print x))는 리스트 요소 1,2,3,nil로 구성된 리스트를 생성한다매크로의 실행은 다음 두 단계로 이루어진다우선, 매크로를 미리 정의딘 Lisp 코드로 펼치고, 다음에, 펼친 Lisp 코드를 평가(실행)한다사용자는 DEFMACRO를 써서 자신이 원하는 매크로를 정의할 수 있다Lisp에서 괄호 앞의 ‘(QUOTE)는 괄호 속의 표현식을 평가(실행)하지 말고, 그 객체(표현식)를 결과로서 반환하라는 뜻이다예를 들어 ‘(a(* 3 4)c)는 (a 12 c)를 결과로 반환한다중첩된 괄호 속의 (* 3 4)는 평가한다는 것에 주의하자Lisp은 컴파일러가 아닌 인터프리터에 의해 실행된다Lisp 프로그램에서는 함수 정의 및 함수 적용(호출)을 “괄호에 의한 리스트 표시 방식”으로 표현된다함수 정의는 (함수명(람다 (파라미터1 … 파라미터n) 표현식)) 으로 정의하며, 함수 적용은 (함수명 파라미터1 … 파라미터n)으로 호출한다예를 들어, (+ 5 7)은 12이고, (+ 3 4 7 6)은 20이다Scheme​Scheme은 Lisp으로부터 유래되었으나 함수를 일등 시민으로 취급한다Scheme에서는 함수가 표현식의 결과 값일 수 있고, 함수가 리스트의 요소로 사용될 수 있으며, 함수가 파라미터로 패스될 수 있고, 함수가 함수의 결과로서 반환될 수 있다Scheme은 단순한 신택스와 시맨틱스를 갖는, 타입이 없는 작은 언어이다Scheme 인터프리터는 상호작용 모드로 동작하면서, read-evaluate-print 순환(REPL)을 무한으로 반복한다  사용자가 입력한 표현식을 읽어서  EVAL 함수에 의해 표현식을 해석하고  결과값을 화면에 display한다EVAL 함수는 다음과 같이 표현식을 평가한다리터럴의 평가는 그 자체를 결과로 displaat한다원시 함수를 포함하는 표현식의 평가는 다음과 같이 실행한다첫째, 특별한 순서 없이, 파라미터 표현식의 각각 평가한다둘째, 파라미터 값에 원시 함수의 적용을 평가한다끝으로, 결과값을 display한다원시 산술 함수는 +,-,*,/,modulo,round,max,min,log,sin,sqrt 등이다음수에 대한 sqrt는 허수이다함수 정의는 (LAMBDA (x) (* x x))의 형식을 가지며, 함수 적용은 ((LAMBDA(x) (* x x)) 7)의 형식을 갖는다DEFINE 함수는 이름을 값이나 람다 함수에 바인딩하는 특수한 함수이다(DEFINE symbol expression)의 형식을 가지며, 그 예로 (DFINE pi 3.141592), (DEFINE two_pi (* 2 pi))을 들 수 있다DEFINE 함수가 이름을 람다 표현식에 바인딩하는 형식은 (DEFINE (function_name parameters) (expression))이다예를 들면, 제곱수를 (DEFINE (square number) (* number number))와 같이 정의하고, 직각삼각형의 빗변의 길이를 (DEFINE (hypotenuse side1 side2)(SQRT(+(square side1)(square side2))))와 같이 정의한다출력 함수는 EVAL 함수의 적용을 통해 그 결과를 display한다논리적 술어(predicate)함수는 부울 값을 반환한다Scheme의 논리적 술어 함수는 =, &lt;&gt;, &gt;,&lt;,&gt;=, &lt;=, EVEN?, ODD?, ZERO?가 있다리스트가 부울식으로서 해석될 때에는 비어있지 않은 리스트는 참이고, 비어있는 리스트는 거짓이다컨트롤 플로우는 택인 컨스트럭트(IF)와 평가 컨트롤(COND)이 있다if는 3개의 파라미터(논리적 술어 표현식, then 표현식, else 표현식)를 갖는다그 형식은 (IF 논리적 술어 then 표현식 else 표현식)이고, 사용 예를 들면 DEFINE(factorial n)(IF (&lt;+ n 1)1(*n(factorial(-n 1))))이다평가 컨트롤은 여럿 중에서 하나 이상이 선택 및 실행되는 COND와 recursion이 있다COND의 형식은(DEFINE (leap? year))    (COND        ((ZERO? (MODULO year 400)) #T)        ((ZERO? (MODULO year 100)) #F)        (ELSE (ZERO? (MODULO year 4)))))와 같다리스트 함수에는 QUOTE,CAR,CDR,CONS 함수가 있다QUOTE는 그 자체를 결과로 반환하며, ‘로 표시한다(QUOTE A) returns A ​(QUOTE (A B C)) returns (A B C)​CAR 함수는(CAR '((A B) C D)) returns (A B) ​(CAR 'A) is an error because A is not a list ​(CAR '(A)) returns A ​(CAR '()) is an error ​CDR 함수는 ​(CDR '((A B) C D)) returns (C D) ​(CDR 'A) is an error ​(CDR '(A)) returns () ​(CDR '()) is an error​CONS 함수는 ​(CONS 'A '()) returns (A) ​(CONS 'A '(B C)) returns (A B C)​(CONS '() '(A B)) returns (() A B)​(CONS '(A B) '(C D)) returns ((A B) C D)CAR, CDR을 가지고 a_list의 두번째 리스트 요소를 결과값으로 반환하는 함수를 정의하면, (DEFINE (second a_list)(CAR(CDR a_list)))가 된다이것은 a_list에서 첫째 요소를 제외한 나머지를 반환하고, 이중에서 첫째 요소를 반환한다는 뜻이다리스트를 생성하기 위해 CAR CDR의 연속으로 적용해 보면, (CADDAR ‘((A B (C)D)E)) == (C) 임을 알 수 있다리스트 함수는 다수의 파라미터로부터 하나의 리스트를 생성한다CONS는 생성할 수도 있으나, List함수가 편리하다논리적 술어 함수 중에서 EQ? NULL? LIST?는 심볼 아톰과 리스트에도 적용할 수 있다EQV?은 숫자 아톰과 심볼 아톰에 모두 적용할 수 있다Scheme에서 함수 정의의 예를 들어 보자멤버 함수는 파라미터 간의 소속관계를 평가한다리스트의 맨앞 리스트 요소에서부터 차례로 비교하기 위해, COND와 EQ, CAR, CDR을 사용한다append 함수는 앞의 파라미터에 뒤의 파라미터를 잇는다list1의 리스트 요소를 앞에서부터 하나씩 새로운 리스트에 넣기를 반복한다list1의 리스트의 요소를 모두 새로운 리스트에 넣고 나면, 이때 lsit1은 NULL이 되므로, list2의 요소를 새로운 리스트에 넣으면 된다이를 위해 COND와 NULL?, CONS, CAR, CDR을 이용한다두개의 리스트가 같은지 판단하려면, 각 리스트의 맨앞 요소에서부터 하나씩 같은지 비교하기를 반복한다이를 위해 COND, EQ?, CAR, CDR 등을 이용한다반복 처리는 모두 recursion을 이용한다즉, 이들 모두 recursion으로 프로그래밍 된다root1 = (-b + sqrt(b2 - 4 ac))/2a, root 2 = (-b - sqrt(b2 - 4 ac))/2 a​(DEFINE (quadratic_roots a b c) ​  (LET ( ​     (root_part_over_2a ​                    (/ (SQRT (− (* b b) (* 4 a c))) (* 2 a))) ​     (minus_b_over_2a (/ (− 0 b) (* 2 a))) ​         ) ​  (LIST (+ minus_b_over_2a root_part_over_2a) ​                  (− minus_b_over_2a root_part_over_2a)) ​))​LET 함수는 로컬 변수를 생성한다표현을 쉽게 하기 위해 루트 부분과 루트가 없는 부분(이것을 마이너스 부분)으로 나누어, 이들을 각각 로컬 변수 root_part_over_2a, minus_b_over_2a로 언급한다LIST 함수에서 이들을 언급하며 근의 공식 함수를 정의한다함수의 합성은 두개의 함수를 파리미터로 받아들여 합성 함수를 결과로 반환한다합성 함수는 DEFINE (compose f g)(LAMBDA(x) (f(g(x))))로 정의한다CADDR을 (DEFINE (third a_list) ((compose CAR (compose CDR CDR)) a_list))와 같이 정의한다리스트의 모든 요소에 적용하는 함수로 map 함수를 정의해 보자함수 정의의 형식은 (DEFINE (mao fun a_list) 표현식)이며, a-list의 모든 요소에 함수 fun을 적용하라는 의미이다즉, 함수 map을 정의하는데 파라미터로서 fun이라는 함수를 쓴다따라서 이것은 고차 함수이다처리 목적에 맞게 처리하려면, 리스트 요소를 하나씩 반환하는 함수가 필요하며, 이렇게 반환된 리스트 요소에 fun을 적용하기를 반복하면 된다위의 map 함수 정의에서 (COND … NULL? … ELSE …) 부분은 리스트 요소를 하나씩 꺼내는 처리 로직을 수행한다맵함수 사용 예: (map (LAMBDA(num)(*num num num))’(3 4 2 6))은 (27 64 8 216)를 반환한다 (DEFINE (adder a_list) ​      (COND ​          ((NULL? a_list) 0) ​          (ELSE (+ (CAR a_list) (adder (CDR a_list)))) ))​(adder '(3 4 5)) ​   (+ 3 (adder (4 5))) ​   (+ 3 (+ 4 (adder (5)))) ​   (+ 3 (+ 4 (+ 5 (adder ())))) ​   (+ 3 (+ 4 (+ 5 0))) ​   (+ 3 (+ 4 5)) ​   (+ 3 9) ​   (12)​리스트에 있는 아톰의 합을 구하는 프로그램을 작성해보면, 코드는 위에서 보듯이 매우 간결하다실제 평가 과정을 보면, recursion이 있어 매우 복잡해 보이지만 이것은 인터프리터의 역할이다만일 EVAL 함수를 써서 코딩하면, 아래 프로그램이 된다Alternative code with EVAL function:​(DEFINE (adder a_list) ​    (COND ​        ((NULL? a_list) 0) ​        (ELSE (EVAL (CONS '+ a_list))) ​))​(adder '(3 4 5)) ​(EVAL (+ 3 4 5) ​(12)ML​ML은 타입 검사를 엄격하게 수행하는 언어이다평가 환경은 프로그램에서 명시적 또는 암묵적으로 선언된 모든 변수명을 그 유형(타입)과 함께 테이블을 포함한다이 테이블은 컴파일러의 심볼 테이블과 유사하다ML 신택스는 Lisp이나 Scheme에 비해 IPL과 더욱 유사하다산술 표현식은 인픽스 방식으로 표현된다함수 정의는 함수명(파라미터) = 표현식;의 신택스를 갖는다예를 들어, fun circumf( r ) = 3.14159rr;로 정의 되었다면, 함수 circumf는 부동점 파라미터를 받아서 부동점 결과를 생산한다이 값의 타입은 표현식의 값으로부터 추론된다함수 적용은 circumf(1.3)과 같이 호출된다ML의 컨트롤 플로우는 if 표현식 then 표현식1 else 표현식2에 의한다ML에서는 주어진 파라미터에 대한 패턴 매칭을 통해 함수의 반환값을 정의하는 특정 표현식을 선택하기도 한다예를 들어, 팩토리알을 구할 떄fun fact(n : int): int = if n &lt;= 1 then 1 else n * fact(n − 1);로 표현할 수도 있지만, ​fun fact(0) = 1 | fact(1) = 1 | fact(n : int): int = n * fact(n − 1);로 표현할 수도 있다.후자에서는 Fact(0), Fact(1)의 값을 구할 때, 두개의 식 fun fact(0) = 1, fact(1) = 1에 대한 패턴 매칭을 통해 그 결과값을 선택할 수 있다ML에서는 h, t는 각각 헤드와 테일을 나타내며, CAR, CDR과 같다그리고 ::는 CONS와 같다두개의 리스트를 append하는 함수는fun append([], lis2) = lis2 | append(h :: t, lis2) = h :: append(t, lis2);로 정의된다.주어진 리스트에서 리스트 요소의 개수를 구하는 함수는fun length([]) = 0 | length(h :: t) = 1 + length(t);이다ML에서 값을 선언하는 방법은 변수명에 값을 바인딩하는 것이다그 형식은 val new_name = expression이다만일 새로운 값을 바인딩하려면 새로운 변수명에 새로운 값을 바인딩하여 테이블에 새로운 엔트리로 생성해야 한다val의 정상적인 사용은 표현식에서 사용하는 변수에 대해, Let안에서 바인딩하는 것이다Let val radius = 2.7 ​      val pi = 3.14159 ​   in pi * radius * radius ​   end;​예에서 radius와 pi는 표현식에 제한된 변수임을 명확히 선언하고 있다많이 쓰이는 고차 함수로 리스트를 필터링하는 filter함수가 있다필터는 다음과 같이 동작한다  필터는 술어 함수를 파라미터로 받아들여서, 술어 만족 여부에 따라 필터링하는 함수를 반환한다(술어 함수는 종종 fn으로 정의된 람다 표현식으로 주어진다)  반환된 필터링 함수는 리스트를 파라미터로 받아들여서 다음과 같이 처리한다          각 리스트 요소에 대해 술어함수를 적용하여 술어 조건을 만족시키는지 검사      그 결과가 참이면, 리스트 요소를 새로운 리스트(결과 리스트)에 추가한나다      참이 아니면, 스킵한다        이렇게 생성된 새로운 리스트를 결과로 반환한다필터의 사용을 보면 Filter(fn(x)) =&gt; x &lt;100, [25, 1, 50, 711, 100, 150, 27, 161, 3]);는 결과로서 100보다 작은 요소만으로 구성된 새로운 리스트 [25, 1, 50, 27, 3]를 반환한다많이 쓰이는 다른 함수로 map함수가 있다map함수는 파라미터로 함수 (fa)를 받아 들여서 새로운 함수를 만든다새로운 함수는 파라미터로 리스트를 받아 들인다각 리스트 요소에 파라미터로 받은 함수(fa)를 적용한다합성 함수는 val h = g o f로 정의하며, 이것은 h(x) = g(f(x))와 같다커링은 하나 이상의 파라미터를 가진 함수를 하나의 파라미터를 가진 함수로 교체하는 것이다하나의 파라미터를 가진 함수는 함수를 반환하며, 반환된 이 함수는 초기 함수의 다른 파라미터를 받아 들여 결과를 반환한다예를 들어, (DEFINE (add x y)(+ x y))의 커리 함수는 DEFINE (add y) (LAMBDA (x) (+ y x))이며, 이것이 호출되면, 그 결과는 (+ y x)으로 리덕션된다Haskell​Haskell은 순수 함수 언어로 알려져 있다연산자는 표시 방식만 다를 뿐 다른 FPL과 거의 같다Haskell 역시 앞에서 Scheme에서 본 것과 유사한 let 컨스트럭트를 지원한다다른 언어와 다르게 지연 평가를 수행하며, 표현식은 값이 필요할 때에만 평가된다이에 비해 이른(eager) 평가에서는 함수가 호출되기 전에 미리 함수에 대한 파라미터를 평가한다따라서 엄격한 시맨틱스를 갖는다Support FP in IPL자바 스크립트에서는 이름을 가진 함수를 정의할 수 있다ex) 함수명 (파라미터 여러개) { 표현식 (블록)}여기서 함수명을 빼면 익명의 함수를 정의하게 된다파이썬에는 람다 표현식이 가능하다즉, lambda a,b: 2*a-b라고 하면, 파라미터 a,b로 이름이 없는 익명의 함수를 정의하는 것이다파라미터와 함수 바디를 콜론으로 구분한다파이썬에서는 고차 함수 filter와 map를 정의할 수 있다이들은 첫째 파라미터로 모두 람다 표현식을 사용하며, 두번째 파라미터로 시퀀스 타입을 사용한다두 함수 모두 두번째 파라미터와 동일한 타입의 시퀀스를 결과로 반환한다.예를 들어 map(lambda x : x**3, [2, 4, 6, 8]이라고 하면, 반환 결과는 [8, 64, 216, 512]이다.이 예에서 첫번째 파라미터는 함수(표현식)임을 기억하라.이 map은 2004년 구글의 MapReduce의 map과 같은 의미이며, ​병렬 처리의 한 방법으로 유명해졌다. ​파이썬은 파라미터의 개수를 제한하고, ​명시적으로 새로운 함수를 정의하고 적용할 수 있도록 partial 함수를 지원한다.먼저 제한적으로 적용하려는 함수를 임포트하고,​ (여기서 add5는 add a b : a + b에서 파라미터를 ​한 개로 줄여서 add + 5로 정의한 것이다.)​ 명령문 add5=partial (add, 5)은 함수 add+5를 add5로 정의하고, ​함수 add5(15)를 적용(호출)하면 결과는 20이다. ​",
        "url": "/pl-20"
    }
    ,
    
    "st-10": {
        "title": "POSIX Thread Programming",
            "author": "lee989898",
            "category": "",
            "content": "POSIX Thread ProgrammingThread Overview ​  프로세스처럼 독립적으로 수행되는 프로그램 코드​          “경량 프로세스(light-weight process)”라고도 함​      “프로세스 내에서 독립적으로, 순차적으로 수행되는 instruction stream 또는 제어의 흐름”이라고도 함​      여러 스레드는 동시에 실행이 가능​      스레드들의 실행에 관한 스케쥴링은 OS가 담당​      싱글 코어에서도 여러 스레드의 실행이 가능 ​        한 프로세스내의 스레드들은 같은 주소 공간을 사용 ​          공유 매모리를 이용하여 스레드간의 통신을 이용함으로써 복잡한 프로세스간 통신(IPC) 기능을 사용하지 않아도 됨​      스레드간의 통신 비용이 IPC 비용보다 낮음​        Process는 실행을 위하여 resource들이 필요하며 실행 상태를 메모리에 저장 ​          Process ID, group ID, … ​      Program instructions​      Registers, Stack​      Heap ​      File descriptor, …​        Thread는 Process 내부에 존재하면서 resource들을 같이 사용 ​          Registers, stack, 등은 thread 별로 따로 존재  ​        공통 스레드 구현​          병렬 소스 코드 내에서 호출되는 서브루틴 라이브러리      직렬 또는 병렬 소스 코드에 포함된 컴파일러 지시문 세트        스레드 구현은 컴퓨팅에서 새로운 것이 아니다          역사적으로 하드웨어 공급업체는 고유한 스레드 버전을 구현했다      이러한 구현은 서로 상당히 다르다      프로그래머가 휴대용 스레드 응용 프로그램을 개발하기 어려움​        관련 없는 표준화 노력으로 인해 두 개의 매우 다른 스레드 구현이 발생했다          POSIX Threads (Pthread)​      OpenMP​      Pthread Introduction ​  IEEE POSIX (Portable Operating System Interface for UNIX) 1003.1c Standard​          과거에 하드웨어 업체별로 각각 제작되어 사용되었던 스레드에 관한 구현을 표준화 ​      이 표준에 따라 구현된 스레드를 POSIX Thread 또는 Pthread로 부름​                  스레드를 생성하고 동기화하는 system call 들로 구성​                    표준화는 계속 진행 중​                  가장 최근의  표준은 IEEE Std 1003.1, 2004 Edition​                      C-프로그래밍 언어의 type과 procedure call의 집합으로 정의 ​                   header 파일 및 thread library로 구현​                  libc library의 일부로 구현되기도 함​                      우수한 성능 : 프로세스와 비교​          스레드 생성에 드는 OS overhead가 프로세스 생성에 비해 현격히 낮음​                  50,000번의 프로세스 생성(fork() 사용) vs. 스레드 생성(pthread_create() 사용) ​          실행 시간의 단위는 second, time 커맨드에 의해 측정​          스레드 관리에 드는 resource도 프로세스에 비해 현격히 적음​                      Pthread에서는 ​          Parallelism 생성​      동기화(synchronization)​을 지원함​        Communication에 대한 explicit한 지원은 없음​          Shared-memory 모델이므로 communication은 implicit하게 일어남​​        스레드의 상태​          준비(ready) : 스레드가 실행될 수 있는 상태​      실행(running) : CPU의 서비스를 받고 있는 상태​      블록(block) : sleep(), read(), 세마포어 연산 등으로 기다리는 상태​      종료(terminated) : 스레드가 종료 또는 취소된 상태​​        준비 상태​          스레드가 처음 생성되면 준비 상태로 감​      CPU의 서비스를 받을 수 있는 상태​        실행 상태​          OS의 스케줄러에 의해 CPU의 서비스를 받고 있는 상태​      스케줄링에 의해 준비상태로 갈 수 있음​        블록 상태​          실행 상태에서 즉시 처리할 수 없는 작업을 만나는 경우​                  read(), wait(), sleep(), 세마포어/뮤텍스/조건변수를 기다리는 경우​                    원하는 조건이 만족되면 준비 상태가 됨​        종료 상태​          스레드 시작함수에서 return 또는 pthread_exit()가 호출된 경우​      사용하던 자원의 대부분을 시스템에 반납​      종료 상태 값을 부모 스레드에게 넘겨주기 위한 자원은 부모 스레드에서 pthread_join()을 통해 읽어가면 완전히 삭제​        Application 프로그램은 하나의 스레드로 시작​          Main 스레드 또는 master 스레드로 불림 ​        pthread_create() 호출에 의해 새로운 child 스레드를 생성​          새로운 child 스레드의 생성은 procedure 호출의 형태를 띔​        pthread_exit() 또는 pthread_join() 호출에 의해 새로 생성되었던 스레드 종료​          Master 스레드만 남게 됨​        스레드 생성int pthread_create (​  pthread_t   *thread, // 생성된 스레드의 핸들 ​  pthread_attr_t   *attr, // 스레드 속성을 지정하는 인자​  void   *(*start_routine) (void *), // 스레드 시작함수(start routine) 주소​  void   *arg ) // 스레드 시작 함수의 인자(들)  thread : 새로운 child 스레드가 성공적으로 생성될 경우 생성된 스레드의 핸들​  attr : 생성되는 child 스레드의 속성을 지정(디폴트 값은 NULL)​  start_routine : 새로 생성되는 child 스레드를 지정하는 함수의 시작 주소​  arg : 시작 함수들의 인자(들)​  리턴 값 ​          성공시 0을 리턴​      에러 발생시 에러코드의 정수 값(errno)을 리턴​        Pthread 프로그램 컴파일  일반적으로 –lpthread 옵션이 필요​          스레드 라이브러리가 다른 라이브러리(예 : libc)에 통합된 경우는 불필요 ​        -D_REENTRANT 옵션​          멀티 스레드 환경에서 싱글 스레드의 경우와 구별된 errno를 사용하도록 함​      일반 함수들이 멀티 스레드 환경에 적합하게 동작하도록 함​        컴파일 예제​          Linux/GCC의 경우​                  % gcc test.c –lpthread (-lpthread 옵션에 –D_REENTRANT 포함)​                    Solaris/Studio 컴파일러의 경우​                  % cc –mt test.c (-mt 옵션에 –D_REENTRANT 포함, 스레드 라이브러리는 libc 라이브러리에 포함됨) ​                      스레드 종료void  pthread_exit(void   *retval);​  생성된 child 스레드의 종료​          프로세스와 마찬가지로 return을 만나면 종료​      또는 pthread_exit() 호출시 종료​      pthread_exit() 호출에 의해 child 스레드가 종료할 경우 할당되었던 자원들은 반납되지 않음​      나중에 pthread_join() 호출에 의해 반납됨 ​      Detach 된 스레드는 예외  ​      int  pthread_join(pthread_t   thrd,   void   **thread_return);  Parent 스레드에서 호출​          자신이 생성한 child 스레드가 종료할 때까지 기다림​                  thrd​                          종료를 기다릴 스레드의 핸들​                                thread_return​                          child 스레드의 종료 상태가 저장됨​              NULL로 하면 종료 상태를 받지 않음​              child 스레드의 종료값은 return, pthread_exit()로 남길 수 있음​                                            Child 스레드가 종료되기 전에 parent 스레드가 먼저 종료되지 않게 할 때 사용​          Parent 스레드가 종료하면 child 스레드가 함께 종료되며​      Child 스레드의 작업이 모두 이루어 지지 않은 상태일 수 있음​        Child 스레드의 종료 시점을 정확히 파악하여 어떤 작업을 하고 싶거나 종료 상태 값을 얻기 위해 사용​  종료된 child 스레드에 할당되었던 resource 들은 반납됨 ​  스레드 Detachint   pthread_detach(pthread_t   thrd);  Detached 스레드​          Join이 가능한 스레드(pthread_join()을 사용)와 대비​      Parent 스레드가 생성한 child 스레드에 대해 pthread_detach()를 호출하면 parent 스레드가 나중에 wait하지 않음​                  빠른 스레드의 실행에 도움이 됨​                    Detach 된 스레드에 pthread_join()를 호출하면 error 발생​      Detach 된 스레드는 pthread_join() 호출 없이 할당되었던 resources 들이 반납됨 ​                  스레드 Attribute                      스레드의 attribute는 스레드가 생성될 때 설정됨          이미 생성된 스레드의 attribute 값을 바꾸는 것은 제한적인 경우에만 가능 ​        따라서 pthread_create를 호출하기 전에 원하는 attribute 값들을 설정해야 ​  Attribute 설정과 관련된 pthread API          pthread_attr_init()​      pthread_attr_destroy()​      pthread_attr_setdetachstate()​      pthread_attr_getstacksize()​      pthread_attr_setstacksize()​        스레드는 joinable 또는 detached 스레드로 생성 가능​  Default stack size는 OS 마다 다른 값을 지정​  최소 스택 크기는 변수 PTHREAD_STACK_MIN에 저장된다  기타 스레드 Attribute들  Guard size: 스택 오버플로로부터 보호하기 위해 사용  스케줄링 속성 상속(스레드 생성에서) or not  Scheduling parameter(s): 특히 스레드 우선순위  Scheduling policy: FIFO or Round Robin​  Contention scope: 이 스레드는 어떤 스레드와 CPU를 놓고 경쟁하는가  Stack address: 스택의 위치를 ​​명시적으로 지정  Lazy stack allocation: 요청 시 할당(lazy) 또는 한 번에 모두 선행Synchronization​  스레드의 동기화 문제  여러 스레드가 공유 데이터에 접근하여 값들을 읽거나 저장          Run time 에 공유 데이터가 어떤 값을 가질지 예측하기 어려움​        Data race 문제  두 개 이상의 스레드가 같은 변수를 access, 그 중 적어도 하나의 access는 write 연산을 실행​  Access들이 동시에 발생, 그러나 동기화되지 않은 상태로  기본적인 동기화 Mechanism: Mutex  스레드들이 서로 배타적으로 공유데이터에 접근하도록 하기위해 Mutex (mutual exclusion)를 사용​          스레드들은 거의 독립적으로 실행​      Common한 data structure를 사용함​        Mutex외에도 세마포어를 많이 사용​  Mutex 사용방법  Critical 영역에 들어가기 전에 mutex 를 잠금​  Critical 영역에서 나오면서 mutex 잠금을 해제​  다른 스레드들은 이 mutex 잠금이 해제될 때까지 대기​  Mutex 사용 절차pthread_mutex_t mutex; // 뮤텍스 선언​Pthread_mutex_init(&amp;mutex); // 뮤텍스 초기화 작업​pthread_mutex_lock(mutex); // 뮤텍스 잠금​... // 공유데이터(크리티컬 영역) 액세스​pthread_mutex_unlock(mutex); // 뮤텍스 잠금 해제​  Mutex 선언 및 초기화  Mutex의 변수 타입 : pthread_mutex_t​  여러 스레드들이 사용하므로 전역 변수로 선언​  반드시 초기화를 해야 사용 가능​  초기화 방법​          함수를 통한 초기화​      매크로를 통한 초기화​        Mutex 초기화에 특별한 타입을 지정하지 않음 ​  단 한 번의 잠금만 허용​          스레드 A가 잠금을 하고 있는 상황에서 스레드 B가 잠금을 시도하면 B는 A의 잠금이 해제될 때까지 기다림​      A에 의해 잠긴 뮤텍스에 대해 A가 다시 잠금을 시도하면 deadlock이 발생하여 A는 영원히 블록 상태가 됨​      이러한 현상을 피하기 위해 pthread_mutex_trylock()을 사용​      Mutex를 얻지 못하는 경우 블록되지 않고 바로 리턴되고 EBUSY 에러 발생​        잠금되어 있는 않은 mutex에 잠금해제를 시도하면 아무 동작을 하지 않음​  Mutex의 삭제  더 이상 mutex를 사용하지 않을 때 삭제​  잠금 상태의 mutex를 삭제하려 시도하면 에러 발생​          EBUSY 에러 발생​        Mutex의 현재 상태(잠금, 잠금해제) 확인 함수는 없음​  안전하게 mutex를 삭제하기 위해서는 삭제 전에 무조건 mutex를 해제해야 함​pthread_mutex_unlock(&amp;mutex);​pthread_mutex_destory(&amp;mutex);  Mutex와 deadlock  Deadlock​          두 개의 스레드가 두 개의 mutex를 사용​      각 스레드가 mutex를 하나씩 잠그고 있는 상태에서 상대방의 mutex 해제를 기다리는 현상​      deadlock이 발생하면 프로그램은 영원히 블록​        Deadlock을 피하는 방법​          Mutex를 잠그는데 일정한 순서를 정하여 사용​        성능​          Mutex를 많이 사용하면 프로그램의 성능이 저하됨​      Mutex를 얻은 상태에서 처리하는 작업의 양(Critical Section)을 최소화 해야 함​                  Mutex가 잠긴 동안 다른 스레드가 블록될 가능성이 높으며 Critical Section이 길수록 전체 프로그램 성능이 저하될 수 있음​                    다른 data structure에 대해서는 다른 lock을 적용        Spin Lock​  Mutex lock 과 달리, lock을 얻을때까지 CPU cycle을 소비하면서 계속 spinning 함​          Mutex lock : lock을 얻지 못하면 바로 sleep 모드로 들어감 ​      Adaptive mutex lock : 잠깐 동안 spinning 하다가 sleep 모드로 들어감 ​        Spin lock APIs​          pthread_spin_init() ​                  PTHREAD_PROCESS_PRIVATE : 생성되는 spin lock이 프로세스에 private 하게 사용될 경우 ​          PTHREAD_PROCESS_SHARED : 다른 프로세스와 공유할 경우​                    pthread_spin_lock()​      pthread_spin_unlock()​      pthread_spin_destroy()​        pthread_spin_trylock() ​          Lock을 얻으려 시도​      Lock을 얻는 경우나 얻지 못하는 경우 모두 바로 리턴        Barrier  Barrier: 글로벌 동기화          특히 SPMD(동일한 기능의 여러 복사본을 병렬로 실행할 때)        Simple use of barriers: all threads hit the same one​          work_on_my_subgrid();​      barrier;​      read_neighboring_values();​      barrier;​        more complicated: barriers on branches (or loops)​          if (thread_id % 2 == 0) {​      work1();​      barrier; } ​      else ​      barrier;​            모든 스레드 라이브러리에 Barrier가 제공되지 않는다    Barrier APIs​          pthread_barrier_init(&amp;barrier, attr, no_of_threads)                  pthread_barrier_t  barrier;          Default value of attr is “NULL”                    pthread_barrier_destroy(&amp;barrier)      pthread_barrier_wait(&amp;barrier)      Semaphore  Semaphore : counting and signaling mechanism          지정된 개수의 아이템들을 위한 접근 제어에 활용                  아이템 개수가 하나이면 mutex와 동일​                    스레드간에 신호를 보내는 역할​        두 종류의 semaphore​          Named semaphore​      Unnamed semaphore        Unnamed semaphore의 초기화​sem_t *sem;​int sem_init(sem_t *sem, int pshared, unsigned int value);  sem : 세마포어 객체​  pshared : 다른 스레드와 공유할 것인지의 여부​  value : 세마포어의 초기값​  예 : sem_init(&amp;sem, 0, 10)​Unnamed semaphore의 종료​      sem_destroy(&amp;sem)    Named semaphore의 초기화​          sem_open(sem_name, FLAGS, permission, value)​      예 : sem_open(“/my_sem”, O_CREAT, 0777, 10)​        Named semaphore의 종료​          sem_close(sem) : semaphore와의 연결을 끊지만, 시스템 상에 semaphore를 남겨둠​      sem_unlink(sem_name) : semaphore에 사용된 resource를 free 시킴        세마포어의 값을 감소시키는 함수 ​          크리티컬 영역에 진입하면서 자동으로 세마포어의 값을 감소(-1)시킴      int sem_wait(sem_t *sem);​int sem_trywait(sem_t *sem);      세마포어의 값을 1 증가시키는 함수int sem_post(sem_t *sem);        현재 세마포어의 값을 읽는 함수int sem_getvalue(sem_t *sem, int *sval);  Conditional Variable  조건변수​          스레드 간에 특정 조건이 발생했음을 알리는 통신을 위해 사용​      조건변수는 반드시 mutex와 함께 사용되어야 한다​        조건변수의 생성​          함수를 이용한 초기화와 매크로를 이용한 초기화 방법이 있음​pthread_cond_t cond;​      pthread_cond_init(&amp;cond, NULL); // 함수를 이용한 초기화​pthread_cond_t cond = PTHREAD_COND_INITIALIZER; // 매크로를 이용​  조건변수의 삭제​pthread_cond_destory(&amp;cond);  조건변수를 기다리는 함수​int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);​  cond : 조건 알림이 발생할 때까지 대기​  mutex : mutex가 cond를 제어​  동작​          Mutex 해제 -&gt; 블록 상태 -&gt; 조건 알림을 받음 -&gt; 깨어나면서 mutex를 얻음​        조건 알림을 보내는 함수​int pthread_cond_signal(pthread_cond_t *cond);      조건 변수 cond에 의해 기다리던 조건이 발생했음을 대기하고 있는 스레드에게 통보​    하나의 생산자 스레드와 여러개의 소비자 스레드가 있는 경우​          pthread_cond_signal() 함수를 사용하면 단 하나의 스레드만 깨우고 나머지 스레드는 영원히 기다릴 가능성이 있음​      pthread_cond_broadcast()를 사용​                  여러 스레드를 동시에 깨움​          깨어난 스레드들 중 공유 데이터를 위한 mutex를 얻은 스레드만이 공유 데이터에 접근​                      Producer-Consumer 예제 ​          Queue를 사용​                  생산자 스레드는 queue에 메시지 쓰기 작업을 수행​          소비자 스레드는 queue에서 메시지 읽기 작업을 수행​          운영체제의 scheduler는 생산자와 소비자 스레드가 교대로 실행되는 것을 보장하지 않음​                    조건변수를 사용하여 queue의 길이가 0보다 클 경우 소비자 스레드를 깨움​      ",
        "url": "/st-10"
    }
    ,
    
    "sc-17": {
        "title": "__방화벽__",
            "author": "lee989898",
            "category": "",
            "content": "방화벽  Firewalls?  조직의 내부망을 외부 인터넷과 격리시켜 일부 패킷은 통과시키고 나머지는 차단하는 HW와 SW의 조합  Firewall 서비스  Traffic monitoring​  Traffic control​  NAT – 내부 network 보호​  VPN – 내부 traffic 노출차단  Firewalls을 쓰는 이유  서비스 거부 공격 방지:          SYN 플러딩: 공격자가 많은 가짜 TCP 연결을 설정하고 “실제” 연결을 위한 리소스가 남지 않음        내부 데이터의 불법적인 수정/접근을 방지한다          예: 공격자가 CIA의 홈페이지를 다른 것으로 교체        내부 네트워크(인증된 사용자/호스트 집합)에 대한 승인된 액세스만 허용  Firewall types  Stateless packet filter​  지나는 packet에 대해 미리 정의된 규칙에 따라 pass/block 결정​  Packet의 다음 정보를 기반으로 결정​          source IP address, destination IP address​      TCP/UDP source and destination port numbers​      ICMP message type​      TCP SYN and ACK bits​        example 1: block incoming and outgoing BitTorrent traffic source or dest port = 6881-6889​      example 2: Block outbound Web access, port=80.        ACL: 규칙이 있는 테이블, 들어오는 패킷에 위에서 아래로 적용: (액션, 조건) pair    장점​          Simple : 동작방식이 직관적이며 간단, 구현용이​      Fast​        단점​          application layer protocol의 취약점공격에 차단 불가능​      사용자/application 별 서비스 제공불가능 ​      필터링시 사용 정보가 제한되어서 정교한 필터링 불가능​      IP주소 위변조 여부 판단 불가능        Statefull packet filter​  동일한 상태정보를 가지는 패킷들을(packet flow) 그룹으로 필터링​          상태정보: src IP/port, dst IP/port ​        장점​          정교한 필터링​        단점​          상태정보 테이블 검사수행에 따른 성능저하​        Application gateway      애플리케이션 데이터 및 IP/TCP/UDP 필드에서 패킷을 필터링한다    장점​          Application layer protocol 공격 차단​      사용자 인증가능​      정교한 Log, audit 가능​        단점​          응용 프로그램마다 다른 응용 프로그램 게이트웨이가 필요하다(텔넷, http, ftp, 이메일 …)      모든 데이터가 게이트웨이를 통과하기 때문에 성능이 저하됨        방화벽 및 게이트웨이의 한계  IP spoofing: 라우터는 데이터가 “실제로” 청구된 소스에서 오는지 알 수 없다  여러 앱의 경우. 특별한 대우가 필요하며 각각의 앱이 있다  클라이언트 소프트웨어는 게이트웨이에 접속하는 방법을 알아야 한다.          예를 들어, 웹 브라우저에서 프록시의 IP 주소를 설정해야 한다        내부 공격자 방어에 취약​  데이터 내용은 미확인 – 문서 등 내부에 심겨진 악성코드 방어 취약",
        "url": "/sc-17"
    }
    ,
    
    "sc-16": {
        "title": "__침입탐지__",
            "author": "lee989898",
            "category": "",
            "content": "침입탐지  IDS(침입탐지 시스템)  침입탐지시스템​  침입행위에 대한 탐지를 수행하고 탐지시 대응할 수 있도록 지원하는 일련의 시스템​  Intrusion?​          시스템에 허가되지 않은 방법으로 내부 자원에 접근​      Login 시도 (ID, PWD 추측)​      불법적으로 데이터 도용시도 (rootkit)​      Root/관리자 권한 획득시도​      메일발송 실행파일을 숨겨놓고 메일전송시도​      Backdoor 접근시도        패킷 필터링          오직 TCP/IP 헤더만 본다      패킷 간의 연관성을 알아 내기 어렵다        IDS          depp packet inspection: 패킷 콘테츠 까지 검사한다      다수의 패킷을 검사한다                  port scanning          network mapping          Dos attack                      Dectection 방법  Signature-based dectection​          침입사건들을 패턴화(signature)​    + Signature example​      실행 파일 첨부 메일 유형​      파일 읽기 시도 유형​      로그인 시도 유형​    + 장점​      known attack에 대해 효율적​    + 단점​      Unknown attack에 취약​      새로운 공격유형 발견때마다 signature 생성해야​      일반적으로 False negative rate 높음        Anomaly-based dectection​          정상범위를 벗어나는 사건을 탐지​    + Anomaly example​      휴일에 traffic 량이 평소보다 20%증가​      일반사용자가 갑자기 1000통 메일발송​      특정 호스트에 단시간 주문요청 100%증가​      국내 사용자 카드가 해외에서 결재​    + 장점​      Machine learning 처리​      Unknown attac에 대해 효율적​    + 단점​      정상범위 정의 어려움​      비정상탐지까지 기다려야​        IDS types  Network-based IDS​  Wireless IDS (wireless IDS)​  Host-based IDS​  Distributed Host-based IDS  Network-based IDS​  Example​          Network 망에 곳곳에 traffic을 모니터, 분석하여 침입탐지​        Example​          Ddos, worm  ​        장점 ​          Host는 부하적음 (하나의  NIDS로 여러 host보호)​      조기 탐지가능​      취약한 부분의 packet 을 정밀분석하여 다양한 침입탐지 ​        단점​          각 host 내부는 탐지제한​      전체 network 망에 부하        Wireless IDS (wireless IDS)​  무선통신 WLAN network망의 traffic 분석​  장점​          무선통신의 취약성위협 탐지​        단점​          Network 부하, 비용        Host-based IDS​  특정 host 컴퓨터내부를 모니터링, 분석하여 탐지​  Example​          로그분석, 파일시스템 기록분석, 실행코드분석 ​        장점​          악성sw 탐지용이​      내부공격자 탐지​        단점​          각 host마다 다름​      Host 부하        Distributed Host-based IDS  여러 HIDS들이 연계하여 전체적으로 host들을 분석하여 탐지 ​  장점​          효율적이고 정확성​      공격들의 연관관계 파악용이​        단점​          HIDS보다 복잡, 부담        Honey Pot  꿀단지​  의도적으로 해커의 침입을 유도하는 시스템​  해커 정보수집, 공격유형파악, 대응전략수립, 법적증거 ​  침입자 활동감시, 로그기록  IDS 평가 기준  False Positive rate​          정상을 침입으로 판단하는 확률​        False Negative​          침입을 정상으로 판단하는 확률​        True Positive rate​  True Negative rate​  IPS (Intrusion Prevention System)  침입방지시스템​  IDS+침입방지기능​  Example​          IDS로 침입탐지하고 계정, 연결 등 차단​      ",
        "url": "/sc-16"
    }
    ,
    
    "algorithm-08": {
        "title": "분기 한정",
            "author": "lee989898",
            "category": "",
            "content": "분기 한정  분기 한정  안내 표지판과 같은 지표를 활용하여 최종 해를 찾는 기법  상태 공간 트리 이용  최적화 문제에만 적용 가능  최적 해를 구하기 위해 모든 해를 다 고려해야 하므로 트리의 노드를 순회하는 방법과 무관  하지만 최적의 해에 더 빨리 도달하기 위해 가장 좋은 한계값을 가진 노드를 먼저 탐색하는 최선 우선 탐색 사용  분기 한정의 핵심 원리  상태 공간 트리의 각 노드를 탐색할 때마다, 그 노드가 유망한 지를 알기 위해 한계값(그 노드로부터 확장하여 얻을 수 있는 실현    가능한 해의 한계)을 계산한다.  만약 그 한계값이 그 때까지 찾은 최고 해의 값보다 더 좋으면 그 노드는 유망하다고 판단하고 확장을 하면서 탐색을 계속한다. 그렇지 않으면 그 노드는 유망하지 않다고 판단하고 탐색을 멈춘다.  노드에서 탐색 중단 이유  노드의 한계값이 그 때까지 찾은 최고 해의 값보다 못하다  노드는 문제의 제약 사항들을 만족시키지 못하므로 실현 가능한 해가 될 수 없다  노드가 나타내는 실형 가능한 해들의 부분 집합이 더 이상의 추가 선택들을 할 수 없는 경우에 해당한다          세 번째 경우에 실현 가능한 해에 대한 목적 함수의​ 값이 그때까지 찾은 최고 해의 값보다 더 좋다면 ​최고 해의 값을 목적 함수의 값으로 갱신한다.​        최선 우선 탐색  최적의 해에 더 빨리 도달하기 위한 전략  너비 우선 탐색 사용  한 유망한 노드의 모든 자식 노드들을 만든 후 남아 있는 유망하나 확장되지 않은 노드들 중에서 최고의 한계값을 가진 노드를먼저 확장  최고의 한계값을 가진 노드를 우선적으로 선택하기 위해서 우선 순위 대기열 사용  우선 순위 대기열은 힙을 사용하여 효과적으로 구현  너비 우선 탐색  트리의 노드들을 다음과 같은 순서로 탐색  트리의 루트 노드를 먼저 탐색  다음으로 트리의 수준 1에 있는 모든 노드를 왼쪽에서 오른쪽으로 탐색  다음으로 수준 2에 있는 모든 노드들을 왼쪽에서 오른쪽으로 탐색  마지막 수준까지 이 과정을 반복  최선 우선 탐색 알고리즘  v,u : 트리의 노드  value(v): 노드 v에 대응되는 실현 가능한 해의 값  bound(v): 노드 v의 한계값  best: 현재까지 찾은 최고 해  PQ: 상태 공간 트리를 대신하는 우선 순위 대기열          PQ는 유망하나 확장되지 않은 노드들 포함      Best-First-Branch-and-Bound(state-space-tree T)​// 입력: T – 상태 공간 트리​// 출력: 최적 해의 값​1  initialize(PQ) // PQ를 빈 대기열로 초기화​2  v = T의 루트 노드​3  best = value(v)​4  insert(PQ, v)           // 노드 v를 PQ에 삽입​5  while (not empty(PQ)) { // PQ에 노드들이 남아 있는지 확인​6    v = remove(PQ) // PQ에서 최고 한계값을 가진 노드를 제거​7    if (bound(v) &gt; best) // 노드 v가 유망한지 확인​8       for (each child u of v) {​9           if (value(u) &gt; best) best = value(u)​10          if (bound(u) &gt; best) insert(PQ, u)  }  }​11  return best​  배낭 채우기 문제  N(&gt;=1)개의 물건들 중에서 배낭의 용량 C를 초과하지 않고 배낭에 넣을 수 있는 물건들의 최대 가치를 구하라  각 물건은 배낭에 넣거나 넣지 않을 수 있더  $w_i$: 물건 i, 1&lt;=i&lt;=N,의 무게  $v_i$: 물건 i, 1&lt;=i&lt;=N, 의 가치  가정: 물건들이 단위 무게당 가치($v_i$ / $w_i$)의 내림차순으로 정렬되어 있다  배낭 채우기 상태 공간 트리  루트 노드: 배낭에 물건들을 넣기 전의 초기 상태  트리의 수준 i, 1&lt;=i&lt;=N, 에 있는 각 노드는 첫 번째 물건부터 i번째까지의 물건들 중에서 배낭에 포함된 물건들의 특정 선택을 나타낸다. 이 특정 선택은 루트 노드부터 그 노드까지의 경로에 의해 유일무이하게 결정된다  한 노드의 왼쪽에 있는 자식 노드는 다음 물건을 배낭에 넣는 경우를 나타내고 오른쪽에 있는 자식 노드는 다음 물건을 배낭에 넣지 않는 경우를 나타낸다. 이 선택의 총 무게 w와 총 가치 v를 해당 노드에 한계값과 같이 저장한다. 그 노드의 한계값은 이 선택 후 남은 물건들 중 일부를 포함시킴으로써 얻을 수 있는 배낭의 물건들의 가치에 대한 상한을 나타낸다.  노드의 한계값 계산 방법  배낭에 이미 포함된 물건들의 총 가치 v에 배낭의 남은 용량(C - w)를 전부 다음 물건으로만 채운 경우의 가치를 더한다(w는 배낭에 이미 포함된 물건들의 총 무게). 즉, 트리의 수준 i, 0 &lt;= i &lt; N, 에 있는 노드의 한계값은 다음과 같이 계산된다  한계값 &gt;= 실현 가능한 해의 값  트리의 수준 n에 있는 노드의 한계값 = v  최선 우선 탐색 알고리즘  상태 공간 트리의 각 노드에 다음 값들을 저장한다.​          level: 트리에서 노드의 수준​      weight: 이미 선택된 물건들의 총 무게​      value: 이미 선택된 물건들의 총 가치​      bound: 한계값​        root: 루트 노드​  u, v:  노드 ​  maxValue: 지금까지 찾은 최고 해의 값​  PQ: 상태 공간 트리를 대신하는 우선 순위 대기열​          주: PQ는 유망하나 확장되지 않은 노드들 포함      KnapsackBandB(N, Wt[0 . . N – 1], Val[0 . . N – 1], C)​// 입력: N – 물건들의 수​// Wt[0 . . N – 1]– 각 물건의 무게를 저장하는 배열​// Val[0 . . N – 1] – 각 물건의 가치를 저장하는 배열​// C – 배낭의 용량​// 출력: 배낭에 넣을 수 있는 물건들의 최대 가치​1  initialize(PQ) // PQ를 빈 대기열로 초기화​2  maxValue = 0 // maxValue를 0으로 초기화​3  root.level = 0​4  root.weight = 0​5  root.value = 06  root.bound = computeBound(root) // 루트 노드의 한계값 계산​7  insert(PQ, root)          // root를 PQ에 삽입8  while (not empty(PQ)) {          // PQ가 비어 있지 않은 동안 반복​9    v = remove(PQ)          // PQ에서 최대 한계값을 가진 노드 v를 끄집어 낸다​10   if (v.bound &gt; maxValue) {          // 노드 v가 유망하면 확장​11      u.level = v.level + 1          // 노드 u를 노드 v의 자식 노드로 만든다​12      u.weight = v.weight + Wt[v.level] // u는 다음 물건을 넣는 경우​13      u.value = v.value + Val[v.level];​14      if (u.weight &lt;= C and u.value &gt; maxValue)​15         maxValue = u.value                // maxValue를 더 나은 해의 값으로 바꾼다​16      u.bound = computeBound(u) // 자식 노드의 한계값을 계산​17      if (u.bound &gt; maxValue)​18         insert(PQ, u);  // u가 유망하므로 PQ에 삽입​19      w.level = v.level + 1                 // 노드 w는 다음 물건을 넣지 않는 경우​20      w.weight = v.weight  ​21      w.value = v.value​22      w.bound = computeBound(w) // 자식 노드의 한계값 계산​23      if (w.bound &gt; maxValue)​24         insert(PQ, w);  // w가 유망하므로 PQ에 삽입​     }}​25  return maxValue computeBound(u) // 노드 u의 한계값을 계산// 입력: u - 트리의 노드// 출력: u의 한계값1 if(u.weight &gt;= C) return 02 else if(u.level &lt; N)            return u.value + (C - u.wight) x (Val[u.level]/Wt[u.leve])3 else return u.value  시간 복잡도: O($2^n$)  일 배정 문제  N(&gt;1) 명의 사람에게 N개의 일을 배정  한 사람에게 정확하게 하나의 일만 배정  모든 일은 정확하게 한 사람에게 배정  C[i,j], 1&lt;= i, j&lt;=N: 사람 i를 일 j에 배정하는 비용  총 배정 비용이 최소가 되도록 일을 배정  비용 행렬의 각 행에서 한 요소를 선택하는 문제와 같다  선택된 요소들은 다른 열에 있어야 하고 총 배정 비용이 가장 작아야 한다  가능한 해는 n-짝(n-tuple)($j_1$,$j_2$, … ,$j_n$)으로 나타낼 수 있다. $j_i$, 1 &lt;=i &lt;= n, 는 사람 i에게 배정된 일의 번호  완전 탐색 알고리즘  아이디어: 가능한 일 배정과 1부터 N사이의 정수들의 순열과 일대일 대응 관계가 있다는 사실을 이용  알고리즘: 1부터 N사이의 정수들의 모든 순열을 생성하고 각 순열에 대응하는 일 배정의 총 비용을 계산한 후 총 비용이 가장 작은 일 배정을 선택한다  시간 복잡도: 1부터 N사이의 정수들의 모든 순열의 수 = N!(&gt;$2^n$)          O(N!)        분기 한정 알고리즘  상태 공간 트리 = N항(N-ary) 트리​  해: 루트 노드로부터 잎까지의 경로​  살아 있는 노드: 아직 가지 치지 않은 유망한 잎​  현재 트리의 살아 있는 노드들중에서 가장 유망한 노드의 모든 자식 노드들을 생성 ​  가장 유망한 노드 = 한계값이 가장 작은 노드​  최선 우선 탐색 사용  최선 우선 탐색 알고리즘  상태 공간 트리의 각 노드에 다음 값들을 저장한다          personNumber: 사람의 번호​      jobNumber: 일의 번호​      sumAssignedCost: 현재까지 배정된 일들의 비용들의 합​      bound: 한계값​      parent: 부모 노드​      assigned: 사람들에 일들의 배정 여부를 저장하는 배열        root: 루트 노드  child: 자식 노드  queue: 살아 있는 노드들을 포함하는 우선 순위 대기열  일 배정 분기 한정 알고리즘JobAssignmentBandB(N, C[0 . . N – 1, 0 . . N – 1])​// 입력: N – 사람들(일들)의 수​//        C[0 . . N – 1, 0 . . N – 1]) – 특정 사람에게 특정 일을 배정하는 비용 배열​// 출력: 일 배정 결과와 최소 배정 비용​1  Initialize(queue) // queue를 빈 대기열로 초기화​// 루트 노드의 값들을 초기화​2  root.personNumber = -1​3  root.jobNumber = -1​4  root.sumAssignedCost = 0​5  root.parent = null​6  for (i = 0; i &lt; N; i++) root.assigned[i] = false​// 루트 노드의 한계값 계산​7  root.bound = computeBound(-1, -1, root.assigned)​// 루트 노드를 queue에 삽입​8  queue.insert(root)// queue가 비어 있지 않은 한 한계값이 최소인 살아 있는 노드를 ​// 찾아서 그 노드의 자식 노드들을 queue에 추가​9  while ( not queue.empty( )) {​      // 최소 한계값을 가진 노드를 queue에서 끄집어 낸다​10   minNode = queue.remove( )​11   i = minNode.personNumber + 1  // i는 일을 배정할 다음 사람​12   if (i = N) {​13      모든 사람들에게 일들이 배정된 결과를 출력한다​14      최소 배정 비용을 반환한다      }// 사람 i에 배정 가능한 일을 배정하는 모든 자식 노드를 만들어 queue에 추가​15  for (j = 0; j &lt; N; j++) {​16      if ( not minNode.assigned[j] ) { // 일 j가 배정되지 않았는지 확인 ​17         child.personNumber = i​18         child.jobNumber = j​19         for (k = 0; k &lt; N; k++) child.assigned[k] = minNode.assigned[k]​20         child.assigned[j] = true21         child.parent = minNode​            // 배정된 일들의 총 비용에 새로 배정된 일의 비용을 더한다​22         child.sumAssignedCost = minNode.sumAssignedCost + C[i][j]​            // 새 자식 노드의 한계값 계산​23         child.bound = child.sumAssignedCost + computeBound(i, j, child.assigned)​            // 새 자식 노드를 queue에 추가​24        queue.insert(child)  }​        }​     }computeBound(x,y,assigned)// 입력: x - 방금 배정된 사람의 번호//      y - 방금 배정된 일의 번호//      assigned - 사람들에 일들의 배정 여부를 알려 주는 배열// 출력: 남은 사람들에게 남은 일들을 배정하는 데 드는 총 비용의 하한1 bound = 02 for (i = x + 1; i &lt; N; i++){3       minCost = $\\infty$4       minIndex = -15       for ( j = 0; j &lt; N; j ++){ // 사람 i에 일을 배정하는 최소 비용을 찾는다6           if(not assigned[j] and (j !=y) and C[i][j] &lt; minCost){7               minIndex = j8               minCost = C[i][j]}}            bound = bound + minCost // 다음 사람에게 배정 가능한 일의 최소 비용을                                    // 더한다            }9 return bound  시간복잡도: O(N!)",
        "url": "/algorithm-08"
    }
    ,
    
    "pl-19": {
        "title": "Lambda Calculus​",
            "author": "lee989898",
            "category": "",
            "content": "Lambda Calculus​Why functional programming?​함수 프로그래밍이 왜 필요한가?소프트웨어 제품이 신뢰성이 낮고, 관리하기 어려우며, 올바른지 증명하기 하기 어렵다. 그 이유는 다음과 같다  소프트웨어를 새로 릴리즈할 때마다, 알려진 오류는 수정되나 새로운 오류가 발견된다​  소프트웨어의 정밀한 설계는 오랜 기간의 연구 개발을 필요로 하나, 현실적으로 시장 출시 압박이 우선한다 ​  하드웨어의 처리 능력이 증가함에 따라 과거에 못하던 복잡한 어플리케이션을 자동화하느라, 소프트웨어의 복잡도가 증가한다이러한 현상을 극복하기 위해, 컴퓨터 과학자들은 두가지 중요한 문제를 풀어야 한다  저비용으로 대규모 소프트웨어의 신뢰성과 사용자 편의성을 개선하는 방법 ​  저비용으로 처리 능력을 증가시키는 방법이러한 문제에 대한 해결책으로  명령형 프로그래밍을 지지하는 측에서는, 소프트웨어 공학, 프로그램 증명 기법, 스펙을 프로그램으로 변환하는 기법, 새로운 (병렬) 컴퓨터 아키텍처 등을 연구해 왔다  함수 프로그래밍을 지지하는 측에서는 프로그램으로서의 함수를 대안으로 연구해 왔다Imperative and Functional programming style​계산 모델을 튜링 머신에 기반한 IPL은 기본 개념으로 ​메모리, 변수, 할당문, 반복처리(iteration)을 갖는다  메모리는 프로그램과 데이터를 저장한다  변수는 메모리 셀을 차지하고 있으며, 계산 결과의 변화에 따라 변경 가능한 값을 저장한다 ​  할당문은 계산 결과를 메모리에 저장하며, 이를 통해 변수의 값을 변경시킨다  Iteration은 값이 변하는 변수를 통해 반복처리를 제어한다명령형 프로그래밍의 장점은 실행 시스템의 구현이 단순하고 저비용 고효율이다명령형 프로그래밍의 단점은 ​  Goto는 아무런 조건없이 점프만하기 때문에, ​프로그램의 올바름을 판단하기 어렵게 만든다  난로컬 변수와 할당문으로 인해 부작용이 발생하며, ​이로 인해 프로그램의 올바름을 판단하기 어렵게 만든다  알고리즘의 어느 부분이 동시 처리 가능한지, ​동시처리하면 안되는지 탐지하기 어려워서, ​알고리즘이 필요 이상으로 순차적이다​  최근 들어 많은 연구자들은 소프트웨어 위기와 속도 문제가 ​명령형 언어와 튜링 머신의 계산 모델에 기인한다고 추측하고 있다함수 프로그램에서는  함수 파라미터의 실제 ‘값’이 함수 호출의 결과를 유일하게 결정한다 ​  할당문이 없어서 함수의 부작용이 발생할 수 없다FUNCTION increment (INTEGER value) : INTEGER;​BEGIN​value + 1​END;​:​print(increment (41));​ print(increment (41));​함수의 결과는 파라미터의 값에 의해서만 결정되므로, ​어떠한 조건 하에서도 그 결과는 같다. ​이것을 referential transparenc라고 한다. ​이러한 이유로, 함수 increment의 결과 값은 둘다 42이다함수 프로그래밍 언어에서는 함수를 ‘일등 시민’으로 취급한다. 따라서 함수를 파라미터로 주고 받을 수 있다명령형 프로그래밍 언어에서는 함수를 파라미터로 주고 받을 수 없다함수 프로그래밍 언어는 함수의 일반적인 사용(합성 함수 f(g(x)) 등)을 지원한다. 이것은 종래의 명령형 언어에서 허용되지 않는다함수 프로그래밍 언어는 계산 모형을 람다 계산학에 기반하고 있으며, ​기본 개념으로 표현식(expression), 리커젼, 평가, 변수가 있다표현식은 수학식을 의미하며, ​리커젼은 재귀 함수에 의한 반복처리로서, iteration과 다르다평가는 함수의 실행을 의미하지만, 아무 것도 수정하지 않는다변수는 수학적 의미의 변수로서 알려지지 않은 값을 가지며, ​구체적인 값의 추상화일 뿐, 메모리를 차지하지 않는다. 따라서 값의 placeholder 역할을 하며, 수정 불가능하다FPL에서는 명령형 언어적 의미의 변수가 없으므로, ​iteration이 불가능하며, ​대신에 반복처리를 위한 리커젼이 있다FPL의 장점은 ​IPL의 기본 개념이 없어서, 소프트웨어 신뢰성을 높인다프로그래머는 함수를 정의하기만 하고, 인터프리터(실행 시스템)가 계산한다할당문이 없고, 변수의 개념이 IPL의 변수와 다르고, 부작용이 없다변수는 ‘아직 알려지지 않은 값’을 명명하고 언급한다부작용이 없어서, 올바름 증명이 쉽고, 함수의 평가는 순서에 무관하다. 따라서 FPL은 병렬 처리에 적합하다FPL의 단점은, ​우선, 실행 속도가 매우 느려서 비효율적이다그 이유는 다음과 같다  머신 아키텍처가 함수 언어에 적합하게 설계되지 않았다 ​  함수 호출 비용이 비싸다. 특히 지연 평가시에  파괴적 갱신(갱신되면 먼저 값이 없어짐)에 적합하므로, ​효율적인 컴파일 방법을 찾기 어렵고, 어떤 알고리즘에 대해, 시간 및 공간 복잡도가 너무 높다. ​이러한 경우에 효율을 위해 프로그램 변환이 필요하다  아직 효율적인 컴파일 방법이 널리 사용 가능하지 않다. 많은 경우에 함수 프로그램의 효율이 받아 들일 수 있는 수준에 있지만, ​컴파일 방법이 매우 복잡하고 연구 수준에 머물어 있다명령형 프로그램의 특성이 강한 어플리케이션에 아직 부적합하다  상호 작용이 강한 어플리케이션을 함수 프로그래밍 스타일로 표현하는 능력이 아직은 부족하다. 이들 어플리케이션으로는 상호적 프로그램, DBMS, OS, 프로세스 컨트롤 등이다  함수 프로그래밍 기술 개발이 필요하다. 함수 스타일로 표현하기 어려운 어플리케이션을 함수 스타일로 표현하는 방법을 개발하는 것이 필요하다.  현재, 윈도우, 다이알로그, 메뉴 등을 사용하는 상호적 프로그램을 함수 언어로 명세화하는 방법이 알려져 있다Functions as programs ​함수가 프로그램인가?팩토리알을 구하는 함수는 프로그램이라고 간주해도 문제가 없다. ​프로그램의 종료 확인 함수(Halting)는 계산 가능하지 않고, 따라서 원하는 결과를 생산하지 못한다함수가 임의의 프로그램에 대해 halting 함수를 계산한다고 하자. ​만일 파라미터 프로그램이 종료되지 않는다면 ​Halting 함수는 종료되지 않을 것이고, ​Result 0이 절대로 생산되지 않는다이들 예에서 함수는 람다 계산학에 기반한 계산 모델을 사용하여 평가된다. 평가는 IPL의 실행과 유사하지만, IPL의 파괴적 갱신이 없다는 면에서 다르다.​ 람다 계산학은 함수 정의 방식과 변수 대체 규칙(substitution)으로 구성된다FPL로 작성된 프로그램은 함수의 모음과 초기 표현식으로 구성된다. ​초기 표현식이란 모든 파라미터가 상수인 (또는 상수로 대체된) 표현식을 말하는데, ​이 식은 평가되어야 한다. -&gt; reduce​함수 정의는 표현식 내에서 다음 형태로 구성된다. ​(여기서는 scheme 문법을 차용함)define (함수명 파라미터1 … 파라미터n) 표현식)이와 같이 함수 프로그램을 정의하는 것은 recursive하다표현식은 함수 결과를 명세화하며, 값, 파라미터, 함수 적용(application)을 나타낸다. ​함수 적용(application), (f a)는 함수 f를 a에 적용하라는 뜻이다초기 표현식은 (+ 2 3), (squareinc 5)과 같이 계산될 수 있는 표현식이다Evaluation of functional programs​함수 프로그램의 평가는 실행이나 계산을 의미하는데, 이것은 초기 표현식의 평가와 리덕션(표현식의 축소화)에 의한다초기 표현식의 평가는 인터프리터가 수행하며, ​반복적으로 리덕션(또는 rewriting)을 수행한다예를 들어 ​(ident 42) → 42​(square (+ 1 2)) → (square 3) → (* 3 3) → 9​(squareinc 7) → (square (inc 7) → (square (+ 7 1)) → (square 8) → (*8 8) → 64​각 리덕션 단계에서(화살표로 표시)  함수 적용은 함수의 파라미터를 대응하는 함수 body로 교체하는 것이다. 리덕션 가능한 표현식(redex)은 함수 정의에 따라 rewrite 될 수 있는 서브 표현식을 말한다  다음 상황에서 리덕션 과정이 끝난다​          더 이상 redex가 남아 있지 않고 ​(즉, 더 이상 어떠한 함수 정의라도 적용할 수 없을 때)​      초기 표현식이 가장 단순한 형태(normal form; 상수만 있는 축소화된 표현식)에 있을 때, ​결과를 프린트하고 종료한다​        Order of Evaluation부작용이 없어서, 평가 순서는 무관하다. ​리덕션 가능한 표현식이 다 없어진 후에, ​계산 결과는 항상 같고, 유일하다그러나 순서가 완전히 무관한 것은 아니다. ​경우에 따라 리덕션 순서는 결과를 생산하지 못할 뿐더러 종료되지 않을 수 있다종료 못하는 리덕션 순서의 예:리커젼 함수의 정의가​(define (inf x) (inf x))(define (alwaysseven x) 7)만일 앞의 것을 먼저 계산하면, ​(alwaysseven (inf 2)) → (alwaysseven (inf 2)) → … 종료되지 않는다그러나 뒤의 것을 먼저 계산하면, ​(alwaysseven (inf 2)) → 7로 종료된다리덕션 전략에는 call by value, call by name이 있다먼저 리슾, 스킴, 엠엘 등에서 사용되는 call by value를 살펴 보자  Eager, strict evaluation이라고 한다. ​  리덕션 절차에 의해 함수 적용 그 자체가 리덕션 가능한 표현식이라고 간주(확인)되기 전에, ​함수의 파라미터를 항상 리덕션한다 (그것이 초기 표현식일 때) ​  파리미터에 대한 함수 적용은 그 파라미터가 값일때만, 리덕션 가능한 표현식이 된다  조건 연산자 if의 적용 후에, if의 파라미터를 평가한다하스켈에서 사용되는 Call by name를 살펴 보자  lazy evaluation이라고 한다  값이 알려져서 초기 표현식이 되고 값을 반환해야 할 때가 되면, ​비로소 리덕션 가능한 서브 표현식의 값이 계산된다​  조건 함수의 call by name은 ​첫째 파라미터(if 다음의 부울식)의 평가를 요구한다정리하면, ​Eager는 초기 표현식이 만들어지면 바로 계산하여 리덕션(축소화)하지만, ​Lazy는 초기 표현식이 만들어지더라도 그 식의 값이 필요할(반환해야 할) 때 계산한다표현식에 조건함수가 있다면, if 다음의 부울식을 계산해 가면서 표현식을 펼쳐 가면서 리덕션한다Higher-order functions​FPL은 함수의 개념에 대해 일반적인 관점을 갖는다. 함수는 ‘일등 시민’으로 (객체처럼) 취급된다함수는 파라미터와 결과로서 함수를 가질(사용할) 수 있다. 고차 함수는 파라미터로 함수를 갖거나 결과로서 함수를 생산한다일차 함수는 파라미터와 결과로서 함수가 아닌 값을 갖는다(define (atzero f) (f 0))​(atzero inc) → (inc 0) → (+ 0 1) → 1​(atzero square) → (square 0) → (* 0 0) → 0​(atzero ident) → (ident 0) → 0예에서 파라미터로서 함수 f를 갖는다. ​이때 f는 목적에 따라 inc, square, ident 등이 된다. ​이와 같이 파라미터로서 함수를 쓰는 것은 ​동일한 함수를 다른 경우에 적용하는데 유용하다(define (SG n) ​    (if (= n 0) ​        0 ​        (+ (G n) (SG (- n 1)))))​(define (PG n) ​    (if (= n 0) ​        1 ​        (* (G n) (PG (- n 1)))))(define (Sgen f n) ​    (if (= n 0) ​        0 ​        (+ (f n) (Sgen f (- n 1))))) ​(define (Pgen f n) ​    (if (= n 0) ​        1 ​        (* (f n) (Pgen f (- n 1)))))​자연수 n을 인풋으로 받아서 ​sum, product를 구하는 프로그램을 짠다고 하면, ​위와 같다위쪽 두개는 함수 파라미터가 없이 ​미리 정의된 함수 G만을 사용하여 계산하는 경우이고, 아래쪽 두개는 함수 파라미터를 갖고 있어서, ​목적에 따라 다양한 함수를 사용하여 계산할 수 있는 경우이다파라미터와 결과로서 함수를 갖는 함수의 예로 함수 합성을 들 수 있다함수의 합성은 두개의 함수를 인풋으로 받아서, 합성 함수를 반환한다​합성 함수를 정의하려면, 함수를 나타내는 표현식을 함수명 없이 쓸 수 있어야 한다. 이와 같은 함수를 익명 함수라고 부르며, 그 신택스는 다음과 같다(lambda (파라미터1, … 파라미터n)  body)​ 이것을 이용하여 합성 함수를 정의하면, ​(define (compose f g) (lambda (x) (f (g x))))가 된다​파라미터로 주어진 함수와 동일한 유형의 함수와 ​n일 때 갱신된 새로운 값을 반환하는 ​고차 함수의 정의는 다음과 같다(define (change-value-at-n  f  n  new-value)​        (lambda (x)​            (if (= x n)​                new-value​                (f x))))​여기서 람다가 들어가는 이유는 이것이 새로운 함수이기 때문이다표현식을 정의하는 신택스는 (define name expr)이다. 표현식의 예는 (define a (+ 3 4)) (* a 2)  결과는 14이다Data structures​FPL의 데이터 구조는 read-only이다Overwrite할 수 없고, 글로벌하게 사용하지 못하지만, ​파라미터로서 함수에 패스된다리스트는 FPL에서 미리 정의된 자료구조로, recursive하다리스트를 구성하는 데 필요한 데이터 컨스트럭터는 다음과 같다  empty: 엠티 리스트를 나타낸다. ​  cons: 값과 리스트를 인풋으로 받아서 v를 첫째 요소로 하는 새로운 리스트를 반환한다. ​  여러 값을 리스트로 만들어야 할 때 cons 대신에 list 함수를 사용한다. ​리스트의 조작을 위해 미리 정의된 셀렉터는 다음과 같다  car: 리스트를 인풋으로 받아서 첫째 요소를 반환한다.    ​  cdr: 리스트를 인풋으로 받아서 첫째 요소를 제외한 나머지를 반환한다.    ​(define Pamuk (list #t 2 #f))에서, ​(car Pamuk)은 #t을 반환하고,​(cdr Pamuk)은 (2 #f)를 반환한다. ​Definition of Lambda calculus람다 계산학은 FPL의 계산 모델이다람다 계산학은 하나의 변환 규칙과 하나의 함수 정의 방식(스킴)으로 구성된다변환 규칙은 변수 대체로서, 베타 변환이라고도 한다표현식은 이름이거나 함수이다이름은 값을 담고 있는 것의 식별자이고, ​함수는 파라미터의 이름을 표시하기 위해, ​그리스 문자 람다를 사용한다함수의 body는 λ의 뒤에 나오는 표현식으로, ​파라미터를 어떻게 재구성할 것인지 명세화한다  표현식의 (순환적) 정의는 다음 3개의 규칙에 의한다                              &lt; expression &gt; := &lt; name &gt;          &lt; function &gt;          &lt; application &gt; ​                      &lt; function &gt; := λ &lt; name &gt; . &lt; expression &gt; ​  &lt; application &gt; := &lt; expression &gt;&lt; expression &gt;여기서 name은 파라미터명을, application은 함수의 적용을 나타낸다함수의 적용은 name과 function이 나열될 수 있다. 앞에서 나온 f a처럼 함수의 body는  이다합성 표현식은 지속적인 표현식을 적용하여 합성 표현식을 평가한다즉, E1E2E3 . . . En ≡  (. . . ((E1E2)E3) . . . En)이다여기서 ≡는 동동성(equivalence)를 나타낸다모호함을 줄이기 위해, λx.x ≡ (λx.x)와 같이 괄호를 사용한다함수는 표현식에 적용될 수 있다  이러한 경우에 해당되는 단순한 예로, (λx.x)y을 들 수 있다이것은 y에 identity 함수를 적용하는 것이다  이때, 표현식이 모호해 질 수 있으며, 괄호를 써서 모호성을 피한다  함수 적용의 평가는 파라미터를 함수 정의의 body로 대체하는 것이다. 위의 예에서, x를 y로 대체하는 것이 함수 적용의 평가이다(λx.x)y → [y/x]x → y​에서 [y/x]는 x를 y로 대체하는 것을 나타낸다대체하는 것을 베타 리덕션이라고도 한다이것을 자세히 들여다 보면, 두 단계로 이루어짐을 알 수 있다​파라미터가 표현식을 받아들인다(take in). 이후 표현식으로 body의 파라미터를 교체한다리덕션(축소화)은 함수 적용을 통해 ​표현식에 포함된 함수 정의를 줄여 나가는(축소하는) 과정이다변수는 자유 변수와 속박 변수로 구분된다  모든 name(변수)는 함수 정의 내에서 로컬이다  함수 λx.x에서 body 내의 x는 그 앞에 λx가 있기 때문에 속박 변수이다​. 자유 변수는 name 앞에 λ가 없다​  표현식 (λx.x)(λy.yx)에서, 첫째 표현식의 body에 있는 x는 첫째 λ에 속박되어 있다. 두번째 표현식의 body에 있는 y는 두번째 λ에 속박되어 있다.  두번째 표현식의 body에 있는 x는 자유변수이며, 첫번째 표현식의 x와 전적으로 독립적이다. ​​이 그림은 표현식 (λx.x)(λy.yx)의 베타 리덕션을 보여준다앞 표현식의 x가 두번째 표현식을 받아 들여서 ​앞 표현식의 body의 x를 두번째 표현식으로 교체한다. 이와 같이 함수 적용을 통해, 표현식의 함수 정의를 제거함으로써, ​표현식을 축소해 나간다베타 리덕션의 조금 복잡한 사례를 살펴 보자표현식이 (λx.(λy.xy))y 라고 하자대체할 때, 자유 변수와 속박 변수를 혼동하지 않도록 조심해야 한다왼쪽의 함수는 속박변수 y를 포함한다. ​오른쪽 표현식의 y는 괄호 밖에 있으며, 따라서 자유 변수이다. ​변수 y는 왼쪽에서는 속박 변수, 오른쪽에서는 자유 변수이다. ​이때 이들을 혼동하면 (λy.yy) 로 잘못 리덕션된다혼동을 피하려면, 속박 변수 y를 t로 재명명(rename)하면 된다교체했다고 가정하고, ​새로 교체한 변수가 이후의 표현식에서 기존의 바운드 변수로 사용되었다면, ​전혀 다른 두 변수가 동일한 이름을 쓰게 되기 때문에, ​새로 교체한 변수와 기존의 바운드 변수를 구분할 필요가 있다이를 위해 기존의 바운드 변수를 재명명(rename)한다그러나 (λx.(λt.xt))y 와 같이 끝의 y는 free이므로 rename하지 않는다Arithmetic functions​S ≡ λnab.a(nab); n is the number of a​S0 ≡ (λnab.a(nab))0​→ λ ab.a(0ab) → λab.a(b) ≡ 1​S1 ≡ (λnab.a(nab))1 ​→ λab.a(1ab) → λab.a(ab) ≡ 2 ​Successor 함수를 이와 같이 정의하자여기서 n은 a의 개수이다. 앞에서 정의한 0, 1, 2, 3을 참고하자그렇다면 Addition과 Multiplication 함수는 ​Successor 함수를 이용하여 다음과 같이 정의할 수 있다2+3은 2S3으로, (λsz.s(sz)))S3 로 정의할 수 있고, 이것을 리덕션하면, ​→S(S3) → · · · → 5 가 된다. ​3*3은 (λxya.x(ya))33 → (λa.3(3a)) 으로 정의되며, ​이것을 리덕션하면 9가 된다. ​—​Recursion리커젼은 순환적으로 정의된 데이터에 대한 함수 정의에 자연스럽게 적용되는 절차이다Function Y: Y ≡ (λy.(λx.y(xx))(λx.y(xx))) ​함수 Y를 이와 같이 정의한다Y를 함수 R에 적용하면, YR은 이와 같다YR ≡ (λx.R(xx))(λx.R(xx))  ​이것을 리덕션하면, YR -&gt; R(YR)가 된다. ​람다 계산학에서 리커젼은 이와 같이 표현되며, ​R의 평가(계산)은 YR의 순환 호출을 사용한다",
        "url": "/pl-19"
    }
    ,
    
    "sc-15": {
        "title": "__DRM(Digital Right Managemment__",
            "author": "lee989898",
            "category": "",
            "content": "DRM(Digital Right Managemment  DRM  digital 저작권 관리  Digital contents의 불법 사용을 제한/방지하고, 저작권을 보고하기 위한 기술 및 서비스  Digital contents          audio,video,image,text,multimedia,sw 등        저작권이란  Copyright  저작자가 자신이 창작한 저작물에 대해 갖는 권리(저작권법)          복제권: 저작자는 저작물을 복제할 권리를 갖는다      공연권      공중송신권      전시권: 원본이나 복제물을 전시할 권리      배포권: 원본이나 복제물을 배포. 다만, 저작자의 허락을 받아 판매등의 방법으로 거래에 제공된 경우는 제외      대여권: 영리를 목적으로 대여할 권리      2차적 저작물작성권: 원저작물로 하는 2차적저작물을 작성하여 이용할 권리        Common DRM business model  Provider          저자물(권) 소유        Distributor          유통을 담당하는 배급자      합법적인 소비자에게만 제공해야        Clearinghouse          디지털 상품에 대한 권리발급      배급료, 사용료 처리 (Log기록)        Consumer          Clearinghouse에 사용료지급하고  distributor로부터 컨텐츠제공받음        주요기술 1: Stegano graphy(숨겨진 글)  평범해 보이는 미디어에 내용을 아는 수신자만 알아볼 수 있도록 은밀히 정보를 숨기는 기술  암호화알고리즘이 안전하지 않을 때 유용  주요기술 2: Watermark  빛을 비출때나 반사될 때 더 밝게 보이는, 인지할 수 있는 종이의 무늬나 그림  지폐, 상표, 문서 등의 위조 방지에 많이 사용된다  Digital watermarking          Text, image, video, audio 등의 원본 데이터에 본래 소유주만이 아는 mark를 사람의 감각으로 식별할 수 없게 삽입하는 기술      일부 digital data가 손상되더라도 인간은 감지할 수 없음        복제방지, 원본여부, 재생횟수제한, 유효기간설정, 시간제한 등에 활용",
        "url": "/sc-15"
    }
    ,
    
    "sc-14": {
        "title": "__Diffie-Hellman__",
            "author": "lee989898",
            "category": "",
            "content": "Diffie-Hellman  Diffie-Hellman  보안성 없는 매체를 통한 Symmetric key 공유  송/수신자를 위한 일회용 Secret/shared session key agreement protocol  이산대수문제  IPSEC, 상용sw에 자주 사용  Steps  p,g: 큰 정수, 1 &lt; q &lt; p, 모든 사용자에 공개  Alice는 임의로 a 생성, A = $g^a$ mod p 계산  Bob은 임의로 b 생성, B = $g^b$ mod p 계산  A,B를 서로 교환  Alice와 Bob은 K=$g^{ab}$ mod p  Deiffie-Hellman의 취약성: 중간자 공격  Man in the middle attack: Trudy poses as Alice and as Bob          Diffe-Hellman은 매우 복잡한 프로토콜이지만, 제 3자가 x 또는 y 값을 알아내지 않아도 되기 때문에 중간에서 밥과 앨리스를 속이는 것이 가능하다.​      중간자 공격 절차​                  앨리스가 x를 선택한 후 R1=Gx를 계산하여 R1을 밥에게 전송​          제 3자가 R1을 가로챈 후, z를 선택한 다음 R2=Gz mod N을 계산하여 R2를 앨리스와 밥에게 전송​          밥이 y를 선택한 다음 R3=Gy mod N을 계산해서 R3을 앨리스에게 전송, R3을 제 3자가 가로챔​          앨리스와 제 3자가 공유한 키 K1=Gxz mod N을 계산​          제 3자와 밥은 공유한 키 K2=Gzy mod N을 계산​                    경우 앨리스와 밥은 제 3자와 공유한 키를 서로간의 공유한 키로 생각​        사용자 인증을 하지 않아서 발생하는 문제 -&gt; 전자서명, 인증서",
        "url": "/sc-14"
    }
    ,
    
    "st-09": {
        "title": "프로세스통신-socket",
            "author": "lee989898",
            "category": "",
            "content": "프로세스통신-socket  Socket  Pipe는 통신하는 프로세스들을 하나의 시스템 내부로 한정 ​  Socket은 같은 시스템에 속한 프로세스들 뿐만 아니라, 서로 다른 시스템들에 속한 프로세스들 간의 통신을 가능케 함​          socket() 시스템 호출에 의해 만들어 짐 ​      응용 프로그램의 관점에서는 pipe와 마찬가지로 파일 디스크립터를 통해 접근(read, write, 등) 가능​      Kernel의 관점에서 socket은 IPC를 위한 통신의 끝점(또는 출입구)에 해당함​        전혀 관계없는 프로세스간에 통신을 위해 socket을 식별할 목적으로 이름을 붙임​          파일 이름 또는 번호​      bind() 시스템 호출 사용​        이름 붙이기      Linux 도메인에서는 socket 이름으로 파일 이름 사용 (경로명 포함)        INET(Internet) 도메인에서는 socket 이름으로 포트번호 사용​          Well-known port: ftp는 21번, telnet은 23번, 등등. ​      통신 상대 프로세스가 속한 컴퓨터 시스템 이름(IP address) +   포트 번호        Stream Socket을 이용한 IPC  Virtual circuit​          통신 대상에 연결(논리적 접속)을 설정​      그 연결을 통하여 데이터를 송수신​      송수신이 끝나면 연결 해제​      연결형 통신이라고 부름 : 전화에 비유​        Stream socket​          Virtual circuit 기능을 이용하여 구현한 socket​      프로세스간에 대량의 데이터를 송수신하는 경우 이용 ​      통신의 신뢰성 보증​      송신한 정보가 없어지거나 바뀌지 않음​      올바른 순서로 수신됨​            연결형 프로토콜의 예 : TCP (Transmission Control Protocol)    Client :​          Socket 작성 : socket() 시스템 호출​      Socket에 이름 붙임 : bind()  생략 가능​      Server에 접속 요구 : connect()​      데이터 송수신 : read()/write()  socket이 파일 디스크립터로 접근 가능하므로​      Socket 제거 : close()​        Server : ​          Socket 작성 : socket() 시스템 호출​      Socket에 이름 붙임 : bind()​      Client의 접속 요구 받을 준비 : listen()​      접속 요구 허가 : accept()​      데이터 송수신 : read()/write()​      Socket 제거 : close()        Datagram Socket을 이용한 IPC  Datagram​          통신 대상에 연결(논리적 접속)을 설정할 필요 없음​      개개의 데이터를 그때 그때 상대방에게 보냄​      비 연결형 통신이라고 부름 : 편지에 비유​        Datagram socket​          Datagram 기능을 이용하여 구현한 socket​      프로세스간에 작은 데이터를 계속해서 보내는 통신​      매번 데이터를 보낼 때마다 상대방을 지정 ​      전송 데이터의 신뢰성이 보증되지 않음 : 시간, 순서, 등​            비 연결형 프로토콜의 예 : UDP (User Datagram Protocol)    Client :​          Socket 작성 : socket() 시스템 호출​      Socket에 이름 붙임 : bind()  생략 가능​      데이터 송신 : sendto() ​      데이터 수신 : recvfrom()​      Socket 제거 : close()​        Server : ​          Socket 작성 : socket() 시스템 호출​      Socket에 이름 붙임 : bind()​      데이터 수신 : recvfrom()​      데이터 송신 : sendto()​      Socket 제거 : close()        socket() system call#include &lt;sys/types.h&gt;​#include &lt;sys/socket.h&gt;​int socket(int domain, int type, int protocol)  소켓을 생성​          int domain :  사용하는 도메인의 종류​      int type :      사용하는 소켓 타입​      int protocol : 사용하는 프로토콜의 종류​            정상 종료시 생성된 소켓에 대한 파일 디스크립터 반환, 에러시 -1 반환    Domain의 종류 ​          PF_UNIX : unix domain ​      PF_INET : inet domain​      그 이외​        Socket type의 종류​          Sock_stream : stream socket​      Sock_dgram : datagram socket​      그 이외​        사용되는 고유의 protocol 지정. 대부분 0을 사용  bind() system call​#include &lt;sys/types.h&gt;​#include &lt;sys/socket.h&gt;​int bind(int sockfd, struct sockaddr *my_addr, int len)  int sockfd : socket() 시스템 호출에서 돌려 받은 socket 파일 디스크립터를 지정​  struct sockaddr *my_addr : 이름을 붙일 구조체​          struct sockaddr *my_addr 에는 다음을 지정​                  Unix domain 또는 Inet domain 중 어느 쪽을 사용할 지​          Socket 이름​                      int len :  이름이 붙여진 구조체(*my_addr)의 길이​  Unix Domain에서 socket의 주소 정보는 socketaddr_un 구조체에서 정의​```#include &lt;sys/un.h&gt;​#define UNIX_PATH_MAX 108​struct sockaddr_un {​    sa_family_t   sun_family;     /* sa_family_t는 short과 같은 타입/​     / PF_UNIX 설정 /​    char sun_path[UNIX_PATH_MAX];   / 경로명 */​};+ Inet Domain에서 socket의 주소 정보는 socketaddr_in 구조체에서 정의​#include &lt;netinet/in.h&gt;​struct sockaddr_in {​    sa_family_t     sin_family;   /* PF_INET 설정 /    u_int16_t        sin_port;      / 포트 번호 /​    struct in_addr   sin_addr;    / IP 주소 */​}; ​ struct in_addr { u_int32_t  s_addr; };  /* IP 주소 */ ```  connect() system call#include &lt;netinet/in.h&gt;​#include &lt;sys/types.h&gt;​#include &lt;sys/socket.h&gt;​int connect(int sockfd, const struct socketaddr *serv_addr, socklen_t addr_len)  스트림 소켓 이용시 client에서 호출 (서버에 접속 요청)​  정상 종료시 0을 반환, 에러시 -1 반환​          int sockfd : socket 파일 디스크립터를 지정​      struct sockaddr *serv_addr : 접속하고 싶은 서버의 소켓 주소 정보 ​      socklen_t addr_len : 서버의 소켓 주소 정보 구조체의 길이​​                  listen() system call                    #include &lt;sys/socket.h&gt;​int listen(int sockfd, int backlog)  스트림 소켓 이용시 server에서 호출 정상 종료시 0을 반환, 에러시 -1 반환​  int sockfd : socket 파일 디스크립터를 지정​  int backlog : 연결 요청에 대한 대기열의 최대 길이(대개 5)  accept() system call#include &lt;sys/types.h&gt;​#include &lt;sys/socket.h&gt;​int accept(int sockfd, struct sockaddr *client_addr, socklen_t *addrlen)  스트림 소켓 이용시 server에서 호출​  정상 종료시 소켓에 대한 새로운 파일 디스크립터를 반환, 에러시 -1 반환​  int sockfd : socket 파일 디스크립터를 지정​  struct sockaddr *client_addr : client의 socket 주소 정보 구조체를 가리키는 포인터​  socklen_t *addrlen : client의 socket 주소 정보 구조체의 길이  send() system call#include &lt;sys/types.h&gt;​#include &lt;sys/socket.h&gt;​int send(int sockfd, const void *buf, size_t len, int flags)  Send() : 소켓으로 데이터 보냄  정상 종료시 실제 보낸 바이트 수를 반환, 에러시 -1 반환​  int sockfd : accept로 반환된 파일 디스크립터를 지정​  const void *buf : 송신 버퍼의 시작 주소​  size_t len : 송신 데이터의 길이​  int flags : 송신 옵션  recv() system call#include &lt;sys/types.h&gt;​#include &lt;sys/socket.h&gt;​int recv(int sockfd, void *buf, size_t len, int flags)  Recv() : 소켓으로부터 데이터 받음  정상 종료시 실제 받은 바이트 수를 반환, 에러시 -1 반환​  int sockfd : accept로 반환된 파일 디스크립터를 지정​  void *buf : 수신 버퍼의 시작 주소​  size_t len : 수신 데이터의 길이​  int flags : 수신 옵션  sendto() system call​#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;​int sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *to, socklen_t tolen)  Sendto() : 데이터그램 소켓으로 데이터 보냄​  정상 종료시 실제 보낸 바이트 수를 반환, 에러시 -1 반환​  int sockfd : 파일 디스크립터를 지정​  const void *buf : 송신 버퍼의 시작 주소​  size_t len : 송신 데이터의 길이​  int flags : 송신 옵션 ​  const struct sockaddr *to : 받을 곳의 소켓 주소 정보 구조체를 가리키는 포인터​  socklen_t tolen : 받을 곳의 소켓 주소 정보 구조체의 길이​  recvfrom() system call#include &lt;sys/types.h&gt;​#include &lt;sys/socket.h&gt;​int recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlen)  Recvfrom() : 데이터그램 소켓에서 데이터 받음​  정상 종료시 실제 받은 바이트 수를 반환, 에러시 -1 반환​  int sockfd : 파일 디스크립터를 지정​  void *buf : 수신 버퍼의 시작 주소​  size_t len : 수신 데이터의 길이​  int flags : 수신 옵션​  struct sockaddr *from : 보내는 곳의 소켓 주소 정보 구조체를 가리키는 포인터​  socklen_t tolen : 보내는 곳의 소켓 주소 정보 구조체의 길이  System V IPC​  Semaphores​  Shared memory​  Message queues​  Semaphores  여러 프로세스에 대한 공유 데이터 개체에 대한 액세스를 제공하는 카운터  공유 리소스를 얻으려면                            Test semaphore controlling resource​                          1-1 If value &gt; 0, value –, grant use​              1-2 If value == 0, sleep until value &gt; 0​                                                            Release resource, value ++​                      Steps 1-1, 1-2 atomic 연산이어야 한다  세마포어는 하나 이상의 세마포어 값의 집합으로 정의되다          세마포어가 생성될 때 집합에 값의 개수도 지정된다        Functions#include &lt;sys/sem.h&gt;​int semget(key_t key, int num_sems, int sem_flags);​int semctl(int sem_id, int sem_num, int command, …);​int semop(int sem_id, struct sembuf *sem_ops, size_t num_sem_ops);  semget : 세마포어 생성 또는 세마포어 키 반환          Key : 동일한 세마포어에 액세스하기 위한 10진수 값      num_sems : 세마포어의 수        semctl : 세마포어 정보 제어          sem_id : 세마포어 ID​      sem_num : 세마포어의 수      command : 세마포어 명령        semop : 세마포어 값 변경  생성(semget)은 초기화(semctl)와 무관하다​  Shared memory  가장 빠른 형태의 IPC: 프로세스 간 데이터 복사 불필요  공유 메모리 세그먼트에 대한 액세스를 동기화해야 함 -&gt; 세마포어가 사용됨  Functions#include &lt;sys/types.h&gt; ​#include &lt;sys/ipc.h&gt; ​#include &lt;sys/shm.h&gt; ​int shmget(key_t key, int size, int flag); ​        Returns: shared memory ID if OK, -1 on error  공유 메모리 식별자 얻기  Size : 공유 메모리 세그먼트의 크기  Flag : ipc_perm.mode​#include &lt;sys/types.h&gt; ​#include &lt;sys/ipc.h&gt; ​#include &lt;sys/shm.h&gt; ​int shmctl(int shmid, int cmd, struct shmid_ds *buf);​        Returns: 0 if OK, -1 on error  다양한 공유 메모리 작업​#include &lt;sys/types.h&gt; ​#include &lt;sys/ipc.h&gt; ​#include &lt;sys/shm.h&gt; ​void *shmat (int shmid, void *addr, int flag); ​        Returns: pointer to shared memory segment if OK, -1 on error  주소에 공유 메모리 첨부  flag ​          SHM_RDONLY : 세그먼트가 읽기 전용이다​        addr==0: 커널이 선택한 첫 번째 주소에서          recommended​        addr!=0 &amp;&amp; SHM_RND is not specified:​          addr이 제공한 주소에서        addr!=0 &amp;&amp; SHM_RND is specified:​          주어진 주소에서 (addr – (addr modulus SHMLBA))​      #include &lt;sys/types.h&gt; ​#include &lt;sys/ipc.h&gt; ​#include &lt;sys/shm.h&gt; ​void shmdt (void *addr); ​        Returns: 0 if OK, -1 on error  공유 메모리 세그먼트 분리  Message queues  메시지의 연결 목록          커널에 저장      메시지 대기열 식별자로 식별        msgget: 새 대기열 생성 또는 기존 대기열 열기  msgsnd: 대기열에 새 메시지 추가  msgrcv: 대기열에서 메시지 수신  Fetching order: based on type#include &lt;sys/types.h&gt; ​#include &lt;sys/ipc.h&gt; ​#include &lt;sys/msg.h&gt; ​int msgget(key_t key, int flag); ​        Returns: msg queue ID if OK, -1 on error  새 대기열 생성 또는 기존 대기열 열기  Flag : ipc_perm.mode​#include &lt;sys/types.h&gt; ​#include &lt;sys/ipc.h&gt; ​#include &lt;sys/msg.h&gt; ​​int msgsnd(int msqid, const void *ptr, size_t nbytes, int flag); ​        Returns: 0 if OK, -1 on errorstruct mymesg {​  long mtype;         /* positive message type */​  char mtext[512];    /* message data, of length nbytes */​};  큐의 끝에 메시지 배치  ptr은 메시지를 가리킨다  nbytes : 메시지 데이터의 길이#include &lt;sys/types.h&gt; ​#include &lt;sys/ipc.h&gt; ​#include &lt;sys/msg.h&gt; ​int msgrcv(int msqid, void *ptr, size_t nbytes, long type, int flag); ​        Returns: data size in message if OK, -1 on error  대기열에서 메시지 검색  type == 0 : 큐의 첫 번째 메시지가 반환된다  type &gt; 0 : 메시지 유형이 유형과 동일한 큐의 첫 번째 메시지가 반환된다  type &lt; 0 : 메시지 유형이 유형의 절대값보다 작거나 같은 가장 낮은 값인 큐의 첫 번째 메시지가 반환된다",
        "url": "/st-09"
    }
    ,
    
    "algorithm-07": {
        "title": "되추적",
            "author": "lee989898",
            "category": "",
            "content": "되추적  되추적  완전 탐색을 개선한 기법  후보 해들을 단계적으로 만들어 가는 과정에서 후보 해들을 평가  만약 한 후보 해가 최종 해가 될 수 없다고 판단되면 탐색을 멈추고 다른 후보 해를 탐색  최적화 문제와 결정 문제 해결 가능  하산 길 선택  하산 길에 갈림길에 안내 표지판이 없다면          갈림길에서 한 길을 선택한 후 그 길을 따라 계속해서 간다      길이 끊기면 절벽에 도달하면 갈림길로 되돌아온다      갈림길에서 다른 길을 선택해서 간다        상태공간트리  특정 알고리즘의 진행 과정을 나타낸 트리  노드: 한 해의 구성요소들에 대한 특정 선택  후보 해: 루트 노드에서 종단 노드까지의 경로  후보 해 중에 해가 있음  해가 될 가능성이 전혀 없는 노드의 자손 노드들을 고려하지 않음      예: 미로 찾기    노드의 유망성          해가 될 가능성이 있는 노드는 유망하고 아니면 유망하지 않다        되추적이란?          어떤 노드의 유망성을 점검한 후, 유망하지 않다고 판정이 되면 그 노드의 부모 노드로 돌아가서 다음 자식 노드에 대한 탐색을 계속한다        상태 공간 트리에서 깊이 우선 탐색          유망한 노드만 자식 노드 탐색      유망하지 않은 노드는 가지 쳐서 탐색 중단        순열 생성  &lt;1,2, …, N&gt;의 모든 순열을 생성하라  예: N = 3인 경우          &lt;1,2,3&gt;, &lt;1,3,2&gt;, &lt;2,1,3&gt;, &lt;2,3,1&gt;, &lt;3,1,2&gt;, &lt;3,2,1&gt;      ​  아이디어: 배열의 첫 번째, 두 번째와 세 번째 요소를 각각 첫 번째 요소와 교환한 후 배열의 나머지 부분에 대해 순열을 생성하는 일을 재귀적으로 반복한다permute(A[], k) // &lt;A[k], A[k + 1], ..., A[N-1]&gt;의 모든 순열을 생성// 입력: A[0 .. N - 1] - 순열을 저장하는 배열, k - 배열 A의 지수// 출력: &lt;A[k], A[k + 1],..., A[N-1]&gt;의 모든 수열1 if (k = N) { A[0 .. N - 1]을 출력한다; return}2 for(i = 1; i &lt;= N; i++) // A[k]를 i로 정하기 전에 가능한지 확인3   if(promising(A,k,i)) { // A[k]를 i로 정하는 것이 가능한 경우4       A[k] = i7       permute(A, k+1)} // A[k+1], ..., A[N-1]&gt; 의 모든 순열을 생성// 최초호출: permute(A[], 0) // A[k]를 i로 정하는 것이 가능한지 확인promising(A[],k,i)1 flag = true2 j = 03 while(j &lt; k &amp;&amp; flag){4 if(j = A[j]) flag = false5 j++       }6 return flag  해밀토니안 회로 찾기  헤밀토니안 회로: 연결된 무방향 그래프에서 한 정점에서 출발하여 모든 정점을 정확히 한번씩 방문하고 다시 출발 정점으로 돌아오는 경로      헤밀토니안 회로 찾기 문제: 연결된 무방향 그래프에서 해밀토니안 회로를 찾아라    가정: n - 그래프내의 정점들의 수          트리의 루트 노드에 시작 정점을 놓는다      for(i = 1; i &lt; n; i++)              트리의 수준 i에 i번째로 방문할 정점으로 시작 정점을 제외한 모든 정점을 선택하는 것을 고려한다        i번째 방문 정점 j의 선택 조건          i가 (n-1)이라면 j는 시작 정점과 인접해야 한다      i가 (n-1)보다 작다면 루트 노드로부터 j까지의 경로상의 (i-1)번째 정점과 인접해야 한다      j는 루트 노드로부터 j까지의 경로상에서 j 전에 방문한 (i-1)개의 정점들 중 하나가 되어서는 안된다            위 조건들을 만족하면 트리의 다음 수준 (i + 1)에 대해 같은 과정을 계속하고 아니면 해 탐색을 멈추고 부모 노드로 되돌아가서 i번째로 방문할 정점으로 아직 선택안한 정점들 중의 하나를 선택하고 조건을 확인한다    n: 정점들의 수  i, 1 &lt;= i &lt;= n : 정점의 번호  1: 시작 정점  그래프 G = (V,E)는 인접 행렬 G로 표현한다.                                                      G[i - 1][j - 1] = { 1, (i,j) $\\in$ E              0, (i,j) $\\notin$ E}                                            path[i], 0&lt;= i &lt;= n-1: 해밀토니안 회로에서 i번째 정점  path[0] = 1hamiltonian(G[][], i)// 입력: i - 그래프의 정점//      G[0 .. n - 1][0 .. n - 1] - 그래프의 인접 행렬// 출력: 해밀토니안 회로1 if (valid(G,i))2   if ( i = n - 1) { path[0 .. n - 1]을 출력한다; return}5   else // i번째로 방문할 정점을 모든 정점을 시도해 본다6       for( j = 2; j &lt;= n; j++){7           path[i + 1] = j8           hamiltonian(G,i + 1)    }// 최초 호출: hamiltonian(G, 0)boolean valid(G[][], i) // 경로상의 i번째 정점이 유효한 선택인지 확인1 if(i = n - 1 and G[path[n-1]-1][path[0] - 1] = 0)    // 경로상의 마지막 정저이 첫 번째 정점과 인접하지 않은 경우2   return false3 else if( i &gt; 0 and G[path[i - 1]- 1][path[i] - 1] = 0)    // 경로상의 i번째 정점이 이미 선택되었는지를 확인4   return false5 else { // 경로상의 j번째 정점이 이미 선택되었는지를 확인6    j = 17    while(j &lt; i){8       if(path[i] = path[j]) return false9       j++ }    }10 return true  시간 복잡도: O($n^n)$  그래프 색칠하기  m-색칠하기 문제: 무방향 그래프에서 최대 m(&gt;1)개의 색들을 사용하여 인접한 정점들을 서로 다른 색으로 칠하라      응용 분야: 지도 색칠하기    지도에서 각 국가는 그래프에서 한 정점으로 나타내고 국경을 맞대고 있는 두 개의 국가들은 대응하는 정점들 사이의 간선으로 나타내면 모든 지도는 그에 상응하는 평면 그래프로 표현할 수 있다​  m-색칠하기 상태 공간 트리  수준 i, 1&lt;=i&lt;=n,에서 정점 i에 가능한 m개의 색들을 각각 시도해 본다(n은 정점들의 수)  루트 노드에서 종단 노드까지의 경로가 각각 후보 해가 된다. 이 경로상의 어떤 두 개의 인접한 정점들이 같은 색인지를 확인하여 같은 색이면 그 경로는 더 이상 고려하지 않고 가지 친다  m-색칠하기 되추적 알고리즘  n: 정점들의 수  m: 색들의 수  i, 1&lt;= i &lt;= n: 정점의 번호  1: 시작 정점  그래프 G = (V,E)는 인접 행렬 G로 표현한다                                                      G[i-1][j-1] = {1, (i,j) $\\in$ E              0, (i,j) $\\notin$ E}                                            vcolor[i], 1&lt;=i&lt;=n: 정점 i에 칠해진 색m_coloring(G[][], i)// 입력: G[0 .. n - 1][0 .. n - 1] - 그래프의 인접 행렬//      i - 그래프의 정점// 출력: vcolor[1..n] - 정점들에 칠해진 색들의 배열1 if (valid(G, i))2   if ( i = n){3       vcolor[1 .. n] 을 출력한다4       return5   } else { //다음 정점에 모든 색을 시도해 본다6       for( c = 1; c &lt;= m; c++){7           vcolor[i + 1] = c8           m_coloring(G, i + 1) }    }// 최초 호출: hamiltonian(G,0)// 정점 i에 칠해진 색이 유효한지 확인한다boolean valid(int G[][], i)1 j = 12 while(j &lt; i){    // i의 색이 인접한 정점(들)의 색과 같은지 확인3   if (G[i - 1][j - 1] = 1 and vcolor[i] = vcolor[j])4       return false5   j++    }6 return true  시간복잡도: O($m^n$)",
        "url": "/algorithm-07"
    }
    ,
    
    "sc-13": {
        "title": "Key Management (KDC &amp; CA)",
            "author": "lee989898",
            "category": "",
            "content": "Key Management (KDC &amp; CA)  Session Key  Session: 회기, 입회기간  통신 seesion이 시작될 때 생성되서 종료될때 폐기되는 동적 대칭키  통신 session마다 다른 키를 사용하면 안전  다중사용자가 세션키사용 할 경우  2명의 사용자 간에 1개의 비밀키 사용  3명의 사용자 간에 3개의 비밀키 사용  사용자 1명 추가 시 3개의 비밀키가 추가로 필요  n명이면 n(n-1)/2 만큼의 키가 필요  대칭키 유지 및 관리 부하  KDC (Key Distribution Centre)  중앙의 신뢰할 수 있는 키관리, 분배 책임주체  사용자들은 KDC 등록신청하면, KDC가 각 사용자들과 비밀키를 공유  각 사용자는 이 키를 사용하여 KDC와 통신한다  Operation  Alice와 Bob은 KDC와의 통신을 위한 $K_{A-KDC}$, $K_{B-KDC}$ 를 알고 있다. Alice는 KDC와 통신하여 세션키 R1 과 $K_{B-KDC}$(A,R1)을 얻는다.Alice는 Bob에게 $K_{B-KDC}$(A,R1)을 보내고 Bob은 R1을 추출해낸다  KDC 장단점  KDC의 장점          비밀키 방식은 비교적 속도가 빠름      서버를 사용하지 않는 경우보다 키 관리를 쉽게 해줌        KDC의 단점          단일 실패 지점 (SPoF, Single Point of Failure)                  KDC가 고장나면 전혀 서비스를 할 수 없음          해결책: 미러 서버 가동                          서버와 미러간의 일관성 문제 발생 가능                                          +KDC가 공격되면 모든 비밀키가 노출될 수 있음      KDC의 신뢰성이 매우 중요함      KDC에 대한 병목현상 발생        Hierarchical Key Control  단일 KDC는 대규모 네트워크에서 비효율적  KDC를 계층화          local KDC                  single LAN or building          같은 domain 에서의 통신시 키 분배                    global KDC                  다른 domain 간의 통신시 키 선택                    KDC의 손상시 지역에 한정        CA (Certification Authorities)  for public key cryptography  전자서명을 위해선 신뢰성 있는 공개키 보관장소 필요 해커가 다른 사용자의 공개키를 자기것인 척 하는 것을 방지  공인인증서의 발급과 관리하는 기관  Role          사용자들의 공개키를 저장하고 관리      사용자들이 요청시 해당 공개키를 서명해서 전송(public key certificate, 공개키 인증서)        Operation  Bob은 CA에 공개 키를 등록한다          Bob은 CA에 신원증멸 을 제공한다      CA는 Bob을 공개 키에 바인딩하는 인증서를 생성한다      CA가 디지털 서명한 Bob의 공개 키를 포함하는 인증서: CA는 “이것은 B의 공개 키이다”        Alice가 Bob의 공개 키를 원할 때:          Bob의 인증서를 얻는다.      CA의 공개 키를 Bob의 인증서에 적용하고 Bob의 공개 키를 가져온다        공개키 인증서 (공인인증서, Public Key Certificate)  특정 공개키가 해당 사용자의 공개키임을 신뢰할수있는 기관에서 보증하는 문서 -&gt; 사용자 인증  사용자 공개키에 공인인증기관의 전자서명을 첨부한 것  4요소          공개키인증서: 공개키가 누구것인지, 대칭되는 비밀키는 누가 갖고있는지      인증서정책: 인증서 사용방식      인증서경로: 인증서를 연결하는 방식      인증서 철회리스트: 유효성확인        공개키 기반구조 (PKI, Public key Infrastructure)  정의​          공개키 방식을 통해 암호화 및 전자서명/인증서의 사용을 가능하도록 해주는 기반구조로 X.509(표준), PGP, AADS/X9.59 등 있다​        ​구성 요소​          사용자 : 개인이나 기관 또는 응용 서비스​      인증기관(CA) : 공개키 인증서발급 및 관리​      등록기관(registration authority: RA): 사용자 인증서 신청시 인증기관대신 신분확인​      저장소(repository): 인증서,사용자정보,인증서취소,상호인증서 등을 저장 검색​      인증서정책(policy): 권한, 사용범위 정의​      공개키인증서​        국내 인증기관(CA)  전자서명법​          공인인증서: 전자서명을 생성하기 위하여 이용된 정보가 가입자에게 유일하게 속한다는 사실등을 확인하고 증명하는 전자정보. 이름, 유효기관, 발급기관, 전자서명방식, 인증번호등 포함​        공인인증기관(CA) : 공인인증서의 발급과 관리를 담당하는 기관으로 금융결제원, 한국정보인증, 한국증권전산, 한국전자인증, 한국전산원, 한국무역정보통신, 코스콤​  주요역할​          공개키와 비밀키 생성, 인증서 발급/폐지​        등록기관(RA, Registration Authority)​  인증기관의 위임을 받아 사용자가 신청시 신원확인 및 공개키 생성/등록을 수행  국내 공인 인증서 발급절차​  발급기관(CA or RA)에 공인인증서 발급신청(직접방문, 신분증제출)​  발급기관에서 등록확인서 발급 (참조번호, 인가코드)​  발급기관 홈페이지접속해서 공인인증서 발급 신청​  공인인증서 파일이 발급​",
        "url": "/sc-13"
    }
    ,
    
    "pl-18": {
        "title": "Concurrency",
            "author": "lee989898",
            "category": "",
            "content": "Comcurrency동시 실행은 인스트럭션 수준, 문장 수준, 서브프로그램 수준, 프로그램 수준, 이렇게 4개 수준에서 이루어 질 수 있다인스트럭션 수준에서는 두개 이상의 머신 인스트럭션을 동시에 실행한다. 문장 수준에서는 두개 이상의 고급언어 문장을 동시에 실행한다. 서브프로그램 수준에서는 두개 이상의 서브프로그램을 동시에 실행한다. 프로그램 수준에서는 두개 이상의 프로그램을 동시에 실행한다동시 실행 통제 메커니즘은 프로그래밍의 유연성을 증가시킨다동시 실행 통제 메커니즘은 원래 운영체제의 문제를 풀기 위해 발명되었으나, ​다양한 응용 프로그램에서도 요구된다프로그램 수준의 동시 실행 사례는 웹에서 볼 수 있다웹 브라우저는 다음과 같은 여러가지 기능을 동시에 실행해야 한다  웹 서버에게 데이터를 주고 받기  텍스트와 이미지를 스크린에 렌더링하기​  마우스와 키보드에 의한 사용자 액션에 대응하기IE9는 별도의 코어를 사용하여 클라이언트 측의 스크립트 코드를 인터프러터 방식으로 처리한다.  ​문장 수준의 동시 실행은 프로그램 수준의 경우와 매우 다르다언어 설계자는 문장 수준의 동시 실행을 위해 다음에 대해 중점을 둔다  데이터를 다수의 메모리에 어떻게 분산시킬 것인가? ​  어느 문장을 동시 실행할 것인가?동시 실행 알고리즘은 확장성이 있어야 한다사용하는 프로세서의 수를 증가시킬수록 실행 속도가 증가하면, 확장성이 있다고 말한다알고리즘은 이식성이 있어야 한다알고리즘이 다른 아키텍처의 기계에서 효율적으로 실행된다면, ​이 알고리즘은 이식성이 있다고 말한다이식성은 하드웨어의 수명이 비교적 짧아지고 있어서, 매우 중요하다플린은 컴퓨터를 다음과 같이 분류하였다  SISD는 하나의 인스트럭션이 하나의 데이터를 처리하는 것으로, ​프로세서가 하나인 컴퓨터가 이에 속한다  SIMD는 하나의 인스트럭션으로 여러 데이터를 처리한다. ​벡터 프로세서가 이에 속하며, 벡터 프로세서는 벡터 연산자의 여러 오퍼랜드를 저장하는 여러 개의 레지스터를 갖고 있어서, ​이들 여러 오퍼랜드에 대해 하나의 인스트럭션을 실행한다  MISD는 하나의 데이터에 대해 다수의 인스트럭션을 차례로 동시 실행한다. ​마치 파이프라인처럼, 파이프라인 컴퓨터가 이에 속한다 ​  MIMD는 다수의 인스트럭션이 다수의 데이터를 동시 실행한다. MIMD는 여러 개의 프로세서로 구성되며, 각 프로세서는 자신의 인스트럭션 스트림을 처리한다          ​MIMD 컴퓨터에는 분산형과 공유 메모리형, 두가지 유형이 있다. ​분산 MIMD 머신은 하나의 랙에 구성되거나 각 지역에 분산되어 구성되며, ​각 프로세서는 자신의 고유 메모리를 갖는다      공유메모리 MIMD 머신은 여러 프로세서가 하나의 메모리를 공유하며, ​메모리 액세스의 충돌을 방지하기 위한 동기화 수단을 제공해야 한다      플린의 분류에 따라, 각각의 머신을 그림으로 표현하면 이 아래 그림과 같다. PU는 프로세싱 유닛으로 싱글 코어 및 멀티코어 프로세서이다​동시 실행을 필요로 하는 이유는 다음과 같다  프로그램이 하드웨어를 동시에 사용하도록 설계되었다면, ​멀티 프로세서 머신에서 프로그램의 실행 속도는 빠르다  프로그램이 컴퓨트 바운드가 아니라면, ​싱글 프로세서 머신에서 실행하더라도, ​동시 실행하도록 짜여진 프로그램은 순차 실행하도록 짜여진 프로그램보다 빠르다  동시 실행은 문제 해결책에 대한 다른 방식의 개념화 방법을 제공한다. 문제의 해결책을 설계할 때 Recursion이 자연스러운 방법인 경우가 있는 것처럼, ​동시 실행이 자연스러운 문제가 많이 있다예를 들어 시뮬레이션은 여러 개의 엔티티를 포함하고, ​여러 엔티티가 자신에게 주어진 역할을 수행한다. 이때 각 엔티티는 서로 종속되어 있지 않기 때문에 동시 실행이 가능하다. 이와 같이 문제에 따라서 동시 실행이 자연스러운 경우가 있다  어플리케이션 프로그램을 여러 머신에 분산시켜야 하는 경우가 있다.  ​이때, 각 머신은 특정 타스크(동시 실행 통제 메커니즘)를 실행하면서, 프로그램 실행을 동기화해야 한다Semaphore프로그램이 여러 서브프로그램으로 구성되어 있을 때, ​동일 프로그램 내의 다른 서브프로그램과 동시 실행되는 서브프로그램을 Task 또는 Process라고 한다자바에서는 특정 메소드, 즉 run method가 Task의 역할을 하며, ​이 메소드는 쓰레드라고 불리는 객체 내에서 실행된다동시 실행되는 Task들 간에 실행 순서를 통제하는 것을 동기화라고 한다협력적 동기화는 Task A가 Task B의 종료를 기다렸다가, Task B의 종료 후 Task A가 실행하는 방식으로, 실행 순서를 통제한다경쟁적 동기화는 Task A, B가 공유 변수(데이터 위치) x를 접근할 필요가 있다면, ​Task B가 x를 접근하고 있는 동안, Task A는 Task B가 x의 접근을 종료하기를 기다리는 방식으로 실행 순서를 통제한다가장 단순한 형태의 협력적 동기화의 예로 생산자-소비자 문제를 들 수 있다하나의 서브 프로그램(생산자)이 데이터를 생산하고, ​다른 서브프로그램(소비자)이 그것을 소비한다. 생산된 데이터는 보통 스토리지 버퍼에 저장된다경쟁적 동기화는 두 Task가 정확히 동시에 공유 변수에 대한 접근을 방지해야 한다만일 TOTAL이 공유 변수이고, ​Task A가 TOTAL+1, Task B가 TOTAL*2고 Task A, B가 동시에 TOTAL을 변경하고자 한다면, ​이들 간에 공유 변수에 대한 레이스 컨디션이 발생한다이를 해결하기 위해 상호배제를 보장해 줘야 하는데, ​이때 데드락이 발생할 수 있다. 따라서 데드락 방지책도 함께 제공해야한다동시 실행을 위한 언어 설계 시, 고려사항은 다음과 같다 ​  경쟁 및 협업 동기화​  Task 스케줄링​  Task를 언제 어떻게 생성하고, Task의 실행을 언제 어떻게 시작 및 종료시킬 것인가?세마포어는 Task 동기화에 사용되는 단순한 메커니즘이다세마포어는 카운터(정수)와 Task 서술자를 저장하는 큐로 구성되며, ​Task 서술자는 Task 실행 상태에 관한 모든 관련 정보를 저장한다. 연산자는 wait, release가 있다협력 동기화를 위한 세마포어 변수는 다음과 같다엠티스팟 세마포어는 엠티스팟 카운터와 엠티스팟 큐로 구성되며, ​풀스팟 세마포어는 풀스팟 카운터와 풀스팟 튜로 구성된다엠티스팟 카운터는 버퍼의 비어있는 칸의 수를 나타내고,​ 풀 카운터는 버퍼의 채워진 칸의 수를 나타낸다엠티스팟 큐는 버퍼에 빈칸이 생기기(즉, 아이템이 나가기)를 기다리는 생산자의 Task를 저장하고, 풀스팟 큐는 버퍼에 아이템이 채워지기를 기다리는 소비자의 Task를 저장한다협력 동기화를 위해 필요한 공유 버퍼에 대한 연산자는 ​디파짓과 펫치가 있다먼저 디파짓을 살펴 보면, ​디파짓은 공유 버퍼에 데이터를 넣기 위한 생산자의 액션으로 다음과 같이 진행된다​  버퍼에 빈칸이 있는지 엠티스팟 세마포어를 검사한다​  만일 적어도 하나 있으면, 디파짓을 실행하고, 엠티스팟의 카운터를 -1 하고, 풀스팟의 카운터를 +1한다 (버퍼에 채워진 칸이 하나 이상 있다는 것을 나타냄)​  만일 버퍼가 꽉차면, 엠티스팟 큐에 생산자의 Task 서술자를 넣고, 버퍼에 빈칸이 생길 때까지 기다린다다음, 펫치를 살펴 보자펫치는 버퍼로부터 데이터를 빼내기 위한 소비자의 액션으로 다음과 같이 진행된다버퍼가 비어있지 않은지 풀스팟 세마포어를 검사한다. 만일 비어있지 않다면, 펫치를 실행하고(버퍼로부터 데이터를 빼내고), 엠티스팟 카운터를 -1하고, 풀스팟 카운터를 +1한다만일 버퍼가 비어있다면, 풀스팟 큐에 소비자의 Task 서술자를 넣고, 데이터가 생길 때까지 기다린다앞의 버퍼에 대한 연산에서 보았듯이, 디파짓과 펫치는 ​세마포어의 카운터와 버퍼에 대한 조작(+, -, 디파짓, 펫치)을 수반한다디파짓과 펫치는, ​이 연산을 세마포어에 대해 직접 수행할 수 있지만, 세마포어에 대한 ‘연산’을 별도로 정의하고, 이를 통해 세마포어 조작을 간접적으로 수행하기도 한다이때 세마포어에 대한 연산은 wait(빨간불)과 release(초록불)이다wait에서, 카운터가 0보다 크면 카운터 -1한다. 만일 카운터가 0보다 크지 않으면, 큐에 Task 서술자를 넣고 기다린다​release에서, 큐가 비어 있으면, 카운터를 +1한다. 만일 큐가 비어 있지 않으면, 큐에서 Task를 빼서 실행한다컴피티션이 언제 어디에서 일어나는가?Shared variable을 서로 갱신하겠다고 동시에 요청할 때 발생한다이때 shared variable에 대한 mutual exclusion(상호배제)를 위해 ​별도의 세마포어가 필요하다그런데 이 세마포어는 카운터가 필요없다. 이러한 이유로 이진 세마포어로 정의한다만일 앞의 shared buffer의 협력적 동기화 문제에서, ​한번에 하나의 Task만 버퍼에 접근할 수 있다고 제한한다면, Shared buffer에 대한 별도의 이진 세마포어가 필요하다브린치 한센이 세마포어에 대해 말하기를, ​세마포어는 무결점의 프로그래머를 위한 동기화 도구이다그러나 이런 프로그래머는 매우 드물다. ​따라서, 세마포어의 사용은 동기화의 신뢰성 문제를 야기한다Monitor세마포어의 사용은 동기화의 신뢰성 문제를 야기한다모니터는 이와 같이 동기화의 신뢰성 문제를 해결하기 위한 방법으로  공유 데이터 구조를 연산자로 캡슐화하여 ​  프로그래머로부터 공유 데이터구조의 상세 사항을 숨긴다이렇게 하여 동기화에 대한 책임을 런타임 시스템으로 돌린다 ​모니터는 class로 구현될 수 있다​  공유 데이터 타입을 갖는 추상 데이터 타입으로 표현 ​  이 클래스의 객체에 대한 접근은 액세스 메소드에 동기화 modifier를 추가하여 통제한다모니터는 concurrent pascal, ada, java 등에서 지원된다사용자 프로그램은 모니터를 사용하여 공유 버퍼에 접근한다  공유 데이터는 사용자 프로그램 안에 없고, 모니터 안에 있다 ​  액세스 메커니즘은 모니터(런타임 시스템)의 일부분으로, 상호 배제를 보장한다. 즉, 모니터가 바쁠 땐, 모니터에 대한 호출이 block되고 큐에 들어가서 기다린다​위 그림은 모니터를 표현한 것이다. 모니터는 상호배제만을 제공하기 때문에, ​협력 동기화에서 요구되는 프로세스 간의 협력은 프로그래머가 코딩해야 한다자바 쓰레드쓰레드는 run 메소드를 실행하는 프로세스이다즉, run 메소드는 쓰레드에 할당되어야 실행된다. 쓰레드 클라스는 쓰레드가 아닌 다른 클라스의 부모가 될 수 없고, ​쓰레드의 서브 클래스에게 서비스를 제공한다Run method는 자바에서 동시 실행 단위로서, ​Run 메소드 코드는 main 메소드, 다른 run 메소드 등과 동시 실행 된다Run 메소드로 클라스를 정의하는 방법은 두 가지가 있다  첫째 방법은, 쓰레드 클래스의 서브클래스를 정의하여 서브 클라스의 run 메소드로 오버라이드하는 방법이다. 만일 새로운 서브 클래스가 다른 부모를 갖고 있으면, 이 방법은 동작하지 않는다  둘째 방법은, 다른 부모로부터 상속된 서브 클래스를 정의하고 runnable 인터페이스를 구현하는 방법이다. Runnable은 run 메소드 프로토콜을 제공하기 때문에, runnable로 구현된 어떤 클래스도 run 메소드를 정의한다정리하면, 쓰레드 클래스는 다른 클라스의 부모가 될 수 없기 때문에, ​어플리케이션 클라스의 메소드를 쓰레드로 실행하려면 runnable로 실행해야 한다​쓰레드 클라스는 동시 실행 자바 프로그램을 생성한다. 쓰레드 클라스는 컨스트럭트, 메소드 등으로 구성된다쓰레드 클라스의 메소드는 ​  Run 메소드는 쓰레드의 액션을 서술한다​  Start 메소드는 run 메소드를 호출하여, 그 쓰레드의 동시 실행을 시작한다  setPriority 메소드는 쓰레드의 우선순위를 변경하고 ​  getPriority 메소드는 쓰레드의 현재 우선순위를 반환한다​아래 코드는 run 메소드로 쓰레드의 액션을 서술하고, ​Start 메소드로 그 쓰레드의 동시 실행을 시작하는 것을 보여준다class MyThread extends Thread {​public void run() { . . . }​}​. . .​Thread myTh = new MyThread();​myTh.start();​Yield 메소드는 동시 실행중인 쓰레드로부터 프로세서의 자발적인 포기를 요구한다이 쓰레드는 즉시 프로세서를 포기하고 ready 큐로 들어 간다Sleep 메소드는 쓰레드가 지정된 시간이 지난 후에 block되기를 원한다이 쓰레드는 ready 큐에 들어간다Join 메소드는 메소드에게, ​다른 쓰레드의 run 메소드가 종료될 때까지, ​실행을 msec 단위로 지연시킬 것을 강요한다아래 코드는 join 메소드의 사용 예를 보여준다public void run() {​Thread myTh = new Thread();​myTh.start();​// do part of the computation of this thread​myTh.join(); // Wait for myTh to complete​// do the rest of the computation of this thread​}​세마포어 클라스는 카운팅 세마포어를 구현한다객체는 카운터만 있고, 큐는 없다. 메소드는 acquire 메소드(wait)와 release(release) 메소드가 있다아래 코드는 이들 메소드의 사용 예를 보여주고 있다. 디파짓과 펫치의 앞뒤에 이들 메소드가 있음을 주의하라acquire()는 세마포어 -1 한다release()는 세마포어 +1 한다여기서 세마포어는 fullspot, emptyspot이다자바 쓰레드에서 상호배제는 모니터 개념으로 구현한다이때 메소드는 synchronize로 지정된다ManageBuf에서 디파짓과 펫치를 synchronize로 정의하여, ​동일한 객체에 대해 실행할 때 서로 방해하는 것을 방지한다아래 코드는 모니터 개념으로 구현된 ManageBuf에서 메소드가 synchronized로 지정된 예를 보여준다class ManageBuf {​  private int [100] buf;​  . . .​  public synchronized void deposit(int item) { . . . }​  public synchronized int fetch() { . . . }​  . . .​}​모니터는 상호배제를 구현하므로, 프로세스 간의 협력적 동기화를 구현하지 못한다따라서 프로세스 간의 협력 동기화의 구현을 위해, ​쓰레드 대기 리스트(wait list of threads)와 wait, notify, notifyAll을 구현한다각각의 객체(P-C 문제에서 producer, consumer가 객체)는 쓰레드 대기 리스트를 가지며, ​대기 리스트에 있는 쓰레드들은 이 객체로부터 자신의 실행에 필요한 ​이벤트를 기다리고 있는 것이다wait 메소드는 쓰레드를 대기 리스트에 넣고 기다리게 한다Notify 메소드는 어떤 대기 쓰레드에게 ‘기다리고 있는 이벤트가 발생했음’을 알린다Notify 메소드가 특정 쓰레드를 깨울 수는 없고, ​JVM이 쓰레드 대기 리스트에서 무작위로 하나를 선택한다NotifyAll 메소드는 ‘객체에서 발생된 이벤트’를 기다리고 있는 쓰레드를 ​모두 깨워서 task-ready queue에 넣는다이렇게 하는 이유는 대기 리스트에 있는 쓰레드들이 기다리고 있는 조건이 ​모두 다를 수 있기 때문이다  자바 쓰레드: Lock자바 쓰레드는 lock을 지원한다자바 쓰레드에 미리 정의된 ReentrantLock 클라스는 ​Lock 인터페이스를 구현하는 데 사용되며, ​lock 인터페이스는 lock, unlock, tryLock 메소드를 선언한다lock 메소드는 try 블록을 사용하여 크리티칼 코드(크리티칼 섹션)를 둘러싼다. unlock 메소드의 호출은 finally 절 안에 있어야 하며, lock의 해제를 보장한다  Statement-Level Concurrency고성능 포트란에서 두 개의 리스트에서 ​서로 대응되는 요소 간의 연산을 병렬 처리하고자 할 때 다음과 같은 문장이 추가된다PROCESSOR proc(n) -&gt; 배열 처리 문장을 동시 실행(병렬 처리)하기 위해 프로세서 n개를 할당 ​DISTRIBUTE (BLOCK vs. CYCLIC) -&gt; 같은 크기의 블록으로 나누어져 프로세서에 할당, 돌아가면서 하나씩 프로세서에 할당 ​ALIGN array1_elt WITH array2_elt -&gt; 배열1에 배열2를 대응시킴",
        "url": "/pl-18"
    }
    ,
    
    "algorithm-06": {
        "title": "NP-완전",
            "author": "lee989898",
            "category": "",
            "content": "NP-완전  문제의 분류  풀 수 있는(solvable) 문제​          P 문제: 다항 시간 내에 풀 수 있는 문제 ​      NP 문제: 다항 시간 내에 풀 수 없는 문제​                  비결정론적 다항 시간 알고리즘으로 해결할 수 있는 문제​                    NP-완전 문제: 지수 시간 내에 풀 수 있는 문제​        풀 수 없는(unsolvable) 문제​          예: 정지 문제(Halting Problem)​      ​  결정 문제​          Yes 혹은 No의 해를 요구하는 문제​      예: 무방향그래프의 정점 s 에서 정점 f 까지 가는 경로의 거리가 K(상수) 이하인 경로가 있는가?​        최적화 문제​          최적의 해를 요구하는 문제​      예: 무방향그래프의 정점 s 에서 정점 f 까지 가는 최단 경로의 거리는 얼마인가?​      최적화 문제는 모두 대응하는 결정 문제로 바꾼 다음 해결한다.​      최적화 문제는 대응하는 결정 문제보다 풀기가 쉽지 않다. ​        NP  비결정론적 다항 시간 알고리즘에 의해 해결할 수 있는 결정 문제들의 집합​  비결정론적 다항 시간 알고리즘이란?​          한 결정 문제의 사례 I를 입력으로 받아 다음을 수행하는 2 단계 알고리즘​      비결정론적 ‘추측’ 단계: 주어진 사례 I에 대한 해 S를 ‘추측’한다.​      결정론적 ‘확인’ 단계: 사례 I와 해 S를 입력으로 받아 S가 I에  대한 해임을 결정론적 다항 시간에 확인하고 그 해가 맞으면 ‘Yes’ 라고 답하고 해가 아니라면 ‘No’ 라고 답하거나 알고리즘이 종료되지 않게 한다. ​        NP 문제는 해가 Yes 라는 근거가 주어졌을 때 그 해가 옳은 근거임을 다항 시간에 확인해 줄 수 있다. ​  NP-완전 문제  NP에 속하는 문제​  어떤 NP-완전 문제를 다항 시간 알고리즘에 의해 풀 수 있다면 나머지 모든 NP-완전 문제들도 다항 시간 알고리즘에 의해 풀 수 있다.​  NP-완전 문제는 결정 문제만으로 국한한다. ​  NP-완전 문제의 핵심 원리  결정 문제의 변환을 이용한 해결 과정​          결정 문제 A를 다항 시간에 해결할 수 있는지 알고 싶다.​      가정​                  다항 시간에 해결 가능한 결정 문제 B를 이미 알고 있다.​          문제 A를 다항 시간에 문제 B로 변환할 수 있고 문제 B의 해(Yes 혹은 No)가 문제 A의 해와 항상 일치한다.​                          문제 A의 사례를 문제 B의 사례로 변환한다. ​              변환된 문제 B의 사례를 문제 B의 알고리즘을 이용하여 해결한다.주: 문제 A도 다항 시간에 해결할 수 있다.​                                            다항 시간에 해결할 수 있는 결정 문제가 아직까지 발견되지   않았다. 따라서 문제 A를 다항 시간에 해결할 수 있는지는 알 수 없다. ​  NP-완전 문제들은 서로 다항 시간에 변환 가능하다.  NP-완전 정의  결정 문제 D는 다음 조건들을 만족시켜야 한다. ​          문제 D는 NP에 속한다.​      NP에 속한 모든 문제는 다항 시간에 문제 D로  변환 가능하다.​        NP-hard  NP-완전보다 넓은 범위의 문제를 포함한다. ​  문제 A가 다음 조건을 만족하면 NP-hard이다.​          NP에 속한 모든 문제는 다항 시간에 문제 A로 변환 가능하다. ​        NP-완전 문제는 NP-hard에 속한다. ​  NP-hard 문제는 반드시 NP 문제일 필요는 없다.​  NP-hard는 최적화 문제도 포함한다.​  문제 A가 다음 조건들을 만족하면 NP-완전이다. ​          A는 NP에 속한다.​      A는 NP-hard이다. ​      ​  한 문제가 NP-hard에 속한다는 것을 증명하는 것은 매우 어렵다. 왜냐하면 NP에 속한 모든 문제를 다항 시간에 그 문제로 변환 가능함을 보여야 하기 때문이다. ​  정리: 한 NP-hard 문제를 다항 시간에 주어진 문제로 변환 가능하다면 그 문제는 NP-hard에 속한다. ​  한 문제가 NP-hard에 속한다는 증명은 이 정리를 이용한다.​  문제 A의 NP-완전 증명 방법​  문제 A가 NP에 속함을 보인다.​  한 NP-hard 문제 C의 사례를 다항 시간에 문제 A의 사례로 변환하는 알고리즘을 작성한다.​  2의 알고리즘을 수행하여 얻은 결과 사례 C와 사례 A의 Yes/No 해가 일치함을 보인다.​주: 어떤 문제가 NP-완전 문제임을 증명하는 것은 쉽지 않다. ​  NP-완전 문제​  논리곱 정규형-만족​  완전 부분 그래프​  정점 커버​  부분 집합의 합​  그래프 색칠하기​  논리곱 정규형-만족 문제  부울 연산식은 논리곱 정규형으로 표현될 수 있다.  문제: 논리곱 정규형의 주어진 부울 연산식의 값이 true가 되도록 부울 연산식의 변수들에 true나 false 값을 할당할 수 있는가?  예: a,b,c -부울 변수,$\\bar{a}$, $\\bar{b}$ , $\\bar{c}$ : a,b,c의 역부울 연산삭: ($\\bar{a}$ $\\lor$ $\\bar{b}$ $\\lor$ c) $\\land$ ($\\bar{a}$ $\\lor$ b) $\\land$ (a $\\lor$ $\\bar{b}$ $\\lor$ $\\bar{c}$ )해: a = true, b = true, c = true  완전 부분 그래프​  무방향 그래프 내에 있는 최대 크기의 완전 부분 그래프를 찾아라  정점 커버​  무방향 그래프 내에 있는 최소 크기의 정점 커버를 찾아라  정점 커버: 무방향 그래프에서 각 간선의 양쪽 끝의 두 정점들 중에서 적어도 1개의 정점을 포함하는 정점들의 집합  예: 아래 그래프에서 최소 크기의 정점 커버 C = {a,c,e}  부분 집합의 합 문제  정수들의 집합 S의 요소들의 합이 K가 되는 S의 부분 집합을 찾아라.  예: S = {10,20,40,70,80}, K = 160          부분 집합{10,70,80}        그래프 색칠하기 문제  무방향 그래프에서 인접한 정점들을 서로 다른색으로 가장 적은 수의 색을 사용하여 색칠하라  예: 아래 그래프에서 a,c: 빨강, b,d: 초록, e: 파랑",
        "url": "/algorithm-06"
    }
    ,
    
    "sc-12": {
        "title": "접근 제어",
            "author": "lee989898",
            "category": "",
            "content": "접근 제어  Access Control  허가되지 않은 사용자의 자원 접근 막는다  정당한 사용자라도 허가되지 않은 방법으로 자원사용 하는 것을 막는다  정당한 사용자가 허가된 방식으로만 자원에 접근하도록 한다  Access control components  Authentication function: 사용자가 시스템에 접근할 수 있는지 결정  Access control function: 사용자의 요청이 허용되는지 결정  Security admin: 사용자의 요청이 자원에 어떻게 접근하는지를 명시한 권한 DB를 관리  Audit: 사용자가 시스템 자원에 접근하는 것을 기록, 감시  Access control architecture  Access Control Policy  접근 제어 정책  어떤 상황에서, 누구에게 어떤 종류의 접근이 허용되는지를 결정  권한 DB에 저장되며 보안 admin이 관리  종류 (동시에 사용가능)          Discretinoary access control(DAC)      Mandatory access control(MAC)      Role-based access control(RBAC)      Attribute-based access control(ABAC)        Discretinoary access control(DAC)  임의 접근 제어  요청자의 신분에 따라 무엇을 할 수 있는지 정의  Window, unix 등 컴퓨터 시스템 널리 사용  Access Matrix 사용          주체와 객체, 권한을 행렬로 표현      행: 자원접근 주체, subject      열: subject가 접근하는 대상자원, object      Entry: 허용되는 접근      -Matrix가 커질 수 있고, 희박해지면 메모리 낭비        방법1. ACL - Access control lists          Access matrix를 열로 분리      객체에 대한 권한을 가진 주체 파악에 유리        방법2. Capablility tickets          Access matrix 행으로 분리      특정 주체에 대해 승인된 객체와 권한 명시      특정 사용자에 허가된 객체/권한들을 정리하기 쉬움      다른 주체에서 티켓을 빌려 주거나 양도 -&gt; 보안문제 발생      티켓 무결성, 기밀성, 인증성      OS가 관리      분산, Cloud 환경에 적합        방법 3. authorization table          한 행에 한 주제의 한 자원에 대한 권한명시      RDB로 구현 용이        DAC 장단점 분석          장점                  객체별 세분화된 접근 제어가능                    단점                  Access Matrix 사용에 따른 메모리 낭비          주체나 객체별로 제어하기 때문에, 전체 자원의 일관성 있는 제어 어려움                      Role-based access control (RBAC)  각 사용자 대신에 역할에 접근 권할을 할당      상업적으로 회사,기관,조직에서 많이 쓰임    사용자 vs 역할 vs 자원의 관계는 다대다      관계는 동적이다    RBAC 장단점 분석          장점                  전체적으로 일관성있는 제어정책가능          직무분석 용이                    단점                  각 주체, 객체별 유연하게 하기 어려움                      Attribute-based access control(ABAC)  가장 최근  주체와 자원의 속성을 표현  DAC, RBAC의 기본개념 실형가능  유연성과 표현력이 우수  3요소 - 속성, 정책 모델, 아키텍처 모델  +유연하고 세분화 보안정책 설계      -설계자 과다업무, 비용    속성          주체, 객체, 환경, 권한에 의해 미리 정의되고 할당된 요구되는 동작의 특정 측면을 정의하는 성질​      주체 속성​                  주체는 정보가 객체사이에 이동하거나 시스템 상태를 변경하는 능동적 존재(User, application, process, device)​          주체의 이름, 소속, 직책 등​                    객체 속성​                  정보를 포함하거나 받는 수동적 시스템 존재 (file, device, table, record, process, program, network)​          MS Word문서는 이름, 저자, 날짜 등을 속성으로 가짐​                    환경 속성​                  운영, 기술, 상황, 환경 기술​          현재 날짜, 시간, 네트워크 보안 레벨                    ",
        "url": "/sc-12"
    }
    ,
    
    "pl-17": {
        "title": "ImplementSubprogram",
            "author": "lee989898",
            "category": "",
            "content": "ImplementSubprogram서브프로그램 호출과 반환의 구현, 이것을 서브프로그램 링키지(linkage)라고 한다Semantics of Calls and Returns서브프로그램 링키지는 호출과 반환에 관련된 액션들의 실행으로 구성된다. 이러한 액션들을 호출 및 반환 시맨틱이라고 한다일반적인 서브프로그램 호출 시맨틱은 다음을 포함한다  파라미터 패싱 방법의 구현  로컬 변수에 대한 스토리지 할당 및 바인딩 (로컬 변수가 정적 변수가 아닐 경우) ​  콜러의 실행 상태 저장: ​          실행상태는 콜러의 재실행(resume)에 필요한 레지스터 값, CPU 상태 비트, 환경 포인터(EP)를 포함하며​      EP는 콜리의 실행 중에, 로컬 변수 및 파라미터를 접근하는데 사용된다  ​        콘트롤을 콜리에게 이전​  콜리에 나타나는 난로컬 변수의 접근 메커니즘의 생성서브프로그램의 반환 시맨틱은 다음을 포함한다  포말 파라미터의 로컬 값을 액추얼 파라미터에게 인아웃 또는 아웃 모드로 카피​  로컬 변수의 스토리지를 해제​  콜러 실행 상태의 재저장​  콜러에게 콘트롤 이전Implementing “Simple” Subprograms단순 서브프로그램의 호출 및 반환을 어떻게 구현하는지 보자단순 서브프로그램에서는 ​서브프로그램의 중첩을 허용하지 않고, 모든 로컬 변수가 정적이다. 호출과 반환에 필요한 스토리지는 다음의 데이터를 포함한다  콜러의 상태 정보, 파라미터, 복귀 주소, 함수의 반환값​단순 서브프로그램은 서브프로그램 코드와 데이터로 구성되는데 ​데이터 파트는 로컬 변수, 호출과 반환에 필요한 데이터(위에 언급된)를 포함한다단순 서브프로그램의 호출 시맨틱스(액션과 그 순서)은 다음과 같다  현재 수행중인 프로그램(콜러)의 실행 상태를 저장 ​  파라미터의 계산 및 패스​  콜리에게 복귀 주소를 패스​  콜리에게 컨트롤을 이전단순 프로그램의 반환 시맨틱스(액션과 그 순서)는 다음과 같다  포말 파라미터의 현재 값을 대응하는 액추얼 파라미터에게 카피 (만일 pass-by-value-result나 pass-by-value라면) ​  함수 값을 콜러에게 카피(만일 콜리가 함수라면) ​  콜러의 실행 상태를 재저장​  콜러에게 컨트롤을 재이전(되돌려줌)실행중인 서브프로그램의 데이터 파트를 위한 데이터 구조로 액티베이션 레코드를 정의한다. 액티베이션 레코드는 로컬 변수, 파라미터, 복귀 주소로 구성된다단순 서브프로그램의 액티베이션 레코드(AR)는 크기가 고정되어 있고, ​정적으로 할당된다. 따라서 스택에 저장되지 않는다. ​이러한 액티베이션 레코드는 recursion을 지원할 수 없다​위 그림은 단순 서브프로그램의 액티베이션 레코드의 예이다. 예에서 단순 서브프로그램은 A, B, C이고, 이들의 코드와 액티베이션 레코드는 오른쪽 그림과 같이 메모리에 할당된다메모리에 할당되는 A, B, C의 코드와 데이터의 위치는 ​정적으로 할당되기 때문에 호출되는 순서와 무관하다A, B, C 모두 별개로 컴파일될 수 있으며, ​이 경우 링커에 의해 그림과 같이 모아진다Implementing Subprograms with Stack-Dynamic Local Variables서브프로그램의 로컬 변수가 스택-동적일 경우, ​서브프로그램의 호출 및 반환 구현에 대해 알아보자스택 동적 로컬 변수는 런타임 스택에 할당된다. ​장점은 recursion의 지원이다스택-동적 로컬 변수가 있는 서브프로그램의 호출과 반환을 구현하려면 ​액티베이션 레코드가 더욱 복잡해진다  컴파일러는 ‘스택에서 로컬 변수의 암묵적인 할당과 해제’를 지원하기 위한 코드를 생성해야 한다  Recursion은 하나의 서브프로그램에 대해 여러 개의 액티베이션 레코드를 추가할 가능성이 있다. ​즉, 액티베이션 레코드 여러 개가 스택에 생성된다int AddTwo(int x,y){    int sum;    sum = x + y;    return sum;}위 함수를 실행하려면 어떤 데이터가 필요할까?파라미터 x, y, 로컬 변수 sum, AddTwo 종료후 복귀할 return address 이와 같이, 액티베이션 레코드는 함수를 한번 실행하는데 필요한 데이터로 구성된다위의 코드에서, AddTwo  함수가 호출될 때, 액티베이션 레코드가 생성되고 런타임 스택에 저장된다그러면 스택에 저장된 이들 변수를 어떻게 접근할까? ​Caller의 스택 포인터를 이용하면 가능한가? 아니다SP는 액티베이션 레코드를 스택에 저장하고자 할 때, ​스택 메모리를 할당하고(나중에 해제하는) ‘시스템이 사용하는’ 레지스터이다. 따라서 서브프로그램이 사용할 수 있는 레지스터가 아니다​액티베이션 레코드에 저장된 파라미터나 로컬 변수에 접근하려면  액티베이션 레코드에 접근할 때, ​BP(베이스 포인터)를 사용한다. BP는 AR의 맨앞의 주소를 말하며, ​서브프로그램의 실행 중에 변경되지 않는다 BP는 지정된 레지스터에 저장되는데, 그림에서 이것을 BP라고 표시하자  파라미터나 로컬 변수에 접근하려면, ​BP+옵셋을 계산하여 스택에 저장된 파라미터나 로컬 변수에 접근한다 ​  서브프로그램이 종료되어 반환될 때, ​BP는 ‘caller의 액티베이션 레코드의 BP’로 재저장된다여기서 return addr는 복귀 주소로, ​서브프로그램의 종료후 되돌아갈 caller의 위치를 나타낸다BP는 항상 현재 실행 중인 프로그램의 액티베이션 레코드의 시작 주소를 가리킨다서브 프로그램이 호출되면, 현재 BP는 callee의 액티베이션 레코드(dynamic link)에 저장되고 ​BP는 새로 생성된 callee의 액티베이션 레코드의 시작 주소를 가리키도록 새롭게 설정된다즉, callee로부터 반환되자마자, BP는 callee의 액티베이션 레코드(dynamic link)의 값으로 재저장된다​위 그림은 코드와 데이터, 서브프로그램 링키지 코드(AddTwo PROC),그리고 액티베이션 레코드가 저장된 스택을 보여준다esp, ebp는 각각 스택포인터, 베이스 포인터이며, eax는 반환값을 저장하는 장소이다AddTwo PROC은 스택에 할당된 액티베이션 레코드에 접근하여, ​스택에 저장된 두 수를 더하여 eax에 저장하여 반환하고, 반환후 5와 6이 저장되었던 8 바이트를 청소하고 종료하는 과정을 보여준다이때 EBP, ESP를 caller의 것으로 변경한다액티베이션 레코드 내에서 로컬 배열의 할당은 위의 그림과 같다동적 링크가 있는 것이 특이하다. ​동적 링크는 스택 메모리에 저장되어 있는, ​바로 아래의(caller의) 액티베이션 레코드를 가리킨다​Recursion이 없이, 여러 서브프로그램으로 구성된 프로그램에서, ​메인이 B를 호출하고, ​B가 C를 호출하고, ​A가 C를 호출한다고 하자그렇게 되면, 위와 같이 액티베이션 레코드가 스택 메모리에 할당된다. 동적 링크는 바로 아래(caller)의 액티베이션 레코드를 가리킨다이와 같이, 스택에 스택-동적 액티베이션 레코드가 연속적으로 쌓여진 것을 동적 체인(dynamic chain)이라고 한다로컬 변수의 접근은 BP와 옵셋을 계산에 의하며, 이러한 옵셋을 로컬 옵셋이라고 한다. 로컬 변수의 로컬 옵셋은 컴파일러에 의해 컴파일 타임에 결정된다​​​Recursion이 있을 때, ​액티베이션 레코드는  위의 그림과 같다. 여기서 파라미터는 n이다첫째, 둘째, 셋째 recursion을 호출했을 때 function value가 모두 ?셋째 recursion을 종료되었을 때 둘째 호출이 종료되었을 때 function value가 모두 ?이 아니다Nested Subprograms중첩 서브프로그램의 호출과 반환 구현 방법을 살펴 보자서브프로그램이 그 안에 다른 서브프로그램을 포함하는 경우, 이것을 중첩 서브프로그램이라고 부른다중첩 서브프로그램에서, 난로컬 변수에 어떻게 접근할 것인가? 이들 변수는 스택의 액티베이션 레코드에 있다난로컬 변수에 접근하려면, ​먼저 스택에서 올바른 액티베이션 레코드를 찾아야 한다다음, 액티베이션 레코드 내에서 그 변수의 옵셋을 찾아야 한다정적 스코프일 경우​  정적 조상 스코프에 선언된 변수가 나타나고 접근될 수 있다 ​  언급된 모든 난로컬 변수는 스택의 다른 액티베이션 레코드에 할당되어 있다올바른 액티베이션 레코드를 찾으려면, ​정적 조상의 액티베이션 레코드를 체인으로 연결하라정적 링크는 정적 부모의 시작 주소를 가리키는 포인터이다정적 체인은 실행 중인 서브프로그램의 정적 부모를 포함해서 모든 정적 조상을 연결한다체인을 따라가면, 올바른 액티베이션 레코드를 찾을 수 있다  스코프의 중첩은 정적이기 때문에 컴파일 타임에 미리 알려진다 ​  따라서 쉽게 찾아갈 수 있다정적 체인을 따라가는데 필요한 정보는  static_depth: 정적 스크프의 중첩 깊이​  Chain_offset(또는 nesting_depth): 난로컬 변수를 언급한 서브프로그램의 staic_depth 와 난로컬 변수를 선언한 서브프로그램의 static_depth 간의 차이 ​변수의 언급은 (chain_offset, local_offset)으로 표현되며, local_offset 은 액티베이션 레코드 내에서 언급된 변수의 옵셋이다호출할 때, 액티베이션 레코드를 생성한다  동적 링크는 스택의 old 탑 포인터이다​  정적 링크는 ‘가장 최근의 정적 부모’의 액티베이트 레코드를 가리킨다액티베이션 레코드를 생성한 후, 정적 체인을 생성하는 방법은 두가지가 있다  ​  동적 체인을 따라가면서 부모 스코프를 찾는다  컴파일러가 서브프로그램 호출을 만나면, 호출된 서브프로그램의 정적 부모를 찾아서 그 부모로부터의 nesting_depth를 기록한다. 그 서브프로그램이 호출될 때, 콜러의 정적 링크에 있는 값과 nesting_depth의 수로부터 callee의 정적 링크를 찾을 수 있다정적 체인은 다음과 같은 문제를 내포하고 있다. 중첩 깊이가 크면, 난로컬 변수에 대한 참조(레퍼런스)가 늦다. 난로컬 참조의 비용 산출이 어렵다Implementing Dynamic Scoping동적 스코프 방법의 구현에는, 딥 액세스와 쉘로우 액세스, 두가지 방법이 있다딥액세스는 동적 체인에서 액티베이션 레코드를 검색하여 난로컬 참조를 찾는다  체인의 길이를 정적으로 결정할 수 없다  모든 액티베이션 레코드는 검색 과정을 위해 변수명을 가져야 한다쉘로우 액세스는 각 변수명마다 하나의 스택을 유지하고, 중앙 테이블에 각 변수명에 대해 하나의 엔트리를 할당한다",
        "url": "/pl-17"
    }
    ,
    
    "st-08": {
        "title": "프로세스통신-pipe",
            "author": "lee989898",
            "category": "",
            "content": "프로세스통신-pipe  Inter-Process Communication (IPC)​  프로세스들끼리 데이터를 주고 받는 기능 수행  예: Client/Serve 응용 프로그램, 등  Pipe/Socket: 파일 디스크립터를 사용하여 접근 가능한 IPC방법들  Pipe  리눅스에서 가장 오래된 IPC이다  Pipe은 메모리 버퍼 영역을 가리킴​          읽기용 입구 하나, 쓰기용 입구 하나를 가짐​        파일 디스크립터로 접근(access)​          읽기용 입구와 쓰기용 입구에 각각 다른 파일 디스크립터가 할당됨​        통신을 하게 될 프로세스들이 파일 디스크립터 들을 공유해야 : (예) 부모, 자식 관계​          프로세스는 pipe() system call을 사용하여 파이프를 생성한다      동일한 프로세스가 fork()를 호출하여 자식 프로세스를 생성한다      그러면 파이프는 parent 프로세스와 child 프로세스 간에 사용된다        파이프의 한계          Half duplex: 데이터는 한 방향으로만 흐른다      공통 조상이 있는 프로세스 사이에서만 사용할 수 있다​                  일반적으로 parent 프로세스와 child 프로세스 사이에 사용          프로세스가 파이프를 생성하면 모든 자식이 파이프를 상속할 수 있다                    휘발성: 파이프를 생성한 프로세스가 종료되면 사라진다      process는 파이프를 전달할 수 없으며 parent로부터 상속해야 한다                                    Linux 셸에서 파이프 기호는 “          “이다                                                                        % ls -alg              more​                                                                                      %  cmd1              cmd2​                                          터미널에서 cmd1 입력      cmd1의 출력은 cmd2의 입력      cmd2의 출력은 터미널 화면에 연결한다        Long pipes:​                                                      $ pic paper.ms              tbl              eqn              ditroff -ms​                                            Pipe을 이용하여 두 개의 프로세스 들이 통신을 할 경우, producer가 write한 순서대로 consumer가 read하게 된다​          선입선출(First-In First-Out)관계​        단방향 pipe : ​          Producer 프로세스는 pipe에 대한 write용 입구만 사용​      Consumer 프로세스는 pipe에 대한 read용 입구만 사용​        쌍방향 pipe : ​          Pipe을 두 개 열어 사용​      하나의 pipe는 한쪽 방향의 통신에만 사용됨​        Pipe: pipe() system call#include &lt;unistd.h&gt;int pipe(int fd[2]) // int fd[2]; 파일 디스크립터  정상 종료하면 0을 반환, 에러 발생시에는 -1을 반환​  pipe() system call은 인자로 넘겨 받은 fd[0], fd[1]에 파일 디스크립터를 저장해서 반환​  fd[0]: 읽기 모드에서 연 파일 디스크립터(읽기용 입구)​      fd[1]: 쓰기 모드에서 연 파일 디스크립터(쓰기용 출구)​    Pipe(), fork() 시스템 호출에 의해 부모/자식 프로세스가 fd[0], fd[1]를 공유한다고 가정​  쓰는 쪽(write() system call) 프로세스에서는 읽기용 파일 디스크립터(fd[0])를 닫아 놓음(close() system call)​  읽는 쪽(read() system call) 프로세스에서는 쓰기용 파일 디스크립터(fd[1])를 닫아 놓음(close() system call) ​  Pipe: popen()#include &lt;stdio.h&gt;FILE *popen(const char *cmdstring, const char *type);    반환값: 정상이면 파일 포인터, 오류 시 NULL  popen은 “cmdstring”을 실행하기 위해 fork() 및 exec()를 수행한다​  popen의 유형은 “r” 또는 “w”이다​          type이 “r”이면 반환된 파일 포인터는 “cmdstring”의 stdout에 연결된다      type이 “w”인 경우 반환된 파일 포인터는 “cmdstring”의 표준 입력에 연결된다        Pipe: pclose()#include &lt;stdio.h&gt;int pclose(FILE *fp);    반환값: cmdstring의 종료 상태 또는 오류 시 -1  “pclose”는 std I/O 스트림을 닫고 명령이 종료될 때까지 기다렸다가 셸의 종료 상태를 반환한다  FIFO  파이프와 비슷하다, “named pipe” 라고 불리운다​  파일의 종류  FIFO는 파이프의 한계를 극복한다​  관련 없는 프로세스 간에 사용 가능#include &lt;sys/types.h&gt;    #include &lt;sys/stat.h&gt;int mkfifo(const char *filename, mode_t mode);정상이면 0, 오류시 -1을 반환한다  FIFO 생성은 파일 생성과 유사하다          Mode: open() 함수와 동일한 권한        FIFO를 사용하는 것은 파일을 사용하는 것과 유사하다          생성되면 FIFO에 대한 열기, 닫기, 읽기, 쓰기, 연결 해제 등을 사용할 수 있다        파이프와 마찬가지로 읽기를 위해 열려 있는 프로세스가 없는 FIFO에 쓰면 SIGPIPE 신호가 생성된다  FIFO의 마지막 작성자가 FIFO를 닫으면 FIFO의 판독기에 대해 파일 끝이 생성된다  PIPE_BUF(커널의 파이프 버퍼 크기)는 FIFO에 원자적으로 쓸 수 있는 최대 데이터 양을 지정한다          여러 프로세스의 데이터 쓰기 &lt;= PIPE_BUF는 인터리브되지 않는다        FIFO 사용 예          셸 명령에서 중간 파일을 생성하지 않고 한 셸 파이프라인에서 다른 셸 파이프라인으로 데이터를 전달하는 데 사용​      클라이언트와 서버 간에 데이터를 전달하기 위해 클라이언트-서버 애플리케이션에서 사용        FIFO : 출력 스트림 복제  입력 스트림을 두 번 처리하는 절차 작성  tee(1)은 표준 입력을 표준 출력과 명령줄에 명명된 파일 모두에 복사한다$ mkfifo fifo1​$ prog3 &lt; fifo1 &amp;​$ prog1 &lt; infile | tee fifo1 | prog2  FIFO : 클라이언트-서버 통신  서버는 클라이언트와 통신하기 위해 “well-known” FIFO를 생성한다(well-known: FIFO의 경로 이름은 서버에 접속해야 하는 모든 클라이언트에게 알려져 있음)  클라이언트 데이터의 interleaving을 피하기 위해 클라이언트는 한 번에 최대 PIPE_BUF 바이트를 써야 하다​  문제: 서버가 단일 “well-known” FIFO를 사용하여 클라이언트에 응답할 수 없음  서버는 클라이언트별 FIFO를 사용하여 응답할 수 있도록 각 클라이언트에 대해 FIFO를 생성한다          e.g.: /tmp/serv1.XXXX, where XXXXX is client’s process ID ​        서버는 SIGPIPE를 잡아야 함(1개의 작성자가 있는 FIFO, 판독기 없음)​          클라이언트는 서버에서 응답을 읽기 전에 요청을 보내고 종료하여 클라이언트별 FIFO를 하나의 작성자(서버)와 리더 없이 남겨둔다      ",
        "url": "/st-08"
    }
    ,
    
    "sc-11": {
        "title": "이메일 보안",
            "author": "lee989898",
            "category": "",
            "content": "이메일 보안  PGP  운영체제에 상관없이 확정성이 뛰어나다  S/MIME  공개키 기반의 프로토콜이다  RSA, El Gamel을 사용한다  대칭키 방식과도 연동된다(3DES)  Requirements of secure E-mail  기밀성  송신자 인증  메시지 무결성  수신자 인증  Secure e-mail: 기밀성  앨리스는 기밀성을 입증한 e-mail, m을 밥에게 보내고 싶다  랜덤 대칭키를 생성한다, KS  메시지를  KS로 encrypt한다  또한 KS를 밥의 공개키로 encrypt한다      밥에게 KS(m)과 KB(KS)를 보낸다    밥은 그의 private키로 decrypt하여 KS를 찾아낸다  KS로 KS(m)을 decrypt하여 m을 찾아낸다  Secure e-mail: 송신자 인증, 무결성  앨리스는 송신자 인증과 메시지 무결성을 지키고 싶다  앨리스는 메세지를 digitally 사인한다  메시지와 디지털 시그니처 모두 보낸다  Secure e-mail: all together  앨리스는 보안,송신자 인증,메시지 무결성을 지키고 싶다  앨리스는 3가지 키를 사용한다          그녀의 private key      밥의 public key      새로 만들어진 대칭키        Email 보안 표준  PGP  S/MIME          이메일을 위해 MIME에 보안서비스 제공 표준      인증,무결성,부인방지,기밀성 제공      ",
        "url": "/sc-11"
    }
    ,
    
    "sc-10": {
        "title": "signature",
            "author": "lee989898",
            "category": "",
            "content": "signature  서명  자기의 동일성을 표시하고 책임을 분명하기 하기 위하여 문서 따위에 자기 이름을 써넣음​  전자서명의 기본 아이디어  송신자(alice)는 자신의 비밀키로 암호화​  수신자는 송신자의 공개키로 복호화  시나리오:+ Bob은 public key를 공개된 장소에 두고, private key는 자신이 가지고 있다+ Alice는 Bob의 public key를 가져와, 메시지를 암호화해서 전송​+ 이 메시지는 다른 사람이 보더라도 풀 수 없다. 메시지를 복호화하려면 Bob의 private key가 필요하기 때문-&gt;기밀성보장​  문제점1. Bob은 Alice가 메시지를 작성했다는것을 확신할 수 있을까? NO​  문제점2. Bob은 메시지가 중간에 변경되지않았다는것을 확신할 수 있을까? NO​  해결법  Alice는 메시지로 MAC을 만들고, 이것을 Alice가 자신의 private key로 암호화 한다​     만들어진 것을 본래 메시지에 붙인다 -&gt; 서명​     이것을 Bob의 public key로 암호화 해서 전송  다른 사람은 Bob의 private key가 없으므로 볼수없다 -&gt; 기밀성​  Bob은 자신의 private key로 열면 평문과 시그니쳐가 나온다​     Bob은 다음과 같이 무결성,인증을 한다​   ",
        "url": "/sc-10"
    }
    ,
    
    "pl-16": {
        "title": "서브프로그램",
            "author": "lee989898",
            "category": "",
            "content": "서브프로그램Fundamentals of Subprograms서브프로그램이 무엇인지 왜 필요한지 살펴 보자동일한 코드 부분(segment)이 프로그램의 여러 곳에서 나타난다고 하면, 이 코드를 여러 곳에 중복해서 코딩하기보다는,​한번만 코딩하고, 필요할 때마다 그 코드 부분으로 점프했다가 끝나면 되돌아 오는 방식으로, 프로그램을 짤 수 있다이러한 코드 부분을 서브프로그램이라고 한다.동일한 코드 부분이 프로그램의 여러 곳에 나타나고, ​나타나는 곳마다 사용되는 변수가 다르다고 가정해 보자. 이때 파라미터를 갖는 서브프로그램을 사용할 수 있다. 서브프로그램의 개념은 쓰레드와 같은 것으로 발전하고 있다서브프로그램은 다음과 같은 특징을 갖는다  각 서브 프로그램은 단하나의 진입점을 갖는다  호출한 서브프로그램(caller)는 호출된 서브프로그램(callee)의 실행 중에는 중지된다​  callee가 종료되면, 컨트롤을 항상 caller에게 되돌려준다  Basic Definitions서브프로그램은 정의부와 선언부로 구성된다서브프로그램 정의부는 서브프로그램의 인터페이스와 액션을 서술하고, ​정의부의 맨앞에는 서브프로그램의 헤더가 있다. 헤더는 void adder(parameter) 처럼 서브프로그램 이름, 유형, 포말 파라미터 등을 포함한다포말 파라미터의 개수, 순서, 타입을 파라미터의 프로파일(시그니처, 요약)이라고 부른다서브프로그램 선언부는 파라미터 프로파일과 반환 타입을 선언한다. 서브프로그램 호출(call)은 서브프로그램으로 점프한다  Parameters서브프로그램에서 데이터에 접근하는 방법은 두가지가 있다  난로컬 변수에 직접 접근하는 경우 ​  파라미터 패싱을 사용하는 경우파라미터 패싱을 사용하여 데이터를 접근할 때에는 ​로컬 변수명을 사용한다. 난로컬 변수에 직접 접근하는 것보다 융통성이 높아 파라미터화에 의한 계산이 가능하다. 난로컬 변수에 대한 광범위한 접근은 부작용으로 인해 신뢰성을 감소시킨다. ​순수 함수 언어는 수정 가능한 데이터를 허용하지 않으며, 메모리 내용을 변경할 수 없도록 제한한다포말 파라미터는 callee의 헤더에 있는 파라미터를 말한다서브프로그램이 호출될 때만 메모리에 바인딩되고, ​액추얼 파라미터를 통해서 바인딩되기 때문에, ​종종 더미 변수로 취급되기도 한다. 액추얼 파라미터는 caller에서 사용되는 값이나 주소를 나타낸다  Binding Actual to Fromal Parameter액추얼 파라미터를 포말 파라미터에 바인딩하는 방법은 두 가지가 있다  위치 파라미터: 파라미터의 순서가 중요  키워드 파라미터: 파라미터의 이름이 중요, 순서는 중요하지 않음파이썬에서 sumer(my_length, list=my_array, sum = my_sum), 포말 파라미터는 length, list, sum이고, 액추얼 파라미터는 my_length, my_array, my_sum 이라면, ​첫번째 파라미터는 위치 파라미터이고, ​두번째 세번째는 키워드 파라미터이다키워드 파라미터의 장점은 순서에 얽매이지 않는다는 것이고, ​단점은 사용자가 포말 파라미터의 이름을 알고 있어야 한다는 것이다C++, 파이썬 등에서는 액추얼 파라미터가 모두 다 패스되지 않을 경우, ​포말 파라미터는 대응되지 않는 나머지 파라미터에 대해 디폴트 값을 가질 수 있다. C++에서 파라미터는 위치에 연관되기 때문에 ​디폴트 파라미터는 마지막에 나타나야 하며, 디폴트값은 서브프로그램 헤더에 있다  Two Categories of Subprograms서브프로그램에는 프로시져와 함수가 있다. 프로시져는 파라미터화된 계산을 정의하는 문장의 모음이고, 함수는 프로시져와 구조적으로 닮았으나 ​의미적으로 수학의 함수를 본떠서, 값을 반환한다수학적으로 함수는 하나의 값만 반환하기 때문에 부작용이 없으나, ​실제 프로그래밍 언어에서는 부작용이 있다. ​사용자는 새로운 연산자를 함수로 정의할 수 있다서브프로그램 내에 정의된 변수는 모두 로컬이며, ​그들의 스코프는 항상 서브프로그램 안이다로컬 변수는 정적 또는 스택-동적으로 바인딩된다​로컬 변수가 스택-동적이라면, ​서브프로그램의 실행이 시작될 때 메모리에 바인딩되고, 실행이 끝나면 메모리에서 떨어진다스택-동적 변수의 장점은  Recursive 서브프로그램이 스택-동적 로컬 변수를 갖는다 -&gt; recursion 처리가 가능​  액티브 서브 프로그램의 로컬 변수가 ​액티브하지 않은 서브프로그램이 해제한 로컬 변수의 메모리를 사용할 수 있다프로그램이 시작되고나서 아직 끝나지 않은 상태에서는 ​자주 호출되는 서브프로그램의 실행이 끝났다고 해도 ​그 서브 프로그램의 변수는 아직 메모리를 차지하고 있을 수 있다. 이때 서브프로그램의 상태를 액티브라고 한다현대 언어에서, 서브프로그램의 로컬 변수는 디폴트로서 스택-동적으로 바인딩된다C, C++ 함수에서, 로컬 변수는 정적이라고 명시되어 있지 않으면 스택-동적이다int adder(int list[], int listlen) {​ static int sum = 0;​ int count;​ for (count = 0; count &lt; listlen; count ++)​ sum += list [count];​ return sum;​}위의 예에서 sum 변수는 정적이고, count 스택 동적이다  Nested Subprograms서브프로그램이 다른 서브프로그램안에만 있어야 한다면, ​이것을 중첩 서브프로그램이라고 한다다른 서브프로그램 안에서 숨어서(hide) 다른 프로그램이 호출할 수 없게 만든다서브프로그램의 중첩으로 처리 논리와 스코프의 계층구조를 생성할 수 있다  정적 스코핑의 사용 ​  알골, 파스칼에서 허용 ​  C 계열 언어는 서브프로그램의 중첩을 허용하지 않음​  자바스크립트, 파이썬 등은 중첩 허용Parameter-Passing Methods파라미터 패싱에 대한 시맨틱 모델은 3가지가 있다  포말 파라미터가 대응하는 액추얼 파라미터로부터 데이터를 받는 것이다. 이것을 in mode라고 한다 ​  포말 파라미터가 액추얼 파라미터에게 데이터를 보내는 것이다. 이것을 out mode라고 한다  포말 파라미터가 대응하는 액추얼 파라미터로부터 데이터를 받고, 액추얼 파라미터에게 데이터를 보내는 것이다. 이것을 inout mode라고 한다파라미터간에 데이터를 주고 받는 방법은 두가지가 있다. 실제 값을 카피하여 주고 받는 방법과 액세스 패스(접근 경로)를 주고 받는 방법이다  Implementation Models of Param Passing파라미터 패싱 구현 모델에는 ​pass by value(in mode), pass by result(out mode), ​pass by value result(inout mode), pass by reference(inout mode)가 있다Caller의 액추얼 파라미터를 Pass by value 모델로 callee에게 보낼때, 액추얼 파라미터의 값은 copy를 통해, ​대응되는 포말 파라미터의 초기화에 사용된다. 단점은 다음과 같다​  copy 하면, ​  추가적인 메모리를 필요로하고, 실제 이동 비용이 발생한다  만일 접근 경로(access path)에 의한다면, callee에서 쓰기 보호를 해야하는 동시에, ​간접 주소방식에 의한 접근 비용이 추가된다Callee의 파라미터를 pass by result 모델로 caller에게 보낼 때, ​  대응되는 포말 파라미터는 로컬 변수처럼 행동한다 ​  Callee가 종료되어 컨트롤을 caller에게 돌려주면, 포말 파라미터의 값을 caller의 액추얼 파라미터로 전달한다​  추가적인 메모리 위치와 copy 연산이 필요하다Pass by result에 내재하는 문제는 다음과 같다Caller와 callee가 ​Caller: sub(p1, p1) -&gt; actual parameter p1, p1Callee: sub(x, y) -&gt; formal parameter x, y 라고 하자 액추얼 파라미터 두개가 p1으로 같고, ​대응하는 포말 파라미터 두개의 이름이 x, y로 다르다Caller가 callee를 호출해서 callee가 실행 후 종료되고, ​Callee가 calle에게 결과값을 반환할 때, ​x, y 중 어느 것이 p1에 마지막으로 copy 되느냐에 따라, ​p1의 값이 달라진다. ​x거나 y이다. 이것이 pass by result에 내재하는 문제이다Pass by value result는 ​pass by value와 pass by result의 결합으로 ​pass by copy라고도 부른다액추얼 파라미터의 값은 대응하는 포말 파라미터의 초기화에 쓰이고, ​포말 파라미터는 로컬 변수처럼 행동한다. ​포말 파라미터의 값은 액추얼 파라미터에게 반환된다. ​단점은 in, out 모두 카피에 의존하는 것이다Pass by reference 모델은 접근 통로의 패스를 통해, ​파라미터를 패스한다즉, callee에게 caller의 액추얼 파라미터를 접근하도록 허용한다. 따라서 pass by sharing이라고도 한다장점은 패싱 프로세스가 효율적이다. ​Copy 연산, 메모리 모두 필요없다단점은 느리고, 예기치 않았던 난로컬 변수를 접근할 수도 있다대부분 언어에서, 파라미터 패싱의 구현은 런타임 스택을 통해 일어난다C에서 파라미터 패싱은 pass by value를 지원한다. 포인터를 사용하면, Pass by reference를 구현할 수 있다자바는 모든 파라미터에 대해 pass by value를 지원하며, 객체 파라미터에 대해 pass by reference를 지원한다  Type Checking Parameters파라미터에 대한 타입 검사는 ​액추얼 파라미터와 포말 파라미터 간에 타입의 일관성을 검사하는 것이다파라미터의 타입 검사는 소프트웨어의 신뢰성을 위해 매우 중요하다포트란 77, 원시 C에는 파라미터 타입 검사가 없다. ANSI C, C++에는 선택적이며, ​파이썬, 루비에서는 변수가 타입을 갖지 않기 때문에 ​파라미터 타입 검사가 없다파라미터의 타입이 다차원 배열일 경우, ​서브프로그램이 따로 컴파일되어 있고, ​다차원 배열이 서브프로그램으로 패스된다고 가정하자. 컴파일러는 메모리 매핑을 위해, ​선언된 배열의 크기를 알 필요가 있다row-major 매트릭스의 메모리 매핑 함수는address(mat[i,j]) = address(mat[0,0]) + i * #_columns + j 이다즉, 컬럼의 길이만 알면 전체 크기를 알 수 있다현대 프로그래밍 언어에서 다차원 배열 파라미터를 어떻게 패스하는지 살펴 보자C, C++에서,1) 프로그래머가 액추얼 파라미터의 첫번째 서브스크립트를 제외하고, ​나머지 서브스크립트의 크기를 선언하는 방법void fun(int mat[][10]) { ... }​void main() {​   int mat[5][10];   ...​   fun(mat);   ... }​위 프로그램에서 mat은 2차원 배열이고, ​함수 fun(mat)은 mat을 파라미터로 하는 함수이다. 이와 같은 방식은 서브프로그램의 유연성을 불허한다는 것이다2) 이에 대한 해결책으로, ​배열에 대한 포인터, 차원 크기를 파라미터로 패스하는 방법이 있다다만, 배열 처리를 위해 ​사용자는 메모리 매핑 함수를 포함해야 하는 불편함이 있다자바에서는 배열을 객체로 취급한다. 이들은 모두 일차원 배열이지만 ​배열의 각 요소가 배열일 수 있어서 ​다차원 배열을 파라미터로 쓸 수 있다. 자바에서 각 배열은 named constant(length와 같은)를 상속받는다.  Design Considerations파라미터 패싱 방법의 구현시, 다음 두가지를 고려해야 한다  효율성  일방(in, out) 또는 쌍방(inout) 데이터 이동:caller-callee간에그러나 이들 고려사항은 서로 상충된다. ​프로그래밍을 잘하려면, 변수에 대한 접근을 가능한한 일방(in, out)으로 제한하는 것이 좋다pass by reference(inout)는 크기가 큰 데이터 스트럭처를 패스하는데 더욱 효율적인 반면, ​변수에 대한 접근을 제한하는데 문제를 일으킬 수 있다Parameters That Are Subprograms  Subprogram Name as Parameters이번엔 서브프로그램 이름을 파라미터로 패스하는 경우를 살펴보자. 종종 서브프로그램 이름을 파라미터로 패스하는 것이 편리할 때도 있다. ​즉, 계산을 서브프로그램으로 패스하는 것이다파라미터 타입 검사  C, C++ 함수 포인터로 패스함 ​-&gt; 함수 포인터의 타입은 파라미터 타입을 포함하므로 파라미터 타입 검사는 가능함 ​  자바는 메소드 이름을 파라미터로 패스하는 것을 불허함서브프로그램 중첩을 허용하는 언어에서, ​어떤 바인딩 방식에 의한 레퍼런싱 환경을 사용하는가  쉘로우 바인딩: 패스된 서브프로그램을 실행시킨 call문(호출문)의 환경 ​  딥바인딩: 패스된 서브프로그램에 정의된 환경​  즉흥(ad hoc) 바인딩: 서브프로그램을 액추얼 파라미터로 패스한 호출문의 환경function sub1() {​  var x;​  function sub2() { alert(x); };​  function sub3() {​     var x; x = 3;​     sub4(sub2); }​  function sub4(subx) {​     var x; x = 4;​     subx(); }​  x = 1;    sub3(); }Sub4의 sub에 대해​ 쉘로우 바인딩을 했을 경우 ​실행시킨 call문의 환경은 sub4가 되고, ​sub4에서 x는 4이다딥 바인딩을 했을 경우​ Sub2가 정의된 환경은 sub2가 되고, Sub2에서 x는 난로컬로서 sub1에 따른다. ​따라서 x는 1이다즉흥 바인딩일 경우, ​Sub2를 파라미터로 넘긴 call문의 환경은 sub3가 되고, ​Sub3에서 x는 3이다Design Issues for Functions언어 설계시 고려사항은  부작용 허용 여부? 부작용을 줄이려면 파라미터는 항상 in mode가 좋다  반환 값의 타입은? 대부분의 명령형 언어가 반환값의 타입을 제한함  C는 배열과 함수를 제외하고 모든 타입을 허용함  C++은 C와 유사하나 사용자 정의 타입을 허용​  자바는 모든 타입 허용  파이썬, 루비는 반환값 타입으로 객체도 허용Coroutines코루틴에서 중요한 것은 재시작(resume) 명령프로그램 단위의 유사 동시 실행 기능을 제공함. 인터리빙​위그림은 A가 먼저 시작하고, B를 재시작하고나서 스스로 중지했다가, ​B가 A를 재시작하고 나서 스스로 중지했다가, ​번갈아 가며 실행되는 형태를 보여주고 있다​위 그림은 B가 먼저 시작하고, A를 재시작하면서 스스로 중지하고, ​번갈아가며 실행되는 형태를 보이고 있다​위그림은 loop에서 서로 중지하고 상대방을 재시작하는 것을 반복하다",
        "url": "/pl-16"
    }
    ,
    
    "st-07": {
        "title": "Signal",
            "author": "lee989898",
            "category": "",
            "content": "Signal  Signal Concepts​  Signal은 프로세스에 보내는 메시지이다. signal은 시스템에서 어떤 유형의 이벤트가 발생했음을 알려준다          Signal은 커널에서 프로세스로 보내진다​      때로는 다른 프로세스의 요청으로 전송된다​        Signal은 exceptions,interrupts​과 유사하다  Signal은 일종의 IPC(Inter-Process Communication)  Sending a Signal  커널은 다음과 같은 이유로 신호를 보낸다​          커널이 0으로 나누기(SIGFPE), 잘못된 메모리 참조(SIGSEGV), child 프로세스 종료(SIGCHLD)와 같은 시스템 이벤트를 감지했다      다른 프로세스가 대상 프로세스에 signal를 보내도록 커널을 명시적으로 요청하기 위해 kill 시스템 호출을 호출했다                  보낼 수 있는 신호를 표시하려면 “% kill -l”을 시도하자                    터미널에서 CTRL-C를 입력하여 실행 중인 프로세스(SIGINT) 중지      ​  Receiving a Signal​  대상 프로세스는 커널에서 신호를 수신하고 세 가지 가능한 방법 중 하나로 반응한다          Signal 무시(아무것도 하지 않음)                  SIGKILL 및 SIGSTOP을 제외한 모든 신호는 무시할 수 있다                    프로세스 종료(선택적 코어 덤프 사용) -&gt; default action      시그널 핸들러라는 user-level 함수를 실행하여 Catch the signal                  비동기 인터럽트에 대한 응답으로 호출될 때 하드웨어 예외 핸들러와 유사          신호 처리기는 signal() 시스템 호출을 호출하여 실행된다                      프로세스는 커널에게 “이 신호가 발생하면 위의 세 가지 중 하나를 수행하십시오”라고 알려야 한다  Linux Signals / Linux Signal List  Every signal has a name​          Begins with ‘SIG’​        Signals are all defined by positive integers (signal numbers) in the header  and ​  SVR4 and 4.3+BSD both have 31 different signals  SIGABRT​          Generated by calling the abort() system call​      Process terminates abnormally​        SIGFPE​          Floating-Point Exception Signal​      Signals an arithmetic exception, such as divide-by-0, floating point overflow, 등등        SIGILL​          Illegal Instruction Signal: illegal HW instruction executed​      Can’t be caught or ignored​      A sure way to kill any process​        SIGINT​          Interrupt Signal​      Generated by the terminal driver when we type the interrupt key (Ctrl C)​      Sent to all processes in the foreground process group​        SIGKILL​          Kill Signal​      Can’t be caught or ignored​      A sure way to kill any process​        ​SIGPIPE​          Generated when writing on a pipe with no process to read: reader has already terminated​        SIGQUIT​          Quit Signal​      Generated by the terminal driver when we type terminal quit key (Control + Backslash) and sent to all processes in the foreground process group​      Usually core file is generated​        SIGSEGV​          Indicates that the process has made an invalid memory reference​      SEGV means “segment violation” ​        SIGTRAP​          Special signal used to transfer control to the debugger (like sdb, adb) ​      Usually ptrace system call is used to invoke SIGTRAP​      It is not usually used except for debugging​        SIGUSR1 &amp; SIGUSR2​          User-defined signals, for use in application programs​        Linux Signal List     signal()#include &lt;signal.h&gt;​void (*signal(int signo, void(*func)(int))) (int)​    반환: 정상이면 신호의 이전 처리, 오류 시 SIG_ERR ​ + signal function은 signal \"signo\" 수신과 관련된 기본 동작을 수정한다+ signo: signal number를 나타낸다​+ func:​    + 신호 수신 시 사용자 정의 함수(signal handler) 호출    + SIG_IGN: signal를 무시    + SIG_DFL: default action을 취한다 + signal handler에 단일 정수 인수(signal number)가 전달되고 아무 것도 반환하지 않습니다  kill()#include &lt;sys/types.h&gt;​#include &lt;signal.h&gt;​int kill(pid_t pid, int signo);​    반환: 정상이면 0, 오류시 1  Kill : 프로세스 또는 프로세스 그룹에 신호를 보낸다  super user는  모든 프로세스에 신호를 보낼 수 있다​      발신자의 실제 또는 유효 사용자 ID는 수신자의 실제 또는 유효 사용자 ID와 같아야 한다    Pid &gt; 0​          Signal to the process whose process ID is pid​        Pid == 0​          Signal to the processes whose process group ID equals that of sender​        Pid &lt; 0​          Signal to the processes whose process group ID equals abs. of pid​        Pid == -1​          POSIX.1 leaves this condition unspecified (used as a broadcast signal in SVR4, 4.3+BSD)​        killpg()#include &lt;signal.h&gt;​int killpg(int pgrp, int sig)​// int pgrp -&gt; 프로세스 그룹 ID​// int  sig -&gt; 시그널 번호​  프로세스 그룹으로 시그널을 보냄​  반환값 : 정상 종료시에는 0, 에러 발생시 -1​",
        "url": "/st-07"
    }
    ,
    
    "algorithm-05": {
        "title": "탐욕 기법",
            "author": "lee989898",
            "category": "",
            "content": "탐욕 기법  탐욕 기법  매 번 선택할 때 마다 그 순간에 좋은 선택을 함으로써 최종적인 해에 도달한다.  최적인 해들을 모아서 최종 해를 만들었다고 해서, 그 해가 궁극 적으로 최적이라는 보장이 없다.  따라서 탐욕 기법은 항상 최적의 해를 만들어내는 지를 반드시 검증해야 한다.  선택 기준  선택이 실현 가능해야 한다.  모든 선택들 중에서 최적이라고 여겨지는 선택을 해야 한다.  한 번 선택하면 나중에 되돌릴 수 없다.  설계 전략  비어 있는 해 모음으로 시작한다.  탐욕적인 기준에 따라 해 모음에 추가할 다음 해를 선택한다.  새 해 모음이 실형 가능한지를 확인한다.실현 가능하다면 새 해 모음을 확정하고 아니면 선택한 해를 버린다.  새 해 모음이 최종 해라면 종료한다. 아니면 2번으로 간다.  거스름돈 주기거스름돈을 동전들의 수가 최소가 되도록 주어야 한다.  액면가가 다른 m(&gt;=1)개의 동전들이 있다.  동전 i,1&lt;=i&lt;=m,의 액면가는 $d_i$ 이고 $d_1$ &gt; $d_2$ &gt; … &gt; $d_m$ = 1이다.  액면가가 같은 동전들의 개수는 무한히 많이 있다.  거스름돈 n(&gt;=1)을 최소 개수의 동전들을 사용하여 주어야 한다.  탐욕 알고리즘의 아이디어주어야 할 거스름돈이 남아 있는 동안 다음을 반복한다.  남은 동전들 중 액면가가 가장 큰 동전을 선택한다.  선택한 동전을 거스름돈에 추가하면 거스름돈이 주어야 할 금액을 초과한다면 그 동전을 버린다. 아니면 그 동전을 거스름돈에 추가하고 주어야 할 거스름돈을 추가한 동전의 액면가만큼 감소시킨다.주: 최적의 알고리즘  탐욕적인 알고리즘coinChange(d[],m,n)//거스름돈에 포함되는 동전들의 수를 최소화한다.//입력: m - 액면가가 다른 동전들의 수//     d[1..m] - 동전들의 액면가를 저장하는 배열//     n - 거스름돈//출력(반환 값): 거스름돈에 포함된 동전들의 최소 개수1  count = 02  i = 13  while(n &gt; 0 &amp;&amp; i &lt;=m){4    count = count + $\\frac{n}{d[i]}$ 　//가치가 가장 큰 동전들을 최대한 많이 선택5    n = n mod d[i] 　　　 //남은 거스름돈을 계산6    i = i + 1 　　　　　　 //다음으로 가치가 큰 동전을 선택    }7  return count  시간 복잡도  입력의 크기: m(액면가가 다른 동전들의 수)  기본 연산: 4번의 배정문  기본 연산의 수행 횟수: 최대 m  시간 복잡도: m = $\\theta$(m)  최소 비용 신장 트리 찾기  n(&gt;1)개의 도시들을 최소한의 비용으로 연결하는 철도망을 새로 구축하려고 한다.  모든 도시들을 서로 연결하기 위해 도시간 철도를 최소한(n-1)개 깔아야 한다.  각 철도는 두 도시를 연결한다.  이 철도망들 중에서 철도 노선들의 총 길이가 최소가 되도록 철도망을 구축해야 한다.  최소 비용 신장 트리  신장트리: 연결된, 무방향 그래프 안에 있는 모든 정점을 다 포함하면서 트리가 되는 연결된 부분 그래프  산장트리는 순환을 포함하지 않으며 그래프 안에 있는 모든 정점들을 연결시칸다.  신장트리의 가중치: 모든 간선들의 가중치들의 합  최소 비용 신장 트리: 최소 가중치를 가진 신장트리​  억지 기법 알고리즘  모든 신장 트리를 찾은 후 그 중에서 최소 비용 신장 트리를 선택한다.  시간 복잡도 분석          최악의 경우, 지수 시간보다도 나쁘다.        탐욕적인 전략  신장 트리에 추가할 최선의 간선들을 반복적으로 한 번에 하나씩 선택한다. 선택 시점에서 추가할 최선의 간선을 쉽게 알 수 있다고 가정한다.  (n-1)개의 간선들이 신장 트리에 포함된다면 종료한다.  한 간선이 선택되면 그 간선의 정점들을 합친다.  적절한 이유정점 a와 b가 연결된다면 정점a에 연결하는 것은 정점 b에 연결하는 것과 같다.명제. n(&gt;0)개의 정점들을 가진 그래프 G는 (n-1)개의 간선들을 가지고 순환이 없으면 트리이다. 또한 G가 트리이면 (n-1)개의 간선들이 있고 비순환 그래프이다.정리. 간선 e가 정점 v에 접합한 가장 가중치가 작은 간선이라면 e를 포함하는 최소 비용 신장 트리가 있다.  최소 비용 신장트리 찾기 - 정점지향 전략  처음 시작할 때 한 정점 $v_0$를 선택한다.  $v_0$ 에서 나가는 가장 가중치가 작은 간선 ($v_0$, x)를 선택한다. 그 간선을 최소 비용 신장 트리 T에 추가하고 $v_0$와 x를 합친다. 모든 정점이 T에 포함될 때까지 이 과정을 반복한다.  프림 알고리즘  적색 정점: 처음에 선택된 정점 $v_0$와 합쳐진 정점      청색 정점: 그 외 다른 정점    아이디어다음을 (n-1)번 반복한다:          한 적색 정점과 한 청색 정점을 연결하는 가장 가중치가 작은 간선을 선택한다.      선택된 간선의 청색 정점을 적색으로 바꾸고 그 간선을 트리에 추가한다.        그래프의 표현: 비용 행렬 WR: 적색 정점들의 집합, B: 청색 정점들의 집합V: 그래프내의 모든 정점들의 집합T: 트리 내에 포함되는 간선들의 집합    R = {$v_0$}    B = V - {$v_0$}   T = $\\emptyset${공집합}   for(i = 1; i &lt; n; i++) {   　　w[ r,b ]가 최소인 $r \\in R$과 $b \\in B$를 선택한다.   　　T = T U {(r,b)}　　// 간선 (r,b)를 트리에 추가한다.   　　B = B - {b}   　　R = R U {b}　　　//정점 b를 적색으로 바꾼다.명확하게 청색 정점의 관점을 취해야 한다. 단순히 어느 적색 정점이 자신에게 가장 가까운지만 기억한다. 이는 한 정점이 적색이 될 때 쉽게 갱신될 수 있다.  시간 복잡도이 알고리즘은 중복 계산을 많이 한다. 매번 반복할 때마다 최소 간선을 거의 같은 집합에서 찾는다.$\\theta$($n^3$)  개선된 프림 알고리즘near[0 .. n - 1]: 각 청색 정점에 가장 가까운 적생 정점을 저장하는 배열isblue[0 .. n - 1]: 각 정점이 청색이면 true를 아니면 false를 저장하는 배열T: 트리 내에 포함되는 간선들의 집합   isblue[0] = false 　　　　//정점 0은 적색이다   T = $\\emptyset$   for(i = 1; i &lt; n; i++){   　　isblue[i] = true 　　　　//다른 정점들은 청색이다   　　near[i] = 0 } 　　　　　 // 가장 가까운 적색 정점은 0이다   for(i = 1; i &lt; n; i++){   　　minval = $\\infty$   　　for(b = 0; b &lt; n; b++)　//적색 정점들에 가장 가까운 청색 정점을 찾는다   　　　if(isblue[b] &amp;&amp; W[b,near[b]]&lt; minval){   　　　　minval = W[b,near[b]]   　　　　newred = b }   　isblue[newred] = fasle 　　　//정점 newred를 적색으로 바꾼다   　T = T $\\cup$ { (newred, near[newred])}　//가장 가중치가 작은 간선을 T에 추가한다   　for(b = 0; b &lt; n; b++)   　　　if(isblue[b] &amp;&amp; W[b,newred] &lt; W[b,near[b]])near[b] = newred　　}  시간 복잡도  입력 크기: n(정점들의 수)  기본 연산: isblue의 요소들에 대한 참조 횟수  참조 횟수          각 i, 1&lt;= i &lt; n, 에 대해 항상 n이다.      따라서 총 참조 횟수 = (n-1) x n $\\in$ $\\theta$($n^2$)        최소 비용 신장 트리 찾기 - 간선 지향 전략  그래프에 남아 있는 가장 가중치가 작은 간선을 선택한다.  선택된 간선이 합쳐진 두 개의 정덤들 사이에 있다면 그 간선을 버리고 아니면 최소 비용 신장 트리에 추가한다.  (n - 1)개의 간선들이 추가될 때까지 과정 1과 2를 반복한다.  크루스칼 알고리즘//e: 간선들의 수    간선들을 가중치 순서로 오름차순으로 정렬하여 배열 EDGELIST[1 .. e]에 저장한다    T = $\\emptyset$    ecount = 0  　 　 　 　//최소 비용 신장 트리에 추가된 간선들의 수    k = 0  　 　 　 　 　 　 　//처리된 간선들의 수    while (ecount &lt; n - 1){    　k = k + 1    　(v, w) = EDGELIST[k]    　if(! together(v,w)){    　　T = T U {(v,W)}    　　v와 w를 합친다    　  ecount = ecount + 1 }} 주: together(v,w) : v와 w가 이미 합쳐졌으면 true이다.분삭: (n-1)번의 통합과 최대 e번의 together를 수행한다.정렬시간 = $\\theta$( e log e)  단일 출발점 최단 경로 찾기연결된 가중 그래프에서 한 특정 정점에서 다른 모든 정점으로 가는 최단 경로를 찾아라.  다익스트라 알고리즘  아이디어: 출방 정점 $v_0$로 부터 가까운 순서로 다른 정점들까지의 최단 경로를 찾는다.  진행 과정          i번째 반복이 시작되기 전에 $v_0$에 가장 가까운 (i - 1)개의 정점들까지의 최단 경로들을 찾았다.      $v_0$, 이 정점들과 최단 경로들 상의 간선들은 주어진 그래프의 부분 트리 $T_i$를 형성한다.      $T_i$내에 있는 정덤들에 인접한 ‘가장자리 정점’들 중에서 찾는다.      $T_i$내에 있는 정점들에 인접한 ‘가장자리 정접’들 중에서 찾는다.      모든 가장자리 정점 u에 대해서 u에 인접한 트리내의 정점 v까지의 거리, W(u,v)와 출발 정점에서 v까지의 최단 경로의 길이, $d_v$의 합을 계산한다.      u에 인접한 트리 내의 정점들이 2개 이상인 경우에는 각 인접 정점에 대해 합을 계산한다. 그러한 합들 중 가장 작은 합을 갖는 가장자리 정점을 트리에 추가할 다음 정점으로 선택한다.      ​위 그림은 트리 $T_i$이다.  n( &gt; 0): 정점들의 수  i, 0 &lt;= i &lt; n: 정덤의 번호  출발 정점: 0  정점 i에 d[i]와 p[i]를 저장한다.                  d[i]: 출발 정점에서 각 정점까지의 최단 겅로의 거리  d[0] = 0  d[i] = $\\infty$ ,i는 최단 경로 트리 내에 포함되지 않은 정점                    p[i]: 출발 정점에서 각 정점까지의 최단 경로 상의 마지막에서 두 번째 정점(트리에서 부모 노드)의 번호  i = 0혹은 트리안에 포함되지 않은 정점이면 p[i] = -1              주어진 그래프는 인접 행렬 w로 나타낸다  트리에 추가할 정점 $u^*$를 선택한 후의 연산  $u^*$를 가장자리 정점에서 트리내에 포함되는 정점으로 바꾼다.  $u^$에 인접한 트리에 포함되지 않은 각 가장자리 정점 v에 대해 다음 조건을 확인한다.d[$u^$]  + w($u^$ ,v) &lt; d[v]위 조건이 만족된다면 다음을 수행한다d[v] = d[$u^$] + w($u^$, v)p[v] = $u^$  다익스트라 알고리즘    T = $\\emptyset$    //트리에 포함된 정점들의 집합을 공집합으로 초기화한다    for( i = 0; i &lt; n; i++){    d[i] = $\\infty$    //정점 i의 최단 거리를 $\\infty$ 로 초기화 한다    p[i] = -1 }    //정점 i의 부모 노드를 -1(없음)으로 초기화한다    d[0] = 0    //출발 정점 0의 최단 거리를 0으로 한다                                while(          T          &lt; n){}                        T에 포함되지 않은 정점들 중에서 배열 d의 요소값이 가장 작은 정점 u를 선택한다    T = T U { u}    //선택된 정점을 트리에 추가한다// 트리에 새로 추가된 정점의 인접 정점들의 출발 정점으로부터 최단 거리를 갱신한다    for( v = 0; v &lt; n; v++)    if(v $\\notin$ T and w[u,v]  0 and d[u] &lt; $\\infty$ and d[u] + w[u,v] &lt; d[v] ){    d[v] = d[u] + w[u,v]     p[v] = u }}시간복잡도    +  기본 연산: 10번 조건 확인    +  9 ~ 12번의 반복문내에서 기본 연산의 수행 횟수 = n    +  트리에 모든 정점이 포함되어야 하므로 $\\theta$($n^2$)",
        "url": "/algorithm-05"
    }
    ,
    
    "sc-09": {
        "title": "Hash",
            "author": "lee989898",
            "category": "",
            "content": "HashHash와 관련된 Key Concepts인 Integrity와 Authentication을 다시 한번 살펴보자  Integrity  무결성  원본 그대로임을 보장  변조가 없다는 것 혹은 변경이 있었음을 알게 됨  주요 공격: modification  Integrity를 지키기 위한 Solution : hash  Authentication  인증  송수신자 서로간의 신원 확인  주요 공격 : impersonation  Authentication을 지키기 위환 solution : 전자서명, 공인인증서  Hash Functions  임의의 긴 입력 값을 적절하게 처리하여 고정된 길이의 짧은 값을 출력하는 함수  Message Authentication Code로 무결성 제공  전자 서명으로 sender authentication 제공  공인인증서, 가상화폐 등에 사용  컴퓨터보안에서 대표적인 hash function은 MD2,4,5 SHA1, HAS160  http://www.miraclesalad.com/webtools/md5.php위 사이트에서 임의의ㅣ 입력값에 대한 해쉬값을 관찰할 수 있다.해쉬의 특징으로는 대표적으로 3가지가 있다.  입력길이에 상관없이 출력길이가 일정  조금이라도 입력값이 다르면 출력값은 완전히 다름  revers가 어렵다(일방향성)위 성질중 integrity는 2번에 의해서 보장된다.Encrypt/decrypt와의 차이점은 3번이다. 복호화가 어렵기 때문이다.예를 들어보자 h(x): x/23해서 소수점 7~10자리 수를 추출h(345689) = xx.95652177391출력값은 일정하나, reverse는 불가능하다.그러나 h(232.8395049993) = 7391 처럼 다른 값을 넣었음에도 값이 같은 일명 collision이 일어날 수 있다.Collison은 서로 다른 입력값이 같은 해시값을 계산하는 것을 의미한다.충동저항성은 collision이 일어날 확률이 작음을 의미한다.  MAC  메시지 무결성: 변경되지 않은 원본이 맞음​   메시지와 해쉬값을 붙어서 보낸다.받는사람은 비교해서 같으면 원본 다르면 원본이 아닌걸 알 수 있다.하지만 여기서 sender authenticationd은 제공되지 않는다.Digital Signature에서 이문제를 해결한다.  Digital Signature  무결성과 인증을 동시에 제공  키를 사용한다(키를 모르는 사용자는 생성불가)​   비교하여 같으면 변조되지 않고 보낸사람을 인증해준다.하지만 mac도 한계가 있는데 제 3자에 대한 sender authentication이 불가능 하다.키를 모르면 인증을 못하기 때문이다.  Replay Attack​   위 그림은 MAC 공격방법이다.Attacker는 고객이 보낸 똑같은 패킷을 복사하여 고객으로 위장하는 공격 방법이다.이러한 공격을 막는 방법은 패킷에 추가정보로 시간을 알려주는 time stamp를 넣어 해결할 수 있다.대표적인 해쉬 함수로는 두가지 계열이 있는데 MD와 SHA 계열이다.  MD (Message Digest)  MD2,4,5,6​  Ron Rivest (RSA), 1990~92​  Merkle structure기반​  128bit hash 값​  512 bit block size ​  MD4는 32bit CPU 전용 (MS)​  MD5는 SHA1등 최신 해시들의 기초가됨​  2005 강한 충돌 내성 깨짐  SHA (Secure Hash Algorithm)  NIST 1993​  Merkle structure기반​  SHA0,1은 160bit hash 값, SHA2는 224~512bit​  512 bit block size ​  최대 2^64-1 bit 메시지처리​  가장 많이 사용​  2005 강한 충돌 내성 깨짐​   위 그림은 Merkle structure의 예시이다.MD, SHA 두가지 모두 Merkle structure기반인데 이것은Message를 block으로 나누어서 고정된 길이의 입력값을 받아들여 고정된 길이로 출력하는 압축함수를 반복 사용하여 긴 길이의 입력을 처리할 수 있는 해쉬 함수로 학대하여 설계하는 방식이다.  Hash attack  같은 해시값을 갖는 다른 입력값을 찾아낸다​  예를 들면, (ID, PWD)값은 해시값으로 저장되어 있다.​  만일 같은 해시값을 갖는 (ID2, PWD2)를 찾는다면, (ID, PWD)로 로그인 가능​하다  (ID, PWD), (ID2, PWD2)를 충돌쌍(collision pairs)라 한다​",
        "url": "/sc-09"
    }
    ,
    
    "pl-15": {
        "title": "컨트롤 스트럭처",
            "author": "lee989898",
            "category": "",
            "content": "컨트롤 스트럭처프로그램의 컨트롤 스트럭처에는 3가지가 있다.  sequence(begin-end)  selection(if-else, case)  iteration(loop)각 컨트롤 스트럭처는 여러 개의 문장으로 구성된다스트럭처는 여러 문장의 묶음으로, ​실행 제어 방법에 따라 각각 키워드(begin, if, while, …)를 포함한다여기서 컨트롤 스트럭처의 if, while 문을 제어문이라고 하고, ​제어문의 실행 결과에 따라 실행되는 문장을 실행문이라고 한다시퀀스는 순차적으로 실행되는 문장들의 연속을 말하며, ​실행 제어가 순차적이라서 시작과 끝만 명시하면 된다Selection은 제어문이 참이냐 거짓이냐에 따라 실행문이 다르며, 하나의 selection 스트럭처에 제어문과 실행문을 여럿 포함하기도 한다Iteration도 제어문과 실행문의 반복으로 구성되는데, for, while, repeat 등 목적에 따라 그 신택스와 시맨틱스가 다양하다프로그래머는 이들 컨트롤 스트럭처를 사용하여 쉽게 프로그램을 구조화 할 수 있다  Controlling Program Flows프로그램은 나름의 로직을 갖고 있어서, 이에 따른 실행 제어(flow control)가 필요하다명령형 프로그램에서 계산은 다음과 같이 진행된다. 변수를 읽고 연산자를 실행하여 표현식을 계산하여, ​변수에 결과 값을 부여한다또, 여러 경로 중에서 선택하여 실행을 제어하거나, ​반복 실행한다. 컨트롤 스트럭처는 제어문과 실행문으로 구성된다.그러나 이 표현은 문제가 있다. 시퀀스는 제어문이 없다Selection StatementsSelection문은 2개 이상의 실행 경로 중에서 선택하는 것이다두가지 범주가 있는데, 둘 중에 하나 선택하는 것과 여럿 중에 선택하는 것이 있다  If StatementsIf문의 일반적 형식은 if 제어 표현식 then 실행문1 else 실행문2 이다제어 표현식은 산술식이거나 부울식이다프로그래밍 언어에서 실행문1과 실행문2는 단순문이거나 복합문이다C, C++에서 복합문을 { }로 둘러싸고, 펄에서는 모든 실행문을 { }로 구분하고, 파이썬에서는 indentation으로 구분한다자바에서는 중첩 if문을 허용한다. dangling else 문제가 발생할 수 있으니 if에 대응되는 else가 어느 것인지 살펴가며 신중하게 써야 한다.자바를 비롯한 대부분의 언어에서는 else를 가장 가까운 if에 대응시킨다C, C++에서는 가장 가까운 if에 else를 대응시키는 것의 대안으로서, {}로 둘러싼 복합문을 사용할 수도 있다. ​​복합문 대신에 end를 사용하기도 한다  Switch Statements​Switch는 여러 대안 중에 하나 선택하여 실행할 경우이다전형적인 형식은 아래와 같다Switch 표현식 {​case 상수 표현식1: 실행문1   ​…​default … }이다. 스위치문의 case는 동시에 상수 표현식을 비교하는 것이 아니라 상수 표현식을 순차적으로 비교하여 끝까지 실행한다 이것을 피하려면, break 사용해야 한다C에서는 스위치문의 제어 표현식으로 정수 타입만 허용한다. 실행문은 시퀀스, 블록, 복합문을 모두 허용한다. 조건이 맞으면 여러 case가 실행가능하다.디폴트시에, ​If문에 의한 제어가 가능하다파이썬에서는 스위치 대신에 if elif를 사용할 수 있다Iterative StatementsIteration, recursion은 문장이나 복합문의 반복 실행한다카운터로 제어하는 counter-controlled loop은 반복문의 실행 횟수를 세는 변수를 갖는다. ​초기값, 종료값, 증분(반복할 때마다 더해지는 값)설계할 때 고려사항은 Loop 변수의 유형과 스코프를 정의해야 하며, Loop에서  변화하는 Loop변수의 값이 Loop 제어에 영향을 미치는지 확인해야 한다  for StatenebtsC의 for 반복문을 보면, ​for ([expr_1] ; [expr_2] ; [expr_3]) ​loop body… 와 같다다음과 같이 카운터 변수가 여럿일 수 있고, ​부울식을 포함할 수 있다for (count1 = 0, count2 = 1.0;​ count1 &lt;= 10 &amp;&amp; count2 &lt;= 100.0; sum = ++count1 + count2, count2 *= 2);자바에서 컨트롤 표현식은 부울식이어야 한다  while Loops​while Loop은 부울식에 의해 제어된다ctrl_expr는 부울식으로, Loop의 맨앞에 또는 맨뒤에 위치한다while (ctrl_expr) ​ loop body… ​    do ​ loop body ​while (ctrl_expr) ​break 처럼 loop 컨트롤이 loop body의 중간에 위치하기도 한다. 이것을 user-located loop control이라고 부른다. Break 외에도 continue가 있다자료구조를 구성하는 요소에 의해 제어되는 반복 처리가 있다. Iterator를 호출하면, 자료구조에서 다음 요소를 반환해준다. 이밖에 for에서도 자료구조에 의한 반복처리를 제어할 수 있다  ​  Unconditional Branching앞에서 언급했듯이 goto는 가독성 문제를 일으킨다. 자바는 goto가 없다Guarded Commands각 문장 앞에 부울식이 있는 것을 Guarded Commands라고 한다. 즉 가디드 코멘드는 ​selection 문장의 각 라인이 ​부울식과 ‘하나의 문장 또는 문장의 시퀀스’로 구성된다. ​이렇게 하는 목적은 ​프로그램 개발 중에도 프로그램의 correctness(올바름)를 증명하기 위한 것으로, ​Concurrent 프로그래밍의 기초가 된다. 기존의 언어는 개발(코딩)을 마치고 테스트를 통해 프로그램의 올바름을 확인한다  Selection Guarded Commandselection의 Guarded Commands는 if 안의 각 문장마다 부울식이 있다​이 가디드 코멘드의 시맨틱은 다음과 같다. 부울식을 계산해서, ​하나 이상이 참이면, 그 중에 아무거나 선택한다. 아무것도 참이 아니면, 실행 오류로 처리한다프로그램의 correctness는 선택된 문장에 종속되지 않는다if x &gt;= y -&gt; max := x​[] y &gt;= x =&gt; max := y​fiif (x &gt;= y)​      max = x;​else​    max = y;x, y가 같을 때, 전자는 아무거나 선택되어 수행되나, ​후자는 max=x가 수행된다  Loop Guarded Commanddo &lt;Boolean&gt; -&gt; &lt;statement&gt;​[] &lt;Boolean&gt; -&gt; &lt;statement&gt;​...​[] &lt;Boolean&gt; -&gt; &lt;statement&gt;​od​Loop Guarded Command에서, ​do 다음에 나오는 모든 문장의 앞에 부울식이 있다룹 가디드 코멘드의 시맥틱스는 다음과 같다. 부울식을 계산하고, 하나 이상이 참이면, 아무거나 선택하여 룹을 시작한다. 아무것도 참이 아니면, 룹에서 나온다",
        "url": "/pl-15"
    }
    ,
    
    "st-06": {
        "title": "Process_Control",
            "author": "lee989898",
            "category": "",
            "content": "Process Control  Process Identifiers  모든 프로세스에는 음이 아닌 정수인 고유한 프로세스 ID가 있다  Process ID 0: swapper (scheduler process)​          시스템 프로세스      커널의 일부        Process ID 1:  init  process​          부트스트랩 절차가 끝날 때 커널에 의해 호출됨      /etc/init  or  /sbin/init​      시스템을 특정 상태로 만든다(다중 사용자)      일반 사용자 프로세스이지만 수퍼유저 권한으로 실행      PID 1 is 불멸이다        Process ID 2:  pagedaemon​          가상 메모리 시스템의 페이징 지원              kernel process           #include &lt;sys/types.h&gt;​  #include &lt;unistd.h&gt;​  pid_t getpid(void);      // returns process ID​  pid_t getppid(void);     // returns parent process ID​  uid_t getuid(void);      // returns real user ID​  uid_t geteuid(void);     // returns effective user ID​  gid_t getgid(void);      // returns real group ID​  gid_t getegid(void);     // returns effective group ID​                      이 함수 중 어느 것도 오류 반환이 없다  fork()#include &lt;sys/types.h&gt;​#include &lt;unistd.h&gt;​pid_t fork(void);반환값: 자식의 경우 0, 부모의 자식 프로세스 ID, 오류 시 -1  fork()는 Unix 커널에서 프로세스를 생성하는 유일한 방법이다  자식 프로세스는 fork()에 의해 생성된 새로운 프로세스이다​  fork()는 한 번 호출되지만 두 번 반환된다          returns 0 in child process​      returns the child process ID in parent process​        자식 프로세스는 getppid()를 호출하여 부모 프로세스 ID를 얻을 수 있다.  부모와 자식은 fork() 호출에 따라 명령을 계속 실행한다  자식은 부모의 데이터 공간, 힙 및 스택의 복사본을 얻는다  종종 읽기 전용 텍스트 세그먼트가 공유된다      종종 fork() 다음에 exec()가 온다    child에게 상속되는 속성          실제 사용자 및 그룹 ID, 유효 사용자 및 그룹 ID      보조 그룹 ID      프로세스 그룹 ID, 세션 ID,      set-user-ID 및 set-group ID 플래그      현재 작업 디렉토리      루트 디렉토리      파일 모드 creation mask      signal mask 및 배치      열려 있는 파일 설명자에 대한 close-on-exec 플래그      environment      연결된 공유 메모리 세그먼트      리소스 제한        child에게 상속되지 않는 속성          fork()의 반환 값      프로세스 ID가 다르다      file locks      보류 중인 알람이 child에 대해 지워진다      child에 대한 보류 중인 신호 집합은 빈 집합으로 설정된다.        exit()  프로세스는 5가지 방법으로 종료할 수 있다:​          Normal Termination​                  main()에서 반환을 실행한다. exit() 호출과 동일          exit()​          _exit()​                    Abnormal Termination​                  calling abort() (generates SIGABRT signal)​          프로세스는 자체적으로(abort()에 의해) 또는 다른 프로세스에 의해 생성된 신호를 수신한다                      프로세스가 어떻게 종료되든 상관없이 커널의 동일한 코드가 결국 실행된다          프로세스에 대해 열려 있는 모든 설명자를 닫는다​      메모리 해제 등        exit(): Termination status  Exit status: ​          Argument of  exit(), _exit() ​      main()의 반환 값      프로세스 종료 방법에 대한 정보      자식 프로세스에서 부모 프로세스로 전달        Termination status:​          Normal termination: Exit status -&gt; Termination status​      Abnormal termination: kernel indicates reason -&gt; Termination status​        부모는 자식 프로세스의 종료 상태를 얻을 수 있다          by wait() or waitpid()​        부모가 자식보다 먼저 해지하면 어떻게 되나?          init는 자식 프로세스의 부모가 된다        자식이 먼저 종료된다고 가정          죽은 자식 프로세스의 최소 정보(pid, 종료 상태, CPU 시간)는 부모가 wait() 또는 waitpid()를 호출할 수 있도록 커널에 의해 유지된다      Zombie: 완료되었지만 부모가 아직 기다리지 않은 프로세스        wait(), waitpid()  child가 종료될 때          커널은 부모에게 SIGCHLD 신호를 보낸다      비동기식 이벤트​        parent가 취한 조치          기본 작업: “무시”      또는 부모가 사용자가 정의한 신호 처리기를 호출할 수 있다        wait 또는 waitpid를 호출하는 프로세스는          block(자식이 아직 실행 중인 경우), 또는      child의 해지 상태로 즉시 반환, 또는              오류와 함께 즉시 반환(child 프로세스가 없는 경우)          #include &lt;sys/types.h&gt;​  #include &lt;sys/wait.h&gt;​​  pid_t wait(int *statloc);​  pid_t waitpid(pid_t pid, int *statloc, int options);​  ​둘 다 반환: 정상이면 프로세스 ID, 오류 발생 시 0 또는 -1                      statloc​          종료 상태를 저장할 정수에 대한 포인터        모든 자식이 끝날 때까지 Wait() 블록  Waitpid()는 block 되지 않도록 선택할 수 있다.​          그것은 많은 옵션을 가질 수 있다        종료 상태를 검사하는 매크로            Macro      설명                  WIFEXITED(status)​      자식이 정상적으로 종료되면 참 WEXITSATUS(상태): 종료 상태 가져오기(하위 8비트)              WIFSIGNALED(status)​      자식이 비정상 종료되면 참(신호 수신)WTERMSIG(status): 종료를 일으킨 신호 번호를 가져온다.WCOREDUMP(status): 코어 파일이 생성된 경우 true              WIFSTOPPED(status)​      자식이 현재 중지되어 있으면 참 WSTOPSIG(status): 정지를 일으킨 신호 번호를 가져온다.              WEXITSTATUS(stat_val)      WIFEXITED가 0이 아니면 자식 종료 코드를 반환한다              WTERMSIG(stat_val)      WIFSIGNALED가 0이 아니면 신호 번호를 반환한다              WSTOPSIG(stat_val)      WIFSTOPPED가 0이 아니면 신호 번호를 반환한다      #include &lt;sys/types.h&gt;​#include &lt;sys/wait.h&gt;​​   pid_t waitpid(pid_t pid, int *statloc, int options);  waitpid()​          하나의 특정 프로세스를 기다린다      provides a nonblocking version of wait​      supports job control (with the WUNTRACED option)​        the pid argument for waitpid​          -1  : 모든 자식 프로세스를 기다린다      &gt; 0 : 프로세스 ID가 pid인 자식 프로세스를 기다린다      0   : 프로세스 GID가 같은 자식을 기다린다(호출 프로세스의)      &lt; -1 : 프로세스 GID가 같은 자식을 기다린다(pid의 절대값)        waitpid에 대한 옵션 상수          WNOHANG  :                  pid로 지정된 자식을 즉시 사용할 수 없으면 차단하지 않고 0을 반환환다                    WUNTRACED:                  상태가 아직 보고되지 않은 경우 pid로 지정된 중지된 자식의 상태를 반환환다                      exec프로세스가 exec 함수 중 하나를 호출할 때  프로세스는 새 프로그램으로 완전히 대체된다. 텍스트, 데이터, 힙 및 스택 세그먼트를 부모의 주소 공간에 로드한다.  새 program은 main function에서 시작한다.      새 program은 caller와 동일한 PID를 사용한다.    #include &lt;unistd.h&gt;main(){ printf(\"execiton ls\\n\")};execl(\"/bin/ls\",\"ls\",\"-l\", (char *)0);perror(\"execl failed to run ls\\n\");exit(1);}        exec: Program Execution  프로세스 실행을 맡고 있는 시스템 콜은 execve()이다  같은 기능을 하면서 라이브러리 함수로 분류되어 있는것으로 execv(), execvp(), execle(), execl(), execlp()가 있다 ​  이 6가지를 합쳐서 exec()시스템 콜이라 부른다exec() 이후에 오는 문자에 의해 구별되는 표시는 다음의 의미가 있다.  l -&gt; argv 정보를 개개의 문자열 데이터를 가르키는 포인터 arg0,arg1……. argn으로 전달한다  v -&gt; argv 정보를 개개의 문자열 데이터를 가리키는 포인터 배열의 ​선두주소 argv로 전달한다​  e -&gt; envp 정보를 전달한다​      p -&gt; p를 사용하는 경우, 실행할 파일이름을 환경 변수 PATH로 지정한 디렉토리 안에서 찾아내어 실행한다​    #include &lt;unistd.h&gt;int execl(const char *path, const char *arg0, ... *argn,(char *)0);        path: 실행 가능한 파일 경로  arg0~argn: 파일에 전달한 argv 정보(명령 인수)  (char*)0: 마지막임을 알리는 표시로 NULL 포인터  리턴값: 에러시 -1  execl.c#include&lt;unistd.h&gt;main(int argc, char *argv[]){    execl(\"/bin/ls\",\"ls\",argv[1],(char *)0);}  execv.c#include&lt;unistd.h&gt;main(){    char *av[3];    av[0]=\"ls\";    av[1]=\"-1\";    av[2]=(char *)0;    execv(\"/bin/ls\",av);}  execle() #include &lt;unistd.h&gt; int execle(const char *path, const char *arg0...*argn,                    (char *)0, char *const envp[]);  path: 파일의 경로명  arg0 ~ argn: 파일에 전달한 argv 정보(명령 인수)  envp[]: envp 정보(환경변수)  리턴 값: 에러시 -1  execl()에 환경 변수 정보를 전달하는 기능을 추가한 것  execve()#include &lt;unistd.h&gt;int execve(const char* path, char *const argv[],                char *const envp[]);  path: 파일의 경로명  argv: 파일에 전달한 argv 정보(명령 인수)  envp[]: envp 정보(환경변수)  리턴 값: 에러시 -1  execv()에 환경 변수 정보를 전달하는 기능을 추가한 것  execlp()#include &lt;unistd.h&gt;int execlp(const char *file, const char *arg0, .... *argn);  file: 실행하는 파일의 파일 이름  arg0 ~ argn: 파일에 전달한 argv 정보(명령 인수)  리턴 값: 에러시 -1  execlp()는 첫 번째 인자 file에서 지정한 파일 이름을 환경 변수 PATH에서 지정하고 있는 디렉토리 안에서 찾아 실행한다  execvp()#include &lt;unistd.h&gt;int execvp(const char *file, char *const argv[]);  file: 실행하는 파일의 파일 이름  argv: 파일에 전달한 argv 정보(명령 인수)  리턴 값: 에러시 -1  execlp()는 첫 번째 인자 file에서 지정한 파일 이름을 환경 변수 PATH에서 지정하고 있는 디렉토리 안에서 찾아 실행한다  Race Conditions  여러 프로세스가 일부 데이터를 공유  결과는 실행 순서(예: RACE)에 따라 다르다  fork() 후에는 부모 또는 자식이 먼저 실행되는지 예측할 수 없다  실행 순서는 다음에 따라 다르다          시스템 부하      커널의 스케줄링 알고리즘      Race condition 문제는 대부분의 시간 작동하기 때문에 감지하기 어렵다  after fork          parent,child 모두 스스로 무언가를 한다      예를 들어 parent: 로그 파일에 기록 쓰기      예를 들어 child: 로그 파일 생성        parent,child는 다음을 수행해야 한다          초기 작업 세트가 완료되면 서로 알리고      서로 완료될 때까지 기다린다        system()#include &lt;stdlib.h&gt;int system(const char *cmdstring);  문자열이 터미널에서 명령으로 입력된 것처럼 문자열이 sh(1)에 입력으로 제공한다. ex) system(“date &gt; file”);  fork, exec 및 waitpid를 호출하여 시스템을 구현한다.  반환 값:          -1 with errno: fork 또는 waitpid 실패      127 : 실행 실패      쉘 종료 상태: 3개 모두 성공        Process Times#include &lt;sys/times.h&gt;clock_t times(struct tms *buf);struct tms(    clock_t tms_utime;    clock_t tms_stime;    clock_t tms_cutime;    clock_t tms_cstime;)  wall clock time: 프로세스가 실행되는 데 걸리는 시간이며 시스템 부하에 따라 다르다.          반환된 wall clock time의 시간은 과거의 임의의 지점에서 측정된다. 상대 값을 사용한다.        사용자 CPU 시간: 사용자 지침에 기인  시스템 CPU 시간: 프로세스를 대신하여 실행될 때 커널에 귀속됨",
        "url": "/st-06"
    }
    ,
    
    "pl-14": {
        "title": "표현식과 대입문",
            "author": "lee989898",
            "category": "",
            "content": "표현식과 대입문표현식(expression)은 프로그래밍 언어에서 계산을 상술(상세히 서술)하는 수단이다. ​대입문은 변수의 값을 변화시키는 문장으로, 모든 명령형 언어의 필수적 요소이다. ​대입문은 독립적으로 실행 가능한 문장인 반면, ​표현식은 대입문의 일부분으로서, 독립적으로 실행될 수 있는 문장이 아니다. ​대입문과 표현식의 차이를 좀더 살펴 보자.  ​변수가 메모리의 일정 부분임을 상술하는 수단이라는 것과, ​대입문의 BNF 형식이 =임을 알고 있다. ​BNF의 형식으로부터, ​표현식()은 대입문의 일부분임을 알 수 있고, ​대입문의 변수()가 가리키는 메모리에 저장된 값을 ​표현식의 계산 결과로 변경시킨다는 것을 알 수 있다. ​그런데, 표현식의 계산 방식에 따라 계산 결과는 달라질 수 있다.  ​표현식의 계산 방식을 이해하려면, ​연산자와 오퍼랜드의 계산 순서에 대한 규칙을 알 필요가 있다.  ​이들 순서는 결합 법칙과 우선순위 규칙에 의하며, ​오퍼랜드 계산 순서는 오퍼랜드의 부수효과(부작용)때문에 중요하다.  산술식산술식은 연산자, 오퍼랜드, 괄호, 함수 호출로 구성된다. ​연산자는 단항 연산자, 이진 연산자, 삼항 조건 연산자(?:) 등이 있다. ​표현식의 구현은, ​메모리에서 오퍼랜드를 가지고 와서, ​그 오퍼랜드에 산술 연산자를 실행한다. ​산술식 설계시 고려사항 ​연산자 우선 순위, 결합 법칙 등 ​오퍼랜드 계산 순서와 부작용(부수효과) ​연산자 오버로딩 ​표현식에서 오퍼랜드 타입의 혼합연산자 우선순위 규칙은 우선 순위가 다르면서 이웃하는 연산자의 계산 순서를 정의한다. ​전형적인 우선순위 규칙은 괄호&gt;단항연산&gt;지수&gt;곱셈과 나눗셈&gt;덧셈과 뺄셈 ​연산자 결합 법칙은 우선 순위가 같으면서 이웃하는 연산자의 순서를 정의한다. ​전형적인 결합법칙은 좌에서 우로(단, 지수는 우에서 좌로) 적용된다.  ​괄호는 우선순위와 결합 법칙에 앞선다. ​C, C++에서 조건 표현식은 삼항 조건 연산자 ?:를 사용한다. ​average = (count == 0)? 0 : sum / count와 같이 표현한다. ​이것의 의미는 다음과 같다. ​if (count == 0), average = 0​else average = sum / count ​이 문장을 이해하려면, 대입문의 BNF 형식 =을 떠올리면 쉽다. ​그러니까 이 average이고, ​가 삼항 조건 표현식인 (count==0) ? 0 : sum/count이다. 표현식에서 오퍼랜드는 어떻게 계산되는지 살펴 보면, ​변수는 메모리에서 값을 가져온다.  ​상수는 메모리에서 값을 가져오기도 하지만, 기계 언어에 내재되기도 한다. ​괄호가 있는 표현식은 괄호속에 있는 모든 오퍼랜드와 연산자를 먼저 계산하고, 괄호 전체를 계산한다. ​오퍼랜드가 아무런 부작용(부수효과)가 없을 때, 오퍼랜드 계산 순서는 결과에 무관하다. ​그러나 함수가 오퍼랜드일 때, 계산 순서는 다른 결과를 가져온다.  함수는 다수의 파라미터 또는 글로벌 변수를 변경시킬 수 있고,  ​이때 함수 부수효과가 발생할 수 있다. ​이로 인해 표현식의 계산 결과에 영향을 미칠 수 있다. ​--- ​---위 그림에서 함수 부수효과 문제의 예를 보자. ​다음 프로그램에서, ​Main의 a = a + fun1( )의 값은 ​먼저 a를 계산하느냐, fun1( )을 먼저 계산하느냐에 따라 달라진다. ​1. 먼저 a를 계산(메모리에서 가져오는 fetch)하면, ​a가 5이고, fun1()이 3이므로, 둘을 더하면 a는 8이다. ​2. 먼저 fun1을 계산하면, ​fun1은 3이지만 부수효과로서 a가 17이므로, ​둘을 더하면 a는 20이 된다. 수학에서 함수는 x에 대응하는 y값을 찾는 것이므로, 부수 효과가 없다.​함수 언어에서도 마찬가지다. ​부수효과는 본 뉴만 아키텍처 및 이에 기반한 명령형 언어의 계산 모형으로 인해 발생한다. ​본 뉴만 아키텍처 및 이를 그대로 본뜬 명령형 언어의 계산 모형은 ​계산하여 변화된 값의 상태를 항상 메모리에 저장하도록 설계되어 있기 때문이다. ​함수 부수효과의 해결책은 다음 두가지가 있다. ​+ C, C++ 처럼 함수 부수 효과를 허용하지 않도록 언어를 설계하는 것이다. ​    함수에서 단일 파라미터만 허용하여, 단일 값을 반환한다. ​    만일 다수의 파라미터가 필요하면, struct를 사용하여 하나의 파라미터로 만든다. ​    함수에서 글로벌 변수를 접근 불허한다. ​    단점은 파라미터 및 글로벌 변수에 융통성이 없다. ​2. 자바처럼 오퍼랜드 계산 순서를 고정시킨다. ​    좌에서 우로… ​    단점은 컴파일러 최적화를 제한한다.  ​최적화를 위해 표현식을 reordering하기도 하는데 고정 순서는 이를 불허한다. ---+ 과적 연산자기계어에서는 정수의 덧셈 연산자와 부동점 소수의 덧셈 연산자를 구분한다. 부동점 소수의 덧셈: FADD, ​정수의 덧셈: ADD ​프로그래머는 정수의 덧셈과, 부동점 소수의 덧셈에 모두 +를 쓰고 싶어한다.  ​1. 그러면서, 컴파일러가 알아서 이들을 구분하여 번역하기 바란다. ​2. 두개의 배열 변수의 덧셈도 +로 간단히 쓰고 싶어 한다.  ​이와 같이 하나의 연산자를 여러가지 목적으로 사용하는 것을 ​연산자의 과적(오버로딩)이라고 한다. 정수와 부동점에 대한 +의 과적은 ​일상적으로 허용되지만, C와 C++에서는 문제를 일으키기도 한다. ___+ 타입 변환정수와 부동점 소수 간의 덧셈에서, ​데이터를 어떤 유형으로, 그리고 어떤 포맷으로 변환할 것인가? ​유형: 정수, 부동점 소수 ​포맷: 십진수 vs 이진수, 부동점의 (싸인,지수부분,소수부분) 각 몇 비트? Narrowing conversion은 ‘원래 유형의 모든 값’을 포함할 수 없는 유형으로 변환하는 것을 의미한다. ​예를 들어, 더블 부동점 소수를 싱글 부동점 소수로 변환하는 경우. ​이때 항상 safe하지는 않다. -&gt; 값의 크기가 바뀐다. 짤린다. ​​Widening conversion은 원래 유형의 근사값을 포함하는 유형으로 변환하는 것을 의미한다. ​예를 들어 정수를 부동점 소수로 변환하는 경우. ​이때, safe하다. 즉, 근사값으로 바뀌므로 크기가 바뀌지 않는다. ​다만 포맷(내부 표현 방식)의 차이로 인해 정확하게 같지 않을 경우도 있다.   오퍼랜드의 타입이 혼합되어 있을 때, ​명시적이거나 암묵적으로 타입 변환이 필요하다. ​컴파일러에 의한 암묵적 타입 변환을 코어젼이라고 한다. -&gt; 대부분의 언어에서…   ​프로그래머에 의한 명시적 타입 변환을 캐스팅이라고 한다. ​C에서는 (int) angle과 같이 캐스팅을 괄호로 표시한다.  ​___+ 비교 및 부울 표현식비교 표현식은 두개의 오퍼랜드를 비교하기 위해 비교 연산자를 사용한다. 부울 표현식은 부울 연산자 and, or, not를 사용한다. 표현식의 Short-circuit evaluation에 대해 살펴 본다.Short-circuit evaluation은 ​표현식의 결과를 도출하는데 충분한 계산이 완료되면, ​그 이후의 표현식 계산을 중단한다는 의미이다. ​따라서, 표현식의 최소 계산이라고 번역하겠다.  표현식에서 여러 오퍼랜드 중에서 몇 개만 해보고 그 결과를 알 수 있다면 ​모든 오퍼랜드를 계산할 필요가 없다. ​이것을 표현식의 최소 계산이라고 한다. ​간단한 예를 보자. ​(13 * a) * (b/13–1)에서, a가 0이면, 13*a가 0이므로 더 이상 계산할 필요가 없다. ​만일 최소 계산을 채택하지 않을 경우, ​다음 프로그램에서 예상치 않은 문제를 발생시킨다. ​index = 0;​while ((index &lt; listlen) &amp;&amp; (LIST[index]!= key)) index = index + 1; 이고, ​LIST 배열의 인덱스가 0에서 listlen-1까지 라고 가정하자. ​index==listlen일 때, (index &lt; listlen)을 만족시키지 못한다. ​그런데 최소 계산을 채택하지 않기때문에 여기서 중단되지 않고, ​그 이후의 (LIST[index]!= key))를 계산하게 되며, ​이때, LIST[index]에서 인덱싱 문제가 발생하게 된다. ​이와 같이 최소 계산을 채택하지 않을 경우 ​불필요한 오류를 발생시키기도 한다. 최소 계산은 표현식의 부작용에 영향을 받을 수도 있다. ​(a &gt; b) || (b++ / 3)에서 ​||의 두번째 오퍼랜드를 먼저 계산하면 ​b가 증가하여 첫째 오퍼랜드의 결과에 영향을 준다.   ---+ 대입문과 혼합 타입의 대입문대입문의 일반적 형식은  = 이다. ​대입 연산자 = 대신에 :=를 쓰기도 한다. ​= 대신에 :=을 쓰는 이유는 =의 의미가 ‘같다＇의 의미와 혼동되기 때문이다. ​=를 대입 연산자로 사용하는 경우, ‘같다＇의 연산자로 ==를 사용한다. 조건 타겟은 조건에 따라 타겟 변수가 결정된다. ​펄에서 조건 타겟이 포함된 대입문의 예를 보자. ​대입문 ($flag ? $total : $subtotal) = 0에서 ​대입 연산자 =의 왼쪽에 조건식이 포함되어 있는데, ​이 뜻은 만일 ($flag)이 참이면 $total = 0이고, ​거짓이면 $subtotal = 0이다 ​복합 대입문 연산자는 대입문의 =과 연산자를 연결한 것이다. 단항 대입문 연산자는 ++과 같은 것을 의미한다. 표현식에 대입문을 쓰기도 한다. ​while ((ch = getchar())!= EOF){…}​  ch = getchar()위의 while 문의 조건식에 ch = getchar()라는 대입문이 들어가 있다. ​이 대입문이 먼저 실행되고 나서, 조건식이 계산된다. ​그러면 getchar 값이 ch에 할당되고, ​ch!=eof가 참이면 {…}가 실행된다. ​a=b+(c=d/b)-1의 경우처럼, ​표현식에 대입문을 쓰는 것은 대입문의 이해를 어렵게 한다.  ​($first, $second, $third) = (20, 30, 40)와 같이 다수의 값을 할당할 수도 있고, ​  Interchange를 ($first, $second) =($second, $first)와 같이 쓸 수도 있다. 함수 언어에서 identifier는 값의 이름에 불과하며, ​변수를 나타내는 것이 아니기때문에 이들의 값은 바뀔 수 없다. ​val fruit = apples + oranges;에서 ​이름 fruit는 apples와 oranges의 값을 더해서 나온 결과 값의 이름이다.  ​대입문에서 혼합 타입이 가능하다. ​이때 타입 변환이 발생한다. ​---",
        "url": "/pl-14"
    }
    ,
    
    "pl-13": {
        "title": "복잡한 데이터 타입",
            "author": "lee989898",
            "category": "",
            "content": "복잡한 데이터 타입배열과 레코드 타입을 살펴보자  배열배열은 동일한 유형의 데이터 요소의 모임으로, ​각 요소의 위치에 의해 지칭된다(식별된다). ​각 요소의 위치를 나타내는 방식은 ​‘배열의 맨앞에서 시작하여 각 요소의 상대적 위치를 지칭하는 인덱스(서브스크립트, subscript)’에 의한다. ​이와 같이 상대적 위치를 지칭하기 위해서는, ​인덱스와 요소 간의 매핑이 필요한데, ​이러한 매핑을 배열 인덱싱 또는 subscripting이라고 한다. ​1차원 배열 인덱싱은 사소한 문제에 불과하지만, ​배열의 차원이 증가하고 각 차원의 범위가 다양해지면서 ​배열의 인덱싱 문제는 복잡해진다.배열 인덱스 유형은 주로 정수형을 사용하나 언어에 따라 약간 다르다. ​포트란, C, 자바는 정수형만을 지원하나, ​파스칼은 모든 서수 유형(정수, 부울리언, 글자)을 지원한다. ​C, C++, 펄, 포트란은 인덱스에 대해 범위 검사를 하지 않지만, ​자바, ML, C#은 인덱스의 범위를 검사한다. ​배열의 범주를 서브스크립트의 범위와 메모리 할당 시기를 기준으로 나누면,  ​정적 배열, 고정 스택-동적 배열, 고정 힙-동적 배열, 힙-동적 배열로 구분한다. ​정적 배열은 서브스크립트의 범위가 정적으로 고정되어 있고, ​런타임 이전에 메모리가 정적으로 할당된다.  ​장점은 효율적이지만, ​단점은 실행중 필요시마다 동적 할당이 불가능하여 융통성이 없다. ​C, C++에서 static modifier를 포함하는 배열은 정적 배열이다. ​고정 스택-동적 배열은 서브스크립트의 범위가 정적으로 고정되어 있지만, ​메모리는 미리 할당되지 않고, 선언문 실행 중에 할당된다. ​장점은 실행되지 않는 서브프로그램에서 정의된 배열에 대해 ​메모리가 미리 할당되지 않아, 메모리 공간 활용이 효율적이다. ​C, C++에서 static modifier를 포함하지 않는 배열은 고정 스택-동적 배열이다.고정 힙-동적 배열은 스토리지 바인딩이 동적이지만, ​힙에 할당된 후에는 서브스크립트의 범위가 고정된다. ​C, C++에서 malloc에 의해 할당된 배열은 고정 힙-동적 배열이다. ​힙-동적 배열은 서브스크립트 범위와 스토리지의 바인딩이 ​모두 동적이면서 변경 가능하다. ​장점은 배열이 실행 중에 늘어나거나 줄어 들 수 있어서 융통성이 있다. ​C#에서 ArrayList에 의해 정의된 배열은 힙-동적 배열이다. ​배열의 요소없이 생성되고 나중에 add를 써서 배열을 늘인다.C, C++, C#, 자바에서는 ​스토리지 할당시에 배열이 초기화된다. ​포트란은 배열에 대한 연산을 지원한다. ​두 배열의 합(+)은 위치가 같은 배열의 각 요소들간의 합을 배열로 나타낸 것이다. ​A = B + C ——- A, B, C 모두 배열…  ​배열에 대한 연산을 지원하지 않는다면, ​loop을 써서 반복적으로 ​각 요소마다 합을 구해야 함 (A[i] = B[i] + C[i]에 의해)순서를 무시한 데이터 요소의 모임을 associative array라고 하며, ​사용자가 정의한 Key를 인덱스로 사용한다. ​따라서, associative array는 키와 값의 쌍을 나열한 것이다.  ​펄에서 associative array를 다음과 같이 정의하고, ​%hi_temps = (“Mon” =&gt; 77, “Tue” =&gt; 79, “Wed” =&gt; 65, …);​다음과 같이 배열에서 값을 찾는다.  ​$hi_temps{“Wed”} = 83; 여기서 Wed가 키이다. ​다음 명령어는 배열에서 값을 삭제한다.  ​delete $hi_temps{“Tue”};  레코드배열은 동일한 유현의 데이터 요소의 모임인 반면, ​레코드는 다른 유형의 데이터 요소의 모임이다. ​레코드에서는 그 요소의 이름으로 요소를 식별(지칭, 언급)한다. ​레코드 타입에서 각 필드를 지칭(언급)하는 방법은 필드명에 의하며, ​서브 필드를 명확히 지칭하기 위해,  ​코볼에서는 of를 키워드로 하고, ​다른 언어에서는 dot(.)을 쓰기도 한다. ​레코드 타입의 연산은 assignment(필드명에 값 할당), ​레코드간의 필드값 카피 등이다.  ​튜플 타입은 레코드와 유사하나, 각 요소의 이름이 없다는 것이 다르다. ​파이썬의 튜플은 튜플의 값을 변경할 수 없다. ​만일 변경하고자 한다면, ​List 함수를 써서 튜플을 배열로 변환한 다음에, ​배열의 값을 변경한다. ​변경한 후에, tuple 함수를 써서, 튜플로 재변환한다. ​myTuple = (3, 5.8, ‘apple’)은 튜플을 생성한다. ​myTuple[1]은 첫째 요소를 가리킨다. ​+는 튜플 간의 concatenation을 실행하고, ​del은 튜플을 삭제한다.리스트 타입은 튜플과 유사하나, ​각 요소의 값을 변경 가능하다는 것이 다르다. ​파이썬은 리스트 타입을 지원하며, 배열처럼 취급된다. ​배열과 차이점은 각 요소의 값이 어떤 유형이든 상관없다는 것이다.  ​생성, 지칭, 삭제 연산 등을 보면 튜플과 유사함을 알 수 있다.​리스트 포함(comprehension)은 컨스트럭트에 리스트를 포함시키는 것을 말한다. ​이것은 리스트를 필요시 정의할 수 있는 편리한 기능이다. ​형식은 [expression for iterate_var in array if condition]을 취한다.  ​예를 들면, [x*x for x in range(12) if x%3==0]과 같다. ​range(12)는 0에서 12까지의 배열을 생성하는 함수이고, ​x%3은 x를 3으로 나눈 나머지를 말한다. ​이 문장은 0에서 12로 구성된 배열을 생성하고 ​0,3,6,9,12를 제곱하라는 뜻이다. ​포인터와 레퍼런스 타입에 대해 살펴보자.  포인터포인터 타입 변수가 가질 수 있는 값의 범위는 ​메모리 주소와 영(nil)이다.  ​포인터는 간접 주소 지정 방식과 동적 메모리 관리 방식을 제공한다. ​포인터는 힙에 있는 메모리 위치를 접근할 때 사용된다.기본적 연산으로 assignment와 dereferencing이 있다. ​Assignment는 포인터 변수의 값에 주소를 넣어 두는 것이다. ​디레퍼런싱은 포인터의 값이 가리키는 주소에 저장된 값을 산출하는 것이다. ​디레퍼런싱은 명시적이거나 암묵적이다. ​C, C++에서는 명시적인 디레퍼런싱 연산자로 를 사용한다. ​j=ptr는 ptr의 값이 가리키는 주소에 저장된 값을 ​변수 j의 메모리 위치에 넣어 두라는 의미이다. ​아래 그림은 이것을 그림으로 나타낸 것이다.​포인터 사용할 때 나타나는 문제는 다음의 두가지가 있다. ​​      허상 포인터(dangling pointer)는 ​힙-동적 변수에 할당된 메모리를 가리키지 않고 있는 포인터를 말한다.  ​자세히 설명하면, ​힙에 의해 변수에 메모리가 할당되면, ​포인터는 이 메모리를 가리키고 있겠지만,  ​이후 메모리가 해제되었다면, ​이 포인터는 메모리를 가리키지 못하게 된다. ​이러한 포인터를 허상 포인터라고 한다. ​즉, 메모리는 없지만 포인터는 남아 있는 경우이다. ​        memory leakage(기억 상실)​힙-동적 변수의 상실은 힙-동적 변수가 이미 메모리에 할당되어 있지만, ​포인터가 상실되어 ​사용자 프로그램에서 이 동적 변수에 더 이상 접근 가능하지 않은 경우를 말한다. ​즉, 포인터는 없지만 할당된 메모리는 남아 있는 경우이다.  포인터는 언제 메모리에 할당되든지 어떤 변수든 가리킬 수 있으며,  ​동적 스토리지 관리에서 사용된다. ​포인터 산술 연산이 가능하고, ​디레퍼런싱과 ‘무엇의 주소’ 연산이 가능하다.    float stuff[100];​    float *p;​    p = stuff;​    *(p+5) is equivalent to stuff[5] and  p[5]​    *(p+i) is equivalent to stuff[i] and  p[i]C, C++에서는 포인터에 대한 산술 연산이 가능하다. ​5번째값, i번째값  레퍼런스레퍼런스는 포인터와 유사하나, ​기본적으로 다른점은 ​      포인터는 메모리의 주소를 가리키지만, ​  (주소에 대한 연산이 나름의 의미를 갖지만)​        레퍼런스는 메모리의 값을 가리킨다. ​  (주소에 대한 연산이 무의미)  허상 포인터와 허상 객체는 힙 관리 상의 문제이다. ​포인터는 변수가 가리킬 수 있는 범위를 확장시킨다는 면에서 goto와 비슷하다. ​레퍼런스는 포인터의 기능과 유연성을 제공하면서, 위험은 제거한다. ​포인터와 레퍼런스는 동적 데이터 구조를 위해 프로그래밍 언어의 필수적인 요소이다.​이 그림에서는 허상 포인터의 예를 보여주고 있다. ​프로그램 코드가 이와 같을 때, ​*q=30은 이미 해제된 메모리가 남아 있다고 착각한다.  ​Q는 결국 아무것도 가리키지 않는 허상 포인터이다.",
        "url": "/pl-13"
    }
    ,
    
    "sc-08": {
        "title": "ECC",
            "author": "lee989898",
            "category": "",
            "content": "ECC  ECC  Public key  RSA의 대안  암호화는 잘 안 쓰인다 대신 전자서명과 키교환에서 주로 사용  회의적 시각 많다  ECC vs RSA  ECC는 이산대수문제 기반  A = $B^c$, c 찾기문제  RSA보다 작은 길이의 키로 비슷한 보안 제공  RSA보다 작은 키를 사용하지만 수학적 계산량 많다  타원곡선  타원곡선은 타원이 아니다  타원곡선 방정식을 만족하는 점들의 집합          $y^2$ = $x^3$ + ax + b        타원 곡선 모양​  타원곡선의 덧셈          곡선상의 두점 P,Q      P + Q는 두 점을 잇는 직선과 타원곡서의 접점을 x축에 대칭      여기에 mod p를 한다      ​  EC Discrete Log Problem  주어진 조건 ​          E: an EC over (field of modulo p), p:prime​      P: a point in E(Fp), and suppose that P has prime order n​        키 생성(Key generation)​          Private key d: selected in random in [1,n-1]​      Public key Q =dP, 소수 p, P​        ECDLP: The problem of finding d given the domain parameters and Q  (Q = dP일때, P, Q, p를 알더라도 d를 구하기 어렵다)​  ElGamal EC Encryption  Input​          EC domain para (p,E,P,n), Public key Q,  Plaintext m​        OutPut          Ciphertext (C1, C2)​                  Represent the message m as a point M in E​          Select k in [1,n-1],  ​          Compute C1 = kP, ​          Compute   C2 = M + kQ​          Return(C1, C2)​                      Q = dp일때, P,Q를 알더라도 d를 구하기 어렵다",
        "url": "/sc-08"
    }
    ,
    
    "sc-07": {
        "title": "ElGamal",
            "author": "lee989898",
            "category": "",
            "content": "ElGamal  ElGamal  Taher Elgamal, 1985 NSF  이산대수의 어려움을 이용  RSA보다 안전성향상  A = $B^c$, c찾기  Key genetation  큰 소수 p, p보다 작은 임의의 g,x 선택  Y = $g^x$ mod p를 계산  공개키: Y,p,g  비밀키: x  Encryptin/decryption  공개키: Y,p,g  비밀키: x  Encrypt: p-1과 relative prime인 임의의 k(1&lt; k &lt; p-1)a = $g^k$  mod p, b = $Y^k$ M mod p 를 계산          여기서, k를 임의로 선택하기 때문에 동일한 M에 대해서 매번 다르게 암호화된다. (RSA와 차이점)      Ciphertext는 dnjsfo M 길이의 2배가 된다.        Decrypt: b/$a^x$ mod p = $y^k$ M / $a^x$ mod p = M  ElGamal 서명 기법  RSA와 달리 서명만을 위해 설계됨  ElGamal 서명기법은 약간 변형된 형태로 NIST의 디지털 서명 표준(DSS)으로 채택",
        "url": "/sc-07"
    }
    ,
    
    "pl-12": {
        "title": "데이터 타입",
            "author": "lee989898",
            "category": "",
            "content": "데이터 타입선언문 int n으로부터 n에 대해 무엇을 알 수 있을까? ​  n이 취할 수 있는 값의 범위는? (모든 정수) ​  n에 적용 가능한 연산자는? (닫혀 있는 모든 연산자, +, -, *) ​데이터 타입의 개념에 대해 살펴 보면, 특정 타입의 변수를 선언하면,  ​그 변수가 취할 수 있는 값은 특정 집합이고, ​그 값들에 적용 가능한 연산자 집합이 존재한다는 의미이다.  ​PL 설계자가 마주하는 기본적인 설계 이슈는 ​목적에 적합한 충분한 데이터 타입으로 구성된 집합을 어떻게 정의할 것인가? ​무슨 연산자들을 정의하고 이들 연산자를 데이터 타입에 어떻게 지정(specify)할 것인가?데이터 타입은 다음과 같이 진화해 왔다. ​초기 PL에서는, 많은 데이터 타입으로 다양한 응용을 지원하였다. ​PL/1이 이러한 예이다. ​ALGOL68에서 얻은 지혜: ​소수의 기본 타입과 이를 위한 소수의 연산자를 정의하고, ​필요에 따라, 사용자 정의(user-defined) 데이터 타입을 지원하자! ​사용자 정의 타입으로부터 추상 데이터 타입으로 발전하였다.​예를 들어, 스택, 큐, 링크드 리스트 등이 이에 속한다. ​타입의 유용성은 다음과 같다.  ​  프로그램 구조화 및 문서화에 유용​  오류 식별 및 방지에 유용​  최적화 지원에 유용 ​​먼저 비교적 단순한 형태로서, 원시형, 문자열형, 사용자 정의 나열형부터 살펴 보자  원시 타입원시 타입은 거의 모든 언어가 제공하고 있는 기본적인 데이터 타입으로, ​다른 데이터 타입을 사용해서 정의되지 않는 데이터 타입이다. ​Integer, floating-point, Boolean, character ​원시 타입은 하드웨어 구조를 직접 반영한 것도 있다. ​부동점 소수는 4바이트의 싱글 프리시전과 8바이트의 더블 프리시전이 있는데, ​각각의 비트 구성은 ​싱글 프리시전: 싸인 1비트, 지수부분 8비트, 소수부분 23비트이거나 ​더블 프리시전: 싸인 1비트, 지수부분 11비트, 소수부분 52비트이다.    ​​+ 문자열 형문자열 타입의 값은 문자열이다. ​설계 이슈: ​  원시 타입으로? 아니면 배열의 특수형으로? ​  스트링의 길이를 정적으로? 아니면 동적으로?​  스트링 연산자는? assignment, copy, comparison, concatenation, substring, pattern matching, etc문자열을 비교할 때, &gt;의 의미는 사전식 순서의 앞뒤 관계를 의미한다.  ​​C, C++에서 문자열은 원시 타입이 아니라, char 타입을 사용하여 정의한다.  이를 위해 라이브러리 함수를 제공한다. ​  C 스트링 라이브러리의 문제는 제공되는  함수가 오버플로우를 처리하지 못한다는 것이다. ​ 예를 들어, strcopy (src, dest); 에서 ​ src가 50바이트이고, dest가 20바이트이면 어떤 일이 일어날까?  ​자바의 문자열 타입은 원시 타입으로 String,  StringBuffer 클래스를 지원한다.문자열 길이 옵션은 3가지(정적, 제한적 동적, 동적) 옵션이 있다.  ​먼저 정적 옵션을 보면… ​COBOL, Java String 클래스는 정적이다. ​스트링이 생성될 때 길이가 정해진다. ​제한적 동적 옵션은… ​C, C++에서는 동적이나 제한적이다. ​  길이는 최대 길이까지 가변적이다. ​  C에서는 최대 길이로 제한하기 보다, ​스트링에 특수 문자를 사용하여 스트링의 끝을 나타내기도 한다. ​동적 옵션은… Perl, Javascript​Ada는 모든 옵션을 지원한다.문자열 옵션의 구현 방법은 다음과 같다. ​정적 옵션의 구현 방법은 컴파일 시에 문자열의 서술을 위해 ​3개의 필드(타입 이름(static string), 길이, 첫글자의 주소)를 필요로 한다. ​제한적 동적 옵션 구현 방법은 런타임 때 문자열의 서술을 위해 ​4개의 필드(타입이름(limited dynamic string), 최대 길이, 현재 길이, 첫글자의 주소)를 필요로 한다.  ​동적 옵션의 구현 방법은 런타임 때 문자열의 서술을 위해, ​3개의 필드(타입 이름(dynamic string), 현재길이, 첫글자의 주소)를 필요로 한다. ​동적 문자열은 문자열의 증가와 감소에 따라 ​저장 공간을 동적 관리(allocate, deallocate)해야 한다.  ​  사용자 정의 서수 타입서수 타입은 ‘데이터를 모아 놓은 것인데 순서가 중요한’ 데이터의 모임이라고 볼 수 있다. ​Enumeration(나열형)과 subrange(범위형)가 대표적인 서수 타입이다.나열형을 살펴 보면, 속성과 값이 정의되어 있음을 볼 수 있다. ​Coin은 페니, 니켈, 다임, 쿼터를 각각 1, 5, 10, 25로 정의하고, ​Escapes는 각 키마다 아스키 코드의 컨트롤 문자가 대응되어 있음을 볼 수 있다. ​연산자에 대해, 표현의 특성이 integer면, integer 연산을 수행한다.",
        "url": "/pl-12"
    }
    ,
    
    "st-05": {
        "title": "Process",
            "author": "lee989898",
            "category": "",
            "content": "Process  Definition of Process  실행 중인 프로그램  프로그램          데이터와 instructions로 구성된 파일      프로그램은 수동적이다        프로그램을 실행시키기 위해서는 커널 루틴, 리소스(cpu,메모리 등)으로부터 지원을 받아야 한다  프로세스는 다음과 같이 다르게 정의될 수 있다          프로그램 + HW/SW 실행에 필요한 프로그램      프로그램을 실행할 수 있는 환경        Environment ​          이미지 또는 컨텍스트라고도 함      프로그램 텍스트, 힙, 스택, 레지스터 값, 시스템 데이터(현재 디렉토리, open 파일 디스크립터, 누적 CPU 시간 등)로 구성        Modes of Process  사용자 프로세스는 호출될 커널 프로세스를 트리거하는 시스템 호출을 사용할 수 있다  User process / kernel process          트랩 명령(또는 인터럽트)은 사용자 프로세스(모드)에서 커널 프로세스(모드)로의 전환을 할 수 있다      커널 프로세스에서 사용자 프로세스로 복귀        Process Level  Level 0: swapper (scheduler)​  Level 1: kernel process​  Level 2: system process​      Level 3: cmd process    Swapper (scheduler) process​          스스로 프로세스가 되어 실행을 시작하는 커널 프로그램        fork() system call​          부모 프로세스는 fork()를 호출하여 자식 프로세스를 생성한다      자식 프로세스는 부모 프로세스의 모든 환경을 상속한다        각 프로세스가 생성될 때 고유 번호(프로세스 ID)가 할당된다  ID가 0인 프로세스는 특별한 커널 프로세스이다  프로세스 0 forks()하면 init라고 하는 다른 프로세스(ID 1)생긴다  fork init 후 프로세스 0은 스와퍼(또는 스케줄러)가 된다.  Process Tree  Init 프로세스는 시스템에서 생성된 모든 프로세스의 조상이 된다  Init​          sendmail, crom, etc. ​      사용자 ID/암호를 묻는 프로세스 -&gt; Shell​        따라서 init 프로세스를 루트로 하여 “프로세스 트리”가 형성된다  Process: State  New: 프로세스 생성 중  Running: 명령이 실행되고 있다  Waiting: 프로세스가 어떤 이벤트가 발생하기를 기다리고 있다  Ready: 프로세스가 프로세서에 할당되기를 기다리고 있다  Terminated: 프로세스가 실행을 완료했다  Process Group  동일한 로그인 셸(상위 프로세스)에서 생성된 프로세스를 프로세스 그룹이라고 한다  프로세스 그룹 ID로 식별한다  Process Priority  각 프로세스에는 우선 순위가 지정된다  Swapper는 우선 순위가 가장 높은 프로세스를 선택한다  우선 순위 범위는 0(최고) ~ 127(최저)          프로세스의 우선 순위를 확인하려면 “%ps -ef” 및 “%ps -el”을 사용하면 된다        모든 프로세스에 동등한 기회를 제공하기 위해 우선 순위가 동적으로 변경된다  “nice” 명령(nice() 시스템 호출)은 자발적으로 프로세스의 우선 순위를 낮추는 데 사용된다 ​  Process ID  User ID​          Real user ID​      Effective user ID​        Group ID​          Real user ID​      Effective user ID​        Signal  실행중인 프로세스를 외부에서 제어하는 수단​  프로세스간에 동기화를 얻는 수단​  SW interrupt 로 구현됨​  kill() system call 을 이용하여 process 간에 signal 들을 보냄​  signal() system call specifies “what to do” when a process receives a signal​  Try “% kill –l”  Process: Creation          프로세스는 여러 개의 새로운 프로세스를 생성할 수 있다      생성 프로세스: parent 프로세스      새로 생성된 프로세스: child 프로세스                  fork() 시스템 호출은 새로운 프로세스를 생성한다                    리소스 공유                  자식은 부모의 일부 리소스를 공유합니다                    Execution​                  부모와 자식이 함께 실행          부모는 자식이 끝날 때까지 기다린다          wait() 시스템 호출은 자식이 종료될 때까지 기다린다                      Process: Exit  프로세스는 최종 명령 실행을 마치면 종료된다  exit() 시스템 호출을 사용하여 운영 체제에 자신을 삭제하도록 요청한다          프로세스는 데이터를 부모 프로세스로 반환할 수 있다(wait() 시스템 호출을 통해)      프로세스의 모든 리소스(물리적 및 가상 메모리, open 파일 및 I/O 버퍼 포함)는 운영 체제에 의해 할당 해제된다.        프로세스는 적절한 시스템 호출(예: abort())을 통해 다른 프로세스를 종료할 수 있다.  사용자가 임의로 프로세스를 종료(kill)  Process Start  int main(int argc, char *argv[]);​          arc :     command-line arguments의 수​      argv[] :  arguments​에 대한 포인터 배열        C start-up routine​          커널에 의해 시작됨(by the exec system call)​      커널에서 command-line arguments와 environment 가져오기      Call main        Process Termination  Normal termination          return from main()​      calling exit() : ​      calling _exit() ​        Abnormal termination          calling abort()​      terminated by a signal        exit()    #include &lt;stdlib.h&gt;    void exit(int status);  정상적인 프로세스 종료  Execution of clean-up processing​          열려 있는 모든 스트림 닫기      출력 버퍼의 내용을 디스크에 쓰기        상태          프로세스의 종료 상태        _exit()    #include &lt;unistd.h&gt;    void _exit(int status);  정상적인 프로세스 종료  즉시 커널로 돌아가기  atexit()    #include &lt;stdlib.h&gt;    void atexit(void (*func)(void));  사용자가 정의한 종료 핸들러를 등록한다          프로세스당 최대 32개        기능          종료 핸들러      함수 포인터        exit()는 등록의 역순으로 exit 핸들러를 호출한다  비정상 종료(abort) 시 atexit에 등록된 기능이 실행되지 않음  Command-Line Arguments  exec() 및 C-start-up 루틴은 새 프로그램에 command-line arguments를 전달한다  Linux 셸의 정상 작동의 일부  argv[argc]는 NULL 문자(ANSI, POSIX.1)이다  Environment Variable  환경 변수는 부모 프로세스에서 자식 프로세스로 전송된다  파일(.login 또는 .cshrc)에 설정된 환경 변수  환경 변수: 이름 = 값  전역 변수 “environ”을 사용하여 환경 변수에 액세스한다          #include       extern char ** environ;        각 환경 변수는 “name=value” 형식의 문자열로 구성된다          각 문자열은 ‘\\0’으로 끝난다      마지막 환경 변수 목록은 널 포인터이다.        argv와 같은 구조  getenv()    #include &lt;stdlib.h&gt;    char *getenv(const char *name);        반환값: 이름과 관련된 값에 대한 포인터, 찾을 수 없으면 NULL  주어진 이름의 문자열에 대한 환경 목록 검색  일치하는 항목이 발견되면 해당 이름과 관련된 값을 반환한다.  요청한 변수가 존재하지 않으면 null을 반환한다  putenv()    #include &lt;stdlib.h&gt;    int putenv(const char *str);        반환값: 정상이면 0, 오류 시 0이 아닌 값  “name=value” 형식의 문자열을 취한다.  현재 환경 목록에 추가  setenv() / unsetenv()    #include &lt;stdlib.h&gt;​    int setenv(const char *name, const char *value, int rewrite);                                                                반환값: 정상이면 0, 오류 시 0이 아님    void unsetenv(const char *name);​   etenv 등록 환경 변수 이름 = 값  같은 이름의 환경변수가 존재하는 경우          rewrite != 0 -&gt; change new value​      rewrite = 0 -&gt; not change        unsetenv는 환경 변수 이름을 제거한다  Memory Layout of a program​  텍스트 세그먼트: 기계 instructions(읽기 전용, 공유 가능)  초기화된 데이터 세그먼트:​          e.g. int maxcount = 99; (initialized)​        초기화되지 않은 데이터 세그먼트 또는 bss (block started by symbol)​          e.g. long sum[1000];​      프로그램이 실행되기 전에 exec에 의해 0 또는 널 포인터로 초기화됨      (Use “size” command: % size a.out)​  Heap: ​          동적 메모리 할당 (malloc, etc.)​        Stack: ​          자동 변수, 임시 변수, 반환 주소, 호출자 환경(레지스터)        Shared library  Static linking library​          라이브러리 루틴이 실행 파일에 추가된다      실행 파일 크기 증가        Shared library​          파일 실행을 위한 라이브러리 루틴 포함      라이브러리 루틴은 공유 메모리에 로드되고 실행 중에 공유된다      프로그램 크기는 증가하지 않는다      처음 실행할 때 오버헤드가 발생한다        Static libraries as .a (archive files)​          관련된 재배치 가능한 개체 파일을 인덱스(아카이브라고 함)가 있는 단일 파일로 연결한다      아카이브 구성원 파일이 참조를 확인하는 경우 실행 파일에 링크한다        libc.a (the C standard library)​          1392개 개체 파일의 8MB 아카이브.      I/O, memory allocation, signal handling, string handling, data and time, random numbers, integer math​        libm.a (the C math library)​          401개 개체 파일의 1MB 아카이브.​      floating point math (sin, cos, tan, log, exp, sqrt, …) ​        Shared Libraries  정적 라이브러리에는 저장된 실행 파일이 중복된다는 단점이 있다(모든 기능에는 std libc가 필요함)  최신 솔루션: 공유 라이브러리​          응용 프로그램에 동적으로 로드 및 연결,​                  로드 타임 또는 런타임 시                    동적 링크 라이브러리, DLL, .so 파일이라고도 함      일반적으로 동적으로 연결되는 표준 C 라이브러리(libc.so)        동적 연결은 프로그램이 시작된 후에도 발생할 수 있다 (런타임 링크)  Memory Allocation​#include &lt;stdlib.h&gt;​void *malloc(size_t size);​void *calloc(size_t nobj, size_t size);​void *realloc(void *ptr, size_t newsize);​            반환: 정상이면 널이 아닌 포인터, 오류 시 NULLvoid free(void *ptr);  힙에 동적 메모리 할당  적절한 정렬 제공          ex) double은 8의 배수인 주소에서 시작해야 한다            라이브러리는 메모리 풀을 관리한다    malloc(): ​          지정된 바이트 수 할당      메모리의 초기 값이 결정되지 않음        calloc(): ​          지정된 크기의 지정된 수의 개체 할당​      모두 0비트로 초기화        realloc(): ​          이전에 할당된 메모리의 크기를 변경합니다.      새로운 영역의 초기 값이 결정되지 않음        setjmp() / longjmp() ​#include &lt;setjmp.h&gt;​int setjmp(jmp_buf env);​               반환값 : 0, 직접 호출된 경우                없음 0, longjmp 호출에서 반환하는 경우void longjmp(jmp_buf env, int val);​  함수 호출 건너뛰기(nonlocal goto)  깊이 중첩된 함수 호출에서 오류 조건을 처리하는 데 유용하다          오류가 발생했을 때 빠르게 main()으로 돌아가고 싶은 경우      많은 수의 수준 각 오류에 대해 각 수준에서 반환 처리      Direct nonlocal goto: setjmp, longjmp​        env: setjmp 및 longjmp에 사용되는 전역 변수​  setjmp: env의 setjmp 지점으로 돌아가기 위한 정보 저장          직접 호출하면 0 반환      longjmp에 대한 호출에서 반환하는 경우 0이 아닌 값을 반환한다        longjmp: env를 사용하여 setjmp 지점으로 이동하고 val을 반환 값으로 사용          여러 longjmp가 다른 val로 동일한 setjmp 위치를 사용할 수 있다        env는 다른 함수에서 참조할 수 있다",
        "url": "/st-05"
    }
    ,
    
    "algorithm-04": {
        "title": "동적 계획",
            "author": "lee989898",
            "category": "",
            "content": "동적 계획  분할 정복과 같이 주어진 문제를 더 작은 부분 문제들로나눈 후 부분 문제들의 해들을 합병하여 해결한다.  분할 정복과 달리 부분 문제들이 서로 겹친다.  많은 해들 중 최적의 해를 찾는 최적화 문제에 적용한다.​위 그림은 분할 정복과 동적 계획의 분할 과정의 예이다.  동적 계획 전략  문제를 더 작은 부분 문제들로 분할한다.  작은 부분 문제들을 해결하고 해들을 표에 저장한다.  나중에 다른 (부분) 문제를 해결할 때 이미 해결한 부분 문제가 나오면다시 해결하는 대신에 표에서 해를 찾아 사용한다.막대 자르기  막대의 길이는 n(양의 정수)이다.  막대의 길이가 i(양의 정수), 1 &lt;= i &lt;= n-1,인 조각막대로 자를 수 있다.  길이가 i, 1 &lt;= i &lt;= n, 인 (조각) 막대의 판매 가격은 $p_i$이다.      길이가 n인 막대를 여러 개의 양의 정수 길이의 조각 막대들로잘라서 판매할 때 얻을 수 있는 최대 판매 금액을 구해야 한다.물론 막대를 자르지 않고 통째로 팔 수도 있다.    억기 기법 알고리즘          막대를 자르는 모든 경우들을 찾아낸다.      각 경우에서 얻을 수 있는 판매 금액을 계산한 후 그 중 최대 판매금액을 구한다.      ​위 그림은 막대를 자르는 모든 방법들과 판매 금액이다.시간 복잡도: $\\theta$($2^n$)  분할 정복 알고리즘          길이가 n인 막대를 처음에 길이 i, 1&lt;=i&lt;=n-1, 인 막대와 길이 (n-i)인 막대로 자른다.      길이 i인 막대는 그대로 팔고 길이 (n-i)인 막대는 최대 판매 금액을얻을 수 있도록 통째로 팔거나 여러 개의 양의 정수 길이의 조각 막대들로 잘라서 판다.      R(n): 길이가 n인 막대를 판매할 때 얻을 수 있는 최대 판매금액  R(n) = MAX($p_i$, R(n-i))          1 &lt;= i &lt;= n       R(0) = 0$p_i$: 길이가 i인 막대의 판매 가격R(n-i): 길이 (n - i)의 막대를 판매할 때 얻을 수 있는 최대 판매 금액cutRod_DC(p[], i)//길이 i의 막대를 판매할 때 얻을 수 있는 최대 판매 금액, R[i]를 계산한다.//입력: p[i..n] - 막대들의 판매 가격    i - 막대의 길이//출력(반환값): 최대 판매 금액if(i = 0) return 0else{    maxSell = 0    for(j = 1; j &lt;= i; j++)    maxSell = MAX(maxSell, p[j] + cutRod_DC(p,i-j))    return maxSell}최초 호출 maxSellValue = cutRod_DC(p,n)​위 그림은 cutRod_DC(p,4) 호출시 실행 트리 이다.시간 복잡도: $\\theta$($2^n$)  동적 계획 알고리즘 설계 과정cutRod_DP(p[], n)// 길이 n의 막대를 판매할 때 얻을 수 있는 최대 판매 금액을 계산// 입력: p[1 .. n] - 막대들의 판매 가격, n: 막대의 길이// 출력(반환값): 최대 판매 금액배열 maxSell[0 .. n]을 선언한다.maxSell[0] = 0for(j = 1; j&lt;=n; j++){    maxVal = 0    for(k = 1; k &lt;= j; k++)     maxVal = MAX(maxVal, p[k] + maxSell[j - k])    maxSell[j] = maxVal}return maxSell[n]시간복잡도: $\\theta$($n^2$)모든 쌍 최단 경로 찾기​위 그림은 한 그래프 내의 각 정점에서 모든 다른 정점으로 가는 가장 짧은 경로를 찾는 문제이다.가중치를 포함한 방향(혹은 무방향)그래프 G = (V,E)가 주어지면 각 정점에서 모든 다른 정점으로 가는 최단 경로의 거리를 찾아라.  경로의 거리 = 경로 상의 모든 간선의 가중치들의 합  정점들의 수 = n      정점들을 각각 1,2,3, …., n으로 나타낸다.    동적 계획 Floyd 알고리즘문제: 행렬 W가 주어지면 최단 거리 행령 D를 구한다.주 아이디어  최단 경로들을 단계적으로 만든다.  최단 경로들을 경유 가능한 정점들의 집합 L을 이용하여 만든다.최단 경로는 L 내에 있는 정점(들)만을 이용한다.  L에 정점들을 한 번에 하나씩 정점의 번호 순서대로 추가한다.  최단 거리 행렬들을 다음과 같은 순서대로 계산한다.     $D_0$,$D_1$,$D_2$, …, $D_n$​위 그림은 Floyd 알고리즘 예이다.  Floyd 알고리즘AllPairShortestPath(W[])//입력: 가중치 행렬 W [1..n, 1..n]//출력: $D^(i)$ [1..n, 1..n], 0&lt;=i&lt;=n     $D^0$ = W     for(k = 1; k &lt;= n; k++){         n x n 행렬 $D^(k)$ = (dij(k))를 선언한다         for(i = 1; i &lt;= n; i++)           for(j = 1; j &lt;=n; j++)             dij(k) = MIN(dij(k-1),di,k(k-1)+dk,j(k-1)    }",
        "url": "/algorithm-04"
    }
    ,
    
    "pl-11": {
        "title": "변수와 시맨틱스",
            "author": "lee989898",
            "category": "",
            "content": "변수와 시맨틱스변수는 변수명, 데이터 타입, 값, 메모리 주소 등의 속성을 갖는다. ​이들 속성을 변수에 결합하는 것을 바인딩이라고 한다. ​바인딩이 되는 때를 바인딩 타임이라고 하는데, ​주로 컴파일 할 때, 링크할 때, 메모리에 적재할때, 실행할 때가 바인딩 타임이다.값이 assign될 때(assignment statement) 타입이 바인딩 되는 것을 동적 바인딩이라고 한다. ​정적(static) 바인딩은 변수가 정의되거나 맨처음 나타날 때 타입이 바인딩된다. ​바인딩 타임에 따라 변수의 값, 타입 등 ‘변수의 시맨틱’이 달라진다.  ​스코프는 해당 변수가 정의 및 언급(reference)된 문장의 범위를 말한다.  ​프로그램에서 선언(정의)문을 기준으로 하는 방법이 있고, ​값의 할당문 하는(정해지는 순간을 기준으로 하는 방법이 있다. ​전자를 static scope(정적 스코프)라고 하고, ​후자를 dynamic scope(동적 스코프)라고 한다. ​이제 상세히 알아보자  변수우선 변수의 개념을 살펴 보자.변수는 이름, 값, 타입, 주소(메모리)를 속성으로 갖는다. ​이름은 identifier라고 하며, 언어에 따라 정의 방법에 제한이 있는 경우도 있다. ​변수의 값은 변수에 연관된 메모리 위치에 저장된 컨텐트(내용)으로, ​프로그램 실행시 시시각각으로 바뀐다.변수의 타입은 데이터 타입을 말하는 것으로, ​변수가 취할 수 있는 값의 범위와 이에 대한 연산자 집합을 결정한다. ​변수의 타입은 선언문에 의해 정의되거나, ​명명법(naming convention)에 따라 유추 가능하다. ​타입 시스템을 적용하면, 타입 검사 및 프로그램모듈화를 통한 오류 탐지가 가능하다. ​같은 이름의 변수가 서브 프로그램의 스코프에 따라 다른 타입을 가질 수 있으며,  ​이종 타입 간의 연산이 가능할 수도 있다.변수는 메모리의 지정된 주소에 바인딩된다. ​변수가 메모리 주소에 바인딩되면, ​끝날 때까지 그 변수는 살아 있으며(active), ​프로그램이 종료되면 그 메모리는 더 이상 그 변수에 바인딩되지 않는다. ​이와 같이 바인딩이 시작되서 끝날 때까지의 시간을 lifetime이라고 한다.​—​위 그림에서 변수 i는 맨앞과 foo 함수에서 정의되고 있는데,  ​이들 i는 변수명과 타입이 같으나, 메모리 위치는 서로 다르다. ​변수 i는 foo 함수와 bar 함수에서 나타나는 변수 i의 메모리 위치는 ​Foo의 isms foo에 정의된 i를 언급하지만, ​Bar의 i는 맨앞의 i를 언급한다.  ​이들 i가 갖는 값은 변수의 스코프 규칙에 따라다르다.​  바인딩​바인딩은 변수와 주소/타입 간의 매핑을 말한다. ​이들 바인딩에는 정적 바인딩과 동적 바인딩이 있다. ​정적 바인딩은 실행 전(컴파일, 링킹)에 바인딩이 완료되며, ​프로그램 실행 동안에 그 속성이 변경되지 않는다. ​동적 바인딩은 실행 중에 바인딩이 일어나며, ​실행 중에 바뀔 수 있다.변수가 언급(referenced)되기 전에 그 변수는 데이터 타입에 바인딩되어야 한다. ​정적 바인딩에서, 타입 바인딩은 명시적 선언에 의하거나 암묵적 선언에 의한다. ​암묵적 선언이란 선언문 또는 정의문에 의한 것이 아니라 ​변수의 명명법에 의해 타입을 부여하는 것을 말한다. ​Perl에서 변수명이 시작되는 특수문자에 따라 타입이 결정된다. ​$ is a scalar(numeric, character), @ is an array, % is a hash structure ​정적 타입 바인딩에서, 타입과 변수명은 동시에 변수에 바인딩된다.동적 바인딩은 값이 변수에 부여될 때, 값의 타입을 변수에 부여한다. ​동적 바인딩은 파이썬, 자바 스크립트 등에서 사용된다.  ​예를 들어, 프로그램에서 다음과 같이 쓸 수 있다.    ​List = [2, 4.33, 6, 8];​List = 17.3;​이것의 의미는 ​List = [2, 4.33, 6, 8]; -&gt; 이때는 벡터이고, ​List = 17.3; -&gt; 이때는 스칼라이다.  타입 검사연산자의 오퍼랜드가 서로 호환적인 타입인지 ​확인하는 행위를 타입 검사라고 한다. ​호환적인 타입의 의미는 ​두 오퍼랜드의 타입이 연산자에 적합하거나 ​타입 변환이 가능한 경우이다.  ​Int는 real로 자동 변환되는데, 이를 coercion(자동 변환)이라고 한다. ​정적인 타입 바인딩을 적용하면, 정적 타입 검사를 실시하고, ​동적인 타입 바인딩을 적용하면 동적 타입 검사를 실시한다.스토리지(메모리) 바인딩은 ​메모리 풀에서 메모리 셀을 얻어서 변수에 할당하고(allocation), ​메모리를 다 쓰고 나면, 메모리 풀로 반납한다(deallocation). ​변수의 Lifetime은 특정 메모리 셀에 바인딩되어 있는 동안의 시간을 말한다. ​변수가 특정 셀에 바인딩될 때 시작되서, 바인딩이 해제될 때 끝난다.   ​스칼라 변수는 lifetim에 따라 4가지 종류가 있다. ​  정적 변수(Static)  정적 변수는 실행 전에 메모리 셀이 바인딩 되서,   실행이 끝날때까지 그대로 차지한다. ​    포트란77, C의 글로벌 및 정적 변수가 이에 해당 ​  장점은 인스트럭션의 주소 필드가 (데이터가  저장된) 메모리 위치를 직접 가리킬 수 있어서 ​  직접 주소 방식(direct addressing)으로  데이터를 접근할 수 있을 뿐만 아니라, ​  실행시 allocation으로 인한 오버헤드가 없어서, 효율적이다. ​  데이터 구조를 동적으로 생성하거나 객체의 크기를 컴파일   할 때 미리 알아야 한다.  정적 메모리 모델은 recursion을 지원할 수 없다.  스택 동적 변수(stack dynamic)  스택 동적 변수는 다음과 같이 바인딩을 수행한다.  ​          선언문에 정의된 타입은 정적으로 바인딩되지만, ​      스토리지 할당과 초기값 할당 등은 선언문에 정의  된 대로 실행시에 바인딩된다. ​  이것을 elaboration이라고 함) ​예를 들어, 스칼라 변수에 대해 주소를 제외한 모든 속성은 정적으로 바인딩되지만, ​서브 프로그램의 로컬 변수나 자바의 메소드 등은 ​런타임 스택으로부터 메모리가 할당되어 동적으로 바인딩된다. ​장점은 recursion, 서브프로그램 메모리 보존 등이며, ​단점은 allocation, deallocation으로 인한 오버헤드, 간접 주소 방식(indirect addressing)에 의한 비효율 등이다.  ​      간접 주소 방식이란 인스트럭션의 주소 필드가 레지스터를 가리키고, ​그 레지스터 안에 메모리 위치가 저장되어 있어서, ​레지스터를 거쳐야 원하는 데이터를 접근하게 되는 방식이다.      명시적 힙 동적 변수(explicit heap dynamic) 힙은 가상 주소 공간의 일부분으로 동적 메모리 할당을 위해 예약되어 있다. ​명시적 연산자 new, delete에 의해 할당되고 해제된다. ​타입은 정적으로 바인딩되고, ​스토리지는 실행시 변수가 생성될 때 바인딩된다. ​힙에 접근할 때에는 힙 포인터나 레퍼런스를 통해서 접근하게 된다.      Person *p;​  p=(Person *) malloc(sizeof Person);​  p-&gt;name = “Mike”; p-&gt;age = 40;​  free(p);​      위 코드는 C++의 명시적 힙 동적 변수의 예를 보여주고 있다. ​자바 객체는 명시적 힙 동적 변수이다. ​명시적 힙동적 변수의 장점은 동적인 구조를 생성할 수 있다. ​단점은 포인터와 레퍼런스 변수를 올바르게 쓰기가 어려워 프로그램의 신뢰도가 떨어질 수 있고, ​    변수에 대한 레퍼런스 비용과 스트로지 관리의 복잡도가 높다.  ​  암묵적 힙 동적 변수(implicit heap dynamic)값이 할당될 때, 힙 스토리지에 바인딩된다. ​장점은 융통성이 높다.  ​단점은 동적 속성을 유지하기 위한 런타임 비용이 높고, ​컴파일러에 의한 오류 탐지가 매우 낮다.  스코프속성이 바인딩된 변수에 대해, ​그 바인딩이 유효한 또는 영향을 미치는 프로그램의 범위, 이것을 스코프라고 한다.하나의 프로그램을 구성하는 여러 함수에서 ​  동일한 이름의 변수들을 다른 타입으로 선언할 수 있다. ​  이때 이들 변수는 각각 다른 타입으로 바인딩된다. ​  이러한 이유로, 어떤 변수에 언제 어느 타입을 ​  바인딩하는 것이 옳은지 결정하려면, ​  어느 타입의 변수가 프로그램의 어디부터 어디까지 유효한지 ​  구분이 필요하다. ​  이와 같이 변수의 타입이 유효한 프로그램의 영역을 스코프라고 한다. ​​위 그림의 main에서 foo(x)를 호출할 때, ​  이때 x는 int인가 float인가? (int이다)변수의 스코프에 대한 정의를 살펴 보자  스코프는 변수가 visible한(나타나는) 문장의 범위이다. ​  ‘변수가 어떤 문장에서 visible하다(나타난다)’의 의미는 ​  바인딩된 변수가 그 속성을 그대로 유지한 채, ​  그 문장에서 언급(reference)되거나 그 변수에 값이 할당된다는 것이다. ​스코프를 변수가 영향을 미치는 범위라고 했는데, ​  좀더 정확히 말하면, ​  변수가 자신의 속성을 문장의 계산에 반영한다는 의미이다.C++이나 자바에서 포인터, 레퍼런스 타입 등을 설명할 때 ​  Reference란 말이 사용되는데, ​  여기서 설명하는 refence의 의미와 다르다.여기서, ‘문장에 X가 reference된다’는 말은 ‘x가 문장에   ‘언급된다(씌여있다)’는 것을 의미하고, ​    레퍼런스 타입의 레퍼런스를 의미하지 않는다  ​  프로그램에서 nonlocal 변수는 ​    그 변수가 그 프로그램에서 visible하지만 ​  그 프로그램에서 선언(declaration)되지는 않았다는 뜻이다. ​  nonlocal 변수의 선언문은,  ​  프로그램의 공간적 구조(정적 스코프)나 ​  프로그램 호출의 역순(동적 스코프)으로 찾아가면, ​  공간적으로 가깝거나 가까운 호출 함수에서 선언문을 찾을 수 있다. ​언어의 스코프 규칙은, 같은 이름의 변수가 여러 개 선언되었을 때, ​  언급된 이름이 어느 선언문에 의한 변수에 관련되어 있는지 결정한다.  정적 스코프정적 스코프는 변수의 스코프를 ​  프로그램 텍스트 구조에 따라 공간적 개념에 의해 정적으로 결정한다. ​    언급된 이름을 변수에 매핑하려면, ​  프로그래머(또는 컴파일러)는 선언문을 찾아야 한다. ​  먼저 로컬에서 찾은 후, 없으면 스코프를 넓혀가면서, ​  같은 이름을 정의한 선언문을 찾거나 선언  문이 더 이상 없을 때까지 찾는다.   C에서 블록 스코프는 텍스트 레이아웃에 의한 ​  공간적 개념으로 결정된다.  동적 스코프동적 스코프는 프로그램의 텍스트 레이아웃이 아니라, ​  컨스트럭트의 호출 순서에 근거하므로, 런타임 때 결정된다. ​    동적 스코프는 프로그램 실행 중, ​    변수가 언급될 때마다 그 변수의 선언문을 찾아서 동적으로 매핑한다. ​    언급된 변수에 대한 선언문이 어느 함수에 있는지 찾기 위해, ​    함수 호출 순서의 역순으로 해당 변수의 선언문을 찾는다.동적 스코프의 장점은 서브 프로그램을 호출할 때 ​     파라미터를 패스하지 않아도 되니 편리하다. ​    단점은 자주 실행되는 서브 프로그램의 로컬 변수는 ​      역시 자주 실행되는 다른 서브 프로그램에서 자주 나타나기 때문에 ​      계산이 잘못될 가능성이 높다. (신뢰성 문제)​    정적 타입으로 선언된 난로컬 변수의 타입 검사는 불가하여 오류 탐지가 어렵다.  ​   게다가 읽고 이해하기 어렵다.  라이프 타임라이프타임(수명)은 ​변수에 메모리가 할당(allocate)되서 해제(deallocate)될 때까지의 시간을 말한다. ​라이프타임은 스코프와 밀접한 관계가 있지만, 개념적으로는 다르다.​위 그림 C 프로그램에서 로컬 정적 변수 count를 살펴 보자. ​Main에서 fun을 1차 호출하면, count는 1이고, ​2차 호출하면 count는 2이다. ​count의 스코프만 따지면, ​count가 로컬 정적변수이기 때문에 1차, 2차 호출 모두 1, 1이어야 한다.  ​그러나 count의 lifetime이 전체 프로그램의 실행이 끝날 때까지 ​연장되기 때문에, 1,2가 된다.변수의 개념을 좀더 상세히 알아보면, ​x=1, x=x+1의 의미를 따져 보자.여기서 =은 수학의 equal 사인이 아니라, ​x에 1을 할당(assign)한다는 말이다. ​x는 변수의 이름이거나 변수의 위치를 지칭한다. ​즉, 변수는 메모리 셀의 추상화이다. ​따라서, x는 이름(고유식별자)이고, ​x는 어떤 값이 저장된 위치를 지칭한다.  Stack함수가 호출되면, 스택 프레임을 스택의 꼭대기에 push 하고, ​함수 실행이 끝나면, 스택 프레임을 꼭대기로부터 pop한다. ​스택 프레임은 호출되는 함수에 넘겨지는 파라미터 값, ​호출함수가 호출된 함수로부터 값을 넘겨받는 반환 주소, ​호출된 함수의 로컬 변수를 위한 저장 공간을 포함한다.  Heap힙은 동적 메모리 할당이 일어나는 메모리의 일부분이다. ​할당/해제 함수로는 malloc/free(pointer), new(pointer)/delete(pointer)가 있다. ​힙에 대한 메모리 할당은,    ​메모리 일부분이 런타임에 동적으로 할당되고, ​여러 함수에서 언급한 변수는 스코프에 제한이 없다할당된 메모리 크기가 크다.명령형 언어는 본뉴만 아키텍처를 흉내낸 것이다.본뉴만 아키텍처의 주요 구성요소는 메모리와 프로세서이다메모리는 데이터와 명령어를 저장하고, ​프로세서는 메모리 컨텐트를 수정하는 연산을 실행한다이에 대응되는 명령형 언어의 추상화는 변수와 산술식이다변수는 메모리셀에 대응하고, 산술식은 CPU 실행에 대응된다.컴퓨터에 실재로 존재하는 메모리(이것을 물리적 메모리 또는 메모리라고 한다)는 ​때때로 프로그래머의 프로그램을 한꺼번에 메모리에 모두 올려 놓지 않는다.그 이유는 다른 프로그램과 메모리를 나누어 쓰기도 하고, ​프로그램이 메모리 사이즈를 넘어가기도 하기 때문이다.프로그래머가 제한된 물리적 메모리 공간을 고려하면서 ​변수나 배열에 메모리 공간을 할당한다는 것은 매우 복잡하고 어렵다. ​따라서 프로그램을 전부 저장할 수 있는 가상 메모리를 프로그램에 할당하고, ​사용 가능한 메모리에 그만큼의 프로그램을 올렸다 내렸다 하면서 프로그램을 실행한다. ​이와 같이 프로그램을 올렸다 내렸다 하는 작업은 OS가 한다.​가상 메모리에서,  ​변수 i와 배열 a[100]은 메모리에 오렌지 색으로 할당된다. ​함수 foo에서 적용되는 변수 i, j는 연두색으로 할당된다. ​이중에서 적재 가능한 만큼의 프로그램을 메모리에 올려서, ​프로세서에서 실행하고, ​실행이 끝나면, 프로그램의 다음 부분을 올려서 실행하게 된다.이때 가상 메모리를 쓰면, ​전체적인 상대 주소가 변하지 않기 때문에 ​물리적 메모리에 적재할 때 ​프로그램의 주소 변환이 매우 간단해 지는 장점이 있다.​변수의 타입에 따라 할당되는 메모리 공간이 다르다. ​개략적으로 설명하면, ​스택은 프로시져에 대한 정보를 저장하는 공간으로, ​이들 프로시져에서 사용되는 파라미터, 변수 등의 속성 정보 등을 저장한다. ​스택은 중첩 프로시져(함수) 호출, 순환 프로시져(함수) 호출 등을 ​올바르게 처리하기 위한 목적으로 사용된다. ​힙은 malloc, free에 의해 명시적으로 메모리의 동적 할당 및 해제를 위한 메모리 풀(pool)이다.   ​Static에는 정적, 글로벌 변수가 저장된다.Code는 프로그램이 저장된다.  래퍼런싱 환경문장의 레퍼런싱 환경은 문장에 visible한(나타난) 모든 변수명의 집합이다. ​정적 스코프 규칙을 적용하는 언어에서, 레퍼런싱 환경은, ​로컬 변수와 그 안에 공간 구조적으로 포함된 서브 프로그램에 언급된(나타난) 변수를 합친 것이다. ​동적 스코프 규칙을 적용하는 언어에서, 레퍼런싱 환경은, ​로컬 변수와 그 안에서 호출되어 실행 중인(active) 서브 프로그램에 언급된(나타난) 변수를 합친 것이다. ​실행중인 서브 프로그램의 어떤 변수는 레퍼런싱 환경에서 hidden(숨겨질)일 수 있다. ​Hidden이란 active이지만, 나타나지 않는 것을 의미한다. ​이와 같은 hidden 변수는, ​동일한 이름의 변수가 여러 함수에서 선언된 상황에서,  ​앞에서 선언된 같은 이름의 변수가 여전히 active하지만 ​나중에 선언된 같은 이름의 변수가 나타날 때 발생한다.​실제로 동적 스코프는 현대 프로그래밍 언어에서 일반적이지 않고, ​C에서도 지원하지 않는다. ​따라서, 위 그림은 C이지만, ​동적 스코프를 지원한다고 가정하고 레퍼런싱 환경을 따져 보자. ​호출되는 순서는 main -&gt; sub2 -&gt; sub1이다. ​포인트1에서 나타날 수 있는 변수는 main의 d, sub2의 c, sub1의 a와 b, 이다. ​여기서 main의 c, sub2의 c는 hidden이다. ​포인트2에서 나타날 수 있는 변수는 main의 d, sub2의 b와 c이다. ​여기서 main의 c는 hidden 이다. ​포인트3에서 나타날 수 있는 변수는 main의 c와 d이다.  지정 상수이름 지정 상수는 상수인데, 변수명처럼 이름을 부여한 것을 말한다. 이렇게 하는 이유는 읽기 쉽고, 수정하기 쉽도록 하기 위한 것이다. ​스토리지에 바인딩될 때 값이 결정된다.",
        "url": "/pl-11"
    }
    ,
    
    "sc-06": {
        "title": "RSA",
            "author": "lee989898",
            "category": "",
            "content": "RSA  RSA  1978, MIT  가장 널리 사용 (공인인증서 등)  Key size = 1024 ~ 4096 bits  DES is 100 times faster in S/W and 10000 times faster in H/W  RSA Algorithm      키 생성 부분과 암/복호화 부분으로 구성    Part 1. 키생성          Public key : e, n      Private key: d      2개 큰 소수 p,q 선정 n = p * q , p , q는 secret, n은 공개      Public key e는 φ(n) = (p-1)(q-1)과 relative prime하게 선정(유클리드 algorithm), e는 공개      e * d mod φ(n) = 1 인 private key d를 계산(extended euclid algorithm) d는 secret            Part 2. 암호화/복호화    Encryption  Receiver의 public key (e,n)을 받는다  Message M을 정수로 전환하여      E(M) = $M^e$(mod n) = C를 계산    Decryption  D(c) = $C^d$ (mod n) = M (fermat, ouler)  RSA 안정성  해커는 공개키(E,N), 암호문 C를 쉽게 얻을 수 있음  비밀키 D를 얻으려면 N을 인수분해하여 φ(N)를 구해야함  큰 수에 대한 인수분해는 매무 많은 수행시간 요구 (현재 brute force외에 방법없음)  양자 컴퓨터",
        "url": "/sc-06"
    }
    ,
    
    "st-04": {
        "title": "File 조작",
            "author": "lee989898",
            "category": "",
            "content": "File 조작  File system structure ​  i-node          인덱스 노드의 준말      파일의 메타 데이터 저장되어있는 영역      하드디스크에 저장되어 있다      실제 내용                  file type​          access permission bits​          file size​          pointers to data blocks for the file                    Stat 구조체의 field들은 i-node에서 읽어온다        directory block          directory block에는 파일 목록이 있다​                  파일 이름          파일의 i-노드 번호​                      hard link​          디렉토리 블록에서 i-node로 링크      i-노드 번호를 사용하여 링크 만들기​      Hard link는 같은 file system 내부에서만 연결 가능​        i-노드의 링크 수          i-노드를 가리키는 디렉토리 항목 수      Stat 구조체의 st_link        Directory file의 data block 내용으로는  (i-node no, file name) entry 들이 기록된다.  Symbolic link​          Linux 명령 ‘% ln –s /usr/lib lib’​      ex) lrwxrwxrwx 1 root   7   Sep 25  07:14   lib -&gt; /usr/lib​                  파일 이름: lib​          파일 내용: /usr/lib​          파일 크기: 7 bytes​                    파일(데이터 블록)의 내용은 대상 링크의 경로 이름이다.        파일 삭제          디렉토리 블록에서 파일이 삭제되면 i-node의 링크 수가 감소한다      링크 수가 0이 되면 파일의 i-node와 데이터 블록이 모두 삭제된다        파일 이동          리눅스 명령어: mv​      파일의 i-node 및 데이터 블록을 변경하지 않고 디렉토리 항목 변경        link() / unlink()#include &lt;unistd.h&gt;int link(const char * cur_path, const cbar * new_path)  이 호출은 기존 파일(cur_path)에 대한 새 링크/디렉토리 항목(new_path)을 만든다          같은 i-node를 가리키는 directory entry가 하나 더 만들어짐​      해당 i-node의 link count가 하나 증가​        반환 값          성공: 0, 링크 수 증가      오류: -1        매개변수          cur_path: 현재 하드 링크(또는 pathname)      new_path: 새로운 하드 링크(또는 pathname)        보통 link count가 0이 되면 해당 파일은 삭제됨​  다른 프로세스가 사용중인 파일이 삭제되는 것을 방지하기 위해 link count가 0에 도달했더라도 그 파일을 open 한 프로세스의 수가 0 이상이면 삭제하지 않는다​  파일이 close 될 때 kernel은 그 파일을 open 한 프로세스 수가 0 인지 확인하고, 0 일 경우 link count가 0 인지 확인하고 삭제한다  remove()#include &lt;unistd.h&gt;int remove(const char *pathname);  remove()는 파일의 링크 수를 줄이기 때문에 unlink()와 유사하다  반환 값          성공 : 0      오류: -1        매개변수          Pathname: 디렉토리 파일의 경로명이 있는 문자열      pathname이 파일이면 remove() = unlink()      pathname이 디렉토리이면 remove() = rmdir()        rename()#include &lt;stdio.h&gt;int rename(const char *oldname, const char *newname);  파일 또는 디렉토리 이름 지정  반환 값          성공: 0      오류: -1        매개변수          oldname: 현재 하드 링크      newname: 새로운 하드 링크        umask()​#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;mode_t umask(mode_t newmask);  새 파일의 mask 값 설정  umask()는 이전 마스크 값을 반환한다  매개변수          newmask: bitwise OR                  S_IRUSR, S_IWUSR, S_IXUSR          S_IRGRP, S_IWGRP, S_IXGRP          S_IROTH, S_IWOTH, S_IXOTH                      umask : 파일 모드 작성 mask (8진수로 표시)​          (예) root user의 umask 값 : 0022​      일반 user의 mask 값 : 0002​      umask –S 커맨드를 사용하면 symbolic 값을 볼 수 있음​        파일의 실제 허가(protection) mode​          현재의 umask값에 NOT 연산을 수행한 값과 파일이 생성될 때의 모드 값을 AND (논리 연산)시킨 값 : AND(mode, NOT(umask))​        chmod() / fchmod()​#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;int chmod(const char *pathname, mode_t mode);int fchmod(int fd, mode_t mode);  이 호출은 파일의 액세스 권한을 변경하는 데 사용된다.          Stat 구조체의 st_mode 변경        반환 값          성공 : 0      오류: -1, 변수를 설정합니다.        매개변수          pathname: pathname이 있는 문자열      fd: 파일 디스크립터      mode: 파일 보호 모드        truncate() / ftruncate()​#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int truncate(const char *pathname, size_t length);int ftruncate(int fd, size_t length);  이러한 호출은 파일 디스크립터 또는 pathname에서 참조하는 파일을 길이로 지정된 길이로 자른다.  반환 값          성공: 0      오류: -1, 변수 설정        매개변수          pathname: pathname이 있는 문자열      fd: 파일 디스크립터      길이: 크기        utime()​#include &lt;sys/types.h&gt;​#include &lt;unistd.h&gt;​#include &lt;utime.h&gt;​int utime(const char *pathname, struct utimebuf *times);  utime()은 타임스탬프를 수정한다  반환 값          성공: 0      오류: -1 및 변수 ‘errno’ 설정        매개변수          pathname: 파일의 경로명      시간: 마지막 액세스 시간 및 수정 시간        struct utimebuf​{​  time_t    actime;        /* access time /​  time_t    modtime;       / modify time */​  };    각 필드는 1970-1-1 00:00 부터 현재까지의 경과 시간을 초로 환산한 값​  Directory​  디렉토리는 일종의 파일이다          디렉토리에는 소유자, 그룹 및 권한도 있다.      디렉토리에 대해 open, read, fstat, close를 사용할 수 있다      차이 creat() 및 open()을 사용하여 디렉토리를 생성할 수 없음 -&gt; 그렇게 하려면 mkdir() 필요            각 디렉토리 항목에는 i-노드 번호와 파일 이름이 있다.    #include &lt;dirent.h&gt; ​struct dirent {​ino_t d_ino;          /* i-node number */​char  d_name[ ];  /* filename */​}        mkdir()#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;int mkdir(const char *pathname, mode_t mode);  mkdir()은 디렉토리를 만드는 데 사용된다  매개변수          pathname: 새 디렉토리의 경로명      mode: 디렉토리 권한        반환 값          성공: 0      오류: -1        . 과 .. 을 새로 생성된 디렉토리에 넣는다  opendir() / readdir() / closedir() / rewinddir()#include &lt;sys/types.h&gt;​#include &lt;dirent.h&gt;​typedef struct dirent Dirent;​DIR *opendir(const char *pathname);​dirent *readdir(DIR *dir_fd);​int closedir(DIR *dir_fd);​void rewinddir (DIR *dir_fd);   DIR 구조체​          open된 디렉토리를 다루는데 사용되는 구조체​        opendir() 함수는 open()과 유사하다  opendir()은 디렉토리 파일을 읽기 전용으로 연다  opendir()은 열린 디렉토리의 파일 포인터를 반환한다  closedir()은 dir_fd가 가리키는 디렉토리 파일을 닫는다  readdir()          첫 번째 호출이 성공하면 디렉토리의 첫 번째 항목을 struct dirent에서 읽는다      그런 다음 자동으로 디렉토리 포인터가 다음 항목으로 이동한다        rewinddir()은 디렉토리 포인터를 디렉토리의 첫 번째 항목으로 이동한다  rmdir()#include &lt;unistd.h&gt;​int rmdir(const char *pathname);  디렉토리 파일 제거  성공하려면 디렉토리가 비어 있어야 합니다  반환 값          성공: 0      오류: -1        매개변수          경로명: 디렉토리의 경로명        chdir()#include &lt;unistd.h&gt;​​int chdir(const char *pathname);  디렉토리 변경  반환 값          성공: 0      오류: -1        매개변수          pathname: 디렉토리의 전체 또는 상대 경로 이름이 있는 문자열        getcwd()​#include &lt;unistd.h&gt;​char *getcwd(char *buf, size_t size);​  현재 작업 디렉토리의 경로 이름을 가져온다  매개변수          buf: 현재 디렉토리의 경로명을 저장할 버퍼      크기: buf의 크기        Symbolic link​  하드 링크의 한계          디렉토리에 대한 링크를 생성할 수 없다                  루트유저만 가능성                    다른 파일 시스템에 있는 파일에 대한 링크를 생성할 수 없다        하드링크의 한계 해결  파일에 대한 간접 포인터          실제 파일에 대한 경로를 저장하고 있다        파일을 다루는 함수를 사용할 때 심볼릭 링크를 자체를 다루는지 아니면 링크된 대상 파일을 다루는지​  심볼릭 링크 자체를 다루는 함수​          lchown, lstat, readlink, remove, rename, unlink 등​        링크된 대상 파일을 다루는 함수​          access, chdir, chmod, chown, creat, exec, link, mkdir, mkfifo, open, opendir, pathconf, stat, truncate 등​            symlink()      #include &lt;unistd.h&gt;​  int symlink(const char *realname, const char *symname);        반환 값          성공 : 0      오류: -1        매개변수          realname : 현재 파일의 경로명      symname : 심볼릭 링크의 경로명            readlink()      #include &lt;unistd.h&gt;​  int readlink(const char *pathname, char *buf, int bufsize);​        심볼릭 링크 파일의 내용을 읽는 함수​          symlink() 에서 저장된 actualpath 가 buf에 채워진다​      null 문자는 채워지지 않는다​        Return values​          Success : length of string read​      Error : -1​        심볼릭 링크를 open 으로 열면 링크된 대상 파일이 열린다​  sync() / fsync()​  버퍼에 있는 내용을 디스크에 쓰도록 한다  sync()는 시스템 데몬 프로세스에 의해서 30초마다 호출된다          I/O 작업이 끝나기 전에 리턴한다​        fsync()는 지정된 파일에 대해서만 I/O 작업을 수행하도록 한다          I/O 작업이 끝난 후 리턴한다​      ",
        "url": "/st-04"
    }
    ,
    
    "pl-10": {
        "title": "신택스 분석방법",
            "author": "lee989898",
            "category": "",
            "content": "신택스 분석 방법프로그램이 문법에 적합한지 확인하기 위한 신택스 분석 방법에대해 알아보자.​신택스 분석의 목표는 파스 트리(parse tree)를 생성하는 것이다.신택스 분석은 프로그램의 각 문장을 토큰으로 쪼개는 일부터 시작한다.이렇게 쪼개는 것을 렉시칼 어낼리시스라고 하고, ​이것을 수행하는 프로그램을 렉시칼 애널라이저 또는 스캐너라고 한다. ​이렇게 쪼갠 후에 문법적으로 타당한지 확인하는데, ​이것을 신택스 어낼리시스라고 하고, ​이와 같은 일을 수행하는 프로그램을 신택스 애널라이저 또는 파서라고 한다.다시 말하지만 렉시칼 어낼리시스와 신택스 어낼리시스의 궁극적인 목표는 파스 트리를 생성하는 것이다. ​파스 트리로부터 중간 코드가 생성되고, 최적화되어, 최종적으로 코드 생성이 이루어지기 때문에  ​파스 트리의 생성이 PL 구현 시스템에서 가장 중요한 부분이다. ​파스 트리의 생성은 문법에 의존한다.즉, 문법에 적합한 프로그램만 파스 트리로 생성된다. ​문법은 신택스와 시맨틱스를 표현한 규칙의 집합으로, 프로그램이 PL의 문법에 적합한지 판단하는 기준이 된다. ​문장 A=B(A+C)에 대해, 문법(규칙 집합)에 따라 Leftmost derivation을 하려면, ​문장 A=B(A+C)가 문법의 규칙 중에서 어느 규칙에 해당되고, ​이 문장을 구성하는 A, =, B, (, A, +, C, )가 어느 규칙의 어느 심볼에 해당되는지 알 수 있어야 한다.이것을 신택스 어낼리시스라고 한다.이를 위해 A=B*(A+C) 문장을 A, =, B, (, A, +, C, )로 잘라내고, ​이들이 각각 문법이 허용하는 문장 요소 중의 무엇을 나타내는지(연산자, 변수명, assignment 기호 등) 구별해야 하는데, ​이것을 렉시칼 어낼리시스라고 한다.잘라낸 A, =, B, (, A, +, ) 각각을 토큰이라고 한다.언어의 구현은 컴파일러, 인터프리터, 하이브리드 방식, 세가지 중의 하나이다. ​이들 모두 lexical analysis와 syntax analysis를 거친다.렉시칼 애널라이저는 스캐너라고도 하는데, 소스 프로그램을 인풋으로 받아 토큰으로 잘라낸다.신택스 애널라이저는 파서라고도 하는데, 토큰을 인풋으로 받아 문법에 따라 파스 트리를 만든다.​렉시칼 애널라이저는 신택스 애널라이저의 일부분으로 구현된다. ​이러한 이유로 모든 토큰을 한꺼번에 생성하지 않고 필요할 때마다 토큰을 생성하기도 한다.토큰 중에는 변수에 대한 변수명, 타입 등의 속성이 있는데, 이들은 심볼 테이블 안에 저장된다.이들 정보는 신택스 어낼리시스 동안에 lookup되기도 하고 새로운 속성이 매핑되기도 한다.  Lexical analysis렉시칼 애널라이저는 문장에서 각 단어를 추출하고 이들이 어느 범주(문장에서 허용되는 개념의 범주)에 해당되는지구별하는 것이다.추출된 단어에 대해 범주를 매핑시킨 것을 토큰이라고 한다. ​교과서에서는 일반적인 표현보다는 이들 요소를 구분하여 각각 lexeme, token이라고 하는데, ​일반적인 표현을 쓰면, 이들은 각각 word, category이며, 이들을 합친 것을 토큰이라고 한다. ​렉시칼 애널라이저는 이와 같은 토큰을 식별하는 패턴 매처로서, ​주어진 스트링에서, 주어진 패턴에 매치되는 서브스트링을 찾는다. ​이 설명은 매우 정확하지만 매우 까다로와서 렉시칼 애널라이저를 잘못 이해할 수도 있다.​소스 프로그램을 위와 같이 1차원 배열로 표현되어 있다고 치자. ​주어진 스트링에 해당한다. ​‘주어진 패턴’이란 identifier, reserved word 등에 해당되는 스트링을 의미한다. ​Identifier, reserved word 등은 오른쪽 아래의 상태 전이 다이어그램으로 정의된다. ​렉시칼 어낼리시스가 어떻게 진행되는지 설명하기 전에 ​먼저 상태 전이 다이어그램에 대해 알아 보자.렉시칼 애널라이저를 구현하려면, 상태 전이 다이어그램을 그리는 것부터 시작한다. ​​위의 그림은 상태전이 다이어그램을 나타내고 있다.상태전이 다이어그램은 directed graph로, ​노드는 상태를 나타내며 상태명으로 레이블이 붙어 있다.아크는 상태 전이를 나타내며, 인풋 문자로 레이블이 붙어 있다.아크의 레이블은 상태 전이를 발생시키는 인풋 문자로서, ​아크의 이전 상태에서 해당 인풋 글자가 들어오면 아크의 다음 상태로 전이한다는 의미이다.아크는 전이가 일어날 때 수행되어야 할 액션을 포함하기도 한다.그림에서 아크의 위에 있는 Letter, Digit 등은 상태 전이를 일으키는 문자를 나타내고, ​아래쪽의 addChar, getChar 등은 액션을 나타낸다.  ​상태 다이어그램을 단순화하기 위해, reserved word나 identifier을 별도로 인식하기보다 함께 인식할 수 있다.그림에서 두겹의 타원은 identifier와 integer를 인식하기 위한 상태이다. ​identifie가 변수명으로서의 identifier인지 reserved word인지 구별하기 위해 ​심볼 테이블 lookup을 통해 결정한다.상태 전이 다이어그램을 규칙으로 표현할 수도 있는데 이것을 regular grammar라고 한다.그렇다면 ‘주어진 패턴’이란 상태 전이 다이어그램으로 정의되는 것이다.​그러니까 렉시칼 애널라이저는 input file을 하나의 긴 스트링으로 간주하고, ​한글자씩 읽어 들여 상태 전이 다이어그램을 따라 가면서, ​reserved word, identifier 등의 토큰을 긴 스트링 중의 서브 스트링으로서 인식하는 것이다.위 그리에서 Input file을 읽어 들여 코멘트를 무시하고, 렉시칼 어낼리시스를 하면, ​오른쪽의 토큰들을 얻게 된다.정리하면, 주어진 스트링에서, 주어진 패턴에 매치되는 서브스트링을 찾는 역할을 하는 것이 ​바로 상태 전이 다이어그램이고, ​이것을 프로그래밍하면 렉시칼 애널라이저가 된다.​A=B*(A+C)와 같은 간단한 산술식에서 토큰을 추출하는 렉시칼 애널라이저를 구현하기 위해, ​먼저 상태 전이 다이어그램을 그리면 위 그림과 같다. ​unknown은 identifier와 integer 이외의 것을 인식하는데, ​이들은 주로 산술식을 구성하는 연산자나 괄호 등에 해당된다.​이들은 하나의 문자로 구성되어 있기 때문에 싱글 캐릭터 토큰이라고 하는데, ​이들이 산술식의 연산자나 괄호인지 아닌지 결정하기 위해 심볼 테이블을 lookup한다.아크 아래의 액션을 나타내는 함수의 역할에 대해 알아 보자.getChar는 인풋 스트링에서 다음 글자를 가져와서 변수 nextChar에 넣고 ​그 유형을 판단해서 변수 charClass에 그 유형을 넣는다. ​addChar는 nextChar의 글자를 배열 lexeme에 넣는다. ​Lookup은 배열 lexeme에 있는 스트링이 reserved word인지 아닌지 결정한다.  Syntax Analysis우선 신택스 어낼리시스 즉, 파싱이 뭔지, 파서가 뭘하는지 알아보자.파서는 주어진 프로그램에 대해 파스 트리를 생성한다. ​파스 트리는 명시적으로 생성되기도 하지만 ​트리 순회(traversal) 흔적이 생성되기도 한다.(이러한 트리 순회 흔적을 유래(파생, derivation)이라고 합니다.) ​파스 트리와 유래 모두 컴파일러나 인터프리터가 필요로 하는 모든 신택스(구문 구조적) 정보를 포함한다. ​신택스 어낼리시스의 목표는 인풋 프로그램이 문법적으로 올바른지 검사하고, ​문법적으로 올바른 인풋에 대한 파스 트리를 생성한다. ​도중에 오류가 발견되면 오류 진단 메시지를 생성하고, ​인풋 프로그램의 신택스 어낼리시스를 계속한다. ​물론 신택스 어낼리시스 도중에 오류가 발생하면, ​신택스 어낼리시스만 계속하면서 문법적으로 잘못된 부분을 식별할 뿐이지, ​파스 트리를 생성하지는 않는다.파싱 방법은 하향식(탑다운)과 상향식(바텀업) 방식이 있다. ​  Top -down parsing탑다운 파싱은 start 심볼에서 시작하여, 인풋 스트링을 derivation에 어느 BNF 규칙을 적용하는 게 좋을지 따져 보고 ​규칙을 선택하여 derivation한다.이러한 derivation을 트리로 간주하면, 위에서 아래로 내려오면서 ​반복적으로 규칙을 선택하고 적용하여 ​궁극적으로 인풋 스트링(프로그램)이 생성될 때까지 계속한다. ​그래서 이것을 recursive-descent parser(반복적 하강식 파서)라고 한다. ​이와 같은 방식의 파싱 알고리즘을 LL 알고리즘이라고 하는데, ​인풋을 왼쪽에서 오른쪽으로 스캔하고, ​Leftmost derivation을 생성한다. ​Leftmost derivation이란 sentential form(문형식)의 가장 왼쪽에 있는 난터미날에 대해, ​그 난터미날을 LHS로 갖고 있는 규칙을 선정하여, ​그 규칙의 RHS로 바꾸는 것을 의미한다. ​LL의 앞에 있는 L은 ‘왼쪽에서 오른쪽으로’를 나타내고,  ​뒤의 L은 ‘leftmost derivation’을 나타낸다.탑다운 파서의 파싱 결정 문제 ​Preorder에 의해 파스 트리를 생성한다.Preorder 순회는 root, left, right 순서로 트리를 방문한다.​좌선 유도 중인 문형식이 주어졌을 때, 파서는 ​주어진 문형식에서 가장 왼쪽의 난터미날 심볼에 대해, ​그 난터미날 심볼을 LHS로 갖고 있는 규칙을 찾아서, ​그 규칙의 오른쪽 부분으로 문형식의 난 터미날 심볼을 교체한다.(이것을 expand라고 함)이렇게 하여, 좌선 유도에 의한 다음 문형식을 생성한다.​문형식에서 xAa에서, x는 터미날 심볼로 구성된 스트링을, ​A는 난터미날 심볼을, a는 터미날과 난터미날 심볼의 혼합 스트링을 나타낸다.Expand할 때는 적용할 규칙을 선택하여 ​주어진 스트링의 난터미날 심볼을 규칙의 오른쪽으로 교체하여 확장한다.​예를 들어 보자. ​현재 문형식이 xAa이고, ​A에 적용 가능한 규칙이 A→bB | cBb | a 라고 하면, ​탑다운 파서는 어느 규칙을 선택하느냐에 따라, ​다음 문형식으로 xbBa, xcBba, or xaa 중의 하나를 생성한다.이것이 바로 탑다운 파서의 파싱 결정 문제이며, ​백트래킹 비용을 수반한다.  Bottom-up parsing바텀업 파싱은 인풋 스트링을 스캐닝하면서, ​규칙의 RHS에 해당되는 스트링이 발견되면, ​이 스트링을 발견된 규칙의 왼쪽 스트링으로 바꾼다. ​이러한 과정을 반복해서 인풋 스트링이 ​궁극적으로 starting 심볼로 바뀌면 파싱이 끝나는 것이다. ​이렇게 하려면 탑다운 방식과 달리 스택이라는 자료 구조를 필요로 하는데, ​스택에 넣고 빼고 하는 과정을 포함하기 때문에 이것을 shift-reduce 파서라고 한다. ​Shift는 스택에 심볼을 넣는 것, reduce는 스택의 서브 스트링을 규칙의 LHS로 바꾸는 것을 말한다. ​  ​이러한 알고리즘을 LR 알고리즘이라고 하는데, ​L은 왼쪽에서 오른쪽으로 인풋을 스캐닝하고, ​R은 rightmost derivation을 생성한다는 것을 나타낸다.바텀업 파싱의 기본 아이디어는 ​주어진 스트링을 처리할 때, 규칙의 RHS에 해당되는 서브 스트링을 찾아서, ​그 서브스트링을 규칙의 LHS로 교체하는 과정을,  ​주어진 스트링이 start 심볼이 될 때까지 반복하는 것이다. ​바텀업 파싱의 기술적인 이슈는 ​어느 규칙을 적용해서 어느 서브스트링을 교체할 것인지, ​미리 따져보는 것이다.쉬프트-리듀스 파싱은 바텀업 파싱의 일종이다.​예를 보면서, 바텀업 파싱을 알아 보자.문법과 인풋 스트링이 이와 같을 때, ​인풋 스트링의 왼쪽에서부터 시작해서, ​서브스트링에 적용할 수 있는 규칙을 찾아 본다.RHS에 b가 있는 규칙 A → b를 적용할 수 있다. ​빨간색 b에 A-&gt;b를 적용하면,  ​빨간색 b가 규칙 A-&gt;b의 LHS인 A로 교체되어 ​aAbcde가 된다.다음, 빨간색 Abc가 A-&gt;Abc에 의해 A로 교체되어 ​aAde가 되고, ​빨간색 d가 B-&gt;d에 의해, A로 교체되어 ​aABe가 된다.빨간색 aABe가 S-&gt;aABe에 의해 start 심볼 S로 교체되어 ​파싱이 종료된다.위의 그림을 잘 살펴보면, reduce의 의미와 derivarion의 의미가 반대임을 알 수 있다.      바텀업 파싱은 규칙이 허용하는 바에 따라 인풋 스트링의 서브스트링을 ​LHS의 난터미날 심볼로 교체한다. ​이러한 교체는 인풋 스트링이 S로 교체될 때까지 계속된다. ​여기서 교체되는 서브스트링은 ​처음에는 터미날 심볼로 구성되지만, ​점차 터미날 심볼로 구성된 서브스트링이 난터미날로 교체되면서, ​터미날 심볼과 난터미날 심볼로 구성된다.  ​LHS로 교체하는 과정을 보면, ​인풋 스트링의 길이가 점점 줄어들고 있음(즉, reduce되고 있음)을 볼 수 있다.  ​        탑다운 파싱과 비교를 해 보면, ​탑다운 파싱은 S에서 인풋 스트링이 생성될 때까지 규칙을 적용해서 ​가장 왼쪽의(leftmost) 난터미날 심볼을 RHS로 expand한다. ​이것을 좌선 유도(leftmost derivation)이라고 하는데… ​위의 파싱 과정을 거꾸로 살펴 보면, ​가장 오른쪽의 난터미날이 먼저 RHS로 expand됨을 볼 수 있다. ​즉, 우선 유도(rightmost derivation)가 되고 있는 것이다. ​        따라서, 탑다운과 바텀업 파싱의 과정을 보면 서로 반대임을 알 수 있다. ​즉, 바텀업 파싱은 탑다운 우선 유도의 역순과 같다.   ​  바텀업 파싱에서는 어느 서브 스트링에 어떤 규칙을 적용하느냐가 중요하다.앞의 예에서 abbcde(b에 A-&gt;b를 적용) =&gt; aAbcde(d에 B-&gt;d를 적용) =&gt; aAbcBe이 생성되면, ​이후 어떠한 규칙을 적용해도 S로 리듀스되지 않는다.규칙의 LHS로 교체할 수 있는 ‘인풋 스트링 S의 서브스트링 a’를 핸들이라고 한다. ​a가 A → a의 RHS에 매치되면, ​a를 A(규칙의 LHS)로 교체한다.이때 이러한 교체 과정은 탑다운 방식의 우선 유도(rightmost derivation)의 역순으로 나타난다.   ​쉬프트-리듀스 파싱에서 리듀스 연산은 핸들에만 적용 가능하다.쉬프트-리듀스 파싱의 구현 방법에 대해 알아 보자.바텀업 파싱은 쉬프트와 리듀스라는 두개의 액션으로 설명되기 때문에, ​쉬프트-리듀스 파싱으로 불리며, ​이를 위한 자료구조로 스택을 사용한다.  ​​쉬프트 액션은 다음 인풋 토큰을 스택의 꼭대기에 옮겨 넣는 것을 의미하며, ​리듀스 액션은 스택의 꼭대기에 있는 핸들(규칙의 RHS)를 규칙의 LHS로 교체하는 것을 의미한다. ​이 과정을 start 심볼로 리듀스 될 때까지 반복한다.쉬프트할 때 스택을 사용하면, ​현재 처리 중인 스트링에서 리듀스 가능한 서브스트링(핸들)을 찾기 쉬운 경향이 있다.​위 그림은 쉬프트-리듀스의 예이다.쉬프트와 리듀스 둘다 가능할 때, 쉬프트-리듀스 컨플릭트가 발생한다. ​스택에 핸들 if E then S가 있을 때, 문법에 의하면 쉬프트, 리듀스 모두 가능하다. ​그러나, 이것은 그 다음에 나오는 심볼이 무엇이냐에 달려 있다. ​다음에 else가 나온다면 리듀스하면 안되고 쉬프트해야 한다.  ​반대로 else가 나오지 않는다면 리듀스해도 된다.  ​리듀스에 적용할 규칙이 여럿일 때, 리듀스-리듀스 컨플릭트 발생한다.스택에 핸들 id(arg)가 있을 때, Stmt로 리듀스할지, Expr로 리듀스할지?  ​이것 역시 다음에 나오는 심볼에 달려 있다.앞에 언급한 문제를 해결하려면, ​인풋 스트링에서 현재 심볼의 다음에 오는 k개의 심볼을 먼저 본다면 ​현재 어느 규칙을 써서 무엇을 할지 쉽게 결정할 수 있을 것이다이것을 LR(k) 파서라고 하고, 여기서 k는 lookahead라고 한다.​장점은 일반적인 방법이면서 많은 유형의 문법을 다룰 수 있고, 효율적이라는 것이다단점은 구현하기 어렵다는 것이다.컴파일러가 각 단게별로 소모하는 처리 비용을 시간의 비율로 나타내면 다음과 같다. ​  ~ 35-40% of time spent in I/O​  ~ 30% in lexical analysis​  ~ 10% in symbol table management​  ~ 7-15% in parsing and other control​가장 많은 비용을 소모하는 것이 바로 IO이다렉시칼 애널라이저가 그 만큼의 시간을 소모하고, ​정착 알고리듬 측면에서 가장 복잡한 파싱이 비용소모가 적다. ​",
        "url": "/pl-10"
    }
    ,
    
    "pl-09": {
        "title": "정적 시맨틱과 동적 시맨틱",
            "author": "lee989898",
            "category": "",
            "content": "정적 시맨틱과 동적 시맨틱시맨틱에는 정적 시맨틱과 동적 시맨틱이 있다.정적인 시맨틱은 컴파일 시에 확인할 수 있는 시맨틱 규칙을 말한다.이들 시맨틱 규칙은 ​타입 검사, 프로그램에서 변수가 언급되기 전에 이에 대한 정의가 되어 있는지, ​서브 프로그램에서 어느 선언 이 어느 변수에 적용되어야 하는지, ​서브 프로그램과 메소드가 호출될 때 호출 순서를 올바르게 지키는지 등을 포함한다.  ​동적 시맨틱스는 프로그램이 실행될 때 ​프로그램 컨스트럭트가 언제 어떤 행태(계산 결과)를 생성해야 하는지 정의하는 것이다.  BNF로 시맨틱을 표현할 수 있을까?타입 호환성 규칙은 BNF로 서술할 수 있지만, ​새로운 난터미널 심볼과 규칙을 추가로 요구하기 때문에, ​문법이 너무 커지고 신택스 애널라이저(구문 해석기)가 비대해져 유용하지 않다. ​프로그래밍 언어에 공통적으로 적용되고 있는 ​‘모든 변수는 언급되기(reference) 이전에 선언(정의)되어야 한다’는 규칙은 BNF로 서술이 불가하다. ​이러한 종류의 규칙을 정적인(static) 시맨틱스라고 부른다.정적인 시맨틱스는 프로그램 실행시 프로그램의 의미에 간접적으로 관련이 있을 뿐이고, 오히려, 프로그램의 올바른 형태(신택 스)와 직접 관련이 있다. ​따라서, 정적인 시맨틱스의 검사는 컴파일 시에 가능하다.이 말은 정적인 시맨틱스는 컴파일러의 구현시 고려되어야 한다는 의미이다. ​그러면 정적인 시맨틱스를 어떻게 서술할 수 있을까? ​바로 속성 문법(attribute grammar)으로 서술한다. ​속성 문법은, ‘프로그래밍 언어가 만족해야 할’ 정적인 시맨틱 규칙을 서술하고 검사하기 위해 사용되는 ​BNF와 유사한 형태의 문법이다.  속성 문법이 단순한 assignment 문장의 타입 검사에 어떻게 사용 될까?이 assignment 문장의 신택스와 정적 시맨틱스는 다음과 같다. ​  변수명은 A, B, C 뿐이다.​  Assignment의 우변은 변수거나 ‘변수 + 변수’의 표현식이다. ​  변수의 타입은 int거나 real이다.​  우변에 변수 2개가 있을 때, 이들의 타입은 같을 필요가 없다. ​  두 오퍼랜드가 같은 타입이 아닐 때 표현식의 타입은 real이다.(여기서 표현식의 타입이란 표현식을 계산한 결과값의 타입을 말한다.) ​  이들의 타입이 같을 때, 표현식의 타입은 오퍼랜드의 타입과 같다. ​  좌변의 타입은 우변의 타입과 같아야 한다. ​  그래서, 우변의 오퍼랜드의 타입이 mix될 수 있으나, 우변의 계산 결과값과 좌변의 타겟이 같을 때만 assignment는 타당하다.  ​속성 문법은 위와 같은 정적 시맨틱 규칙을 명세한다.​간단한 assignment를 속성문법으로 서술하면 위 그림과 같다. ​속성 문법에는 신택스 규칙과 함께 데이터 타입에 관한 시맨틱 규칙, 그리고 판단식이 서술되어 있다.룩업 함수는 심볼 테이블에서 변수명을 찾아서 변수의 타입을 반환한다.심볼 테이블은 컴파일러가 구문 분석 단계에서 ​변수에 대한 이름, 타입 등을 저장하기 위해 생성한 ​테이블 구조를 말한다. ​실제 타입은 var, expr의 실제 타입을 말한다.실제 타입은 선언되어 있거나 변수명으로부터 유추 가능하다.예를 들어, Perl에서 $, @, %는 ​각각 스칼라(스티링, 숫자), 벡터(배열), 해쉬 구조를 나타낸다.이로부터 변수의 타입을 유추할 수 있다. ​예상 타입은 expr와 관련된 속성으로부터 상속된 타입으로 ​좌변의 변수의 실제 타입에 의해 결정된다.​왼쪽 그림은 속성의 흐름, ​즉 속성이 파스 트리를 따라 상속(pass up, pass down)되는 흐름을 나타내고 있고, ​오른쪽 그림은 속성 문법에 의한 ​attributed parse tree(속성이 부여된 파스 트리)를 보여준다.  ​이와 같이 부여된 속성에 근거하여, 컴파일러는 타입 검사를 할 수 있다.동적 시맨틱스를 서술하는 방법은 여러 가지가 있으나, operational semantics에 대해 살펴 보기로 한다. ​Operational semantics는 연산의 의미에 의해 표현식, 문장, 단위 프로그램의 의미를 서술하는 방식이다. ​시맨틱스 서술의 중요성을 각 사용자별로 따져 보면 다음과 같다.  ​  프로그래머는 원하는 프로그램을 짜기 위해 프로그래밍 언어의 각 문장이 무엇을 하는지 알 필요가 있다. ​  컴파일러 개발자는 프로그래밍 언어에서 각 컨스트럭트의 의미를 정확히 알아야 한다. ​  프로그래밍 언어 설계자는 설계 상의 모호성과 불일치를 발견할 수 있다.Operational semantics는 문장이나 단위 프로그램을 컴퓨터에서 실행한 효과를 명세하여, ​문장이나 프로그램의 의미를 서술한다. ​Operational semantics는 머신 상태의 일련의 변화로 볼 수 있다.여기서 머신의 상태란 프로그램 수행에 따라 변화하는 각 변수 값의 콜렉션(집합)이다.​위의 그림과 같이, operational semantics는 ​문장에 대한 의미를 intermediate code처럼 정해진 방식으로 서술한 것으로 볼 수 있다.Intermediate 언어는 가상 머신에서 실행되는 언어 또는 어셈블리 언어를 말한다.Operational semantics 서술을 위해 intermediate 언어와 가상 머신을 사용하기도 한다. ​​",
        "url": "/pl-09"
    }
    ,
    
    "sc-05": {
        "title": "Number Theory for RSA",
            "author": "lee989898",
            "category": "",
            "content": "Number Theory for RSA–  Introduction  number theory = 정수론  a branch of pure mathematics devoted primarily to the study of the integers  숫자의 성질을 탐구  수학은 과학의 여왕, 정수론은 수학의 여왕(여기서는 양의 정수만 다룬다)  약수  어던 수 m에 대해서 a = mb 라면          b $\\neq$ 0 일때 b는 a를 나눈다 =&gt; 약수      여기서 a,b,m은 정수      나눗셈에서 나머지가 없을 때 약수라고 함        예) 24의 양의 약수          1,2,3,4,6,8,12,24        소수 (Prime numbers)  어떤 수 p의 약수가 $\\pm$ 1과 $\\pm$ p만을 가진다면 p는 소수이다.  1과 자신이외의 자연수로 나눌수 없는 1보다 큰 자연수  고대 이집트 파피루스에도 기록  소수 찾기  어떤 자연수 n이 소수인지는 root(n)까지의 수 중 1을 제외한 약수가 있는지 확인소수의 분포에 규칙성이 있을까? (리만의 가설)  소인수 분해  어떠한 정수 a&gt;1은 다음과 같이 유일하게 소수의 곱으로 표현가능          a = $p_1^{a1}$ $p_2^{a2}$ … $p_t^{at}$      $p_t$ &gt; $p_{t-1}$ &gt; … $p_1$ 는 소수, $a_1$ &gt; 0      예) 91 = 7x13, 3600 = $2^4$ x $3^2$ x $5^2$ , 10164 = 7 x $11^2$ x 12      하지만, 여기서 7 x $11^2$ x 12 -&gt; 10164는 쉽지만 역은 어렵다        서로소 (relatively prime number)  어떤 두 수가 공통적인 소인수를 갖지 못할 때 두 수는 서로소  두 수의 최대 공약수가 1이면 서로소  8과 15는 서로소인가? 서로소이다  모든 정수의 솟수 표현법을 이용하면 최대 공약수 결정이 쉬워짐          300 = $2^2$ x $3^1$ x $5^2$, 18 = $2^1$ x $3^2$      GCD(300,18) = $2^1$ x $3^1$ x $5^0$ = 6        모듈러 연산 (mod)  나머지 연산  a mod b: a를 b로 나눈 나머지  어떤 양의 정수 n과 a가 주어지고, 만약 a를 n으로 나눈다면 다음과 같은 관계를 가지고 몫 q와 나머지 r을 얻는다          a = qn + r      a = r mod n        example: a =11, n = 7          11 = 1 x 7 + 4 = 4 mod 7      11 = 4 mod 7        모듈러 연산자 특성          [(a mod n) + (b mod n)] mod n = (a+b) mod n      [(a mod n) x (b mod n)] mod n = (axb) mod n      (w + x) mod n = (x+w) mod n (교환법칙)      (w * x) mod n = (x * w) mod n (교환법칙)      [ (w+x)+y ] mod n = [ w + (x+y) ] mod n (결합법칙)      [ (w * x) * y ] mod n = [ w * (x * y) ] mod n (결합법칙)      [ w *  (x + y) ] mod n = [( w * x) + (w * y)] mod n (분배법칙)      (0 + w) mod n = w mod n      (1 * w) mod n = w mod n        모듈러 연산의 항등원과 역원          항등원                  어떤 원소와 연산을 해도 자기 자신이 되게 하는 원소          항등원을 만들어 주는 유일한 원소가 역원          모듈러 연산의 역원은?          mod 5 연산, 3의 곱셉의 역원은?                          (3 * ?) mod 5 = 1 ?는 mod 5 연산에 대한 3의 곱셉의  역원                                            합동 (Congruent)  (a mod n) = (b mod n), e두 정수 a와 b는 modulo n에 대해 합동  a $\\equiv$ b mod n으로 표기  예를 들어, 14와 20은 mod 6에 대하여 합동  페르마 정리 (Fermat Theorem)  만약 p가 소수라면 a는 p에 의해 나누어지지 않는 양의 정수이면, 다음이 성립한다          $a^{p-1}$ $\\equiv$ 1 mod p        페르마 정리의 다른 유용한 형태          만약 p가 소수이고 a가 양의 정수라면 $a^p$ $\\equiv$ a mod p가 성립한다        오일러 정리 (Euler Theorem)  오일러의 Totient 함수          정수론에서 오일러의 totient 함수는 φ(n)라고 표기된다      φ(n): n보다 작고 n과 서로 소인 양의 정수의 개수        오일러 함수의 특성          φ(1) = 1      소수n에 대해서 φ(n) = n - 1      소수 p와 q에 대해서 n = pq                  φ(n) = φ(pq) = φ(p) * φ(q) = (p-1)(q-1)                      오일러 정리          서로소인 모든 a와 n에 대한 관계를 나타낸다ㅏ                  $a^{φ(n)}$ $\\equiv$ 1 mod n                      오일러 정리의 추가적인 특성          $a^{φ(n)+1}$ $\\equiv$ a mod n        이러한 속성은 RSA 알고리즘의 유용성을 증명할 수 있음  확장된 유클리드 알고리즘  유클리드 알고리즘          두 양의 정수들에 대한 최대 공약수 찾기        확장된 유클리드 알고리즘          한 수에 대한 곱셈의 역원 결정      만약 GCD(d,f)=1이라면 그때 d는 modulo f 상에서 곱셉에 대한 역원을 갖는다      양의 정수 d &lt; f에 대해, d $d^{-1}$ = 1 mod f인 $d^{-1}$ &lt; f가 유일하게 존재      알고리즘은 $d^{-1}$를 찾아주는 것이다      ",
        "url": "/sc-05"
    }
    ,
    
    "sc-04": {
        "title": "Public Key Cipher",
            "author": "lee989898",
            "category": "",
            "content": "Public Key Cipher  Symmetric vs public key  Encryption key와 decryption key 동일 여부  같으면 symmetric, 다르면 public key  Why no Symmetric key?  Symmetric은 빠르고, 안전하다  동일한 키를 나눠 갖기 어렵다  인터넷에서 키를 나눠 갖기 어렵다  Public key Cipher  송신자, 수신자가 키를 나누어 가지 필요가 없다  private,public키 2가지를 나눠 갖는다  Public key로 잠그면 private key로 열고, private key로 잠그면 public key로 열린다  Internet환경에서 대표적으로 사용  RSA(99%), ECC, El Gammal  주로 수학적 이론에 바탕 -&gt; 정수론 필요",
        "url": "/sc-04"
    }
    ,
    
    "algorithm-03": {
        "title": "분할 정복",
            "author": "lee989898",
            "category": "",
            "content": "분할 정복  분할 정복 설계 전략  분할 단계          문제를 같은 유형의 여러 개의 더 작은 부분 문제들로 나눈다.      부분 문제는 풀기 쉬울 때까지 계속 나눈다.        정복 단계          부분 문제들을 보통 재귀적으로 해결하여 해를 구한다.        합병 단계          문제에 대한 해를 구하기 위해 부분 문제들의 해를 합친다.      최댓값과 최솟값 찾기  문제: 크기가 n인 배열내의 요소들 중 최댓값과 최솟값을 찾는다.  쉬운 전략          최댓값을 찾는다      남은 배열 요소들의 최솟값을 찾는다      총 비교 횟수 = 2n - 3  분할 정복 전략          배열을 반으로 나눈다.      양쪽 절반들의 최댓값과 최솟값을 찾는다.      2에서 찾은 두개의 최댓값들과 두 개의최솟값들을 비교하여 전체 배열의 최댓값과 최솟값을 구한다.        의사코드findMaxMin(A[],i,j,min,max)// A[i..j]의 최댓값과 최솟값을 찾는다// 입력: 배열 A[i..j]// 출력: min(최솟값), max(최댓값)1. if(i == j) { min = A[i]; max = A[j]}2. else if(i = j - 1){3. if(A[i] &lt; A[j]){   min = A[i]; max = A[j]}4. else{ min = A[j]; max = A[i])} }5. else{6. mid = (i+j)/27. findMaxMin(A,i,mid,min1,max1)8. findMaxMin(A,mid+1,j,min2,max2)9. if(min1 &lt; min2) min = min110.else min = min211.if(max1 &lt; max2) max = max212.else max = max1최초 호출: findMaxMin(A,0,n-1,min,max)​위 그림은 실행 트리이다.합병 정렬  쉬운 전략          최솟값을 찾는다.      남은 요소들을 같은 방법을 사용하여 재귀적으로 정렬한다.      총 비교횟수 $\\theta$(n2)  분할 정복 전략          배열을 반으로 나눈다.      왼쪽 반과 오른쪽 반을 각각 정렬한다.      정렬된 왼쪽 반과 오른쪽 반을 합병한다..      ​위 그림은 합병 정렬의 진행 과정이다.  합병 정렬 알고리즘알고리즘 mergeSort(A[], low, high)// 배열 A[low .. high]를 합병 정렬을 이용하여 정렬한다.if(low &lt; high){    mid = (low+high)/2    mergeSort(A,low,mid)    mergeSort(A,mid+1,high)    merge(A,low,mid,high)}최초 호출: mergeSort(A,0,n-1)  Merge 메소드//정렬된 부분 배열 A[low .. mid]와 A[mid+1 .. high]를 합병한다.MERGE(A[],low,mid,high){크기가 (high + 1)인 배열 B를 만든다   h = low; i = low; j = mid + 1   while(i &lt;= mid &amp;&amp; j &lt;=high){     if(A[i] &lt;= A[j] { B[h] = A[i]; i = i + 1}     else{B[h] = A[j]; j = j + 1}     h = h + 1    }   if( i &gt; mid)     for(k = j; k &lt;= high; k++) { B[h] = A[k]; h = h + 1}     else     for(k = i; k &lt;= mid; k++) {B[h] = A[k]; h = h + 1}     for(k = low; k &lt;= high; k++) A[k] = B[k]; }시간 복잡도 $\\theta$(n $log n$)  비재귀 합병 정렬 알고리즘mergeSort2(A[], n)//배열 A[0 .. n-1]를 비재귀 합병 정렬을 이용하여 정렬size = 1while(size &lt; n){  for(i = 0; i &lt; n; i = i + 2*size)  Merge(A,i,i+size-1,i+2*size-1)  size = size * 2}합병 정렬의 단점  합병 정렬의 공간 복잡도: $\\theta$(n)  입력을 위한 메모리 공간 외에 추가로 입력과 같은 크기의 공간이 별도로 필요  2개의 정렬된 부분을 하나로 합병하기 위해 합병된 결과를 저장할 공간이 필요하기 때문이다빠른 정렬절대적으로 가장 빠른 정렬 알고리즘은 아니지만 평균적으로 매우 효율적이다평균 시간복잡도: $\\theta$(n $log n$)최악 시간복잡도: $\\theta$(n2)  기본 아이디어  배열을 두 부분으로 분할한다.          배열내의 한 기준 요소보다 작거나 같은 요소들은 앞부분에 놓는다.      기준 요소보다 큰 요소들은 모두 뒷부분에 놓는다.        각 분할된 부분을 재귀적으로 정렬한다.​위 그림은 빠른 정렬의 진행과정이다.  빠른 정렬 알고리즘quickSort(A[], low, high)// 배열: A[low .. high]를 빠른 정렬을 이용하여 정렬한다.// 입력: 정렬할 수 있는 요소들의 배열 A[low .. high]// 출력: 오름차순으로 정렬된 요소돌의 배열 A[low .. high]if(low &lt; high){    s = partition(A,low,high) // 기준 요소 A[low]를 기준으로 분할    quickSort(A,low,s-1)    quickSort(A,s+1,high)}//최초 호출: quickSort(A,0,n-1)  분할 알고리즘partition(A[], low, high)//입력: 배열 A[0 .. n-1]의 부분 배열 A[low .. high], low &lt; high//출력: A[low .. high]의 분할 후 기준 요소의 최종 위치(지수)를 반환i = low + 1j = highwhile( i &lt;= j){    if(A[i] &lt;= A[low]) i = i + 1    else if( A[j] &gt; A[low]) j = j -1    else { A[i] &lt;-&gt; A[j]        i = i + 1        j = j - 1            }}A[low] &lt;-&gt; A[j]return j분할 정복이 부적절한 경우문제가 분할될 때만다 분할된 부분 문제들의 입력 크기의 합이 분할되기 전의 입력크기보다 매우 커지는 경우",
        "url": "/algorithm-03"
    }
    ,
    
    "pl-08": {
        "title": "프로그래밍 언어의 신택스와 시맨틱스",
            "author": "lee989898",
            "category": "",
            "content": "프로그래밍 언어의 신택스와 시맨틱스프로그래밍 언어의 신택스는 산술식, 문, 프로그램 단위의 형태를 말한다.문은 statement 또는 sentence를 말한다.   ​프로그램 단위는 컨스트럭트(컨트롤 스트럭처)를 말하는데, ​앞으로 명확한 설명을 위해 프로그램 단위라는 추상적인 말을 쓰지 않고, ​가급적 컨스트럭스 또는 컨트롤 스트럭처라는 말을 쓰겠다. ​시맨틱스는 신택스에 맞게 작성된 표현식, 문, 컨스트럭트의 의미를 말합니다. ​자바 while 문에 대해, ​신택스는 while (Boolean_expr) statement 의 형태를 띄어야 하고, ​그 시맨틱스는 부울 표현식이 참일 때, statement를 실행하고, ​컨트롤은 부울 표현식으로 되돌아가서 이 프로세스를 반복하는데, ​부울 표현식이 거짓이면 ​while 컨스트럭트의 실행이 끝난다는 의미이다.​시맨틱스의 서술 방법은 여러 가지가 있지만, ​컴퓨터에서 실행되는 ‘연산의 의미’로 시맨틱스를 서술하는 것을 ​operational semantics라고 하는데, ​위에 서술된 while문의 시맨틱스는 operational semantics의 예이다.​잘 설계된 프로그래밍 언어에서, 시맨틱스는 신택스를 따릅니다. ​이것은 위에 설명된 자바 while 문의 신택스와 시맨틱스의 예를 보면 직관적으로 알 수 있다.그럼 신택스를 어떻게 서술하는지 살펴 보자.신택스 서술 방법으로 BNF가 널리 사용되고 있다.BNF를 메타 언어라고 하는데, 메타 언어란 언어를 서술하는데 사용되는 언어라는 뜻이다.즉, BNF는 프로그래밍 언어의 신택스를 서술하는데 사용되는 메타 언어이다.BNF는 신택스 구조를 위한 추상적 개념을 사용하는 규칙 언어이다.규칙은 화살표 왼편(LHS)과 오른편(RHS)으로 나누어지는데, ​문을 생성하면서, 왼편이 오른편으로 대체된다.BNF가 사용하는 추상적 개념들에는 무엇이 있는지 ​자바의 예를 보면서 알아 보자​자바의 assign과 if 문은 다음과 같이 서술된다.​assign, var, expression, 화살표(-&gt;), =(이퀄 사인)​if_stmt, logic_expr, stmt, if, (괄호), |(세로줄, or의 뜻) 등을 볼 수 있다.화살표를 제외하고, 이들은 각각 BNF를 구성하는 non-terminal/terminal 심볼이다.꺽쇠 괄호로 싸여 있는 것이 non-terminal이다.하나의 왼편에 대해 여러 개의 규칙을 가질 수 있는데, ​이때 여러 개의 규칙에 대해 |를 사용하여 각각의 오른편을 구분합니다. ​List를 보면, 의 오른편에 두개의 규칙이 있음을 알 수 있는데, ​두번째 규칙은 가 identifier와 로 대체하는 것입이다. ​이 규칙의 오른편을 보면, 가 또 들어 있는데,  ​이러한 규칙을 recursive rule(순환 규칙)이라고 한다.문법은 언어를 정의하기 위한 생성 장치이다.문은 문법에 있는 일련의 규칙 적용을 통해 생성되며, ​이러한 일련의 규칙 적용을 유도(derivation)이라고 한다.유도에 의해 생성된 결과를 문형식(sentential form)이라고 한다. ​문형식(sentential form)에서,  ​가장 왼쪽의 난터미날을 먼저 대체하는 것을 좌선유도(leftmost derivation)이라고 하고, ​그 반대를 우선유도(rightmost derivation)이라고 한다.​위 사례는 덧셈과 뺄셈으로 구성된 산술식을 서술하기 위한 문법과 ​그 문법에 의한 산술식의 유도(derivation) 과정을 보여주고 있다.오른쪽에 나열된 일련의 문형식(sentential form)들은 ​program이라는 난터미날 심볼에서 시작하여, ​왼쪽의 문법을 적용하여 좌선유도(Leftmost derivation)된 결과이다.  ​=&gt;의 오른쪽에 있는 begin stmt_list end, ​begin stmt ; stmt_list end, 등은 모두 문형식의 예들이다.마지막에 있는 begin A = B + C ; B = C end 은 문(sentence)이다.그러니까 문과 문형식의 차이는 난터미날 심볼의 유무에 달려 있다. ​​위 사례는 Assignment 문을 위한 문법과 ​그 문법에 의한 assignment 문의 유도를 보여주고 있다. ​왼쪽 아래는 난터미날 심볼 에서 시작하여 leftmostderivation을 보여주고 있고,  ​이것을 트리로 나타내 보면 오른쪽 그림과 같다. ​이 트리를 파스(parse) 트리라고 한다. ​당연한 말이지만 leftmost derivation을 하면, ​파스 트리의 가장 왼쪽 노드부터 터미날 심볼로 바뀌는 것을 볼 수 있다.​이 문법을 가지고 expr에서 시작해서 산술식을 유도할 때, ​+이 포함된 RHS를 먼저 적용하느냐, 이 포함된 RHS를 먼저 적용하느냐에 따라, ​A=B+CA를 위한 파스 트리가 두개 생성된다. ​이와 같이, 문형식에 문법을 적용할 때, ​동일한 문형식에 대해 파스 트리가 여러 개 생성되면, ​이 문법을 모호한 문법이라고 한다. ​문법의 모호성은 중대한 문제를 야기한다.일반적으로 preorder에 따라 산술식을 계산하는데, ​이들 트리는 실행 결과가 서로 다르다. ​왜냐하면, 왼쪽의 트리는 덧셈이 먼저, 오른쪽의 트리는 곱셈이 먼저 계산되기 때문이다.즉, 동일한 문에 대해 어떤 규칙을 먼저 적용하였느냐에 따라 파스 트리가 다르고, ​그 트리의 실행 결과가 항상 같지 않다는 것이다.이러한 이유로 문법의 모호성은 제거되어야 한다.문의 실행 결과가 항상 같지 않을 수 있기 때문에 모호성은 제거되어야 함을 알게 되었다. ​  이러한 모호성을 어떻게 제거할 수 있을까?  ​      연산자에 대한 우선순위를 둔다.즉, 파스 트리의 가장 아래에 있는 연산자부터 먼저 실행한다.따라서, 아래에 있는 연산자가 위의 연산자보다 우선 순위가 높다. ​        우선순위에 따라 연산자 출현 순서를 지정한다.이와 같은 출현 순서의 지정은 별도의 난터미널 심볼을 사용하여 명세할 수 있다.난터미널 심볼은 우선순위가 다른 연산자의 오퍼랜드를 표현하기 위해 사용한다. ​  모호성 제거 방법을 종합하면, 문법을 서술할 때,  ​파스 트리에서 낮은 우선순위의 연산자가 ​높은 우선순위의 연산자보다 위에 나타날 수 있도록, ​낮은 우선순위의 오른쪽 오퍼랜드를 ​새로운 난터미널 심볼로 대체한다.  ​예를 들어 살펴 보자.​+는 *에 비해 트리의 아래에 위치해야 한다.따라서,  -&gt;  + 의 RHS에서 ​오른쪽 오퍼랜드 를 으로 대체한다.  그러면 이제  -&gt;  * 는 ​ -&gt;  * 으로 잠정적으로 바뀐다.  이 규칙의 RHS에서 오른쪽 오퍼랜드는 ​곱셈 다음에 나 (괄호속의 식)을 나타날 수 있다.  (괄호속 식)을 서술할 수 있도록 하기 위해 ​곱셈의 오른쪽 오퍼랜드 을 ​난터미날 심볼 를 사용하여 대체한다.  그러면, 잠정적으로 바뀐  -&gt;  * 은 ​ -&gt;  * 가 된다.원래 는 없었는데, ​곱셈의 오른쪽 오퍼랜드로 (괄호속 식) 또는 를 나타낼 수 있도록 하기 위해 ​라는 난터미날을 새로 도입한 것이다. ​이러한 목적에 의해 가 (괄호속 식) 또는 를 생성하는 규칙을 서술해야 한다.   이 규칙은  -&gt; () | 로 쓸 수 있다.연산자 우선순위와 연산자 출현 순서의 지정에 의해 모호성을 제거하여 ​트리를 생성하면 유일하게 생성된다.그러나 만일 우선순위가 같은 곱셈과 나눗셈이 포함된 산술식을 위한 문법이라면, ​모호성을 어떻게 제거해야 할까? ​이와 긑은 문제는 시맨틱 규칙으로 지정해서 해결해야 한다. ​​A / B * C와 같이 동일한 우선순위를 가진 곱셈과 나눗셈으로 이루어진 식에서, ​이들 연산자간의 계산 순서를 정하기 위해 어떤 시맨틱 규칙을 쓸 수 있을까?  바로 결합 법칙을 이용할 수 있다. ​그런데 결합 법칙에는, ​왼쪽부터 결합하는 방식과 오른쪽부터 결합하는 방식, ​두 가지가 있다.A / B * C 은 어느 방식을 쓰느냐에 따라 계산 결과가 달라진다.  ​    또한 if-else 문법의 모호성 문제도 있다.  ​--- ​---if (logic_expr) if (logic_expr) stmt else stmt에 대해, 위의 문법은 두개의 파스 트리를 생성한다.  따라서 이 문법은 모호성이 있다.  --- ​---  If-else의 모호성 제거는 ‘가장 가까운 then에 else를 매치시킨다’는 규칙으로 해소된다.If문은 then과 else가 모두 있는 것과 ​then만 있고 else는 없는 것으로 구분된다. ​즉 난터미날 는 난터미날 이거나 로 대체된다.는 if… else…를 모두 갖춘 것이고, 는 if… 로 구성되어 있다.는 else 다음에 if… else를 허용하기 위해, 규칙에 else 를 추가한다. ​모호성을 제거한 새로운 문법은 오른쪽 아래와 같다.---&gt; Extended BNF ​---&lt;…&gt;는 난터미날 심볼, x, y, z는 터미날 심볼​( )는 그룹으로 묶기(일상적인 괄호의 의미), ​{ }와 [ ]는 일상적인 의미가 아니고, ​{ }는 0번 이상 반복, ​[ ]는 생략 가능(이 예제에는 없음), ​“ ”는 터미날 심볼을 나타내는 규칙의 표현 기호이며, ​( )는 규칙 표기에 사용되는 기호이기 때문에, ​산술식의 일부로서 표현되는 소괄호는 “(“  “)”로 표기함  --- ​   ---위 그림에서 왼쪽의 BNF를 EBNF로 나타내면 오른쪽과 같다고 되어 있다.  그러나 이 문법은 산술식에서 우선순위를 나타낼 때 사용하는 소괄호와EBNF로 표기법의 소괄호의 의미를 구분하지 못하고 있다.  이를 바로 잡으면, 오른쪽 아래의 문법과 같다.  EBNF에서 ( )를 산술식의 괄호로 쓰려면, “(“, “)”로 써야 한다.---",
        "url": "/pl-08"
    }
    ,
    
    "pl-07": {
        "title": "프로그래밍 언어의 정교화",
            "author": "lee989898",
            "category": "",
            "content": "프로그래밍 언어의 정교화  ALGOL초기 포트란은 IBM 704를 타겟으로 개발되었다.마찬가지로, 많은 언어가 특정 하드웨어에 최적화하도록 개발되었고, ​이들 언어 간의 소통은 불가능했다. ​LISP를 포함한 초기의 다른 여러 프로그래밍 언어도 마찬가지였다.Lisp의 기본 연산자 CAR(content of the address register), CDR(content of decrement register)은 ​IBM 704 하드웨어 아키텍처와 매치되지는 않지만, 연산자 이름에서 ​당시의 프로그래밍 언어가 하드웨어 아키텍처와 밀접한 관련성이 있었다는 흔적임을 알 수 있다. ​이러한 문제를 해결하고자, ALGOL을 개발하였다.ALGOL은 과학 알고리듬의 표현을 위한, 하드웨어구조에 독립적인 명령식 언어이다.    GO TO 27​27 IF (A-B) 5,6,7​알골 이전의 컨트롤 스트럭처는 go to 하나뿐이었다.go to 27은, 위 코드에서 보듯이, 27이라는 레이블이 붙은 문장으로 점프한다.  ​Go to는 레이블 중심의 컨트롤을 하기 때문에, 그 레이블이 어디든 점프하게 된다.이로 인해 프로그램 코드는 스파게티처럼 꼬이게 되어,디버깅이 매우 어려울 뿐만 아니라, 의도하지 않은 영역으로 점프하는 등go to는 해로운 컨트롤 스트럭처로 인식되고 있었다. ​이를 해결하기 위해, ​절(phrase) 수준의 컨트롤 스트럭처로서 if,while, switch, for, until 등이 언어에 포함되었다.뿐만 아니라, 이들 스트럭처를 사용하기 위한 프로그램 설계 방법으로 구조적 프로그래밍(structured programming)이 제안되었다. ​구조적 프로그램 스타일의 핵심은 위에 언급된 컨트롤스트럭처를 적재적소에 적용하여, ​하나의 프로그램을 여러 개의 블록을나누고 이들 블록간의 컨트롤을 구조적으로 유지하자는 것이다.이렇게 하면 프로그램의 디버깅이 쉬울 뿐만 아니라, 프로그램의 개발, 이해, 수정이 쉬워진다.알골 언어는 프로그래밍할 때 기억해야 특별한 제약이 없다.따라서 포트란에 비해 프로그램 작성시 다음과 같은 면에서 자유롭다. ​  코딩할 때 고정된 포맷이 없다. 초기의 포트란은 레이블의 위치 문장의 시작 위치 등이 지정되어 있다  변수명의 길이와 배열의 차원 수에 제한이 없다.초기의 포트란은 변수명의 길이가 6자 이내이며, 차원수도 3개로 제한되어 있었다.  독립성: 기본 개념의 결합에 제한이 없다.허용되지 않는 결합 조건 등 특별한 금지 사항을 기억해야 할 필요가 없다.알골은 1958년 이후에 개발된 모든 언어에 영향을 주었으며, 이들 언어가 사용한 아이디어는 다음과 같다. ​  특정 포맷이 없는 lexical structure(어휘 구조) ​  변수명과 배열 차원의 길이에 제한이 없음 ​  BNF에 의한 구문 구조(신택스)​  타입 개념​  지역 변수의 허용에 의한 블록 구조 ​  Begin-end 및 if-then-else의 중첩 허용에 의한 복합 문장 ​  실행 시 스택 메모리 기반의 동적 배열 할당 ​  Call by value, call by reference, call by name ​  Recursion, 조건식(conditional expression) ​Call by value는 함수 호출 시 파라미터의 ‘값’을 넘겨주고, 이‘값’은 ‘새로운 공간’에 저장되어 호출된 함수에서 사용된다. ​Call by reference는 함수 호출시 파라미터의 ‘주소’를 넘겨주고,되돌려 받을 때도 이 ‘주소’를 이용한다. ​Call by name는 함수 호출시 ‘함수’를 파라미터로 넘겨주면, ‘실제 실행할 때’ 그 ‘함수를 호출’한다. ​Call by value와 call by reference는 값을 저장하는공간을 다루고 있지만,Call by name은 ‘넘어간 함수의 호출 시점’을 다루고 있다.Call by name은 함수 프로그래밍에서 사용하는 방법이다.함수 호출시 파라미터를 call by value로 넘겨준다면, ​그 아웃풋 순서는 hi 다음에 call이지만, ​Call by name으로 한다면, ​그 순서는 call 다음에 hi가 된다. ​그 이유는 call(x)의 x에 함수 hou()의 name이 매치되고, ​call(x) 함수 내에서 x()가 실행되어야 비로소 함수 hou()를 실행하기 때문이다.  BASIC베이직은 개발 시기에 비해 늦게 대중화된 언어이다.MS의 베이직과 같은 언어이다.Basic의 특징은 한대의 컴퓨터에 연결된 다수의 원격 터미날을 통해 다수의 사용자가 시분 할 방식으로 동시에 접속하여 컴퓨터를 사용할 수 있는  개발 환경을 제공하였다.  COBOL코볼은 유니백이 개발한 플로우매틱을 모태로 대음과 같은 특성을 갖는 언어로 개발되었다. ​  변수명은 하이픈(-) 포함해서 30글자까지 ​  산술 연산자를 영어명으로 (산술식 표현이 없음) ​  모든 문장은 동사로 시작함 ​  계층적 데이터 구조(레코드) 제공​  If-then-else의 중첩 ​미국방부가 주도한 설계 고려사항은 다음과 같다. ​  영어처럼 단순하게 ​  사용하기 쉽게​  컴퓨터 사용자의 저변 확대 ​  기존 컴파일러 문제의 회피  PL/I​과학 분야의 계산은 포트란으로, 비즈니스 응용 분야에서는 코볼로 프로그래밍을 하였으나, ​과학분야의 계산과 입출력이 복잡해 지면서 레코드 형태의 출력 구조를 요구하게 되었고, ​비즈니스 분야 응용에서도 부동점 계산이나 배열 등을 요구하게 되었다. ​IBM은 이러한 요구를 수용할 수 있는 하드웨어와 프로그래밍 언어를 동시에 개발하였다.IBM 360은 이들 응용을 모두 커버할 수 있는 하드웨어였고, ​PL/1은 이들 분야의 문제 해결을 위한 프로그래밍 언어였다. ​IBM은 다중 프로그래밍을 지원하는 시스템이었기 때문에, 컴퓨팅 및 저장 공간 단위의 동시성 제어, 인터럽트 처리, 예외 처리, 포인터 등에 대한 관리 메커니즘을 개발하였다. ​그러나 이들은 너무 복잡해서 시스템 오버헤드에 문제를 노출시켰다.여기 부터 언급하는 프로그래밍 언어에서는 데이터 추상화가프로그래밍 언어의 발전 요인이 된다.      SIMULA  이번엔 데이터 추상화를 최초로 지원했던 시뮬라를 살펴보자.시뮬라는 시뮬레이션 프로그램 작성에 편리한 언어로 개발되었다.시뮬라의 가장 중요한 특성으로는 클래스와 코루틴을 들 수 있다. ​클래스는 데이터 추상화의 기본이 되는 구조로서, 로컬 데이터와 이에 대한 함수의 정의를 포함한다. ​시뮬라의 이와 같은 데이터 추상화는 객체 지향 프로그래밍의 객체와 유사하다.  ​코루틴은 서브루틴(서브 프로그램)을 일반화한 것으로, 서브프로그램 실행의 중단과 재시작을 허용한다.​   ​코루틴이 서브루틴의 일반화한 것이라고 했는데, 왜 그런지 서브루틴과 코루틴을 비교해 보자.  ​위 그림에서 볼 수 있듯이, 서브루틴은 호출(call)될 때마다 처음부터 실행하여 결과를 (return)돌려준다.반면, 코루틴은 여러 루틴들이 시작, 중지 및 양보(yield), 재시작을 반복하면서 동시에 실행되는 것을 말한다.  ​이때 재시작은 루틴의 처음부터 시작하는 것이 아니라, 이전에 양보했던 그 지점에서 재시작한다. ​루틴1이 실행되다가, 루틴2에게 양보하고, 루틴2가 실행되다가 루틴1에게 양보하기를 반복한다. ​왼쪽 코드를 보자.이 프로그램은 두개의 코루틴 producer, consumer과, main(즉, call producer)으로 구성되어 있다.프로듀서는 큐가 풀이 아니면, 새로운 아이템을 생산하여 큐에 넣는다. ​만일 큐가 풀이면, 컨슈머에게 양보한다. ​​컨슈머는 큐가 비어있지 않으면, 큐에서 아이템을 뽑아서 처리한다. ​만일 큐가 비어 있으면, 프로듀서에게 양보한다. ​이 프로그램은 프로듀서를 호출함으로써 시작되고, ​콜루틴의 조건에 따라 서로 양보하면서 반복적으로 실행된다. ​논리적으로 보면 이 프로그램은 끝나지 않는 프로그램이다. ​이러한 종류의 프로그램은 일반적인 응용 프로그램보다는 시스템 소프트웨어에서 많이 볼 수 있다.  Smalltalk스몰톡은 최초의 객체지향언어라고 한다.앞의 데이터 추상화에서 시뮬라가 최초의 객체지향언어라고 취급하기도 하지만, ​스몰톡이야말로 객체 지향 언어의 중요한 특성을 구현하였기 때문이다. ​그러면 스몰톡 언어의 특성을 살펴보자.변수, 상수, 레코드 실행, 클래스 등 모든 것이 객체로 취급된다.모든 계산은 객체에 의한 메시지의 전송 및 수신에 의해 수행된다.데이터 추상화, 상속, 동적 타입 바인딩 등   ​스몰톡 언어는 데스크탑 환경을 가정하였는데, 이러한 데스크탑은 프로그래머가 아닌 사용자에 의해 사용될 것이며, 따라서 강력한 휴먼 인터페이스를 필요로 할 거라고 가정하였다. 이러한 이유로 스몰톡은 GUI 설계를 개척하게 되었던 것이다. 이러한 아이디어는 개발되어 Dynabook에 탑재되었다.  C++시뮬라 및 스몰톡의 클래스와 함께, 함수 파라미터 타입 검사 및 컨버전, constructor, 상속된 요소의 접근 통제, 예외 처리 등을 C에 추가하여 C++를 개발하였다. ​절차적(명령형) 프로그래밍과 객체 지향 프로그래밍을 동시에 지원하면서 C++ 언어는 대단히 복잡해졌다. ​C++은 컴파일러의 품질이 좋고 저렴했고 C와 컴패터블했기 때문에 널리 보급되어 지금도 널리 사용되고 있다.  Java자바는 객체지향 언어로, 명령형 프로그래밍 언어이다.자바는 가전제품의 임베디드 소프트웨어 개발에 적합하도록 ​다음과 같은 요구사항에 초점을 맞춰 설계되었다. ​  단순성​  객체지향 프로그래밍 지원​  포인터 대신에 레퍼런스 지원 -&gt; 클래스 정의, 사용자 정의 타입 ​  애플릿 및 동시성(동시처리) 지원 ​C++는 객체지향 프로그래밍을 지원하지만, ​임베디드 소프트웨어에 부적합하다고 평가되었다.그 이유는 절차적 언어를 지원하기 때문에 ​구현 시스템이 너무 크고 복잡하고, 신뢰도가 낮기 때문이다.   ​자바는 순수 객체 지향 언어이다.모든 처리로직은 객체의 메소드로 정의되기 때문에 ​서브 프로그램이 존재하지 않았다.  ​자바는 복잡도를 줄이기 위해 ​단일 상속만을 허용하고 동시성 형태도 단순화하였다. ​자바의 특징은 다음과 같다.  자바는 C++에 비해 실행 속도보다 안정성에 중점을 두고 있다. ​ 안전성은 다양한 면에서 언급될 수 있는데, ​우선 자바 가상 머신을 통한 코드 실행과 배열 범위 검사를 들 수 있다.자바 가상 머신은 하위 플랫폼을 추상화시키는 결과를 가져 오기 때문에 ​하드웨어 플랫폼의 차이점으로 인한 오류 발생을 해소한다.그리고 실행시 배열 범위 검사는 배열 처리 상의  오류를 줄인다.    ​동시성 지원(병렬 처리): thread, runnable task ​  애플릿, GUI, DB access 라이브러리​  컴파일러 및 자바 가상 머신에 의한 이식성​  웹 프로그래밍에 적용성 ​  Pascal(1971)파스칼은 알골의 후속작으로 구조적 프로그래밍을 가르치기 위해 설계되었다.작고 단순하고 전혀 새롭지 않은 언어를 지향하였다.  CC는 시스템 프로그래밍을 위해 개발되었으며, 연산자가 풍부한 반면, 타입 검사가 없는 언어이다.유닉스와 함께 보급되었으며, 다양한 응용 분야에서 사용되었다.  Ada에이다는 이제까지 언급한 프로그래밍 언어의 개념을 하나의 언어로설계 및 구현하려는 시도였다. ​이 프로젝트를 통해 얻은 것은 다음과 같다. ​  패키지는 데이터 추상화를 지원​  예외 처리를 좀더 정교하게 발전​  서브 프로그램이나 패키지를 일반적인 단위 프로그램으로 생성하기때문에, ​  공통 속성을 갖는 알고리듬에 유용함. ​  타스크 간의 소통에 의한 동시성 통제를 통해 병렬 처리를 지원이후 새로운 버전으로 에이다95를 설계하였는데, ​  객체지향​  공유 변수(shared variable) 컨트롤 메커니즘​  사용성을 개선하기 위한 라이브러리 등이 포함되었다. ​​에이다는 들인 노력에 비해, 대중성에서 실패한 사례로 간주된다.비슷한 시기에 나온 C++에 그 자리를 내준 듯 하다. ​",
        "url": "/pl-07"
    }
    ,
    
    "sc-03": {
        "title": "Symmetric Key Cipher",
            "author": "lee989898",
            "category": "",
            "content": "Symmetric Key Cipher  현대암호의 분류​  Symmetric vs public key  Encryption key와 decryption key 동일 여부  같으면 symmetric, 다르면 public key  Block vs Stream cypher  Block          긴 평문을 일정한 길이의 블록으로 나누어 블록단위 암호화하는 방식​      DES, AES 등        Stream          Bit 혹은 byte 단위로 암호화​      키를 키스트림 생성기라는 알고리즘에 입력하여 발생되는 1비트 키의 무한수열로 평문을 암호화​      eStream, RC4 등​        Block vs Stream  암호화할 데이터 type  다음 상황의 데이터 특징은?  영화 파일 다운로드(Block) vs 실시간 방송, 카카오 채팅(Stream)  Block Cipher  긴 평문을 일정한 길이의 블록으로 나누어 블록단위로 암호화하는 방식  SW 구현이 쉽다  Round를 사용하여 반복적으로 암호화하므로 안전  대부분 Feistel cipher structure에 기반  DES, AES, SEED, ARIA, Bluefish, Serpent 등​​  Feistel Cipher Structure란  대부분 Block cipher에 사용  입력 block을 반으로 나눈다      왼,오른쪽 바꿔가며 여러 round수행    Feistel cipher parameters          Block size: 크면 안전해지나 느려짐      Key size: 크면 안전해지나 느려짐      Round 회수: 크면 안전해지나 느려짐      Function으 복잡도: 크면 안전해지나 느려짐        DES (Data Encryprtion Standard)  가장 많이 쓰임  1972 NIST cipher 곰모  1974 IBM Lucifer 선정      1977 미정부 사용결정    Feistel cipher structure  Block size 64bit, key size 56bit      16round    Declared insecure in 1998  변형버전 - 2DES, 3DES(2~3개 key로 3회 암복호화)  AES (Advanced Encryption Standard)  1997 NIST 공모  Rijndael, 2001 NIST 표준선정  Block size 128bit, key size 128,192,256bit  각 키 크기에 따라 10,12,14 rounds  Block Operation Mode  Idea: Block 들을 어떻게 운용하느냐로 안전성 향상  4가지 mode          ECB(Electronic Code Block)      CBC(Cipher Block Chaining)      CFB(Cipher Feedback)      OFB(Output Feedback)        ECB(Electronic Code Block)  각 block이 서로 독립적  +simple  +병렬처리용이  -같은 평문에 대해 동일한 암호문 생성  CBC(Cipher Block Chaining)  Chain: 뒤에 것을 앞에 연결  최초의 평문 blk은 IV와 XOR  결과는 다음 평문 blk와 XOR해서 암호화한다  +같은 평문 blk라도 다른 암호문 blk생성  -Error propagation  Ipsec,Kerberos5 등에서 사용  CFB(Cipher Feedback)  Feddback: 출력을 입력으로  초기 blk을 암호화하여 결과를 평문 blk와 XOR  결과는 다음 encrypt시에 입력으로 사용  평문을 직접 암호화하는것이 아니다  +같은 plaintext blk라도 다른 cipher blk생성  -Error propagation  OFB(Output Feedback)  장단점은 CFB와 동일  CFB에 비해 빠름  스트림 암호  stream: 시내,냇가,흐름  Block을 만들 수 없는 경우  평문을 1 bit(or byte, word)씩 순차적으로 암호화하는 방식  평문과 난수 키 스트림을 1bit씩 단순 XOR  빠름 (XOR 연산)  일반적으로 block cipher에 비해 보안성 낮다  무선통신, 실시간 음성, 영상 스트림 서비스  RC4, ChCha, A5/1, SEAL, SOBER 등",
        "url": "/sc-03"
    }
    ,
    
    "st-03": {
        "title": "File IO",
            "author": "lee989898",
            "category": "",
            "content": "File IO  open() : 열기  open()은 버퍼 공간을 확보하여 파일을 읽거나 쓸 때 사용한다      파일이 존재하지 않을 경우 open()에 의해 새로운 파일이 만들어지기도 한다    #include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int open(const char *pathname, int flags);int open(const char *pathname, int flags, mode_t mode);        pathname: 경로(path)명을 포함한 파일의 이름 또는 장치 이름  flag: 파일 상태 플래그          파일을 열 때 취해지는 구체적 행동을 기술한다      파일 액세스 flag와 선택적인 flag의 OR 연산으로 나타낸다        파일 액세스 flag: 다음 중 하나만 사용할 수 있다            모드(값,8진수)      설명                  O_RDONLY(00)      읽기 전용으로 열기              O_WRONLY(01)      쓰기 전용으로 열기              O_RDWR(02)      읽기/쓰기용으로 열기        선택적인 flag:            모드(값,8진수)      설명                  O_APPEND(02000)      파일의 끝에서부터 데이터를 추가하여 쓴다              O_TRUNC(01000)      파일의 크기를 0으로 만든다(내용삭제)              O_CREAT(0100)      파일이 존재하지 않을 경우 생성한다        mode:          mode_t 타입(unsigned int)      새로운 파일을 만들 대만 필요      Flag에 O_CREAT를 지정한 경우에만 필요       0~8비트 : 파일의 보호 모드      sticky 비트(공유모드)                  여러 사용자들이 이용하는 실행파일에 설정          실행 후 텍스트 이미지를 메모리에 보관함으로써 다음 번에 실행될 떄 빠르게 실행하도록 하기 위해 지정                    setuid 비트 : 1로 셋트 되면 일반사용자가 해당 파일의 소유자 권한으로 파일을 실행할 수 있도록 해준다      setgid 비트 : 1로 셋트 되면 일반그룹이 해당 그룹의 소유자  권한으로 파일을 실행 할 수 있도록 해준다​      setuid , setgid 비트를 설정하면, 그 파일을 실행하고 있는 동안만 그 프로세스의 실효 사용자 ID와 실효 그룹 ID를 그 실행파일의 소유자 ID와  그룹 ID로 변경할 수 있다 ​      예 : root 사용자만이 실행할 수 있는 프로그램을 setuid/setgid 비트를 설정하여 일반 사용자가 실행할 수 있도록 해 준다      O_CREAT flag를 사용하여 파일 생성시, 다음의 매개인자를 사용한다                  매크로      의미                         S_IRUSR      소유자에게 읽기 권한                     S_IWUSR      소유자에게 쓰기 권한                     S_IXUSR      소유자에게 실행 권한                     S_IRGRP      소유그룹에게 읽기권한​                     S_IWGRP      소유그룹에게 쓰기권한​                     S_IXGRP      소유그룹에게 실행권한                     S_IROTH​      other에게 읽기권한​                     S_IWOTH​      other에게 쓰기권한​                     S_IXOTH      other에게 실행권한                     S_IRWXU​      소유자에게 읽기, 쓰기, 실행권한      ​              S_IRWXG​      소유그룹에게 읽기, 쓰기, 실행권한      ​              S_IRWXO​      other에게 읽기, 쓰기, 실행권한​                     S_ISUID​      셋 사용자 ID 비트를 설정​                     S_ISGID​      셋 그룹 ID 비트를 설정      ​              S_ISVTX​      STICKY 비트를 설정      ​            세번째 인자인 mode는 sys/stat.h에서 정의된 플래그의 OR연산으로 만들어진다        리턴 값: 파일 디스크립터 값 또는 -1(open()이 실패할 경우)  ex) int fd;fd = open(“afile”, O_RDWR);ex) int fd;fd = open(“afile”, O_RDWR|O_CREAT,S_IRUSR|S_IWUSR);  File descriptor table: ​          열려진 모든 파일들은 각각 _IO_FILE 이라는 구조체(/usr/include/libio.h 에 정의 됨)에 정보가 저장됨 ​      한 프로세스에 의해 열려진 모든 파일들의 _IO_FILE  타입의 구조체들은 연결 리스트로 결합되어지며, 이것을 file descriptor table이라고 부른다 ​        File descriptor table에서 특정 파일의 위치를 가리키는 index 값(int 타입)을 file descriptor 라고 부른다 ​  File descriptor 값들 중 0, 1, 2는 특별한 파일들을 위하여 사용된다​          0은 stdin, 1은 stdout, 그리고 2는 stderr 파일을 지칭한다        close(): 닫기#include &lt;unistd.h&gt;int close(int fd);  close()는 작업을 종료하기 위해 사용된다​  리턴 값 : 성공이면 0, 에러 발생시 -1을 반환​  fd : 닫고자 하는 파일의 파일 디스크립터​  한 프로세스에서 열 수 있는 최대 파일 수는 limits.h 내의 상수 OPEN_MAX에서 정의됨(/usr/include/bits/posix1_lim.h)​  이 제한은 시스템에 따라 다르지만, POSIX에서는 적어도 20이 되도록 정해져 있다​  한꺼번에 열려진 파일의 개수가 OPEN_MAX가 넘지 않도록 close()를 적절히 사용하여야 한다 ​  파일을 닫지 않더라도 프로세스가 종료하면 모든 열려진 파일들은 자동적으로 닫힌다​  creat(): 파일 생성  새로운 파일을 만들거나, 이미 존재하고 있는 파일의 내용을 모두 무시하고 다시 쓸 때 사용한다​  pathname : 경로명​  mode : open()의 mode와 동일​  리턴 값 : 파일 디스크립터, 실패하면 -1  다음의 두 함수 호출은 기능이 동일하다​          creat( pathname, mode ); ​                                                  open ( pathname, O_WRONLY              O_CREAT              O_TRUNC, mode);​                                            creat()에서는 그 파일의 크기를 0으로 만든다 ​  이때 소유자 모드는 변경하지 않는다​  creat()는 open()이 있기 때문에 많이 쓰이지 않는다  read(): 읽기#include &lt;unistd.h&gt;ssize_t read(int filedes, void *buf, size_t nbytes);  파일에서 원하는 크기의 데이터를 읽는다​  리턴 값 :​          성공하면 읽은 byte 수​      파일의 끝을 만나면 0  읽기 종료​      실패하면 -1​        buf : 읽은 데이터를 저장할 메모리의 시작 주소​  nbytes : 읽을 바이트 수​  buf는 임의의 type의 포인터(generic 포인터)가 될 수 있도록 void 타입으로 지정한다​  읽을 데이터가 충분하면 한 번에 nbytes 만큼 읽는다​  읽을 데이터가 nbytes 보다 적은 경우 더 적게 읽기도 한다​ssize_t  read (int filedes,  void *buf, size_t nbytes);​  size_t  : unsigned integer (unistd.h에서 정의)​  ssize_t : signed integer (unistd.h에서 정의)  write(): 쓰기#include &lt;unistd.h&gt;ssize_t write(int filedes, void *buf, size_t nbytes);  파일에 데이터를 쓴다​  리턴 값​          성공하면 파일에 쓰여진 데이터의 바이트 수​      실패하면 -1​        buf : 쓸 데이터를 저장하고 있는 메모리 공간​  nbytes : 쓸 데이터의 바이트 수  lseek(): 파일의 현재 위치 이동#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;off_t lseek (int filedes, off_t offset, int whence);  lseek는 파일에 대한 임의접근을 가능하게 한다​  파일의 현재 위치(current file offset)를 이동시킨다. 즉 읽기-쓰기 포인터의 위치, 다음에 읽거나 쓸 바이트의 위치를 변경할 수 있다​  파일의 현재 위치(current file offset)​          파일에 대한 읽기/쓰기는 파일의 현재 위치에서 실행된다​      파일을 처음 열면 현재 위치는 0, 즉 파일의 시작이다​      읽기/쓰기 후 파일의 현재 위치는 읽기/쓰기 한 byte 수 만큼 저절로 뒤로 이동된다​      lseek()를 사용하여  임의의 위치로 파일의 현재 위치를 이동할 수 있다​      offset은 음수가 될 수도 있다​        리턴 값: 성공하면 현재의 읽기/쓰기 포인터의 위치를 리턴, 실패하면 -1  offset : 기준점에 더해질 바이트의 수 (byte 단위)​          SEEK_CUR, SEEK_END 와 같이 쓰일 때는 음수도 가능​      off_t는 long int와 같은 의미를 나타낸다​        whence : 시작위치 정하는 방법으로, 다음 중 하나를 사용한다            매크로 이름      값      포인터 위치 지정 방법                  SEEK_SET      0      offset이 파일의 맨 앞에서부터 더해져 이동              SEEK_CUR      1      현재위치에 offset이 더해져 이동              SEEK_END      2      파일의 마지막 바이트 번호에 더해 이동        Disk  Disk들은 platters들로 구성되어 있으며, 각 platter는 두개의 표면(surface)을 갖는다.​          각 surface는 동심원 모양의 track들로 구성​      각 track은 sectors들로 구성되는데, sector들은 gap으로 구분된다      정렬된 track들은 cylinder를 이룬다        최근의 disk는 track들을 recording zone들로 분할한다 ​          같은 zone 내부의 track들은 같은 개수의 sector들을 갖는다.      Zone마다 track 당 sector의 개수(sectors/track )가 달라진다. 바깥 쪽 zone은 track당 sector의 개수가 더 많아진다.   ​      따라서, disk의 용량을 계산할 때  track당 평균 sector의 개수를 사용한다. ​        I/O efficiency  디스크는 mechanical device로서 메모리 (DRAM) 에 비해서 상대적으로 성능이 매우 느린 장치​  성능을 위해서는 디스크 I/O의 횟수를 줄이는 것이 바람직(seek time + rotational delay)​          작은 양을 여러번 I/O 하는 것 보다​      많은 양을 한꺼번에 I/O 하여 횟수를 줄이는 것이 좋다​  ​—        dup(), dup2(): 파일 디스크립터 복제  사용 중인 파일 디스크립터의 복사본을 제공​  Oldfd가 가리키는 사용자 파일 디스크립터 표의 구조체를 새로운 파일 디스크립터가 가리키도록 한다 ​  리턴 값: 성공하면 복사된 새 파일 디스크립터, 실패하면 -1​          dup() 함수는 할당 가능한 가장 작은 번호를 리턴한다​      dup2() 함수는 newfd를 리턴한다​      fdin = open(“in-file”, O_RDONLY);​close(0);​dup(fdin);​close(fdin);  stat(), fstat(), lstat(): 파일 조작#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;int stat(const char * pathname, struct stat *buf);int fstat(int fd, struct stat *buf);int lstat(const char * pathname, struct stat * buf);  파일 조작 시스템 호출은 파일 상태에 대한 정보를 stat 구조체에 가져온다​  리턴값: 성공시 0,  실패시 -1​  pathname: 파일의 경로명​  buf: stat 구조체(파일정보)를 저장하는 구조체​  stat()가 경로명으로 파일을 지정하는 반면, fstat()는 파일 디스크립터를 지정한다​      lstat()는 대상 파일이 심볼릭 링크(symbolic link)인 경우에 링크가 나타내는 파일이 아니라 링크 자신의 상태를 가져온다​        stat 구조체 내용      struct  stat {​    mode_t   st_mode; 파일 모드에 대한 정보​    ino_t      st_ino; 파일의 I-node 번호​    dev_t      st_dev; I-node가 있는 디바이스의 디바이스번호​    dev_t st_rdev; 디바이스번호(디바이스 파일의 경우)​    nlink_t st_nlink;  파일에 관련된 링크의 수​    uid_t st_uid;    소유자의 사용자 ID​    gid_t st_gid;    소유자의 그룹 ID​    off_t st_size;   파일크기(바이트 수)​    time_t st_atime;  최종 엑세스 시각​    time_t st_mtime; 최종 변경 시각​    time_t st_ctime;  최종 상태 변경 시각​    blksize_t st_blksize; 파일 시스템의 블록 크기​    blkcnt_t st_blocks; 할당된 블록수​    };        access(): 파일에 대한 액세스 권한 검사#include &lt;unistd.h&gt;int access(const char * pathname, int mode);  파일에 대하여 mode로 전해준 액세스 권한이 있는지 없는지 확인한다​  pathname : 경로명​  mode : 모드​  리턴값 : 성공시 0, 에러시 -1            매크로 이름      비트패턴      액세스 권한                  R_OK      100      읽기              W_OK      010      쓰기              X_OK      001      실행              F_OK      000      파일이 존재하는지 아닌지      ",
        "url": "/st-03"
    }
    ,
    
    "algorithm-02": {
        "title": "알고리즘의 효율성 분석",
            "author": "lee989898",
            "category": "",
            "content": "알고리즘 분석 체계  입력 크기ex) 배열의 크기, 연결 목록의 길이, 행렬에서 행과 열의 크기, 그래프에서 정점과 간선의 수  실행 시간 측정 단위          기본 연산: 알고리즘의 실행 시간에 가장 많이 기여하는 연산      실행 시간은 입력 크기가 작으면 거의 차이가 없다.        증가 차수          시간 복잡도 함수의 입력 크기(N)에 따른 증가율                  로그 함수: N의 값이 4배 증가할 때 2만큼 증가          1차 선형 함수: N의 값에 비례하여 증가          2차 선형 함수: N의 값이 4배 증가할 때 16배 증가          지수 함수: N의 값이 4배 증가할 때 2의 4 제곱배 증가                    시간 복잡도공간 복잡도: 알고리즘이 수행되는 동안 요구되는 메모리 공간의 크기를 나타낸다.시간 복잡도: 알고리즘이 얼마나 빨리 수행되는지를 나타낸다.  알고리즘의 기본 연산의 수행 횟수를 입력 크기의 함수로 표현  입력 크기뿐만이 아니라 특정 입력 값에도 좌우  복잡도는 입력 크기인 N의 함수로 나타낸다  복잡도 함수는 보통 여러 개의 항들을 갖는 다항식이다.  고차 항이 시간복잡도를 궁극적으로 지배한다.시간 복잡도의 분류  최악 경우 시간 복잡도          모든 입력에 대해서 기본 연산이 수행되는 최대 횟수        최선 경우 시간 복잡도          모든 입력에 대해서 기본 연산이 수행되는 최소 횟수        평균 경우 시간 복잡도          모든 입력에 대해서 기본 연산이 수행되는 평균 횟수      일반적으로 최악 경우보다 구하기가 어려움      복잡도를 간단한 함수로 표현하기 위해 점근적 표기 사용  O(Big O)-표기: 점근적 상한​  Ω(Big Ω)-표기: 점근적 하한​  $\\theta$(Big $\\theta$)-표기: 점근적 상한이면서 점근적 하한​​위 그림은 주요 복잡도 함수의 증가율이다.",
        "url": "/algorithm-02"
    }
    ,
    
    "pl-06": {
        "title": "프로그래밍 언어의 진화",
            "author": "lee989898",
            "category": "",
            "content": "프로그래밍 언어의 진화  1940 ~ 1950초기 컴퓨터는 기계 코드로 직접 프로그램을 작성했었고 이로인해 다음과 같은 제한이 있었다.하드웨어의 제한으로, 부동점 소수의 계산, 인덱싱 등이 지원되지 않았으며, ​계산과 직접 관련이 없는 시스템 소프트웨어의 사용도 제한적이었다.그래서 프로그래머 인건비보다 컴퓨터가 훨씬 비쌌다. ​따라서 프로그램의 읽기 및 쓰기의 용이성, 수정 용이성, 표현력 등은 크게 문제되지 않았으며, ​프로그래밍은 주로 계산 흐름을 지시하는데 중점을 두었다.이러한 여건 속에서, ​초기 프로그래머는 기계 코드로 프로그램을 작성하였다. ​  부동점 소수를 계산하기 위해, 프로그래머는 수동으로 지수를 추적해야 했다.  프로그램이 적재되는 메모리의 위치에 따라 상대 주소를 절대 주소로 직접 변환해야 했다.  배열에 대한 인덱스가 없기 때문에, 셀의 주소를 계산하려면,첫째 셀을 기준으로 셀의 길이만큼씩 더해가면서 주소를 계산하였다.  초기 프로그래머를 위해, 어셈블리 언어와 어셈블러가 개발되었다. ​ 어셈블리어는 이진수로 표현된 기계 언어를 일상적인 구절로일대일 매핑시킨 것이다.  끝으로 복잡한 프로그램이 필요해지고 컴퓨터의값이 떨어지면서 프로그래머의 시간 절약이 매우 중요해졌다.  FORTRAN초기 프로그래밍은 주로 과학 계산에 집중되었으며, 이를 위해 가장 많이 사용된 포트란에 대해 알아보자. ​포트란은 최초의 대중적인 고급 프로그래밍 언어이다.당시의 컴퓨터는 가격이 매우 비쌌고, 계산 용량이 작고 신뢰성도 낮았다.따라서 기계의 효율이 가장 중요했다. ​컴퓨터는 주로 과학 분야의 숫자 계산에 치중되었다.따라서 배열 처리 및 counting loop 처리를 위한 수단을 필요로 했다.   ​포트란은 Formula Translating System에서 For와 Tran을 따온 것으로, ​과학 분야의 이같은 계산 요구를 만족시키도록 설계 및 구현되었다.포트란에서는 변수명이 6글자까지로 제한되고, 사용자 정의에 의한 서브프로그램은 허용된다.데이터 타입은 구현시스템에서 제공되는 정적 타입만 허용된다.추후에 다른 언어의 영향으로 다양한 특성을 갖게 된다.포트란은 명령식 언어로, 포트란 프로그램은 본 뉴만 아키텍처를 따른다.  ​  변수는 메모리 셀을 가리키고, ​  Assignment 문장은 메모리와 CPU간의 데이터 이동을 수행하며, ​  연산과 표현식은 CPU에 의한 계산을 실행한다. ​  실행 흐름을 명시적으로 통제하며, ​  언어와 하드웨어 간 효율적 매핑을 통해, 실행 성능의 효율화를 달성할 수 있지만, 본 뉴만 바틀넥에 의해 제한되기도 한다. ​포트란 프로그래밍 스타일은 큰 문제를 작은 문제로 쪼개고, ​작은 문제를 푸는 프로그램을 짜서 이들을 합치는 방식, ​즉 하향식(탑다운 방식)으로 프로그래밍을 한다. ​프로그램은 위에서 시작해서 차근차근 아래로 컨스트럭트를 따라서 실행되며, ​ go-to를 만나면 점프하기도 한다. ​구조적 프로그래밍 방식에서는 프로그램 디버깅을 어렵게 하는 go-to의 사용을 지극히 제한한다.  LISP함수 프로그래밍 언어 LISP는 링크드 리스트로 표현된 심볼릭(기호) 데이터의 처리를 위한 특성을 제공하기 위해 발명되었으며,인공지능 응용(자연어 처리) 프로그램에서 유래되었다. ​심볼릭 데이터의 처리는 배열로 처리 불가하며, 배열의 셀을 지칭하기위한 인덱스가 없으니 loop을 필요로 하지 않는다.대신에 심볼릭 데이터를 구성하는 심볼(글자) 하나하나를 처리하는 연산이 필요하다. ​이에 적합한 자료구조가 링크드 리스트이고, 이들에 대한 연산은 (+a(*b c)) 같은 형태의 함수로 표현된다. ​인풋과 함수는 모두 리스트로 표현되며, 데이터 타입은아톰과 리스트의 두가지 타입이 있다.Lisp는 배열과 이에 대한 인덱스가 없어서, 인덱스를 증감시키며 배열을 처리하는 loop이 필요하지 않다.물론 반복 처리는 필요하다.Lisp는 이를 위해, 순환 함수를 제공한다. ​​   Lisp에서는 X! 팩토리알 계산 프로그램은 위 그림과 같이 순환 함수로 표현한다.defun은 define function(함수 정의)를 의미한다.파란색 점선 상자는 x * fact(x – 1)을 리스트 형태로 나타낸 것입니다. ​함수 fact(x)를 정의할 때 x * fact(x – 1)에서 볼수 있듯이 fact()를 사용하고 있다.이와 같이 무엇인가를 정의할 때 그 무엇을 사용하면, 이것을 recursion 또는 recursive function이라고 한다.  ​​링크드 리스트 처리를 목적으로 최초에 발명된 Lisp는 지금도 사용되고 있는 언어이다. ​​   리스트는 Lisp 구현 시스템의 내부에서 위와 같이 표현된다.(A B C D)는 선형적으로 연결된 링크드 리스트로 표현되는 반면, ​(A (B C) D (E F G))는 트리 구조의 링크드 리스트로 표현된다. ​그 이유는  A, (B C), D와 (E F G)가 같은 수준에 있어야 하고, ​B와 C가 같은 수준에, 그리고 E, F와 G가 같은 수준에 있어야 하기 때문이다. ​두 리스트가 같은지 검사하는 프로그램을 Lisp로 작성하면 다음과 같다.​(DEFUN equal_lists (lis1 lis2)​     (COND​         ((ATOM lis1) (EQ lis1 lis2))​         ((ATOM lis2) NIL)​         ((equal_lists (CAR lis1) (CAR lis2))​                          (equal_lists (CDR lis1) (CDR lis2)))​         (T NIL)​       )​    )​이 코드는 아톰(즉, 리스트의 말단) 수준에서 각 심볼에 대해 EQ(같은지 아닌지) 검사한다. ​현재 EQ 검사해야 할 리스트가 아톰이 아니면, 그 다음 수준으로 아톰을 만날때까지 내려가서 EQ 검사를 한다. ​이렇게 하려면 equal_lists하는 함수를 함수 내에서 반복적으로 호출해야 한다. 즉, recursion이다. ​여기서 CDR, CAR은 Lisp의 기본 연산자로서, ​CAR은 리스트의 맨 앞의 심볼을 반환하고, CDR은 CAR을 제외한 나머지(아톰이거나 리스트)를 반환한다.최초의 함수 언어 Lisp는 다음과 같은 특징을 가지고 있다.파라미터에 함수를 적용하는 방식으로 계산을 수행하며, ​계산에 필요한 중간 변수나 assignment 개념이 없어서,메모리에 이들을 미리 할당하지 않는다.Recursion(순환 함수)와 조건식을 통해 흐름을 컨트롤하며, ​링크드 리스트를 동적으로 필요시마다 메모리에 할당을 한다.​",
        "url": "/pl-06"
    }
    ,
    
    "pl-05": {
        "title": "프로그래밍 언어의 구현 시스템",
            "author": "lee989898",
            "category": "",
            "content": "프로그래밍 언어의 구현 시스템프로그래밍 언어의 각 특징과 컨스트럭트들이 ​어떻게 구현되는지 이해하는 것은 매우 중요하다.PL 컨스트럭트의 구현은 고급 언어를 어셈블리 언어와 같은 하위 언어로 번역한다.프로그램의 문장을 번역하는 것을 컴파일이라고 하고, ​문장을 의미에 적합하게 매핑하는 것을 인터프리테이션이라고 한다. ​이와 같은 구현 시스템에 대해 왜 알아야 할까? ​컨스트럭트가 효율적으로 구현되고 있는지, ​더 좋은 구현 방법이 있는지, ​이들간의 절충점이 있는지 등을 알아내기 위함이다.컴파일 방법은 컴파일러를 써서 고급 언어로 짠 프로그램을 기계 언어로 번역한다.컴파일 프로세스는 어휘 분석, 구문 분석, 의미 분석, 코드 생성, 링크 및 적재 단계로 구성되어 있다.위 그림은 컴파일러의 구성요소와 이들 요소간의 처리 순서에 의한 컴파일 과정을 ​플로우 차트로 보여주고 있다. ​어휘 분석기(lexical analyzer)는 소스 프로그램의 글자들을 어휘 단위로 모아 놓는다.프로그램의 어휘 단위는 변수, 키워드, 연산자 등을 의미한다.구문 분석기(syntax analyzer)는 어휘 단위를 받아서 파스 트리를 생성한다.파스 트리는 프로그램의 구문 구조를 나타낸다. ​중간 코드 생성기는 소스 프로그램과 기계 코드 사이의 중간 수준의 언어로 작성된 프로그램을 생성한다.중간 언어로 어셈블리 어가 쓰이기도 하고, 이보다 조금 더 고급 수준의 언어가 사용되기도 한다. ​의미 분석기(semantic analyzer)는 중간 코드 생성기(intermediate code generator)의 일부분으로 통합되어 있으며, ​구문 분석시에 탐지되지 않는 타입 오류 등을 검사한다. ​최적화 단계는 중간 코드의 프로그램을 좀더 작고 빠르게 만든다.기계 언어보다 중간 코드를 최적화하는 이유는 기계 코드가 바이너리 형태이기 때문에​ 중간코드(알파벳으로 표현된)에 비해 최적화가 더 어렵기 때문이다. ​코드 생성기는 중간 코드를받아서 컴퓨터가 직접 실행할 수 있는 기계 언어로 변환한다. ​심볼 테이블은 소스 프로그램내의 변수의 타입과 속성(길이 등)을 저장하고 있다. 이들 정보는 어휘 분석기와 구문 분석기에 의해 심볼 테이블에 저장되고, 의미 분석기와 중간 코 드 생성기 및 코드 생성기에 의해 사용된다. ​이렇게 컴파일된 사용자 코드는 실행 시 시스템 코드를 호출하여 ​시스템 소프트웨어의 도움을 받는다. ​이를 위해 실행 직전에 사용자 코드와 시스템 코드를 링크(연결)한다.이 과정을 linking 또는 linking and loading이라고 하고, ​이러한 역할을 하는 시스템 소프트웨어를 linker라고 한다.링킹에 의해 생성된 것을 executable image(실행 이미지) 또는 load module(적재 모듈)이라고 한다.인터프리터는 프로그램을 기계 언어로 번역하지 않고, ​문장의 의미에 적합하게 시뮬레이션하여 결과를 낸다. ​따라서 인터프러터는 고급 언어 처리를 위한 시뮬레이터 또는 ​고급언어를 기계어처럼 처리하는 가상 머신의 역할을 한다. ​인터프리터의 장점은, 프로그램의 실행 오류 발생시, ​소스 프로그램의 몇번 라인에서 오류가 발생했는지 오류 메시지가 알려주기 때문에 ​프로그램 개발에 매우 편리한다. ​단점은 컴파일 코드에 비해 10-100배 느리다는 것이며, ​프로그램의 인터프리테이션 동안에 심볼 테이블이 메모리에 적재되어 있어야 하기 때문에 ​메모리 공간을 많이 차지한다는 것이다. ​인터프리터를 이용하는 대표적인 언어로 자바스크립트, PHP, 파이썬 등이 있다.하이브리드 방식은 먼저 컴파일을 해서 중간 코드를 생성한 다음에, ​중간 코드를 인터프리터에 의해 실행한다. ​자바에서는 자바 가상 머신에서 실행되는 바이트 코드를 중간 코드로 생성한다.  ​바이트 코드는 이진 코드지만 CPU가 아닌 자바 가상 머신이 이해할 수 있는 언어이다.​자바 가상 머신은 바이트 코드 명령어를 하나씩 읽어 들여 실행한다. ​이와 같이 중간 코드를 생성하여 자바 가상 머신으로 실행하면, ​하드웨어의 특이 사항에 제한을 받지 않아서 portability가 높은 장점이 있다. ​​   클래스 및 변수를 선언하고 초기화하는 자바 소스 프로그램을 바이트 코드로 번역한 예는 위와 같다.빨간색 박스를 눈여겨 보시기 보자.메모리에 위치를 잡고, 초기화 함수를 호출하거나 조작하고 반환한다.​",
        "url": "/pl-05"
    }
    ,
    
    "pl-04": {
        "title": "언어 평가 기준과 언어 설계시 기준 간의 균형",
            "author": "lee989898",
            "category": "",
            "content": "언어 평가 기준과 언어 설계시 기준 간의 균형좋은 프로그래밍 언어가 갖춰야 할 기준은 무엇인가 살펴 보자. ​      Readability(읽기 쉬움): 프로그램을 읽고 이해하기 쉬운 정도를 프로그래밍 언어의 readability라고 한다. ​        Writability(쓰기쉬움): 프로그램을 작성하기 쉬운 정도를 프로그래밍 언어의 writability라고 한다. ​        Reliability(신뢰성): 프로그램이 다양한 조건 아래서 ‘원래 하기로 되어 있던’ 일을 수행하는 것을 reliability라고 한다. 즉, 인풋이 같으면 아웃풋이 같아야 한다. 만일 인풋이 같은데 조건에 따라 다른 아웃풋을 낸다면 이 프로그램은 신뢰성이 없는 것이다. ​        비용: 프로그램은 학습 비용, 개발 비용(인건비 등 포함), 실행 비용 등 여러 가지 비용을 수반한다. 이 모든 비용이 적으면 좋은 프로그래밍 언어인 것이다.    Readability를 올리려면 다음과 같은 특성을 갖는 것이 바람직하다.      첫째, 단순성이다. 만일 프로그래밍 언어가, 언어의 고유 기능과 기본 컨스트럭트(constructs; control structure를 의미함)를 비교적 적게 갖고 있으며, ​고유 기능에 대한 다중성이 적을 수록,   ​연산의 오버로딩을 최소한으로 허용할 수록 읽기 쉽다. 여기서 다중성이란 동일한 연산을 수행하는 방법이 여러 가지가 있다는 것을 의미하며,충돌이 발생할 가능성에 대비하여 프로그래머에 의한 조치가 필요하다. 이러한 다중성은 객체 지향 언어에서 두드러지는데, ​C++에서는 허용되지만 Java에서는 허용되지 않는다. 오버로딩은 동일한 이름의 연산을 여러 개 정의하는 것을 의미하고, ​컴파일할 때 어느 연산을 실행할지 컴파일러가 결정한다. ​        둘째, 독립성이다.독립성이란 컨스트럭트 결합 규칙이 문맥에 대해 종속되지 않고 독립적인 것을 의미한다.컨스트럭트 간의 결합 규칙에 예외나 불규칙성이 비교적 적고, ​모든 결합(combination)이 구문적으로 적합하고 문맥에 독립적이어야 읽기 쉽습니다.  구조적 프로그래밍에 필요한 loop, if-then-else, begin-end와 같은 컨트롤 구조를 충분히 제공하면, ​프로그램을 위에서 아래로 읽어 내려가면서 이해할 수 있어서 readability에 기여한다. ​데이터 타입과 데이터 구조의 정의 기능 또한 프로그램의 readability에 기여한다. 데이터 타입의 정의를 통해 데이터가 가질 수 있는 값의 범위와 ​이들 데이터에 허용되는 연산을 이해할 수 있다. 데이터 구조의 정의 기능은 다양한 여러 복잡한 데이터 유형을 모아서, ​새로운 단순한 유형의 데이터를 정의할 수 있는 능력을 프로그래머에게 제공한다. 프로그래머는 이와 같이 복잡한 것을 단순화시킬 수 있어서, ​프로그램을 쉽게 작성할 수 있는 동시에, 다른 프로그래머를 쉽게 이해시킬 수 있다.  Writablility프로그래밍 언어의 쓰기쉬움의 주요 평가 기준은 ​단순성과 독립성, 추상화 지원, 표현력을 들 수 있다. 단순성이란 컨스트럭트의 수가 적다는 것을 의미하고, ​독립성이란 컨스트럭트 결합 규칙이 문맥에 대해 독립적이라는 것을 의미한다. 그러나 컨스트럭트 결합 규칙이 문맥에 지나치게 독립적이면, ​실행시 발생하는 오류를 탐지할 수 없게 될 수도 있다. 따라서 독립성은 프로그래밍 언어를 설계할 때 신중하게 고려해야 한다. 복잡한 구조 또는 연산의 추상화도 프로그래밍 언어의 쓰기쉬움을 평가하는 기준이다. 추상화에는 처리 절차의 추상화(서브 프로그램)와 데이터 추상화가 있다. For loop과 같이 편리한 표현 방식과 같은 표현력 또한 쓰기쉬움 평가의 기준입니다.  Reliablitiy:신뢰성은 타입 검사에 의한 오류 처리, ​프로그램 실행시에 발생하는 예외 처리, ​Aliasing(같은 메모리 주소를 다른 이름으로 레퍼런스하는 것), ​읽기쉬움과 쓰기쉬움 등은 모두 프로그래밍 언어의 신뢰성 평가의 기준이 된다.  Cost:학습, 개발, 컴파일 및 실행, 컴파일러 및 인터프리터와 같은 언어 구현 시스템, 신뢰성, 유지 보수 등 ​프로그래밍 언어 사용에 관련된 모든 비용은 언어 평가 기준에 속한다.이밖에 구현 시스템간의 이식성, 다양한 응용에 대한 적용성, 언어의 표준화에 의한 완결성 및 정확성, 전력 소비 효율 등도 ​프로그래밍 언어의 평가 기준이다언어 설계시 이들 모든 평가 기준을 최적화하기는 매우 어렵다. 문제 해결에 필요한 기준을 먼저 설정하고 이들 간의 균형점을 찾는 것이 중요하다. ​레퍼런스 변수는 메모리 상에 있는 인스턴스를 가리키는 데 사용되는 변수이다. 자바에서는 모든 레퍼런스 변수에 대해, ​이들이 가리키는 메모리에 대한 인덱싱이 적절한지 검사한다.이것은 신뢰성을 높여 주지만 매우 높은 실행 비용을 유발한다. ​강력한 연산자가 많으면 프로그램 짜기는 쉽지만, ​읽고 이해하기 어려울 수도 있다. ​C++의 포인터는 매우 강력하고 유연하여 쓰기 쉬움을 높여주지만, ​주의를 기울이지 않으면 신뢰성에 문제를 일으킨다.",
        "url": "/pl-04"
    }
    ,
    
    "sc-02": {
        "title": "Cryptograpghy",
            "author": "lee989898",
            "category": "",
            "content": "Cryptography  Cryptography?  Cryptography: 안전한 암호 만드는 학문  Cryptoanalysis: 암호 해독      Cryptology: 암호학    Steganography: 메시지 존재자체를 숨기는 것  암호(Encrypt/Decrypt)란?  암호(cryptography)  비밀정보의 교환을 위해 생겨남          처음에는 군사용으로 주로 사용      현재 전자상거래, 전자우편, 무선통신 등에 널리 쓰임        4차산업혁명시대: 정보의 관리, 보호의 중요성 증대          국가, 회사, 단체, 개인에 막대한 영향        암호체계의 효용성 및 안전성 분석          고급 수학이론에 기반        용어 및 등장인물  인터넷은 공개망이다  등장인물: Alice,Bob,hacker  평문(plaintext): 암호화전 문장  암호문(ciphertext): 암호화된 문장  암호화(encryption): 평문을 암호문으로 바꾸는 과정  복호화(decryption): 암호문을 평문으로 바꾸는 과정  암호 알고리즘: 암호와 알고리즘과 복호화 알고리즘  키(key): 암호 알고리즘에 사용되는 정보  History of Cryptography  제1세대 암호          고대 그리스 ~ 19세기 말        제2세대 암호          20세기 전반부(전신의 발명 ~ 제2차 세계대전 이전)        제3세대 암호 - 현대암호          제2차 세계대전 종전 이후 ~ 현재        Shift Cipher  Substitution Cipher  대치, 치환  각 글자를 다른 글자로 대치  키 space는 26!  초당 1010 개 키 계산해도 1011 년 소요  Vigenere Cipher      비게네르 암호  암호화 키를 선택: 키 = (5,22,3,14)  평문: (crypto) = (2,17,24,15,19,14)    암호화: (2,17,24,15,19,14) + (5,22,3,14,5,22) ≡ (7,13,1,3,24,10) = (hnbdyk)​  복호화: (7,13,1,3,24,10) - (5,22,3,14,5,22) ≡ (2,17,24,15,19,14) = (crypto)​  Alan Turing  Enigma 해독  최초의 컴퓨터 colossus 제작  인공지능 시조  컴퓨터 이론 확립  튜링테스트, 튜링머신",
        "url": "/sc-02"
    }
    ,
    
    "st-02": {
        "title": "File",
            "author": "lee989898",
            "category": "",
            "content": "File  File Structure  Tree 구조  계층 구조  Three types: 일반 file(네모), directory file(동그라미), divice file(역삼각형)   File Types  일반 파일          데이터를 포함하고 있는 텍스트 또는 이진 파일      트리 구조의 잎에 해당      Stream file (collection of bytes)임        디렉토리 파일          자기 자신도 하나의 파일      상위 디렉토리에 등록되어 있음(트리 구조를 이룸)      파일의 이름들과 파일 정보에 대한 포인터들을 포함        디바이스 파일          시스템에 접속하는 주변 기기나 메모리, 등의 장치 각각에 대응하는 특수 파일      /dev 디렉토리에서 관리      Special file 이라고 부름                  Character special file과 block special file로 나뉨                    Stream file임                  사용자 프로그램 내에서 일반 파일과 같은 입출력 명령으로 처리                    디바이스 파일의 종류                  문자 특수 파일(Character special file)                          문자 단위로 데이터를 처리하는 장치에 해당하는 파일              Treminal, printer, …                                블럭 특수 파일(block special file)                          블럭 단위로 데이터를 처리하는 장치에 해당하는 파일              Disk, magnetic tape                                            File Name  File name          같은 이름의 파일은 다른 디렉토리에 존재한다      구별하기 위해서 “path” 이름이 필요하다        Path name          Relative path: from .      Absolute path: from /        Home directory: ~  File Info%ls -la합계 180drwx——    4 mhlee    mhlee        4096  3월 23 14:19 C2​drwx——    4 mhlee    mhlee        4096  3월 25 17:10 SUBMIT​-rwxrwxr-x   1 mhlee    mhlee      11888   9월  5 10:35 a.out  d rwx rwx rwx​          d: directory file​      -: 일반 file​      l: symbolic link​      b: block device file​      c: char device file​      p: named pipe (FIFO)​      s: socket​        rwx          Read      Write      Execute      -: no permission      Owner                  User, Group, Other                      chmod          Whom: u,g,o,a      What: r,w,x      How: +,-            chown    chgrp  File System 소개  Disk          Collection of contiguous block      Sector, track, cylinder        논리적인 디스크로 나누어서 사용한다  각각의 파티션에 대응되는 디바이스 파일이 있다   Root file system          OS가 동작하는데 필요한 최소한의 file과 directory들로 이루어짐      Kernel system file, /bin,/etc,/lib,/dev        Swap file system          적어도 DRAM사이즈에 두배 이상이다      데이터를 메모리에 저장하기 위해서 사용한다        Usr file system          Utilty files        Home file system          User area      Login directories, etc        File System Structure  각각의 파일 시스템은 4개 영역으로 나뉜다.          Boot block                  파일 시스템의 첫번째 블록          파일 시스템을 구동하기 위한 시스템이 위치                    Super block                  Boot block 바로 다음의 영역          File system을 관리하는 정보가 저장됨          DRAM,disk에서 카피가 있다          관리자 유저가 “sync”를 사용할 수 있다                    i-node block list                  Super block 다음의 영역          각 파일당 하나의 i-node가 대응한다          File 관리에 필요한 정보 저장                    Data block                  마지막 영역          파일들의 실제 내용이 저장                      File System Mount/Unmount  각각의 파일 시스템은 트리 형태로 표현가능하다  파일 시스템이 여러개면 파일 트리도 여러개 일 것이다  두개 이상의 파일 시스템을 합치는 것을 mount라고 하고 반대를 unmount라고 한다",
        "url": "/st-02"
    }
    ,
    
    "pl-03": {
        "title": "프로그래밍 언어가 프로그램 설계 방법에 준 영향",
            "author": "lee989898",
            "category": "",
            "content": "프로그래밍 언어가 프로그램 설계 방법에 준 영향역사적으로 프로그래밍 언어는 응용의 표현에 적합한 개념이 추가되면서 발전되어 왔으며,  ​그 개념의 활용에 필요한 프로그램 설계 방법이 개발되었다. 이에 대해 간략히 간단히 살펴 보자.      50년대와 60년대 초반에는 숫자 계산을 주로 수행하는 수치 해석 등 비교적 단순한 응용이 컴퓨팅의 주류를 이루었고, 이들 프로그램은 수식 표현이 용이한 Fortra n으로 작성되었다. 이러한 이유로 프로그램 설계 방법은 기계(컴퓨팅 자원)의 효율적 사용 방법을 찾는데 집중되었다.        60년대 후반에는 프로그램의 데이터 처리 절차가 복잡해지고 타인이 작성한 프로그램을 이해하고 수정하기가 어려워지면서, 기계의 효율적 사용보다 프로그래머의 효율(생산성)에 관심이 집중되었다. 따라서 프로그램의 가독성(readability), 다양한 컨트롤 스트럭처에 의한표현의 편리성이 언어의 중요한 요소로 인식되고, 이를 지원하는 ALGOL 언어가 등장했다. 이러한 언어를 통해 구조적 프로그래밍, 하향식 설계, 단계적 정련 기법 등 프로그래밍 기법 또는 설계 방법이개발되었다. 여기서 컨트롤 스트럭처란 if-then, loop, {중괄호} 등과 같이 인풋의 처리 로직을 표현하는 데 사용되는 구조를 말한다.        1970년대 후반에는 데이터의 구조가 복잡해지면서,처리 절차 중심의 프로그램 설계에서 데이터 중심의 프로그램 설계로 옮겨갔다.이를 위해 데이터 추상화 기법이 창안되었다.데이터 추상화 기법은 데이터를 구조화하고, 이 데이터에 대한 연산을 정의한다. 이와 같은 데이터 추상화 기법은 추상 데이터 타입을 지원하는 프로그래밍 언어를 탄생시켰다.이것이 바로 ALGOL을 발전시킨 Pascal의 등장이다.Pascal은 Java가 등장하기 전까지 모든 컴퓨터 관련 학과에서 필수 언어로 가르쳤다.        1980년 중반에 데이터 추상화, 상속(속성, 메소드), 동적 바인딩을 특징으로 하는 객체 지향 언어가 등장하여지금까지 이어오고 있다.C++, Java 등이 대표적인 언어로, 이들 특징은 이후의 다른 언어에서도 지원할 수 있을 정도로 일반적이다.  이 그림은 널리 사용되어 온 프로그래밍 언어의 족보를 보여주고 있다.  많은 언어가 생멸하는 와중에 지속적인 발전이 있었음을 알 수 있다.  눈여겨 볼만한 중요한 언어로는 FORTRAN, COBO L, COMMON LISP, Pascal, C, C++, Java 등이다.",
        "url": "/pl-03"
    }
    ,
    
    "pl-02": {
        "title": "왜 PL을 공부하는가?",
            "author": "lee989898",
            "category": "",
            "content": "왜 PL을 공부하는가?프로그래밍 언어는 알고리즘 또는 계산을 표현하는데 적합하도록 설계된 인공  언어이다.  프로그램은 알고리즘을 프로그래밍 언어로 코딩한 것으로, 데이터 입력,  입력 데이터 처리, 데이터 출력으로 구성된다.언어의 특징을 이해하면, 효과적인 알고리즘의 개발 능력과 언어 활용 능력을  개선 할 수 있다.  대표적인 특성을 예를 들면, 객체지향성, recursion, call by value,  call by reference 등이 있다.응용의 특성에 더욱 적합한 PL을 선택할 수 있게 되고 새로운 언어 학습 능력을  올려주고 새로운 언어를 더욱 쉽게 설계 할 수 있다.  또한 구현 시스템의 중요성을 이해할 수 있다.  구현 이슈 예로는 아래 두가지가 있다.  Recursion과 Loop 중에서 어느 것이 더욱 효율적인가?  작은 서브프로그램을 자주 호출하는 것은 좋은 방법인가?   (Recursion이나 서브 프로그램 호출 비용에 비해 실행 시간이 너무 짧다면,성능을 떨어뜨리기 때문에, Loop을 사용하거나 서브 프로그램을 일정 규모 이상으로 설계하는 것이 좋다.)응용의 특성에 대한 적절한 PL의 선택의 예  Fortran포트란은 부동점 소수를 4바이트로 표현하고, double precision은 8 바이트로 표한하기 때문에 부동점 소수 계산에 강점이 있다. 또한 데이터 구조로 배열을 지원하며, 2차원 배열로 매트릭스를 표현한다. 이러한 이유들로 숫자 계산을 주로 수행하는 과학 응용에서 사용된다.  COBOL입출력 데이터는 여러 데이터 필드로 구성된 레코드 구조이며, 각 필드는 숫자와 문자값을 갖는다. 십진수, 문자를 주로 처리하여  비즈니스 응용에 주로 사용된다.  Lisp심볼릭 컴퓨팅을 주로 수행하는 인공 지능 응용에서 주로 사용된다. 데이터를 링크드 리스트로 표현하며 문자열의 조작에 특화되어 있다.PL의 범주에는 세가지가 있다.  명령/절차적 언어(imperative, procedural)  함수적 언어  논리적 언어 etc) 객체지향 언어는 명령/절차적 언어에서 파생된 것으로서, 별도의 범주로 다루지 않는다.컴퓨터는 명령어를 받아서 연산을 수행한다. 따라서 프로그래밍은 컴퓨터에게 절차적 명령어를 보내는 것과 같다. 아래 코드를 보자.int fact(int n) {    int sofar = 1;    while(n &gt; 0) sofar *= n--;    return sofar;}fact(n)은 n!을 계산하는 함수이며,  함수안에 정의된 sofar는 현재까지 계산된 n!값을 간직하는 변수이다. ​ while loop을 끝까지 돌려보면 n에서 시작하여 n=1일 때까지 계속 곱셈을 실행한다. ​ 즉, sofar는 1에서 n까지 곱한 결과이다.오늘날 모든 컴퓨터는 본 뉴만 아키텍처로 구성되어 있기 때문에, PL은 이 아키텍처를 모방하고 있다. ​아래 그림이 본 뉴만 아키텍처이다.  본 뉴만 아키텍처 컴퓨터에서는 다음과 같이 프로그램을 실행한다.메모리는 프로그램과 메모리를 저장하고, CPU는 연산을 수행한다.프로그램을 실행하려면, 먼저 프로그램과 데이터를 메모리에 저장해야한다. PC(program counter)를 프로그램의 첫번째 명령어 위치로 초기화하고, ​PC가 가리키는 명령어를 Control unit(Decoder 포함)에 적재한다.Control unit(Decoder)는 명령어의 의미(무슨 연산을 해야할지)를 해석하고,​데이터를 레지스터에 적재하여 ALU에서 연산을 수행한다. 연산이 끝나면 그 결과를 메모리에 저장하거나 출력 장치로 내보낸다. 연산 뿐만 아니라 control structure(loop, if-then, etc)도 PC와 control unit에 의해 통제된다.메모리에서 인스트럭션을 CPU로 가져와서 실행하는 반복적인 절차를 Fetch-execute-cycle이라고 한다.Fetch-execution 사이클이 실행하는 인스트럭션은 어셈블리 코드 또는 머신 코드이다. 머신 코드는 컴퓨터가 이해할 수 있는 명령어이고, 어셈블리 코드는 머신코드를 기호로 표현한 것이다.​  Fetch-execution cycle은 다음과 같다. ​  PC를 초기화한다. ​  PC가 가리키는 명령어를 fetch하고 ​  PC를 증가시킨 다음, ​  Fetch한 명령어를 decod하여 ​  실행한다. ​더 이상 실행할 명령어가 없을 때까지 1~4를 반복적으로 실행한다. ​팩토리얼 함수를 예로 들어보자. 여기서는 메모리와 CPU간의 데이터 이동에 대해 살펴보도록 하자.컴퓨터가 고급언어를 머신코드로 번역하지 않고 이해할 수는 없지만, ​설명을 위해 고급 언어를 컴퓨터가 직접 이해한다고 가정한다.변수 sofar과 n은 메모리에서 공간을 잡고 값을 저장하고 있으며, ​프로그램 코드는 메모리에 저장되어 있다. PC가 int sofar를 읽어 오면 Control unit은 =을 assignment로 해석하여 sofar에 1을 할당한다. PC가 while loop의 sofar *=n–를 읽어 오면 ALU에서 반복적으로 n!을 계산하고,PC가 return sofar를 읽어 오면 sofar 값을 메모리에 저장한다. ​  이와 같이 명령/절차적 언어는 본 뉴만 아키텍처에 적합하게 다음과 같이 실행된다.    ​  프로그램의 변수는 메모리 셀을 지칭하고, 그 셀에 저장된 값을 대표한다. ​  Assignment 문장은 메모리와 CPU 간의 데이터를 이동시킨다. ​  연산과 표현식(expression)은 CPU에서 실행된다. ​  실행 흐름의 명시적 통제는 프로그램 카운터에 의한다. ​현재 널리 사용되고 있는 C, C++, Java는 이런 유형의 PL이다. ​명령/절차적 언어는 실행 성능의 최적화를 위한 언어와 하드웨어 간의 효율적 매핑을 허용하지만,본 뉴만 아키텍처에 의해 제한된다.고급어 프로그램은 컴파일러에 의해 어셈블리어 프로그램으로 번역되고 ​어셈블리어 프로그램은 어셈블러에 의해 기계어 프로그램으로 번역된다. 기계어 프로그램은 인터프리터에 의해 ALU 연산으로 해석되어 실행된다.     ​어셈블리어 프로그램은 RISC 아키텍처의 인스트럭션을 포함하고 있다. RISC 아키텍처는 인스트럭션 집합을 가능한 줄이고 단순화시켜 성능 개선을 이룩한 사례로 남아 있다. ​함수적 프로그래밍은 수학 함수식과 유사하다. ​각 서브 프로그램은 함수의 구현이다.fun fact x =    if x &lt;= 0    then 1    else x * fact(x-1); ​코드는 ML 언어로 팩토리얼을 구하는 프로그램을 보여주고 있다. Fact 내에서 fact를 호출하는 Recursion을 사용하고 있다.또 다른 함수 언어로 리스프를 들 수 있다. ML과 달리 변수와 assignment가 없다. 이 말은 변수로 인해 고정적으로 소비되는 메모리가 없다는 말이다. 즉, 필요시 동적으로 메모리를 할당하고 계산한다. ML과 마찬가지로 리커전을 컨트롤 구조로 갖고 있다. 이후 리스프는 변화를 겪으면서 사용되고 있다.​로직 프로그래밍은 술어 논리(predicate logic)에 기반하고 있다. 로직 프로그램은 사실(fact), 규칙(rule), 목표(goal)로 구성되어 있으며,로직 프로그램의 실행은 목표에 사실과 규칙을 적용하여 목표가 논리적으로 추론될수 있는지, 다시 말하면 참인지 거짓인지 증명하는 절차이다. 이를 위해 추론 엔진이 필요한데, ​로직 프로그램의 추론은 resolutionreputation에 의한 추론 엔진을 사용한다. 이 프로그램에서 grandparent(vern, kake)가 추론될 수 있는 살펴보자.​fact:  mother(joanne,jake).​  father(vern,joanne).​ rule:  grandparent(X,Z) :- parent(X,Y),​           parent(Y,Z).​goal:  grandparent(vern,jake). ​규칙 grandparent(X,Z) :- parent(X,Y), parent(Y,Z)에 X, Z에 각각 vern, jake를 대입하면,  ​ grandparent(vern,Z) :- parent(X,Y), parent(Y,jake)가 추론된다.  사실의 mother, father 모두 parent이므로, parent(joanne, jake), parent(vern, joanne)이다. ​로직 프로그래밍 언어는 프로그램에 입력 데이터에서 출력 데이터를 생성하는 절차를 서술하는 것이 아니라, ​ 사실과 규칙을 술어 논리로 선언하고, 원하는 것(목표)가 무엇인지 선언한다. ​ 따라서 로직 프로그래밍 언어는 비절차적(선언적)이다.로직 프로그래밍은 resolution을 해야 하기 때문에, 매우 비효율적(느리다)이다. 따라서 응용 분야가 대단히 좁다.(DB, AI)factorial 계산하는 프로그램을 보자fact(X,1) :- X =:= 1.fact(X, Fact) :-    X &gt; 1, NewX is X - 1,    fact(NewX, NF),    Fact is X * NF보기엔 깔끔해 보일 수 있지만, resolution해서 풀려면 오래걸린다.",
        "url": "/pl-02"
    }
    ,
    
    "pl-01": {
        "title": "프로그래밍 언어란?",
            "author": "lee989898",
            "category": "",
            "content": "프로그래밍 언어란?프로그래밍 언어는 인공적으로 설계된 언어로 컴퓨터가 실행할 수 있는 계산이나  알고리즘을 표현하는 수단이다.인간은 언어로 타인에게 자신의 생각을 표현하듯이 프로그래밍 언어는  자신의 생각을 컴퓨터에게 표현하는 수단이다.  프로그래밍 언어는 왜 이렇게 다양할까?그 이유는 문제의 특성에 따라, 프로그램이 각기 요구하는 프로그래밍  언어의 표현력이 다르기 때문이다.  표현력은 언어 선택에 있어 매우 중요하다.  문제해결에 적합한 언어를 선택하려면 아래 내용을 숙지해야 한다.  언어가 다르면, 알고리즘의 표현이 어떻게 다른가? ​  어떤 언어가 더 적합한가? 언어의 적합성(goodness)을 어떻게 평가할 것인가? ​  왜 이렇게 다른 언어가 많은가? ​  도대체 프로그래밍 언어가 뭔가? ​  프로그래밍 언어의 특성이 왜 이렇게 많은가? ​  이들 특성은 어떻게 구현시스템에서 실현되는가?​ (여기서 구현 시스템이란   컴파일러나 인터프리터 등 PL을 실행   할 수 있는 소프트웨어를 말한다.) ​  위 그림 PL의 트렌드에 따른 언어를 살펴보면 다음과 같은 특성을 갖고 있다.  타입의 안정성을 고려한 언어의 사용 증가: C,C++에 비해 Java, C# 타입이 안정적임  웹 응용을 위해 클라이언트 측의 기능성을 갖춘 스크립트 언어  신택스 보다 알고리즘의 표현력에 중점을 둔 언어  컴파일, 분석, 타입 검사 등 실행 환경과 가상화를 갖춘 언어  자동 오류 탐지 및 복구 등 프로그램 분석 능력을 갖춘 언어  PL에 영향을 미치는 요인을 표현력과 구현 시스템의 효율 측면에서 살펴보면 다음과 같다.      표현력: 응용 도메인의 특성과 프로그래밍 방법을 들 수 있다.     다중 프로그래밍은 큰 작업(프로그램)이 여러 개의 작은 작업(서브프로그램)으로    나뉘어져서 서로 연관성을 가지고 동시에 실행되는 것을 말한다.    물론 동시라는 말은 특정 시간에는 작은 작업 하나가 실행되지만,     타임 피리어드 동안 여러 개의 작은 프로그램이     동시에 처리되는 것으로 보이게 된다.    이것은 CPU의 시분할과 메모리의 공간 분할에 의해 이루어진다.     이렇게 하여 큰 프로그램 하나가 다른 프로그램의 방해없이    여러 개의 작은 서브프로그램으로 나누어져 처리될 수 있는 것이다.  ​        언어 구현 시스템의 효율성: 즉 컴파일러나 인터프리터의 성능을 말한다.    컴파일러나 인터프리터의 성능은 주로 컴퓨터 구조, OS, 관련 도구, 라이브러리 등에 달려 있다.     편의성은 비용을 수반한다.     추상적 관점을 지원하면 편의성은 좋아지지만, 이것을 머신에     표현하는데는 나름의 비용이 들어간다.    이러한 사실을 고려하여 편의성과 비용간에 균형을 잡는 것이     중요하다.   ​  ",
        "url": "/pl-01"
    }
    ,
    
    "algorithm-01": {
        "title": "알고리즘",
            "author": "lee989898",
            "category": "",
            "content": "알고리즘  알고리즘  문제를 해결하기 위한 단계적 절차 또는 방법  순서대로 구체적이고 명확하게 기술해야 함  유효한 입력을 받아 실행한 결과인 해(답)를 출력​  알고리즘의 3가지 조건  명확성          알고리즘의 각 단계는 애매모호하지 않고 명확해야 한다.        정확성          모든 유효한 입력에 대해 올바른 해를 출력해야 한다.        정지성          유효한 입력이 주어지면 유한한 시간 내에 종료되어야 한다.        알고리즘의 효율성  시간 효율성          얼마나 빨리 실행되는 지를 나타낸다.        공간 효율성          컴퓨터 메모리를 얼마나 사용하는지를 나타낸다.        코드 효율성          코드가 얼마나 이해하기 쉬운가를 나타낸다.      알고리즘적 문제 해결 과정​알고리즘의 표현  알고리즘의 표현  자연어(한글 또는 영어)  의사 코드(Pseudocode)  순서도(Flowchart)  프로그래밍 언어(자바, C 또는 파이선 등)  예: 최댓값 찾기 알고리즘  한글          배열의 첫 번째 요소를 최댓값으로 정한다.      배열의 다음 요소가 최댓값보다 크다면 최댓값을 그 요소로 바꾼다.      배열 내에 비교할 요소가 남아 있으면 2단계로 가고 아니면 종료한다.        의사 코드FindMaximum(A[0 . . N - 1])​      // 배열 내의 최댓값을 찾는다.​      // 입력: 크기가 N(&gt; 1)인 숫자들의 배열 A​// 출력: 배열 A내의 최댓값​max = A[0]​      for (i = 1; i &lt; N; i++)​if (A[i] &gt; max) max = A[i]​            ​     return max​  프로그래밍 언어(자바)public class FindMaximum {​         public static void main(String[] args) {​        int[ ] intArray  =  {72, 60, 83, 47, 89, 95};​        int   maximum;​        maximum =  findMaximum(intArray);​        System.out.println(\"최댓값 = \" + maximum);​        }​    public static int findMaximum(int[ ] A) {​        int i, max;​        max = A[0]; ​        for (i = 1 ; i &lt; A.length ; i++)​           if (A[i] &gt; max) max = A[i];​        return  max;​        }​    }​알고리즘의 분류  알고리즘 설계 기법  분할 정복(Divide-and-Conquer)​  동적 계획(Dynamic Programming)​  탐욕 기법(Greedy Technique)​  되추적(Backtracking)​  분기한정(Branch-and-Bound)​  억지 기법(brute-force technique)​  무작위(random) 알고리즘​  근사(approximate) 알고리즘​  병렬(parallel) 알고리즘​  분산(distributed) 알고리즘​  양자(quantum) 알고리즘​  유전자(genetic) 알고리즘​  문제 유형에 따른 알고리즘의 분류  정렬(sorting) 알고리즘​  탐색(searching) 알고리즘​  문자열 처리(string processing) 알고리즘​  그래프(graph) 알고리즘​  조합(combinatorial) 알고리즘​  기하학적(geometric) 알고리즘​  수치(numerical) 알고리즘​",
        "url": "/algorithm-01"
    }
    ,
    
    "st-01": {
        "title": "System Call",
            "author": "lee989898",
            "category": "",
            "content": "System Call  System Calls and Library Functions      System Call: 운영체제의 커널(kernal) 서비스를 받기 위한 일종의 함수 호출        ​System Call의 구조     Library Functions          ex) printf(), scanf(), fopen(), fclose(), gets(), puts(), getw(), fread(), fseek()      대게 system calls을 호출합니다.        System Calls          ex) open(), create(), close(), read(), write(), lseek(), unlink()      user’s program에서 호출할 수 있다      커널 함수를 호출하는 C 함수처럼 보인다        System Call Structure  user 프로그램이 system call을 사용하면 커널 서비스를 호출한다  Two phases          User code 실행 -&gt; user space/mode      Kernel code 실행 -&gt; kernel space/mode        Kernel mode          일반적으로 interrupts와 같은 예외에 의해 활성화된다      trap(SW interrupts)에 의한 시스템 호출 내에서 활성화된다        System Call Table entries          System call no: 3,4      No of parameters: 3,3      Routine name: read, write         System Calls: No &amp; Name  Exit  Fork  Read  Write  Open  Close  Wait  Create",
        "url": "/st-01"
    }
    ,
    
    "sc-01": {
        "title": "Intro",
            "author": "lee989898",
            "category": "",
            "content": "Intro  컴퓨터 보안이란?컴퓨터 hw,sw, 데이터의 도난이나 손상, 컴퓨터가 제공하는 서비스의 중단 또는 오용으로부터 컴퓨터 시스템을 보호보안의 대상: information system resource (hardware, software,data,communication facilities and network)보안의 목표: CIA Triad + Authentication  Key Concepts 1: Confidentiality  Secrecy이라고도 함  기밀성,비밀성  송신자와 수신자만이 내용을 알 수 있게 하는 것  허가된 사용자, 장비만이 data 내용을 알 수 있도록 하는 것  주요 공격: eavesdrop(도청), interception  Confidentiality를 지키기 위한 Solution : Encrypt,decrypt  Key Concepts 2: Integrity  무결성  원본 그대로임을 보장. 변조가 없다는 것 혹은 변경이 있었음을 알게 됨  주요 공격: modification  Integrity를 지키기 위한 Solution: hash  Key Concepts 3: Availablilty  가용성  합법적인 사용자가 허가된 시간에 데이터나 서비스에 access 가능하게 하는것  주요공격: interruption, DDos attack  Key Concepts 4: Authentication  인증  송수신자 서로간의 신원확인  주요공격: impersonation  Authentication을 지키기 위한 Solution: 전자서명, 공인인증서",
        "url": "/sc-01"
    }
    ,
    
    "kotlin-10": {
        "title": "DSL 만들기",
            "author": "lee989898",
            "category": "",
            "content": "DSL 만들기",
        "url": "/kotlin-10"
    }
    ,
    
    "kotlin-09": {
        "title": "애노테이션과 리플렉션",
            "author": "lee989898",
            "category": "",
            "content": "애노테이션과 리플렉션",
        "url": "/kotlin-09"
    }
    ,
    
    "kotlin-08": {
        "title": "제네릭스",
            "author": "lee989898",
            "category": "",
            "content": "제네릭스",
        "url": "/kotlin-08"
    }
    ,
    
    "kotlin-07": {
        "title": "고차 함수, 파라미터와 반환 값으로 람다 사용",
            "author": "lee989898",
            "category": "",
            "content": "고차 함수, 파라미터와 반환 값으로 람다 사용  흐름을 제어하는 키워드  break: 반복문 내의 구문이 실행되는 중간에 즉시 반복문을 종료하고 다음 구문으로 넘어가는 역할을 한다.  continue: 다음 반복조건으로 즉시 넘어가는 역할을 합니다.fun main(){       for(i in 1..10){       if(i == 3) break       print(i)   }      for(j in 1..10){       if(j == 3) continue       print(j)   }    }코틀린은 다중 반복문에서 break나 continue가 적용되는 반복문을 label을 통해 지정할 수 있는 기능이 있습니다.fun main(){       loop@for(i in 1..10){       for(j in 1..10){           if(i == 1 &amp;&amp; j == 2) break@loop           println(&quot;i : $i, j : $j&quot;)       }   }    }  논리연산자논리 값을 연산하여 새로운 논리값을 도출할 떄 쓰는 연산자입니다  &amp;&amp; : 둘다 true인 경우 결과값이 true입니다.  || : 하나라도 true이면 결과값이 true입니다.  ! : 뒤에 붙는 값을 반전시킵니다.fun main(){        println(true &amp;&amp; false)    println(true || false)    println(!false)    println(!true)        var a = 6    var b = 4        println(a &gt; 5 &amp;&amp; b &gt; 5)     }",
        "url": "/kotlin-07"
    }
    ,
    
    "kotlin-06": {
        "title": "연산자 오버로딩과 기타 관례",
            "author": "lee989898",
            "category": "",
            "content": "연산자 오버로딩과 기타 관례",
        "url": "/kotlin-06"
    }
    ,
    
    "kotlin-05": {
        "title": "코틀린 타입 시스템",
            "author": "lee989898",
            "category": "",
            "content": "코틀린 타입 시스템",
        "url": "/kotlin-05"
    }
    ,
    
    "kotlin-04": {
        "title": "람다로 프로그래밍",
            "author": "lee989898",
            "category": "",
            "content": "코틀린 테이블    코틀린 기초    함수 정의와 호출    클래스, 객체, 인터페이스    람다로 프로그래밍    코틀린 타입 시스템    연산자 오버로딩과 기타 관례    고차 함수: 파라미터와 반환 값으로 람다 사용    제네릭스    애노테이션과 리플렉션    DSL 만들기  람다 식과 멤버 참조  함수형 스타일로 컬렉션 다루기  시퀀스: 지연 컬렉션 연산  자바 함수형 인터페이스를 코틀린에서 사용  수신 객체 지정 람다 사용람다 식과 멤버 참조  람다 소개 : 코드 블록을 함수 인자로 넘기기함수형 언어에서는 함수를 직접 다른 함수에 전달할 수 있다무명 내부 클래스로 리스너 구현하기button.setOnClickListener(new OnClickListener(){    @Override    public void onClick(View view){        // 클릭시 수행할 동작    }})람다로 리스너 구현하기button.setOnclickListener{ // 클릭시 수행할 동작}람다는 메소드가 하나뿐인 무명 객체 대신 사용할 수 있다  람다와 컬렉션컬렉션을 다룰 때 수행하는 대부분의 작업은 몇 가지 일반적인 패턴에 속한다data class Person(val name: String, val age: Int)사람들로 이뤄진 리스트가 있고 그중에 가장 연장자를 찾아보자. 람다를 사용해본 경험이 없는 개발자라면 루프를 써서 직접 검색을 구현할 것이다fun findTheOldest(people: List&lt;Person&gt;){    var maxAge = 0    var theOldest: Person? = null    for(person in people){        if(person.age &gt; maxAge){            maxAge = person.age            theOldest = person        }    }    println(theOldest)}&gt;&gt;&gt; val people = listOf(Person(\"Alice\", 29), Person(\"Bob\", 31))&gt;&gt;&gt; findTheOldest(people)Person(name = Bob, age = 31)코틀린에서는 더 좋은 방법이 있다. 라이브러리 함수를 쓰면 된다람다를 사용해 컬렉션 검색하기&gt;&gt;&gt; val people = listOf(Person(\"Alice\",29), Person(\"Bob\", 31))&gt;&gt;&gt; println(people.maxBy{ it.age })Person(name=Bob, age=31)모든 컬렉션에 대해 maxBy함수를 호출할 수 있다. {it.age}는 바로 비교에 사용할 값을 돌려주는 함수다멤버 참조를 사용해 컬렉션 검사하기people.maxBy(Person::age)위 코드는 그 위에 코드와 같은 일을 한다  람다 식의 문법람다는 값처럼 여기저기 전달할 수 있는 동작의 모음이다. 함수에 인자로 넘기면서 바로 람다를 정의하는 경우가 대부분이다코틀린 람다 식은 항상 중괄호로 둘러싸여 있다. 인자 목록 주변에 괄호가 없다화살표가 인자 목록과 람다 본문을 구분해준다. 람다 식을 변수에 저장할 수 있다. 람다가 저장된 변수를 다른 일반 함수와 마찬가지로 다룰 수 있다&gt;&gt;&gt; val sum = { x: Int, y: Int, -&gt; x + y}&gt;&gt;&gt; println(sum(1,2))3코드의 일부분을 블록으로 둘러싸 실행할 필요가 있다면 run을 사용한다. run은 인자로 받은 람다를 실행해 주는 라이브러리 함수다&gt;&gt;&gt; run{ println(42) }42&gt;&gt;&gt; val people = listOf(Person(\"Alice\",29), Person(\"Bob\", 31))&gt;&gt;&gt; println(people.maxBy{ it.age })Person(name=Bob, age=31)위 코드에서 정식으로 람다를 작성하면 다음과 같다people.maxBy({p: Person -&gt; p.age})하지만 위 코드는 번잡하다. 구분자가 너무 많이 쓰이고 인자 타입을 굳이 적을 필요는 없다코틀린에는 함수 호출 시 맨 뒤에 있는 인자가 람다 식이라면 그 람다를 괄호 밖으로 빼낼 수 있다는 문법 관습이 있다people.maxBy() {p: Person -&gt; p.age}위 코드처럼 람다가 어떤 함수의 유일한 인자이고 괄호 뒤에 람다를 썼다면 호출 시 빈괄호를 없애도 된다people.maxBy {p: Person -&gt; p.age}인자가 여럿 있는 경우에는 람다를 밖으로 빼낼 수도 있고 람다를 괄호 안에 유지해서 함수의 인자임을 분명히 할 수도 있다. 둘 이상의 람다를 인자로 받는 함수라고 해도 인자 목록의 맨 마지막 람다만 밖으로 뺄 수 있다. 따라서 그런 경우에는 괄호를 사용하는 일반적인 함수 호출 구문을 사용하는 편이 낫다이제 구문을 더 간단하게 다듬고 파라미터 타입을 없앤다people.maxBy { p -&gt; p.age }로컬 변수처럼 컴파일러는 람다 파라미터의 타입도 추론할 수 있다. 람다의 파라미터 이름을 디폴트 이름인 it으로 바꾸면 람다 식을 더 간단하게 만들 수 있다. 람다의 파라미터가 하나뿐이고 그 타입을 컴파일러가 추론할 수 있는 경우 it을 바로 쓸 수 있다. 람다 파라미터 이름을 따로 지정하지 않은 경우에만 it이라는 이름이 자동으로 만들어진다people.maxBy { it.age} // it은 자동 생성된 파라미터 이름이다람다를 변수에 저장할 때는 파라미터의 타입을 추론할 문맥이 존재하지 않는다. 따라서 파라미터 타입을 명시해야 한다&gt;&gt;&gt; val getAge = { p: Person -&gt; p.age}&gt;&gt;&gt; people.maxBy(getAge)본문이 여러 줄로 이뤄진 경우 본문의 맨 마지막에 있는 식이 람다의 결과 값이 된다  현재 영역에 있는 변수에 접근람다를 함수 안에서 정의하면 함수의 파라미터뿐 아니라 람다 정의의 앞에 선언된 로컬 변수까지 람다에서 모두 사용할 수 있다함수 파라미터를 람다 안에서 사용하기fun printMessagesWithPrefix(messages: Collection&lt;String&gt;, prefix: String){    messages.forEach{        println(\"$prefix $it\") // 람다 안에서 함수의 prefix 파라미터를 사용한다    }}&gt;&gt;&gt; val errors = listOf(\"403 Forbidden\", \"404 Not Found\")&gt;&gt;&gt; printMessagesWithPrefix(erros, \"Error: \")Error: 403 ForbiddenError: 404 Not Foundss람다 안에서 바깥의 변수를 변경해도 된다람다 안에서 바깥 함수의 로컬 변수 변경하기fun printProblemCounts(responses: Collcetion&lt;String&gt;){    var clientErrors = 0    var serverErrors = 0    responsers.forEach{        if(it.startsWith(\"4\")){            clientErrors++        }else if(it.startsWith(\"5\")){            serverErrors++        }    }    println(\"$clientErrors client erros, $serverErrors server errors\")}&gt;&gt;&gt; val responses = listOf(\"200 OK\", \"418 I'm a teapot\", \"500 Internal Server Error\")&gt;&gt;&gt; printProblemCounts(responses)1 client errors, 1 server errors위와 같이 람다 안에서 사용하는 외부 변수를 람다가 포획한 변수라고 부른다. 어떤 함수가 자신의 로컬 변수를 포획한 람다를 반환하거나 다른 변수에 저장한다면 로컬 변수의 생명주기와 함수의 생명주기가 달라질 수 있다  멤버 참조코틀린에서는 함수를 값으로 바꿀 수 있다. 이떼 이중 콜론을 사용한다val getAge = Person::age::를 사용하는 식을 멤버 참조라고 부른다. 멤버 참조는 프로퍼티나 메소드를 단 하나만 호출하는 함수 값을 만들어준다people.maxBy(Person::age)people.maxBy(p -&gt; p.age)people.maxBy(it.age)최상위에 선언된 함수나 프로퍼티를 참조할 수도 있다함수형 스타일로 컬렉션 다루기  필수적인 함수 : filter와 mapfilter와 map은 컬렉션을 활용할 때 기반이 되는 함수다filter 함수는 컬렉션을 이터레이션하면서 주어진 람다에 각 원소를 넘겨서 람다가 true를 반환하는 원소만 모은다&gt;&gt;&gt; val list = listOf(1,2,3,4)&gt;&gt;&gt; println(list.filter { it % 2 == 0})[2, 4]&gt;&gt;&gt; val people = listOf(Person(\"Alice\", 29), Person(\"Bob\", 31))&gt;&gt;&gt; println(people.filter {it.age &gt; 30})[Person(name=Bob, age=31)]filter 함수는 컬렉션에서 원치 않는 원소를 제거한다. 하지만 원소를 변환할 수는 없다map 함수는 주어진 람다를 컬렉션의 각 원소에 적용한 결과를 모아서 새 컬렉션을 만든다&gt;&gt;&gt; val list = listOf(1, 2, 3, 4)&gt;&gt;&gt; println(list.map { it * it})[1,4,9,16]&gt;&gt;&gt; val people = listOf(Person(\"Alice\",29), Person(\"Bob\", 31))&gt;&gt;&gt; println(people.map {it.name})[Alice, Bob]위 코드를 멤버 참조를 사용해 작성할 수도 있다people.map(Person::name)  all,any,count,find : 컬렉션에 술어 적용all과 any는 컬렉션에 대해 자주 수행하는 연산으로 컬렉션의 모든 원소가 어떤 조건을 만족하는지 판단한다count는 조건을 만족하는 함수의 개수를 반환하며, find 함수는 조건을 만족하는 첫 번째 원소를 반환한다val canBeInClub27 = { p: Person -&gt; p.age &lt;= 27}&gt;&gt;&gt; val people = listOf(Person(\"Alice\", 27), Person(\"Bob\", 31)) // 모든 원소가 이 술어를 만족하는지&gt;&gt;&gt; println(people.all(canBeInClub27))false&gt;&gt;&gt; println(people.any(canBeInClub27)) // 술어를 만족하는 원소가 하나라도 있는지true&gt;&gt;&gt; println(people.count(canBeInClub27)) // 술어를 만족하는 원소의 개수1&gt;&gt;&gt; println(people.find(canBeInClub27)) // 술어를 만족하는 원소를 하나 찾기 가장 먼저 조건을 만족하는 원소 반환Person(name=Alice, age=27)어떤 조건에 대해 !all을 수행한 결과와 그 조건의 부정에 대해 any를 수행한 결과는 같다. 또 어떤 조건에 !any를 수행한 결과와 그 조건이 부정에 대해 all을 수행한 결과도 같다  groupBy : 리스트를 여러 그룹으로 이뤄진 맵으로 변경&gt;&gt;&gt; val people = listOf(Person(\"Alice\",31), Person(\"Bob\", 29), Person(\"Carol\", 31))&gt;&gt;&gt; println(people.groupBy { it.age })위 연산의 결과는 컬렉션의 원소를 구분하는 특성이 키이고 ,키 값에 따른 각 그룹이 값인 맵이다각 그룹은 리스트다. 따라서 groupBy의 결과 타입은 Map&lt;Int, List&lt; Person »이다  flatMap과 flatten : 중첩된 컬렉션 안의 원소 처리class Book(val title: String, val authors: List&lt;String&gt;)books.flatMap { it.authors}.toSet() // books 컬렉션에 있는 책을 쓴 모든 저자의 집합flatMap 함수는 먼저 인자로 주어진 람다를 컬렉션의 모든 객체에 적용하고 람다를 적용한 결과 얻어지는 여러 리스트를 한 리스트로 한데 모은다&gt;&gt;&gt; val strings = listOF(\"abc\", \"def\")&gt;&gt;&gt; println(strings.flatMap { it.toList()})[a,b,c,d,e,f]toList 함수를 문자열에 적용하면 그 문자열에 속한 모든 문자로 이뤄진 리스트가 만들어진다시퀀스: 지연 컬렉션 연산map이나 filter 같은 함수는 결과 컬렉션을 즉시 생성한다. 이는 컬렉션 함수를 연쇄하면 매 단계마다 계산 중간 결과를 새로운 컬렉션에 임시로 담는다는 말이다. 시퀀스를 사용하면 중간 임시 컬렉션을 사용하지 않고도 컬렉션 연산을 연쇄할 수 있다people.asSequence() // 원본 컬렉션을 시퀀스로 변환한다    .map(Person::name)    .filter { it.startWith(\"A\")}     .toList() // 결과 시퀀스를 다시 리스트로 변환한다Sequence 인터페이스의 장점은 그 인터페이스 위에 구현된 연산이 계산을 수행하는 방법 때문에 생긴다. 시퀀스의 원소는 필요할 때 비로소 계산된다. 따라서 중간 처리 결과를 저장하지 않고도 연산을 연쇄적으로 적용해서 효율적으로 계산을 수행할 수 있다큰 컬렉션에 대해서 연산을 연쇄시킬 때는 시퀀스를 사용하는 것을 규칙으로 삼는 것이 좋다asSequnence 확장 함수를 호출하면 어떤 컬렉션이든 시퀀스로 바꿀 수 있다. 시퀀스를 리스트로 만들 때는 toList를 사용한다  시퀀스 연산 실행 : 중간 연산과 최종 연산시퀀스에 대한 연산은 중간연산과 최종연산으로 나뉜다중간 연산은 다른 시퀀스를 반환한다. 그 시퀀스는 최초 시퀀스의 원소를 변환하는 방법을 안다최종 연산은 결과를 반환한다. 결과는 최초 컬렉션에 대해 변환을 적용한 시퀀스로부터 일련의 계산을 수행해 얻을 수 있는 컬렉션이나 원소, 숫자 또는 객체다중간 연산은 항상 지연 계산된다최종 연산이 없음&gt;&gt;&gt; listOf(1,2,3,4).asSequence()                .map{print(\"map($it) \"); it * it}                .filter{print(\"filter($it)\"); it % 2 == 0}위 코드를 실행하면 아무 내용도 출력되지 않는다. 이는 map과 filter 변환이 늦춰져서 결과를 얻을 필요가 있을 때 적용된다는 뜻이다&gt;&gt;&gt; listOf(1,2,3,4).asSequence()                .map{print(\"map($it) \"); it * it}                .filter{print(\"filter($it)\"); it % 2 == 0}                .toList()map(1) filter(1) map(2) filter(4) map(3) filter(9) map(4) filter(16)최종 연산을 호출하면 연기됐던 모든 계산이 수행된다. 시퀀스에 대한 map과 filter의 모든 연산은 각 원소에 대해 순차적으로 젹용된다첫 번째 원소가 처리되고, 다시 두 번째 원소가 처리되며, 이런 처리가 모든 원소에 대해 적용된다따라서 원소에 연산을 차례대로 적용하다가 결과과 얻어지면 그 이후의 원소에 대해서는 변환이 이뤄지지 않을 수도 있다컬렉션을 사용하면 리스트가 다른 리스트로 변환된다시퀀스를 사용하면 find 호출이 원소를 하나씩 처리하기 시작한다  시퀀스 만들기시퀀스를 만드는 다른 방법으로 generateSequence 함수를 사용할 수 있다. 이 함수는 이전의 원소를 인자로 받아 다음 원소를 계산한다자연수의 시퀀스를 생성하고 사용하기&gt;&gt;&gt; val naturalNumbers = generateSequence(0) { it + 1}&gt;&gt;&gt; val numbersTo100 = naturalNumbers.takeWhile { it &lt;= 100}&gt;&gt;&gt; println(numbetsTo100.sum()) // 모든 지연 연산은 sum의 결과를 계산할 떄 수행된다5050위 코드에서 naturalNumbers와 numbersTo100은 모두 시퀀스며, 연산을 지연 계산한다상위 디렉토리의 시퀀스를 생성하고 사용하기fun File.isInsideHiddenDirectory() =    generateSequence(this) {it.parentFile}.any{it.isHidden}&gt;&gt;&gt; val file = File(\"/Users/svtk/.HiddenDir/a.txt\")&gt;&gt;&gt; println(file.isInsideHiddenDirectory())true자바 함수형 인터페이스를 코틀린에서 사용코틀린 람다를 자바 API에 사용해도 문제가 없다추상 메소드가 하나만 있는 인터페이스를 SAM인터페이스 또는 함수형 인터페이스라고 부른다  자바 메소드에 람다를 인자로 전달함수형 인터페이스를 인자로 원하는 자바 메소드에 코틀린 람다를 전달할 수 있다void postponeComputation(int delay, Runnable computation);postponeComputation(1000) { println(42)}  // 컴파일러는 자동으로 람다를 Runnable 인스턴스로 변환해준다  SAM 생성자 : 람다를 함수형 인터페이스로 명지적으로 변경SAM 생성자는 람다를 함수형 인터페이스의 인스턴스로 변환할 수 있게 컴파일러가 자동으로 생성한 함수다SAM 생성자를 사용해 값 반환하기fun createAllDoneRunnable() : Runnable {    return Runnable { println(\"All done!\")}}&gt;&gt;&gt; createAllDoneRunnable().run()All done!수신 객체 지정 람다 사용  with 함수with는 수신 객체 지정 람다를 활용한다알파벳 만들기fun alphabet(): String{    val result = StringBuilder()    for (letter in 'A'..'Z'){        result.append(letter)    }    result.append(\"\\nNow I know the alphabet!\")    return result.toString()}&gt;&gt;&gt; println(alphabet())ABCDEFGHIJKLMNOPQRSTUVWXYZNow I know the alphabet!아래 코드는 위 코드를 with를 활용해 작성한 코드이다fun alphabet(): String{    val stringBuilder = StringBuilder()    return with(stringBuilder){  // 메소드를 호출하려는 수신 객체를 지정한다        for (letter in 'A'..'Z'){            this.append(letter) // this를 명시해서 앞에서 지정한 수신 객체의 메소드를 호출한다        }        append(\"\\nNow I know the alphabet!\") // this를 생략하고 메소드를 호출한다        this.toString() // 람다에서 값을 반환한다    } }with 함수는 첫 번째 인자로 받은 객체를 두 번째 인자로 받은 람다의 수신 객체로 만든다. 위 코드에서 this는 with의 첫 번째 인자로 전달된 stringBuilder이다. stringBulder의 메소드를 this.append(letter)처럼 this 참조를 통해 접근하거나 append(“\\nNow…”) 처럼 바로 호출할 수 있다with와 식을 본문으로 하는 함수를 활용해 알파벳 만들기fun alphabet() = with(StringBuilder()){    for (letter in 'A'..'Z'){        append(letter)    }    append(\"\\nNow I know the alphabet!\")    toString()}with가 반환하는 값은 람다 코드를 실행한 결과며, 그 결과는 람다 식의 본문에 있는 마지막 식의 값이다람다의 결과 대신 수신 객체가 필요할 때는 apply 함수를 사용할 수 있다  apply 함수apply함수는 거의 with와 같다. 유일한 차이는 항상 자신에게 전달된 객체를 반환한다는 점뿐이다apply를 사용해 알파벳 만들기fun alphabet() = StringBuilder().apply{    for (letter in 'A'..'Z'){        append(letter)    }    append(\"\\nNow I know the alphabet!\")}.toString()apply는 확장 함수로 정의돼 있다. 위 함수에서 apply를 실행한 결과는 StringBuilder 객체다. 따라서 그 객체의 toString을 호출해서 String 객체를 얻을 수 있다apply를 TextView 초기화에 사용하기fun createViewWithCustomAttributes(context: Context) =    TextView(context).apply{        text = \"Sample Text\"        textSize = 20.0        setPadding(10, 0, 0, 0)    }apply 함수를 사용하면 함수의 본문에 간결한 식을 사용할 수 있다. 새로운 TextView 인스턴스를 만들고 즉시 그 인스턴스를 apply에 넘긴다apply에 전달된 람다 안에서는 TextView가 수신 객체가 된다. 따라서 원하는 대로 TextView의 메소드를 호출하거나 프로퍼티를 설정할 수 있다. 람다를 실행하고 나면 apply는 람다에 의해 초기화된 TextView 인스턴스를 반환한다buildString으로 알파벳 만들기fun alphabet() = buildString{    for (letter in 'A'..'Z'){        append(letter)    }    append(\"\\nNow I know the alphabet!\")}buildString은 StringBuilder 객체를 만드는 일과 toString을 호출해주는 일을 알아서 해준다",
        "url": "/kotlin-04"
    }
    ,
    
    "kotlin-03": {
        "title": "클래스, 객체, 인터페이스",
            "author": "lee989898",
            "category": "",
            "content": "코틀린 테이블    코틀린 기초    함수 정의와 호출    클래스, 객체, 인터페이스    람다로 프로그래밍    코틀린 타입 시스템    연산자 오버로딩과 기타 관례    고차 함수: 파라미터와 반환 값으로 람다 사용    제네릭스    애노테이션과 리플렉션    DSL 만들기  클래스 계층 정의  뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언  컴파일러가 생성한 메서드 : 데이터 클래스와 클래스 위임  object 키워드 : 클래스 선언과 인스턴스 생성클래스 계층 정의  코틀린 인터페이스interface Clickable{    fun click()}위 인터페이스를 구현하는 모든 비추상 클래스는 click에 대한 구현을 제공해야 한다다음은 인터페이스를 구현하는 방법이다class Button : Clickable{    override fun click() = println(\"I was clicked\")}&gt;&gt;&gt; Button.click()I was clicked자바와 마찬가지로 클래스는 인터페이스를 원하는 만큼 개수 제한 없이 마음대로 구현할 수 있지만, 클래스는 오직 하나만 확장할 수 있다코틀린에서는 override 변경자를 꼭 사용해야 한다. overrid 변경자는 실수로 상위 클래스의 메소드를 오버라이드 하는 경우를 방지해준다인터페이스 메소드도 디폴트 구현을 제공할 수 있다. 그런 경우 메소드 앞에 default를 붙여야 하는 자바와 달리 코틀린에서는 메소드를 특별한 키워드로 꾸밀 필요가 없이 메소드 본문을 메소드 시그니처 뒤에 추가하면 된다interface Clickable{    fun click() // 일반 메소드 선언    fun showOff() = println(\"I'm clickable!\") // 디폴트 구현이 있는 메소드}showOff 메소드의 경우 새로운 동작을 정의할 수도 있고, 그냥 정의를 생략해서 디폴트 구현을 사용할 수도 있다동일한 메소드를 구현하는 다른 인터페이스 정의interface Focusable{    fun setFocus(b: Boolean) =         println(\"I ${if (b) \"got\" else \"lost\"} focus.\")    fun showOff() = println(\"I'm focusable!\")}한 클래스에서 모두 디폴트 구현이 들어있는 두 인터페이스를 함께 구현하면 어느쪽 showOff메소드도 선택되지 않는다코틀린 컴파일러는 두 메소드를 아우르는 구현을 하위 클래스에 직접 구현하게 강제한다상속한 인터페이스의 메소드 구현 호출하기class Button : Clickable, Focusable{    override fun click() = println(\"I was clicked\")    override fun showOff(){ // 인터페이스를 구현하는 하위 클래스에서 명시적으로 새로운 구현을 제공해야 한다        super&lt;Clickable&gt;.showOff()        super&lt;Focusable&gt;.showOff()    }}fun main(args: Array&lt;String&gt;){    val button = Button()    button.showOff()    button.setFocus(true)    button.click()}  open, final, abstract 변경자: 기본적으로 final기본적으로 상속이 가능하면 취약한 기반 클래스라는 문제가 발생한다이펙티브 자바를 쓴 조슈아 블로크는 상속을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 상속을 금지하라는 조언을 했다코틀린도 이러한 조언을 따른다. 코틀린의 클래스와 메소드는 기본적으로 final이다클래스의 상속을 허용하려면 클래스 앞에 open 변경자를 붙여야 한다오버라이드를 허용하고 싶은 메소드나 프로퍼티의 앞에도 open 변경자를 붙여야 한다열린 메소드를 포함하는 열린 클래스 정의하기open class RichButton : Clickable { // 이 클래스는 열려있다    fun disable() {} // 이 함수는 파이널이다    open fun animate() {} // 이 함수는 열려있다    override fun click() {} // 이 함수는 열려있는 메소드를 오버라이드한다}기반 클래스나 인터페이스의 멤버를 오버라이드하는 경우 메소드는 기본적으로 열려있다오버라이드하는 메소드의 구현을 하위 클래스에서 오버라이드 하지 못하게 금지하려면 오버라이드 하는 메소드 앞에 final을 명시해야 한다오버라이드 금지하기open class RichButton : Clickable{    final override fun click() {} // 이 final은 쓸데 없이 붙은 중복이 아니다. final이 없는 override 메소드나 프로퍼티는 기본적으로 열려있다}클래스의 기본적인 상속 가능 사태를 final로 함으로써 얻을 수 있는 큰 이익은 다양한 경우에 스마트 캐스트가 가능하다는 점이다. 스마트 캐스트는 타입 검사 뒤에 변경될 수 없는 변수에만 적용 가능하다코틀린에서도 클래스를 abstract로 선언할 수 있다. abstract로 선언한 추상 클래스는 인스턴스화 할 수 없다추상 멤버는 항상 열려있다. 따라서 추상 멤버 앞에 open 변경자를 명시할 필요가 없다추상 클래스 정의하기abstract class Animated{     abstract fun animate() // 추상 함수다. 구현이 없다. 하위 클래스에서 이 함수를 반드시 오버라이드 해야 한다    open fun stopAnimation(){ /// 추상 클래스에 속했더라도 비추상 함수는 기본적으로 파이널이지만 원한다면 open으로 오버라이드를 허용할 수 있다    }    fun animateTwice(){    }}인터페이스 멤버의 경우 final, open, abstract를 사용하지 않는다. 인터페이스 멤버는 항상 열려 있으면 final로 변경할 수 없다. 인터페이스 멤버에게 본문이 없으면 자동으로 추상 멤버가 되지만, 따로 멤버 선언 앞에 abstract 키워드를 덧붙일 필요가 없다final: 오버라이드 할 수 없음, 클래스 멤버의 기본 변경자다open: 오버라이드 할 수 있음, 반드시 open을 명시해야 오버라이드 할 수 있다abstract: 반드시 오버라이드해야 함, 추상 클래스의 멤버에만 이 변경자를 붙일 수 있다. 추상 멤버에는 구현이 있으면 안 된다override: 상위 클래스나 상위 인스턴스의 멤버를 오버라이드 하는 중, 오버라이드하는 멤버는 기본적으로 열려있다. 하위 클래스의 오버라이드를 금지하려면 final을 명시해야 한다  가시성 변경자: 기본적으로 공개가시성 변경자는 코드 기반에 있는 선언에 대한 클래스 외부 접근을 제어한다. 어떤 클래스의 구현에 대한 접근을 제한함으로써 그 클래스에 의존하는 외부 코드를 깨지 않고도 클래스 내부 구현을 변경할 수 있다아무 변경자도 없는 경우 선언은 모두 공개 된다. 자바의 기본 가시성인 패키지 전용은 코틀린에 없다. 코틀린을 패키지를 네임스페이스를 관리하기 위한 용도로만 사용한다패키지 전용 가시성에 대한 대안으로 코틀린에는 intrenal이라는 새로운 가시성 변경자를 도입했다. internel은 모듈 내부에서만 볼 수 있음이라는 뜻이다. 모듈은 한 번에 한꺼번에 컴파일되는 코틀린 파일들을 의미한다코틀린은 최상위 선언에 대해 private 가시성을 허용한다public: (클래스 멤버)모든 곳에서 볼 수 있다, (최상위 선언)모든 곳에서 볼 수 있다internal: (클래스 멤버)같은 모듈 안에서만 볼 수 있다, (최상위 선언) 같은 모듈 안에서만 볼 수 있다protected: (클래스 멤버) 하위 클래스 안에서만 볼 수 있다, (최상위 선언) (최상위 선언에 적용할 수 없음)private: (클래스 멤버) 같은 클래스 안에서만 볼 수 있다, (최상위 선언) 같은 파일 안에서만 볼 수 있다internal open class TalkativeButton : Focusable{    private fun yell() = println(\"Hey!\")    protected fun whisper() = println(\"Let's talk!\")}fun TalkativeButton.giveSpeech() { // 오류: public 멤버가 자신의 internal 수신타입인 TalkativeButton을 노출함    yell() // 오류: yell에 접근할 수 없음    whisper() // 오류: whisper에 접근할 수 없음}어떤 클래스의 기반 타입 목록에 들어있는 타입이나 제네릭 클래스의 타입 파라미터에 들어있는 타입의 가시성은 그 클래스 자신의 가시성과 같거나 더 높아야 하고, 메소드의 시그니처에 사용된 모든 타입의 가시성은 그 메소드의 가시성과 같거나 더 높아야 한다자바에서는 같은 패키지 안에서 protected멤버에 접근할 수 있지만, 코틀린에서는 그렇지 않다. protected 멤버는 오직 어떤 클래스나 그 클래스를 상속한 클래스 안에서만 보인다. 클래스를 확장한 함수는 그 클래스의 private이나 protected 멤버에 접근할 수 없다코틀린에서는 외부 클래스가 내부 클래스나 중첩된 클래스의 private 멤버에 접근할 수 없다  내부 클래스와 중첩된 클래스: 기본적으로 중첩 클래스코틀린의 중첩 클래스는 명시적으로 요청하지 않는 한 바깥쪽 클래스 인스턴스에 대한 접근 권한이 없다는 점이다직렬화할 수 있는 상태가 있는 뷰 선언interface State: Serializableinterface View{    fun getCurrentState(): State    fun restoreState(state: State) {}}중첩 클래스를 사용해 코틀린에서 View 구현하기class Button : View{    override fun getCurrentState(): State = ButtonState()    override fun restoreState(state: State) { }    class ButtonState: State {}}코트린 중첩 클래스에 아무런 변경자가 붙지 않으면 자바 static 중첩 클래스와 같다. 이를 배누 클래스로 변경해서 바깥쪽 클래스에 대한 참조를 포함하게 만들고 싶다면 inner 변경자를 붙여야 한다중첩 클래스: class A내부 클래스: inner class a코틀린에서 바깥쪽 클래스의 인스턴스를 가리키는 참조를 표기하는 방법은 내부 클래스 Inner 안에서 바깥쪽 클래스 Outer의 참조에 접근하려면  this@Outer 라고 써야 한다class Outer{    inner classs Inner{        fun getOuterReference(): Outer = this@Outer    }}  봉인된 클래스: 클래스 계층 정의 시 계층 확장 제한인터페이스 구현을 통해 식 표현하기interface Exprclass Num(val value: Int) : Exprclass Sum(val left: Expr, val right: Expr) : Exprfun eval (e: Expr): Int =     when (e) {        is Num -&gt; e.value        is Sum -&gt; eval(e.right) + eval(e.left)        else -&gt; // else 분기가 꼭 있어야 한다            throw IllegalArgumentException(\"Unknown expression\")    }항상 디폴트 분기를 추가하는 게 편하지는 않다. 실수로 새로운 클래스 처리를 잊어버렸더라도 디폴트 분기가 선택되기 때문에 심각한 버그가 발생할 수 있다코틀린에서는 sealed 클래스로 이런 문제를 해결한다. 상위 클래스에 sealed 변경자를 붙이면 그 상위 클래스를 상속한 하위 클래스 정의를 제한할 수 있다sealed 클래스의 하위 클래스를 정의할 때는 반드시 상위 클래스 안에 중첩시켜야 한다sealed 클래스로 식 표현하기sealed class Expr{ // 기반 클래스를 sealed로 봉인한다    class Num(val value: Int) : Expr() // 기반 클래스의 모든 하위 클래스를 중첩 클래스로 나열한다    class Sum(val left: Expr, val right: Expr) : Expr()}fun eval(e : Expr): Int =    when(e) { // when 식이 모든 하위 클래스를 검사하므로 별도의 else 분기가 없어도 된다        is Expr.Num -&gt; e.value        is Expr.Sum -&gt; eval(e.right) + eval(e.left)    }sealed로 표시된 클래스는 자동으로 open이다. 나중에 sealed 클래스의 상속 계층에 새로운 하위 클래스를 추가해도 when식이 컴파일 되지 않는다. 따라서 when식을 고쳐야 한다는 사실을 쉽게 알 수 있다뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언코틀린에서는 주생성자와 부생성자를 구분한다. 또한 초기화 블록을 통해 초기화 로직을 추가할 수 있다  클래스 초기화: 주 생성자와 초기화 블록클래스 이름 뒤에 오는 괄호로 둘러싸인 코드를 주 생성자라고 부른다. 주 생성자는 생성자 파라미터를 지정하고 그 생성자 파라미터에 의해 초기화되는 프로퍼티를 정의하는 두 가지 목적에 쓰인다class User(val nickname: String) 선언을 같은 목적을 달성할 수 있는 가장 명시적인 선언으로 풀어서 보자class User constructor(_nickname: String){    val nickname: String    init {        nickname = _nickname    }}constructor 키워드는 주 생성자나 부 생성자 정의를 시작할 때 사용한다init 키워드는 초기화 블록을 시작한다. 초기화 블록에는 클래스의 객체가 만들어질 때 실행될 초기화 코드가 들어간다class User(val nickname: String) // val은 이 파라미터에 사응하는 프로퍼티가 생성된다는 뜻이다함수 파라미터와 마찬가지로 생성자 파라미터에도 디폴트 값을 정의할 수 있다class User(val nickname: String, val isSubscribed: Boolean = true)클래스의 인스턴스를 만들려면 new 키워드 없이 생성자를 직접 호출하면 된다&gt;&gt;&gt; val hyun = User(\"현석\")&gt;&gt;&gt; println(hyun.isSubscribed)true&gt;&gt;&gt; val gye = User(\"계영\", false) // 모든 인자를 파라미터 선언 순서대로 지정할 수도 있다&gt;&gt;&gt; println(gye.isSubscribed)false&gt;&gt;&gt; val hey = User(\"혜원\", isSubscirbed = false) // 생성자 인자 중 일부에 대해 이름을 지정할 수도 있다&gt;&gt;&gt; println(hey.isSubscribed)false클래스에 기반 클래스가 있다면 주 생성자에서 기반 클래스의 생성자를 호출해야 할 필요가 있다. 기반 클래스를 초기화하려면 기반 클래스 이름 뒤에 괄호를 치고 생성자 인자를 넘긴다open class User(val nickname: String) {}class TwitterUSer(nickname: String) : User(nickname)클래스를 정의할 때 별도로 성성자를 정의하지 않으면 컴파일러가 자동으로 아무 일도 하지 않는 인자가 없는 디폴트 생성자를 만들어준다open class Button // 인자가 없는 디폴트 생성자가 만들어진다Button의 생성자는 아무 인자도 받지 않짐나, Button 클래스를 상속한 하위 클래스는 반드시 Button 클래스의 생성자를 호출해야 한다class RadioButton: Button()이 규칙으로 인해 기반 클래스의 이름 뒤에는 꼭 빈 괄호가 들어간다. 반면 인터페이스는 생성자가 없기 때문에 어떤 클래스가 인터페이스를 구현하는 경우 그 클래스의 상위 클래스 목록에 있는 인터페이스 이름뒤에는 아무 괄호도 없다class Secretive private construtor(){ } // 이 클래스의 유일한 주 생성자는 비공개이다Secretive 클래스 안에는 주 생성자밖에 없고 그 주 생성자는 비공개이므로 외부에서는 Secretive를 인스턴스화할 수 없다  부 생성자: 상위 클래스를 다른 방식으로 초기화부 생성자는 constructor 키워드로 시작한다. 필요에 따라 얼마든지 부 생성자를 많이 선언해도 된다open class View{    constructor(ctx: Context){    }    constructor(ctx: Context, attr: AttributeSet){    }}class MyButton : View{    constructor(ctx: Context)        : super(ctx){    }    constructor(ctx: Contexgt, attr: AttributeSet)        : super(ctx, attr){        }}위에서 두 부 생성자는 super() 키워드를 통해 자신에 대응하는 상위 클래스 생성자를 호출한다. this()를 통해 클래스 자신의 다른 생성자를 호출할 수 도 있다클래스에 주 생성자가 없다면 모든 부 생성자는 반드시 상위 클래스를 초기화하거나 다른 생성자에게 생성을 위임해야 한다  인터페이스에 선언된 프로퍼티 구현코틀린에서는 인터페이스에 추상 프로퍼티 선언을 넣을 수 있다interface User{    val nickname: String}이는 User 인터페이스를 구현하는 클래스가 nickname의 값을 얻을 수 있는 방법을 제공해야 한다는 뜻이다인터페이스의 프로퍼티 구현하기  class PrivateUser(override val nickname: String) : User // 주 생성자에 있는 프로퍼티class SubscribingUser(val email: String) : User {     override val nickname: Stirng        get() = email.substringBefore(' @ ') // 커스텀 게터}class FacebookUser(val accountId: Int) : User {    override val nickname = getFacebookName(accountId) // 프로퍼티 초기화 식}&gt;&gt;&gt; println(PrivateUer(\"test@Kotlinlang.org\").nickname)test@Kotlinlang.org&gt;&gt;&gt; println(SubscribingUser(\"test@Kotlinlang.org\").nickname)testinterface User{    val email: String    val nickname: String        get() = email.substringBefore(' @ ')}하위 클래스는 추상 프로퍼티인 email을 반드시 오버라이드 해야 한다. 반면 nickname은 오바라이드하지 않고 상속할 수 있다  게터와 세터에서 뒷받침하는 필드에 접근세터에서 뒷받침하는 필드 접근하기class User(val name: String) {    var address: String = \"unspecified\"      set(value: String){          println(\"\"\"              Address was changed for $name:               $field\" -&gt; \"$value\".\"\"\".trimIndent()) // 뒷받침하는 필드 값 읽기        field = value // 뒷받침하는 필드 값 변경하기      }}&gt;&gt;&gt; val user = User(\"Alice\")&gt;&gt;&gt; user.address = \"Elsenheimerstrasse 47, 80687 Muenchen\"Address was changed for Alice:\"unspecified\" -&gt; \"Elsenheimerstrasse 47, 80687 Muenchen\"코틀린에서 프로퍼티의 값을 바꿀때는 user.address = “new value” 처럼 필드 설정 구문을 사용한다. 이 구문은 내부적으로는 address의 세터를 호출한다  접근자의 가시성 변경접근자의 가시성은 기본적으로는 프로퍼티의 가시성과 같다. 하지만 원한다면 get이나 set앞에 가시성 변경자를 추가해서 접근자의 가시성을 변경할 수 있다class LengthCounter{    var counter: Int = 0        private set // 이 클래스 밖에서 이 프로퍼티의 값을 바꿀 수 없다        fun addWord(word: String){        counter += word.length    }}&gt;&gt;&gt; val lengthCounter = LengthCounter()&gt;&gt;&gt; lengthCounter.addWord(\"Hi!\")&gt;&gt;&gt; println(lengthCounter.counter)3컴파일러가 생성한 메서드 : 데이터 클래스와 클래스 위임  모든 클래스가 정의해야 하는 메소드코틀린 클래스도 toString, equals, hashCode 등을 오버라이드 할 수 있다. 코틀린은 이런 메소드 구현을 자동으로 생성해줄 수 있다class Client(val name: String, val postalCode: Int)문자열 표현 : toString()기본 구현을 바꾸려면 toString 메소드를 오버라이드 해야 한다class Client(val name: String, val postalCode: Int){    override fun toString() = \"Client(name=$name, postalCode=$postalCode)\"}&gt;&gt;&gt; val client1 = Client(\"오현석\", 4122)&gt;&gt;&gt; println(client1)Client(name=오현석, postalCode=4122)객체의 동등성 : equals()&gt;&gt;&gt; val client1 = Client(\"오현석\", 4122)&gt;&gt;&gt; val client2 = Client(\"오현석\", 4122)&gt;&gt;&gt; println(client1 == client2)false // 코틀린에서 == 연산자는 참조 동일성을 검사하지 않고 객체의 동등성을 검사한다. 따라서 == 연산은 equals를 호출하는 식으로 컴파일된다classs Clinet(val name: String, val postalCode: Int){    override fun equals(other: Any?): Boolean{        if(other == null || other !is Clinet)            return false        return name == other.name &amp;&amp; postalCode == other.postalCode    }    override fun toString() = \"Client(name=$name, postalCode=$postalCode)\"}클래스 Cllinet로 더 복잡한 작업을 수행해보면 제대로 작동하지 않는 경우가 있다. 이유는 hashCode가 없다는 점이다  해시 컨테이너: hashCode()원소가 오현석이라는 고객 하나뿐인 집합을 만들자. 그 후 새로 원래의 오현석과 똑같은 프로퍼티를 포함하는 새로운 Client 인스턴스를 만들어서 그 인스턴스가 집합안에 들어있는지 검사해보자&gt;&gt;&gt; val processed = hashSetOf(Clinet(\"오현석\", 4122))&gt;&gt;&gt; println(processed.contains(Client(\"오현석\", 4122)))false위 같은 결과는 Client 클래스가 hashCode 메소드를 정의하지 않았기 떄문이다. hashCode가 지켜야 하는 equals()가 true를 반환하는 두 객체는 반드시 같은 hashCode()를 반환해야 한다라는 제약이 있는데 Client는 이를 어기고 있다HashSet은 원소를 비교할 때 비용을 줄이기 위해 먼저 객체의 해시 코드를 비교하고 해시 코드가 같은 경우에만 실제 값을 비교한다class Client(val name: String, val postalCode: Int){    override fun hashCode(): Int = name.hashCode() * 31 + postalCode}  데이터 클래스 : 모든 클래스가 정의해야 하는 메소드 자동 생성data라는 변경자를 클래스 앞에 붙이면 필요한 메소드를 컴파일러가 자동으로 만들어준다. data 변경자가 붙은 클래스를 데이터 클래스라고 부른다data class Client(val name: String, val postalCode: Int)이제 Client 클래스는 자바에서 요구하는 모든 메소드를 포함한다  인스턴스 간 비교를 위한 equals  HashMap과 같은 해시 기반 컨테이너에서 키로 사용할 수 있는 hashCode  클래스의 각 필드를 선언 순서대로 표시하는 문자열 표현을 만들어주는 toStringequals와 hashCode는 주 생성자에 나열된 모든 프로퍼티를 고려해 만들어진다. 이때 주 생성자 밖에 정의된 프로퍼티는 equals나 hashCode를 계산할 때 고려의 대상이 아니라는 사실에 유의하라코틀린 컴파일러는 몇 가지 유용한 메소드를 더 생성해준다데이터 클래스와 불변성 : copy() 메소드데이터 클래스의 프로퍼티가 꼭 val일 필요는 없다/ 그러나 HashMap 등의 컨테니어에 데이터 클래스를 담는 경우엔 불변성이 필수적이다. 게다가 불변 객체를 사용하면 프로그램에 대해 훨씬 쉽게 추론할 수 있다객체를 복사하면서 일부 프로퍼티를 바굴 수 있게 해주는 copy메소드로 데이터 클래스 인스턴스를 불변 객체로 더 쉽게 활용할 수 있다객체를 메모리상에서 직접 바꾸는 대신 복사본을 만드는 편이 더 낫다. 복사본은 원본과 다른 생명주기를 가지며, 복사를 하면서 일부 프로퍼티 값을 바꾸거나 복사본을 제거해도 프로그램에서 원본을 참조하는 다른 부분에 전혀 영향을 끼치지 않는다&gt;&gt;&gt; val lee = Client(\"이계영\", 4122)&gt;&gt;&gt; println(lee.copy(postalCode = 4000))Client(name = 이계영, postalCode = 4000)  클래스 위임 : by 키워드 사용종종 상속을 허용하지 않는 클래스에 새로운 동작을 추가해야 할 때가 잇따. 이럴 때 사용하는 일반적인 방법이 데코레이터 패턴이다이 패턴의 핵심은 상속을 허용하지 않는 클래스 대신 사용할 수 있는 새로운 클래스를 만들되 기존 클래스와 같은 인터페이스를 데코레이터가 제공하게 만들고, 기존 클래스를 데코레이터 내부에 필드로 유지하는 것이다이때 새로 정의해야 하는 기능은 데코레이터의 메소드에 새로 정의하고 기존 기능이 그대로 필요한 부분은 데코레이터의 메소드가 기존 클래스의 메소드에게 요청을 전달한다이런 접근 방법의 단점은 준비 코드가 상당히 많이 필요하다는 점이다class DelegatingCollection&lt;T&gt;(    innerList: Collection&lt;T&gt; = ArrayList&lt;T&gt;()) : Collection&lt;T&gt; by innerList{} 클래스 위임 사용하기class CountingSet&lt;T&gt;(    val innerSet: MutableCollection&lt;T&gt; = HashSet&lt;T&gt;()) : MutableCollection&lt;T&gt; by innerSet { // MutableCollectiom의 구현을 innerSet에게 위임한다    var objectsAdded = 0        override fun add(element: T): Boolean{ // 이 메소드는 위임하지 않고 새로운 구현을 제공한다        objectsAdded++         return innerSet.add(element)    }    override fun addAll(c: Collection&lt;T&gt;: Boolean){ // 이 메소드는 위임하지 않고 새로운 구현을 제공한다        objectsAdded += c.size         return innerSet.addAll(c)    }}&gt;&gt;&gt; val cset = CountingSet&lt;Int&gt;()&gt;&gt;&gt; cset.addAll(listOf(1,1,2))&gt;&gt;&gt; println(\"${cset.objectsAdded} objects were added, ${cset.size} remain\")3 objects were added, 2 reamin이때 CountinSet에 MutableCollection의 구현 방식에 대한 의존관계가 생기지 않는다object 키워드 : 클래스 선언과 인스턴스 생성코틀린에서는 object 키워드를 다양한 상황에서 사용하지만 모든 경우 클래스를 정의하면서 동시에 인스턴스를 생성한다는 공통점이 있다  객체 선언은 싱글턴을 정의하는 방법 중 하나다  동반 객체는 인스턴스 메소드는 아니지만 어떤 클래스와 관련 있는 메소드와 팩토리 메소드를 담을 때 쓰인다. 동반 객체 메소드에 접근할 때는 동반 객체가 포함된 클래스의 이름을 사용할 수 있다  객체 식은 자바의 무명 내부 클래스 대신 쓰인다  객체 선언 : 싱글턴을 쉽게 만들기객체지향 시스템을 설계하다 보면 인스턴스가 하나만 필요한 클래스가 유용한 경우가 많다객체 선언은 object 키워드로 시작한다. 객체 선언은 클래스를 정의하고 그 클래스의 인스턴스를 만들어서 변수에 저장하는 모든 작업을 단 한 문장으로 처리한다클래스와 마찬가지로 객체 선언 안에도 프로퍼티, 메소드, 초기화 블록 등이 들어갈 수 있다. 하지만 생성자는 객체 선언에 쓸 수 없다싱글턴 객체는 객체 선언문이 있는 위치에서 생성자 호출 없이 즉시 만들어진다변수와 마찬가지로 객체 선언에 사용한 이름 뒤에 마침표를 붙이면 객체에 속한 메소드나 프로퍼티에 접근할 수 있다객체 선언도 클래스나 인터페이스를 상속할 수 있다object CaseInsensitiveFileComparator : Comparator&lt;File&gt;{    override fun compare(file1: File, file2: File): Int{        return file1.path.compareTo(file2.path, ignroeCase = true)    }}&gt;&gt;&gt; println(CaseInsenstiveFileComparator.compare( ... File(\"/User\"), File(\"/user\")))일반 객체를 사용할 수 있는 곳에서는 항상 싱글턴 객체를 사용할 수 있다클래스 안에서 객체를 선언할 수도 있다. 그런 객체도 인스턴스는 단 하나뿐이다중첩 객체를 사용해 Comparator 구현하기data class Person(val name: String){    object NameComparator : Comparator&lt;Person&gt;{        override fun compare(p1: Person, p2: Person): Int =            p1.name.compareTo(p2.name)    }}&gt;&gt;&gt; val persons = listOF(Person(\"Bob\"), Person(\"Alice\"))&gt;&gt;&gt; println(persons.sortedWith(Person.NameComparator))[Person(name = Alice), Person(name = Bob)]  동반 객체 : 팩토리 메소드와 정적 멤버가 들어갈 장소코틀린 클래스 안에는 정적인 멤버가 없다. static 키워드를 지원하지 않는다. 그 대신 코틀린에서는 패키지 수준의 최상위 함수와 객체 선언을 활용한다대부분의 경우 최상위 함수를 활용하는 편을 더 권장한다. 하지만 최상위 함수는 private으로 표시된 클래스 비공개 멤버에 접근할 수 없다클래스 안에 정의된 객체 중 하나에 companion이라는 특별한 표시를 붙이면 그 클래스의 동반 객체로 만들 수 있다. 동반 객체의 프로퍼티나 메소드에 접근하려면 그 동반 객체가 정의된 클래스 이름을 사용한다class A{    companion object {        fun bar() {            println(\"Companion object called\")        }    }}&gt;&gt;&gt; A.bar()Companion object called동반 객체는 자신을 둘러싼 클래스의 모든 private 멤버에 접근할 수 있다. 따라서 동반 객체는 바깥쪽 클래스의 private 생성자도 호출할 수 있다부 생성자가 여럿 있는 클래스 정의하기class User{    val nickname : String    constructor(email: String){        nickname = email.substringBefore('@ ')    }    constructor(facebookAccountId: Int){        nickname = getFacebookName(facebookAccountId)    }}이런 로직을 표현하는 더 유용한 방법으로 클래스의 인스턴스를 생성하는 팩토리 메소드가 있다아래 구현에서는 생성자를 통해 User 인스턴스를 만들 수 없고 팩토리 메소드를 통해야만 한다class User private constructor(val nickname: String){ // 주 생성자를 비공개로 만든다    companion object{        fun newSubscribingUser(email: String) = User(email.substringBefore('@ '))        fun newFacebookUser(accountId : Int) = User(getFacebookName(accountId))    }}&gt;&gt;&gt; val subscribingUser = User.newSubscribingUser(\"bob@gmail.com\")&gt;&gt;&gt; val facebookUser = User.newFacebookUser(4)&gt;&gt;&gt; println(subscribingUser.nickname)bob  동반 객체를 일반 객체처럼 사용동반 객체는 클래스 안에 정의된 일반 객체다. 이름을 붙이거나, 동반 객체가 인터페이스를 상속하거나, 동반 객체 안에 확장 함수와 프로퍼티를 정의 할 수 있다동반 객체이 이름 붙이기class Person(val name: String){    companion object Loader{ // 동반 객체에 이름을 붙인다        fun fromJSON(jsonText: String): Person = ...    }}&gt;&gt;&gt; person = Person.Loader.fromJSON(\"{name: 'Dmitry'}\")&gt;&gt;&gt; person.nameDmitry&gt;&gt;&gt; person2 = Person.fromJSON(\"{name: 'Brent'}\")&gt;&gt;&gt; person2.nameBrent동반 객체에서 인터페이스 구현동반 객체에서 인터페이스 구현하기interface JSONfactory&lt;T&gt;{    fun fromJSON(jsonText: String): T}class Person(val name: String){    companion object : JSONfactory&lt;Person&gt;{        override fun fromJSON(jsonText: String): Person = ... // 동반 객체가 인터페이스를 구현한다    }}동반 객체 확장동반 객체에 대한 확장 함수 정의하기class Person(val firstName: String, val lastName: String){    companion object{ // 비어 있는 동반 객체 선언    }}fun Person.Companion.fromJSON(json: String): Person{}val p = Person.fromJSON(json)  객체 식 : 무명 내부 클래스르 다른 방식으로 작성무명 객체를 정의할 때도 object 키워드를 쓴다무명 객체로 이벤트 리스너 구현하기window.addMouseListenr(    object : MouseAdapter(){        override fun mouseClicked(e : MouseEvent){        }        override fun mouseEntered(e : MouseEvent){        }    })객체에 이름을 붙여야 한다면 변수에 무명 객체를 대입하면 된다객체 선언과 달리 무명 객체는 싱글턴이 아니다. 객체 식이 쓰일 때마다 새로운 인스턴스가 생성된다final이 아닌 변수도 객체 식 안에서 사용할 수 있다. 따라서 객체 식 안에서 그 변수의 값을 변경할 수 있다",
        "url": "/kotlin-03"
    }
    ,
    
    "python-13": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-13"
    }
    ,
    
    "python-12": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-12"
    }
    ,
    
    "python-11": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-11"
    }
    ,
    
    "python-10": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-10"
    }
    ,
    
    "python-09": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-09"
    }
    ,
    
    "python-08": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-08"
    }
    ,
    
    "python-07": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-07"
    }
    ,
    
    "python-06": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-06"
    }
    ,
    
    "python-05": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-05"
    }
    ,
    
    "python-04": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-04"
    }
    ,
    
    "python-03": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-03"
    }
    ,
    
    "kotlin-02": {
        "title": "함수 정의와 호출",
            "author": "lee989898",
            "category": "",
            "content": "코틀린 테이블    코틀린 기초    함수 정의와 호출    클래스, 객체, 인터페이스    람다로 프로그래밍    코틀린 타입 시스템    연산자 오버로딩과 기타 관례    고차 함수: 파라미터와 반환 값으로 람다 사용    제네릭스    애노테이션과 리플렉션    DSL 만들기  코틀린에서 컬렉션 만들기  함수를 호출하기 쉽게 만들기  메서드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티  컬렌션 처리: 가변 길이 인자와 중위 함수 호출과 라이브러리 지원  문자열과 정규식 다루기  코드 다듬기: 로컬 함수와 확장코틀린에서 컬렉션 만들기val set hashSetOf(1, 7, 53)val list = arrayListOf(1 ,7, 53)val map = hashMapOf(1 to \"one\", 7 to \"seven\")&gt;&gt;&gt; println(set.javaClass)class java.util.HashSet&gt;&gt;&gt; println(list.javaClass)class java.util.ArrayList&gt;&gt;&gt; println(map.javaClass)class java.util.HashMap  코틀린이 자신만의 컬렉션 기능을 제공하지 않는다&gt;&gt;&gt; val strings = listOf(\"first\", \"second\", \"fourteenth\")&gt;&gt;&gt; println(strings.last())fourteenth&gt;&gt;&gt; val numbers = setOf(1, 14, 2)&gt;&gt;&gt; println(numbets.max())14  코틀린에서는 자바보다 더 많은 기능을 쓸 수 있다함수를 호출하기 쉽게 만들기&gt;&gt;&gt; val list = listOf(1,2,3)&gt;&gt;&gt; println(list)[1, 2, 3]  자바 컬렉션에는 디폴트 toString 구현이 들어있다.그러나 우리에게 필요한 형식이 아닐 수 있다fun &lt;T&gt; joinToString(    collection: Collection&lt;T&gt;,    separator: String,    prefix: String,    postfix: String): String {    val result = StringBuilder(prefix)    for((index, element) in collection.withIndex()){        if(index &gt; 0) result.append(separator)        result.append(element)    }    result.append(postfix)    return result.toString()}&gt;&gt;&gt; val list = listOf(1, 2, 3)&gt;&gt;&gt; println(joinToString(list, \"; \", \"(\", \")\"))(1; 2; 3)  위 함수는 어떤 타입의 값을 원소로 하는 컬렉션이든 처리할 수 있다 그러나 함수를 호출하는 문장이 번잡하다  이름 붙인 인자joinToString(collection, separator = \" \", prefix = \" \", postfix = \".\")  코틀린으로 작성한 함수를 호출할 때는 함수에 전달하는 인자 중 일부의 이름을 명시할 수 있다  호출 시 인자 중 어느 하나라도 이름을 명시하고 나면 혼동을 막기 위해 그 뒤에 오는 모든 인자는 이름을 꼭 명시해야 한다  디폴트 파라미터 값fun &lt;T&gt; joinToString(    collection: Collection&lt;T&gt;,    separator: String = \", \",    prefix: String = \"\",    postfix: String = \"\" ): String {    val result = StringBuilder(prefix)    for((index, element) in collection.withIndex()){        if(index &gt; 0) result.append(separator)        result.append(element)    }    result.append(postfix)    return result.toString()}&gt;&gt;&gt; joinToString(list, \", \", \"\", \"\")1, 2, 3&gt;&gt;&gt; joinToString(list)1, 2, 3&gt;&gt;&gt; joinToString(list, \"; \")1; 2; 3;  함수를 호출할 때 모든 인자를 쓸 수도 있고, 일부를 생략할 수도 있다  일반 호출 문법을 사용하려면 함수를 선언할 때와 같은 순서로 인자를 지정해야 한다&gt;&gt;&gt; joinToString(list, postfix = \";\", prefix = \"# \")# 1, 2, 3;  이름 붙인 인자를 사용하는 경우에는 인자 목록의 중간에 있는 인자를 생략하고, 지정하고 싶은 인자를 이름을 붙여 순서와 관계없이 지정할 수 있다  함수의 디폴트 파라미터 값은 함수를 호출하는 쪽이 아니라 함수 선언 쪽에서 지정된다  정적인 유틸리티 클래스 없애기: 최상위 함수와 프로피터package strings // 코틀린 join.ktfun joinToString(...): String {...} package strings // join.kt를 컴파일한 결과와 같은 클래스를 자바 코드public class JoinKt{    public static String joinToString(...) { ... } }  다른 패기지에서 그 함수를 사용하고 싶을때는 그 함수가 정의된 패키지를 임포트 해야한다  임포트 시 유틸리티 클래스 이름이 추가로 들어갈 필요가 없다  최상위 프로퍼티var opCount = 0fun performOperation(){    opCount++    //...}fun reporstOperationCount(){    println(\"Operation performed $opCount times\")}  함수와 마찬지로 프로퍼티도 파일의 최상위 수준에 놓을 수 있다  이런 프로퍼티의 값은 정적 필드에 저장된다  최상위 프로퍼티를 활용해 코드에 상수를 추가할 수 있다val UNIX_LINE_SEOARATIR = \"\\n\"  최상위 프로퍼티도 다른 모든 프로퍼티처럼 접근자 메소드를 통해 자바 코드에 노출된다  겉으론 상수처럼 보이는데 실제로는 게터를 사용해야 한다면 자연스럽지 못하다  const 변경자를 추가하면 프로퍼티를 public static final 필드로 컴파일하게 만들 수 있다  원시 타입과 String 타입의 프로퍼티만 const로 지정할 수 있다메서드를 다른 클래스에 추가: 확장 함수와 확장 프로퍼티package stringsfun String.lastChar(): Char = this.get(this.length - 1) // 수신 객체 멤버에 this없이도 접근할 수 있다&gt;&gt;&gt; println(\"Kotlin\".lastChar())n  확장 함수는 어떤 클래스의 멤버 메서드인 것처럼 호출할 수 있지만 그 클래스의 밖에 선언된 함수다  확장 함수를 만드려면 추가하려는 함수 이름 앞에 그 함수가 확장할 클래스의 이름을 덧붙이기만 하면 된다  클래스 이름을 수신 객체 타입, 확장 함수가 호출 되는 대상이 되는 값을 수신 객체라고 부른다  위 예제에서는 String이 수신 객체 타입이고 “kotlin”이 수신 객체다  확장 함수 내부에서는 수신 객체의 메소드나 프로퍼티를 바로 사용할 수 있다. 그러나 클래스 내부에서만 사용할 수 있는 비공개 멤버나 보호된 멤버를 사용할 수 없다  임포트와 확장 함수import strings.lastCharval c = \"Kotlin\".lastChar()import strings.lastChar as lastval c = \"Kotlin\".lats()  확장 함수를 정의했다고 해도 자동으로 프로젝트 안의 모든 소스코드에서 그 함수를 사용할 수 있지는 않다  다른 클래스나 함수와 마찬가지로 임포트해야 한다  as 키워드를 사용하면 임포트한 클래스나 함수를 다른 이름으로 부를 수 있다  한 파일 안에서 다른 여러 패키지에 속해있는 이름이 같은 함수를 가져와 사용해야 하는 경우 이름을 바꿔서 임포트하면 이름 충돌을 막을 수 있다  코틀린 문법상 확장 함수는 반드시 짧은 이름을 써야 한다  확장 함수로 유틸리티 함수 정의fun &lt;T&gt; Collection&lt;T&gt;.joinToString(    separator: String = \", \",    prefix: String = \"\",    postfix: String = \"\" ): String {    val result = StringBuilder(prefix)    for((index, element) in this.withIndex()){        if(index &gt; 0) result.append(separator)        result.append(element)    }    result.append(postfix)    return result.toString()}&gt;&gt;&gt; val list = listOf(1, 2, 3)&gt;&gt;&gt; println(list.joinToString(separator = \"; \", prefix = \"(\",postfix = \")\"))(1; 2; 3)  이제 joinToString을 마치 클래스의 멤버인 것처럼 호출할 수 있다  확장 함수는 오바리이드 할 수 없다open class View{    open fun click() = println(\"View Clicked\")}class Button: View{    override fun click() = println(\"Button clicked\")}&gt;&gt;&gt; val view: View = Button()&gt;&gt;&gt; view.click()Button clicked  확장 함수는 오버라이드 할 수 없다  확장 함수는 클래스의 일부가 아니다  확장 함수는 클래스 밖에 선언된다fun View.showOff() = println(\"I'm a view!\")fun Button.showOff() = println(\"I'm a button!\")&gt;&gt;&gt; val view: View = Button()&gt;&gt;&gt; view.showOff()I'm a view!  view가 가리키는 객체의 실제 타입은 Button이지만, 이 경우 view의 타입이 View이기 때문에 무조건 View의 확장 함수가 호출된다  클래스를 확장한 함수와 클래스의 멤버 함수의 이름과 시그니처가 같다면 확장 함수가 아니라 멤버 함수가 호출된다  확장 프로퍼티val String.lastChar: Char    get() = get(length - 1)  실제로 확장 프로퍼티는 아무 상태도 가질 수 없다  확장 함수의 경우와 마찬가지로 확장 프로퍼티도 일반적인 프로퍼티와 같은데, 단지 수신 객체 클래스가 추가된 것이다  뒷받침하는 필드가 없어서 기본 게터 구현을 제공할 수 없으므로 게터는 꼭 정의를 해야한다  초기와 코드도 쓸 수 없다var StringBuilder.lastChar: Char    get() = get(length - 1)    set(value: Char){        this.setCharAt(length -1, value)    }&gt;&gt;&gt; println(\"Kotlin\".lastChar)n&gt;&gt;&gt; val sb = StringBuilder(\"Kotlin?\")&gt;&gt;&gt; sb.lastChar = '!'&gt;&gt;&gt; println(sb)Kotlin!컬렌션 처리: 가변 길이 인자와 중위 함수 호출과 라이브러리 지원  vararg 키워드를 사용하면 호출 시 인자 개수가 달라질 수 있는 함수를 정의할 수 있다  중위 함수 호출 구문을 사용하면 인자가 하나뿐인 메소드를 간편하게 호출할 수 있다  구조 분해 선언을 사용하면 복합적인 값을 분해해서 여러 번 수에 나눠 담을 수 있다  자바 컬렉션 API 확장val strings: List&lt;String&gt; = listOf(\"first\",\"second\", \"fourteenth\")&gt;&gt;&gt; strings.last()fourteenth&gt;&gt;&gt; val numbers: Collection&lt;Int&gt; = setOf(1, 14, 2)&gt;&gt;&gt; numbers.max()14fun&lt;T&gt;List&lt;T&gt;.last(): T{ 마지막 원소를 반환함}fun Collection&lt;Int&gt;.max(): Int{ 컬렉션의 최댓값을 찾음}  last와 max는 모두 확장 함수였던 것이다  가변 인자 함수: 인자의 개수가 달라질 수 있는 함수 정의fun listOf&lt;T&gt;(vararg values: T): List&lt;T&gt; { ... }fun main(args: Array&lt;String&gt;){    val list = listOf(\"args: \", *args) // 스프레드 연산자가 배열의 내용을 펼쳐준다    println(list)}  가변 길이 인자는 메소드를 호출할 때 원하는 개수만큼 값을 인자로 넘기면 자바 컴파일러가 배열에 그 값들을 넣어 주는 기능이다  타입 뒤에 …를 붇이는 대신 vararg 변경자를 붙인다  값의 쌍 다루기: 중위 호출과 구조 분해 선언val map = mapOf(1 to \"one\", 7 to \"seven\", 53 to \"fifty-three\")1.to(\"one\") // \"to\" 메소드를 일반적인 방식으로 호출함1 to \"one\" // \"to\" 메소드를 중위 호출 방식으로 호출함infix fun Any.to(other: Any) = Pair(this, other)val (number, name) = 1 to \"one\"  맵을 만들려면 mapOf 함수를 사용한다  to라는 단어는 중위 호출이라는 특별한 방식으로 to라는 일반 메소드를 호출한 것이다  인자가 하나뿐인 일반 메소드나 인자가 하나뿐인 확장 함수에 중위 호출을 사용할 수 있다  함수를 중위 호출에 사용하게 허용하고 싶으면 infix 변경자를 함수 선언 앞에 추가해야 한다  이런 기능을 구조 분해 선언이라고 한다  to를 사용하면 타입과 관계없이 임의의 순서쌍을 만들 수 있다문자열과 정규식 다루기  문자열 나누기&gt;&gt;&gt; println(\"12.345-6.A\".split(\"\\\\.|-\".toRegex()))[12, 345, 6 ,A]&gt;&gt;&gt; println(\"12.345-6.A\".split(\".\",\"-\"))[12, 345, 6, A]  정규식을 파라미터로 받는 함수는 String이 아닌 Regex타입의 값을 받는다  간단한 경우네는 꼭 정규식을 쓸 필요가 없다. split 확장 함수를 오버로딩한 버전 중에는 구분 문자열을 하나 이상 인자로 받는 함수가 있다  정규식과 3중 따움표로 묶은 문자열fun parsePath(path: String){    val directory = path.substringBeforeLast(\"/\")    val fullName = path.substringAfterLast(\"/\")    val fileName = fullName.substringBeforeLast(\".\")    val extenstion = fullName.substringAfterLast(\".\")    println(\"dir: $directory, name: $fileName, ext: $extension\")}&gt;&gt;&gt; parsePath(/users/yole/kotlin-book/chapter.aboc)dir: /users/yole/kotlin-book, name: chapter, ext: aboc  String을 확장한 함수를 사용fun parsePath(path: String){    val regax = \"\"\"(.+)/(.+)\\(.+)\"\"\".toRegax()    val matchResult = regax.matchEntire(path)    if(matchResult != null){        val(directory, filename, extension) = matchResult.destructured        println(\"dir: $directory, name: $filename, ext: $extension\")    }    }  정규식을 사용  3중 따옴표 문자열에서는 역슬래시를 포함한 어떤 문자도 이스케이프할 필요가 없다  여러 줄 3중 따옴표 문자열  3중 따옴표 문자열에서는 줄 바꿈을 표현하는 아무 문자열이나 그대로 들어간다  3중 따옴표 안에 문자열 템플릿을 사용할 수 있다 ‘$’ 문자를 넣어야 한다코드 다듬기: 로컬 함수와 확장class User(val id: Int, val name: String, val address: String)fun saveUser(user: User){    if(user.name.isEmpty()){        throws IllegalArgumentException(            \"Can't save user $(user.id): empty Name\")        )    }    if(user.address.isEmpty()){        throws IllegalArgumentException(            \"Can't save user $(user.id): empty Address\")        )    }}&gt;&gt;&gt; saveUser(User(1,\"\",\"\"))java.lang.IllegalArgumentException: Can't save user 1: empty Name  코틀린에서는 함수에서 추출한 함수를 원 함수 내부에 중첩시킬 수 있다class User(val id: Int, val name: String, val address: String)fun saveUser(user: User){    fun vaildate(user: USer,                value: String,                fieldName: String){            if(value.isEmpty()){        throws IllegalArgumentException(            \"Can't save user $(user.id): empty $fileName\")        }    }    validate(user, user.name, \"Name\")    validate(user, user.address, \"Address\")}  검증 로직 중복이 사라졌다  불필요한 User 파라미터도 없애보자class User(val id: Int, val name: String, val address: String)fun saveUser(user: User){    fun vaildate(value: String,fieldName: String){            if(value.isEmpty()){        throws IllegalArgumentException(            \"Can't save user $(user.id): \" + \"empty $fileName\")        }    }    validate(user.name, \"Name\")    validate(user.address, \"Address\")}  이 것을 더 개선하고 싶다면 User클래스를 확장한 함수로 만들 수도 있다",
        "url": "/kotlin-02"
    }
    ,
    
    "android-01": {
        "title": "android 시작",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/android-01"
    }
    ,
    
    "python-02": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-02"
    }
    ,
    
    "python-01": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-01"
    }
    ,
    
    "kotlin-01": {
        "title": "코틀린 기초",
            "author": "lee989898",
            "category": "",
            "content": "코틀린 테이블    코틀린 기초    함수 정의와 호출    클래스, 객체, 인터페이스    람다로 프로그래밍    코틀린 타입 시스템    연산자 오버로딩과 기타 관례    고차 함수: 파라미터와 반환 값으로 람다 사용    제네릭스    애노테이션과 리플렉션    DSL 만들기  기본요소: 함수와 변수  클래스와 프로퍼티  선택 표현과 처리: enum과 when  while과 for 루프  코틀린의 예외 처리기본요소: 함수와 변수fun main(args: String&lt;String&gt;){    println(\"Hello, world!\")}위 함수에서 알 수 있는 것들  함수를 선언할 때 fun 키워드를 사용한다  파라미터 이름 뒤에 그 파라미터의 타입을 쓴다  함수를 최상위 수준에 정의할 수 있다. 클래스 안에 함수를 넣어야 할 필요가 없다  배열도 일반적인 클래스와 마찬가지다. 배열 처리를 위한 문법이 따로 존재하지 않는다  함수를 간결하게 사용할 수 있게 감싼 래퍼를 제공하여 println을 사용한다  줄 끝에 세미콜론을 붙이지 않아도 된다  함수fun max(a: Int, b: Int): Int{    return if (a &gt; b) a else b}  함수 이름 뒤에는 괄호 안에 파라미터 목록이 온다  함수의 반환 타입은 파라미터 목록의 닫는 괄호 다음에 온다. 콜론으로 구분해야 한다  코틀린 if는 문장이 아니고 결과를 만드는 식이다  식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있는 반면 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 못한다  코틀린 대부분 제어 구조는 식이다. 반면 자바와 달리 대입문은 코틀린에서 문이다.  (fun max(a: Int, b: Int): Int = if(a &gt; b) a else b) 처럼 간결하게 표현할 수 있다. (식이 본문인 함수, 블록이 본문인 함수)  반환 타입을 생략할 수 도 있다. 컴파일러가 타입을 분석해 프로그래머 대신 프로그램 구성 요소의 타입을 정해주는 타입추론 기능이 있기 때문이다  식이 본문인 함수의 반환 타입만 생략 가능하다  변수val question = \"삶, 우주, 그리고 모든 것에 대한 궁극적인 질문\"val answer: 42  코틀린에서는 키워드로 변수 선언을 시작하는 대신 변수 이름 뒤에 타입을 명시하거나 생략하게 허용한다val answer: Intanswer = 42  초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시해야한다      초기화 식이 없다면 변수에 저장될 값에 대해 아무 정보가 없기 때문에 컴파일러가 타입을 추론할 수 없다    변수 선언 시 사용하는 키워드는 2가지가 있다          val - 변경 불가능한 참조를 저장하는 변수다. val로 선언된 변수는 일단 초기화하고 나면 재대입이 불가능하다      var - 변경 가능한 참조다. 변수의 값은 바뀔 수 있다        기본적으로 모든 변수를 val 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때에만 var로 변경하는게 좋다val message: Stringif(canPerformOperation()){    message = \"Success\"}else {    message = \"Failed\"}```kotlin+ 조건에 따라 val 값을 다른 여러 값으로 초기화 할 수 있다val languages = arrayListOf(“Java”)languages.add(“Kotlin”)+ val 참조 객체는 불변일지라도 그 참조가 가리키는 객체의 배부 값은 변경될 수 있다```kotlinvar answer = 42answer = \"no answer\" // 컴파일 오류 발생  var 키워드를 사용하면 변수의 값을 변경할 수 있지만 변수의 타입은 고정돼 바뀌지 않는다  어떤 타입의 변수에 다른 타입의 값을 저장하고 싶다면 변환 함수를 써서 값을 변수의 타입으로 변환하거나, 값을 변수에 대입할 수 있는 타입으로 강제 형 변환해야 한다  문자열 템플릿fun main(args: Array&lt;String&gt;){    val name = if (args.size &gt; 0) args[0] else \"Kotlin\"    println(\"Hello, $name!\")}  변수를 문자열 안에 사용할 수 있다  문자열 리터럴의 필요한 곳에 변수를 넣되 변수 앞에 $를 추가해야 한다  $ 문자를 문자열에 넣고 싶으면 $를 이스케이프 시켜야 한다fun main(args: Array&lt;String&gt;){    if(args.size &gt; 0){        println(\"Hello, ${args[0]}!\")    }}  복잡한 식도 중괄호로 둘러싸서 문자열 템플릿 안에 넣을 수 있다  문자열 템플릿 안에서 변수 이름만 사용하는 경우라도 ${name}처럼 중괄호로 변수명을 감싸는 습관을 들이면 더 좋다fun main(args: Array&lt;String&gt;){    println(\"Hello, ${if (args.size &gt; 0) args[0] else \"someone\"}!\")}  중괄호로 둘러싼 식 안에서 큰 타옴표를 사용할 수도 있다클래스와 프로퍼티class Person(val name: String)  이런 유형의 클래스를 값 객체라 부른다  코틀린의 기본 가시성은 public이므로 이런 경우 변경자를 생략해도 된다  프로피터class Person(    val name: String       // (비공개)필드, (공개) 게터를 만들어 낸다    var isMarried: Boolean // (비공개)필드, (공개) 게터, (공개) 세터를 만들어 낸다)&gt;&gt;&gt; val person = Person(\"Bob\", true)&gt;&gt;&gt; println(person.name) // 프로퍼티 이름을 직접 사용해도 코틀린이 자동으로 게터를 호출해준다Bob&gt;&gt;&gt; println(person.isMarried) // 프로퍼티 이름을 직접 사용해도 코틀린이 자동으로 게터를 호출해준다true  코틀린 프로퍼티는 자바의 필드와 접근자 메소드를 대신한다  클래스에서 프로퍼티를 선언할 때는 val이나 var를 사용한다          val로 선언한 프로퍼티는 읽기 전용이며, var로 선언한 프로퍼티는 변경 가능하다        커스텀 접근자class Rectangle(val height: Int, val width: Int){    val isSquare: Boolean        get(){            return height == width        }}&gt;&gt;&gt; val rectangle = Rectangle(41, 43)&gt;&gt;&gt; println(rectangle.isSquare)false  isSqaure 프로퍼티에는 자체 값을 저장하는 필드가 필요없다. 이 프로퍼티에는 자체 구현을 제공하는 게터만 제공한다  클라이언트가 프로퍼티에 접근할 때마다 게터가 프로퍼티 값을 매번 다시 계산한다  디렉터리와 패키지package gemotry.shapesimport java.util.Randomclass Rectangle(val height: Int, val width: Int){    val isSquare: Boolean        get(){            return height == width        }}fun createRandomRectangle(): Rectangle{    val random = Random()    return Rectangle(random.nextInt(), random.nextInt())}  모든 코틀린 맨 앞에 package문을 넣을 수 있다. 그러면 그파일 안에 있는 모든 선언이 해당 패키지에 들어간다  다른 패키지에 정의한 선언을 사용하려면 임포트를 통해 선언을 불러와야 한다package gemotry.exampleimport geometry.shapes.createRandomRectangle    // 이름으로 함수 임포트하기fun main(args: Array&lt;String&gt;){    println(createRandomRectangle().isSquare)   // \"true\"가 아주 드물게 출력된다}  클래스 임포트와 함수 임포트에 차이가 없다  최상위 함수는 그 이름을 써서 임포트 할 수 있다      패키지 이름 뒤에 .*를 추가하면 패키지 안의 모든 선언을 임포트 할 수 있다. 모든 클래스뿐 아니라 최상위에 정의된 함수나 프로퍼티까지 모두 불러온다    코틀린에서는 여러 클래스를 한 파일에 넣을 수 있고, 파일의 이름도 마음대로 정할 수 있다. 코틀린에서는 디스크상의 어느 디렉터리에 소스코드 파일을 위치시키든 관계없다선택 표현과 처리: enum과 when  enum 클래스 정의enum class Color{    RED, ORANCE, YELLOW, GREEN, BLUE, INDIGO, VIOLET}  enum은 소프트 키워드이다  enum 클래스 안에도 프로퍼티나 메소드를 정의할 수 있다enum class Color(    val r: Int, val g: Int, var b: Int){    RED(255,0,0), ORANGE(255,165,0), YELLOW(255,255,0), GREEN(0,255,0), BLUE(0,0,255),    INDIGO(75,0,130), VIOLET(238,130,238);        fun rgb() = (r * 256 + g) * 256 + b}&gt;&gt;&gt; println(Color.BLUE.rgb())255  각 enum 상수를 정의할 때는 그 상수에 해당하는 프로퍼티 값을 지정해야만 한다  when으로 enum 클래스 다루기fun getMnemonic(color: Color)=    when(color){        Color.RED -&gt; \"Richard\"        Color.ORANGE -&gt; \"Of\"        Color.YELLOW -&gt; \"York\"        Color.GREEN -&gt; \"Gave\"        Color.BLUE -&gt; \"Battle\"        Color.INDIGO -&gt; \"In\"        Color.VIOLET -&gt; \"Vain\"    }&gt;&gt;&gt; println(getMneminic(Color.BLUE))Battle  각 분기의 끝에 break를 넣지 않아도 된다fun getWarmth(color: Color) = when(color){    Color.RED, Color.ORANGE, Color.YELLOW -&gt; \"warm\"    Color.GREEN -&gt; \"neutral\"    Color.BLUE, Color.INDIGO, Color.VIOLET -&gt; \"cold\"}&gt;&gt;&gt; println(getWarmth(Color.ORANGE))warm  한 분기 안에서 여러 값을 매치 패턴으로 사용할 수도 있다import ch02.colors.Color   // 다른 패키지에서 정의한 Color 클래스를 임포트한다import ch02.colors.Color.* //짧은 이름으로 사용하기 위해 enum 상수를 모두 임포트한다fun getWarmth(color: Color) = when(color){    RED,ORANGE,YELLOW -&gt; \"warm\"    GREEN -&gt; \"neutral\"    BLUE, INDIGO, VIOLET -&gt; \"cold\"}  상수 값을 임포트 하면 코드를 더 간단하게 만들 수 있다  when과 임의의 객체를 함께 사용fun mix(c1: Color, c2: Color) = when(setOf(c1,c2)){    setOf(RED, YELLOW) -&gt; ORANGE    setOf(YELLOW, BLUE) -&gt; GREEN    setOf(BLUE, VIOLET) -&gt; INDIGO    else -&gt; throw Exception(\"Dirty color\")}&gt;&gt;&gt; println(mix(BLUE, YELLOW))GREEN  when의 분기 조건은 임의의 객체를 허용한다  when의 분기 조건 부분에 식을 넣을 수 있기 때문에 많은 경우 코드를 더 간결하고 아름답게 작성할 수 있다  인자 없는 when 사용fun mixOptimized(c1: Color, c2: Color) =    when{        (c1 == RED &amp;&amp; c2 == YELLOW) ||        (c1 == YELLOW &amp;&amp; c2 == RED) -&gt;            ORANGE        (c1 == YELLOW &amp;&amp; c2 == BLUE) ||        (c1 == BLUE &amp;&amp; c2 == YELLOW) -&gt;            GREEN        (c1 == BLUE &amp;&amp; c2 == VIOLET) ||        (c1 == VIOLET &amp;&amp; c2 == BLUE) -&gt;            INDIGO        else -&gt; throw Exception(\"Dirty color\")    }&gt;&gt;&gt; println(mixOptimized(BLUE, YELLOW))GREEN  인자가 없는 when식을 사용하면 불필요한 객체 생성을 막을 수 있다  코드는 약간 읽기 어려워지지만 성능이 향상된다  when에 아무 인자가 없으려면 각 분기의 조건이 불리언 결과를 계산하는 식이어야 한다  스마트 캐스트: 타입 검사와 타입 캐스트를 조합interface Exprclass Num(val value: Int): Exprclass Sum(val left: Expr, val right: Expr): Exprfun eval (e: Expr): Int{    if (e is Num){        val n = e as Num        return n.value    }    if (e is Sum){        return eval(e.right) + eval(e.left)    }    throw IllegalArgumentException(\"Unknown expression\")}&gt;&gt;&gt; println(eval(Sum(Sum(Num(1),Num(2)), Num(4))))7  is를 사용해 변수 타입을 검사한다. 컴파일러가 대신 캐스팅을 해준다. 이를 스마트 캐스트라고 부른다  원하는 타입으로 명시적으로 타입 캐스팅하려면 as 키워드를 사용한다  스마트 캐스트는 is로 변수에 든 값의 타입을 검사한 다음에 그 값이 바뀔 수 없는 경우에만 작동한다  스마트 캐스트를 사용한다면 그 프로퍼티는 반드시 val이어야 하며 커스텀 접근자를 사용한 것이어도 안 된다  리펙토리: if를 when으로 변경fun eval (e: Expr): Int =    if (e is Num){        e.value    } else if (e is Sum){        eval(e.right) + eval(e.left)    } else {}    throw IllegalArgumentException(\"Unknown expression\")    }  return문과 중괄호를 없애고 if식을 본문으로 사용해 더 간단하게 만들 수 있다  if의 분기에 식이 하나밖에 없다면 중괄호를 생략해도 된다  if 분기에 블록을 사용하는 경우 그 블록의 마지막 식이 그 분기의 결과 값이다fun eval (e: Expr): Int =    when(e){        is Num -&gt;            e.value        is Sum -&gt;            eval(e.right) + eval(e.left)        else -&gt;            throw IllegalArgumentException(\"Unknown expression\")}  when을 사용해 더 다듬을 수도 있다  if와 when의 분기에서 블록 사용fun evalWithLogging (e: Expr): Int =    when(e){        is Num -&gt;{            println(\"num: ${e.value}\")            e.value        }        is Sum -&gt;{            val left = evalWithLogging(e.left)            val right = evalWithLogging(e.right)            println(\"sum: $left + $right\")            left + right        }        else -&gt; throw IllegalArgumentException(\"Unknown expression\")}&gt;&gt;&gt; println(evalWithLogging(Sum(Sum(Num(1),Num(2)), Num(4))))num: 1num: 2sum: 1 + 2num: 4sum: 3 + 47  if나 when 모두 분기에 블록을 사용할 수 있다. 그런 경우 블록의 마지막 문장이 블록 전체의 결과가 된다while과 for 루프  대상을 이터레이션: while과 for 루프  while 루프while(조건){    /* ... */}do {    /* ... */} while(조건)  자바와 동일하다  수에 대한 이터레이션: 범위와 수열val oneToTen = 1..10  코틀린의 범위는 폐구간 또는 양끝을 포함하는 구간이다  이런 식으로 어떤 범위에 속한 값을 일정한 순서로 이터레이션 하는 경우를 수열이라고 부른다fun fizzBuzz(i: Int) = when{    i % 15 == 0 -&gt; \"FizzBuzz\"    i % 3 == 0 -&gt; \"Fizz\"    i % 5 == 0 -&gt; \"Buzz\"    else -&gt; \"$i\"}&gt;&gt;&gt; for(i in 1..100){    print(fizzBuzz(i))    }1 2 Fizz 4 Buzz Fizz 7 ...  for  in &gt;&gt;&gt; for(i in 100 downTo 1 step 2){    print(fizzBuzz(i))}Buzz 98 Fizz 94 92 FizzBuzz 88 ...  100부터 거꾸로 세되 짝수만 나오게 하기  증가 값을 음수로 만들면 정방향 수열이 아닌 역방향 수열을 만들 수 있다  증가 값을 사용하면 수를 건너 뛸 수 있다  끝 값을 포함하지 않는 반만 닫힌 범위를 원하면 until 함수를 사용하자  맵에 대한 이터레이션val binaryReps = TreeMap&lt;Char, String&gt;()for(c in 'A'..'F'){    val binary = Integer.toBinaryString(c.toInt())    binaryResps[c] = binary}for((letter, binary) in binaryReps){    println(\"$letter = $binary\")}  .. 연산자를 숫자 타입의 값뿐 아니라 문자 타입의 값에도 적용할 수 있다  binaryReps[c] = binary 라는 코드는 binaryReps.put(c, binary)라는 자바 코드와 같다val list = arrayListOf(\"10\", \"11\", \"1001\")for((index, element) in list.withIndex()){    println(\"$index: $element\")}0: 101: 112: 1001  맵에 사용했던 구조 분해 구문을 맵이 아닌 컬렉션에도 활용할 수 있다  구조 분해 구문을 사용하면 원소의 현재 인덱스를 유지하면서 컬렉션을 이터레이션 할 수 있다  in으로 컬렉션이나 범위의 원소 검사fun isLetter(c: Char) = c in 'a'..'z' || c in 'A'..'Z'fun isNotDigit(c: Char) = c! in '0'..'9'&gt;&gt;&gt; println(isLetter('q'))true&gt;&gt;&gt; println(isNotDigit('x'))true  in 연산자를 사용해 어떤 값이 범위에 속하는지 검사할 수 있다  !in을 사용하면 어떤 값이 범위에 속하지 않는지 검사할 수 있다fun recognize(c: Char) = when(c){    in '0'..'9' -&gt; \"It's a digit!\"    in 'a'..'z', in 'A'..'Z' -&gt; \"It's a letter!\"    ele -&gt; \"I dont know..\"}&gt;&gt;&gt; println(recognize('8'))It's a digit!  in과 !in 연산자를 when 식에서 사용할 수 있다&gt;&gt;&gt; println(\"Kotlin\" in \"java\"..\"Scala\")true&gt;&gt;&gt; println(\"Kotlin\" in setOf(\"Java\", \"Scala\"))false  범위는 문자에만 국한하지 않고 비교가 가능한 클래스라면 그 클래스의 인스턴스 객체를 사용해 범위를 만들 수 있다코틀린의 예외 처리val percentage =    if(number in 0..100)        number    else        throw IllegalArgumentException(            \"A precentage value must be between 0 and 100: $number\")  함수는 정상적으로 종료할 수 있지만 오류가 발생하면 예외를 던질수 있다  함수를 호출하는 쪽에서는 그 예외를 잡아 처리할 수 있다  throw는 식이므로 다른 식에 포함될 수 있다  try, catch, finallyfun readNumber(reader: BufferedReader): Int?{    try{        val line = reader.readLine()        return Integer.parseInt(line)    }    catch(e: NumberFormatException){        return null    }    finally{        reader.close()    }}&gt;&gt;&gt; val reader = BufferReader(StringReader(\"239\"))&gt;&gt;&gt; println(readNumber(reader))239  코틀린은 체크 예외와 언체크 예외를 구별하지 않는다  함수가 던지는 예외를 지정하지 않고 발생한 예외를 잡아내도 되고 잡아내지 않아도 된다  try를 식으로 사용fun readNumber(reader: BufferedReader){    val number = try{        Integer.parseInt(reader.readLine())    } catch(e: NumberFormatException){        return    }    println(number)}&gt;&gt;&gt; val reader = BufferedReader(StringReader(\"not a number\"))&gt;&gt;&gt; readNumber(reader)  try 키워드는 if나 when과 마찬가지로 식이다  try 본문을 반드시 중괄호로 둘러싸야 한다  try도 마지막 식의 값이 전체 결과 값이다fun readNumber(reader: BufferedReader){    val number = try{        Integer.parseInt(reader.readLine())    } catch(e: NumberFormatException){        null    }    println(number)}&gt;&gt;&gt; val reader = BufferedReader(StringReader(\"not a number\"))&gt;&gt;&gt; readNumber(reader)null  catch에서 값 반환하기  try 코드 블럭의 실행이 정상적으로 끝나면 그 블록의 마지막 식의 값이 결과다  예외가 발생하고 잡히면 그 예외에 해당하는 catch 블록의 값이 결과다",
        "url": "/kotlin-01"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://lee989898.github.io/">LEE</a> &copy; 2021</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
        <div class="subscribe-overlay-content">
            
            <h1 class="subscribe-overlay-title">Search LEE</h1>
            <p class="subscribe-overlay-description">
                lunr.js를 이용한 posts 검색 </p>
            <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()"
               id="searchtext" type="text" name="searchtext"
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
        </div>
    </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
