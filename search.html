<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />
    <!-- highlight.js -->

    <!-- custom.css -->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css" />

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- 웹 폰트 -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!-- syntax.css -->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="공부 블로그" />
    <link rel="shortcut icon" href="https://lee989898.github.io/assets/built/images/favicon.jpg" type="image/png" />
    <link rel="canonical" href="https://lee989898.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="LEE" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="공부 블로그" />
    <meta property="og:url" content="https://lee989898.github.io/search" />
    <meta property="og:image" content="https://lee989898.github.io/assets/built/images/blog-cover1.png" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="공부 블로그" />
    <meta name="twitter:url" content="https://lee989898.github.io/" />
    <meta name="twitter:image" content="https://lee989898.github.io/assets/built/images/blog-cover1.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="LEE" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "LEE",
        "logo": "https://lee989898.github.io/"
    },
    "url": "https://lee989898.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://lee989898.github.io/assets/built/images/blog-cover1.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://lee989898.github.io/search"
    },
    "description": "공부 블로그"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://lee989898.github.io/">LEE</a>
            
        
        
            
<ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-android" role="menuitem"><a href="/tag/android/">Android</a></li>
    <li class="nav-kotlin" role="menuitem"><a href="/tag/kotlin/">Kotlin</a></li>
    <li class="nav-git" role="menuitem"><a href="/tag/git/">Git</a></li>
    <li class="nav-algorithm" role="menuitem"><a href="/tag/algorithm/">Algorithm</a></li>
    <li class="nav-study" role="menuitem"><a href="/tag/study/">Study</a></li>
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">All Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag별 Posts</a>
    </li>


</ul>



        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>


    </div>

</header>




<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "pl-09": {
        "title": "PL-09",
            "author": "lee989898",
            "category": "",
            "content": "제 9장  프로그래밍 언어  정적 시맨틱과 동적 시맨틱​",
        "url": "/pl-09"
    }
    ,
    
    "pl-08": {
        "title": "PL-08",
            "author": "lee989898",
            "category": "",
            "content": "제 8장  프로그래밍 언어  프로그래밍 언어의 신택스와 시맨틱스프로그래밍 언어의 신택스는 산술식, 문, 프로그램 단위의 형태를 말한다. ​문은 statement 또는 sentence를 말한다.   ​프로그램 단위는 컨스트럭트(컨트롤 스트럭처)를 말하는데, ​앞으로 명확한 설명을 위해 프로그램 단위라는 추상적인 말을 쓰지 않고, ​가급적 컨스트럭스 또는 컨트롤 스트럭처라는 말을 쓰겠다. ​시맨틱스는 신택스에 맞게 작성된 표현식, 문, 컨스트럭트의 의미를 말합니다. ​자바 while 문에 대해, ​신택스는 while (Boolean_expr) statement 의 형태를 띄어야 하고, ​그 시맨틱스는 부울 표현식이 참일 때, statement를 실행하고, ​컨트롤은 부울 표현식으로 되돌아가서 이 프로세스를 반복하는데, ​부울 표현식이 거짓이면 ​while 컨스트럭트의 실행이 끝난다는 의미이다.​시맨틱스의 서술 방법은 여러 가지가 있지만, ​컴퓨터에서 실행되는 ‘연산의 의미’로 시맨틱스를 서술하는 것을 ​operational semantics라고 하는데, ​위에 서술된 while문의 시맨틱스는 operational semantics의 예이다.​잘 설계된 프로그래밍 언어에서, 시맨틱스는 신택스를 따릅니다. ​이것은 위에 설명된 자바 while 문의 신택스와 시맨틱스의 예를 보면 직관적으로 알 수 있을 것이다.그럼 신택스를 어떻게 서술하는지 살펴 보자.신택스 서술 방법으로 BNF가 널리 사용되고 있다. ​BNF를 메타 언어라고 하는데, 메타 언어란 언어를 서술하는데 사용되는 언어라는 뜻이다.즉, BNF는 프로그래밍 언어의 신택스를 서술하는데 사용되는 메타 언어이다. ​BNF는 신택스 구조를 위한 추상적 개념을 사용하는 규칙 언어이다. ​규칙은 화살표 왼편(LHS)과 오른편(RHS)으로 나누어지는데, ​문을 생성하면서, 왼편이 오른편으로 대체된다.​BNF가 사용하는 추상적 개념들에는 무엇이 있는지 ​자바의 예를 보면서 알아 보자​자바의 assign과 if 문은 다음과 같이 서술된다.​, , , 화살표(-&gt;), =(이퀄 사인)​,  , if, (괄호), |(세로줄, or의 뜻) 등을 볼 수 있다.화살표를 제외하고, 이들은 각각 BNF를 구성하는 non-terminal/terminal 심볼입니다. ​꺽쇠 괄호로 싸여 있는 것이 난터미날이다.하나의 왼편에 대해 여러 개의 규칙을 가질 수 있는데, ​이때 여러 개의 규칙에 대해 |를 사용하여 각각의 오른편을 구분합니다. ​List를 보면, 의 오른편에 두개의 규칙이 있음을 알 수 있는데, ​두번째 규칙은 가 identifier와 로 대체하는 것입이다. ​이 규칙의 오른편을 보면, 가 또 들어 있는데,  ​이러한 규칙을 recursive rule(순환 규칙)이라고 한다.문법은 언어를 정의하기 위한 생성 장치이다.문은 문법에 있는 일련의 규칙 적용을 통해 생성되며, ​이러한 일련의 규칙 적용을 유도(derivation)이라고 한다. ​유도에 의해 생성된 결과를 문형식(sentential form)이라고 한다. ​문형식(sentential form)에서,  ​가장 왼쪽의 난터미날을 먼저 대체하는 것을 좌선유도(leftmost derivation)이라고 하고, ​그 반대를 우선유도(rightmost derivation)이라고 한다.--- ​---위 사례는 덧셈과 뺄셈으로 구성된 산술식을 서술하기 위한 문법과 ​그 문법에 의한 산술식의 유도(derivation) 과정을 보여주고 있다. ​오른쪽에 나열된 일련의 문형식(sentential form)들은 ​이라는 난터미날 심볼에서 시작하여, ​왼쪽의 문법을 적용하여 좌선유도(Leftmost derivation)된 결과이다.  ​=&gt;의 오른쪽에 있는 begin  end, ​begin  ;  end, 등은 모두 문형식의 예들이다. ​마지막에 있는 begin A = B + C ; B = C end 은 문(sentence)이다. ​그러니까 문과 문형식의 차이는 난터미날 심볼의 유무에 달려 있다. ​--- ​---위 사례는 Assignment 문을 위한 문법과 ​그 문법에 의한 assignment 문의 유도를 보여주고 있다. ​왼쪽 아래는 난터미날 심볼 에서 시작하여 leftmostderivation을 보여주고 있고,  ​이것을 트리로 나타내 보면 오른쪽 그림과 같다. ​이 트리를 파스(parse) 트리라고 한다. ​당연한 말이지만 leftmost derivation을 하면, ​파스 트리의 가장 왼쪽 노드부터 터미날 심볼로 바뀌는 것을 볼 수 있다. --- ​---이 문법을 가지고 에서 시작해서 산술식을 유도할 때, ​+이 포함된 RHS를 먼저 적용하느냐, *이 포함된 RHS를 먼저 적용하느냐에 따라, ​A=B+C*A를 위한 파스 트리가 두개 생성된다. ​이와 같이, 문형식에 문법을 적용할 때, ​동일한 문형식에 대해 파스 트리가 여러 개 생성되면, ​이 문법을 모호한 문법이라고 한다. ​문법의 모호성은 중대한 문제를 야기한다. ​일반적으로 preorder에 따라 산술식을 계산하는데, ​이들 트리는 실행 결과가 서로 다르다. ​왜냐하면, 왼쪽의 트리는 덧셈이 먼저, 오른쪽의 트리는 곱셈이 먼저 계산되기 때문이다. ​즉, 동일한 문에 대해 어떤 규칙을 먼저 적용하였느냐에 따라 파스 트리가 다르고, ​그 트리의 실행 결과가 항상 같지 않다는 것이다. ​이러한 이유로 문법의 모호성은 제거되어야 한다. 문의 실행 결과가 항상 같지 않을 수 있기 때문에 모호성은 제거되어야 함을 알게 되었다. ​이러한 모호성을 어떻게 제거할 수 있을까?  ​+ 연산자에 대한 우선순위를 둔다. ​    즉, 파스 트리의 가장 아래에 있는 연산자부터 먼저 실행한다. ​    따라서, 아래에 있는 연산자가 위의 연산자보다 우선 순위가 높다. ​+ 우선순위에 따라 연산자 출현 순서를 지정한다. ​    이와 같은 출현 순서의 지정은 별도의 난터미널 심볼을 사용    하여 명세할 수 있다. ​    난터미널 심볼은 우선순위가 다른 연산자의 오퍼랜    드를 표현하기 위해 사용한다. ​모호성 제거 방법을 종합하면, 문법을 서술할 때,  ​파스 트리에서 낮은 우선순위의 연산자가 ​높은 우선순위의 연산자보다 위에 나타날 수 있도록, ​낮은 우선순위의 오른쪽 오퍼랜드를 ​새로운 난터미널 심볼로 대체한다.  ​예를 들어 살펴 보자.--- ​---+는 *에 비해 트리의 아래에 위치해야 한다따라서,  -&gt;  + 의 RHS에서 ​오른쪽 오퍼랜드 를 으로 대체한다.그러면 이제  -&gt;  * 는 ​ -&gt;  * 으로 잠정적으로 바뀐다.이 규칙의 RHS에서 오른쪽 오퍼랜드는 ​곱셈 다음에 나 (괄호속의 식)을 나타날 수 있다.(괄호속 식)을 서술할 수 있도록 하기 위해 ​곱셈의 오른쪽 오퍼랜드 을 ​난터미날 심볼 를 사용하여 대체한다.그러면, 잠정적으로 바뀐  -&gt;  * 은 ​ -&gt;  * 가 된다.원래 는 없었는데, ​곱셈의 오른쪽 오퍼랜드로 (괄호속 식) 또는 를 나타낼 수 있도록 하기 위해 ​라는 난터미날을 새로 도입한 것이다. ​이러한 목적에 의해 가 (괄호속 식) 또는 를 생성하는 규칙을 서술해야 한다.이 규칙은  -&gt; () | 로 쓸 수 있다.연산자 우선순위와 연산자 출현 순서의 지정에 의해 모호성을 제거하여 ​트리를 생성하면 유일하게 생성된다.그러나 만일 우선순위가 같은 곱셈과 나눗셈이 포함된 산술식을 위한 문법이라면, ​모호성을 어떻게 제거해야 할까? ​이와 긑은 문제는 시맨틱 규칙으로 지정해서 해결해야 한다. ​​A / B * C와 같이 동일한 우선순위를 가진 곱셈과 나눗셈으로 이루어진 식에서, ​이들 연산자간의 계산 순서를 정하기 위해 어떤 시맨틱 규칙을 쓸 수 있을까? ​바로 결합 법칙을 이용할 수 있다. ​그런데 결합 법칙에는, ​왼쪽부터 결합하는 방식과 오른쪽부터 결합하는 방식, ​두 가지가 있다.A / B * C 은 어느 방식을 쓰느냐에 따라 계산 결과가 달라진다.  ​    또한 if-else 문법의 모호성 문제도 있다.  ​--- ​---if () if ()  else 에 대해, 위의 문법은 두개의 파스 트리를 생성한다. ​따라서 이 문법은 모호성이 있다.  --- ​---If-else의 모호성 제거는 ‘가장 가까운 then에 else를 매치시킨다’는 규칙으로 해소된다.If문은 then과 else가 모두 있는 것과 ​then만 있고 else는 없는 것으로 구분된다. ​즉 난터미날 는 난터미날 이거나 로 대체된다.는 if… else…를 모두 갖춘 것이고, 는 if… 로 구성되어 있다.는 else 다음에 if… else를 허용하기 위해, 규칙에 else 를 추가한다. ​모호성을 제거한 새로운 문법은 오른쪽 아래와 같다.---+ Extended BNF--- ​---&lt;…&gt;는 난터미날 심볼, x, y, z는 터미날 심볼​( )는 그룹으로 묶기(일상적인 괄호의 의미), ​{ }와 [ ]는 일상적인 의미가 아니고, ​{ }는 0번 이상 반복, ​[ ]는 생략 가능(이 예제에는 없음), ​“ ”는 터미날 심볼을 나타내는 규칙의 표현 기호이며, ​( )는 규칙 표기에 사용되는 기호이기 때문에, ​산술식의 일부로서 표현되는 소괄호는 “(“  “)”로 표기함  --- ​---위 그림에서 왼쪽의 BNF를 EBNF로 나타내면 오른쪽과 같다고 되어 있다.  ​그러나 이 문법은 산술식에서 우선순위를 나타낼 때 사용하는 소괄호와EBNF로 표기법의 소괄호의 의미를 구분하지 못하고 있다.  ​이를 바로 잡으면, 오른쪽 아래의 문법과 같다. ​EBNF에서 ( )를 산술식의 괄호로 쓰려면, “(“, “)”로 써야 한다.---",
        "url": "/pl-08"
    }
    ,
    
    "pl-07": {
        "title": "PL-07",
            "author": "lee989898",
            "category": "",
            "content": "제 7장  프로그래밍 언어  프로그래밍 언어의 정교화      ALGOL    초기 포트란은 IBM 704를 타겟으로 개발되었다. ​ 마찬가지로, 많은 언어가 특정 하드웨어에 최적화하도록 개발되었고, ​ 이들 언어 간의 소통은 불가능했다. ​    LISP를 포함한 초기의 다른 여러 프로그래밍 언어도 마찬가지였다. ​ Lisp의 기본 연산자 CAR(content of the address register) , CDR(content of decrement register)은 ​ IBM 704 하드웨어 아키텍처와 매치되지는 않지만, 연산자 이름에서 ​ 당시의 프로그래밍 언어가 하드웨어 아키텍처와 밀접한 관련성이 있었 다는 흔적임을 알 수 있다. ​    이러한 문제를 해결하고자, ALGOL을 개발하였다. ALGOL은 과학 알고리듬의 표현을 위한, 하드웨어  구조에 독립적인 명령식 언어이다.      GO TO 27​   27 IF (A-B) 5,6,7​        알골 이전의 컨트롤 스트럭처는 go to 하나뿐이었다. ​  go to 27은, 위 코드에서 보듯이, 27이라는   레이블이 붙은 문장으로 점프한다.  ​    Go to는 레이블 중심의 컨트롤을 하기 때  문에, 그 레이블이 어디든 점프하게 된다. ​  이로 인해 프로그램 코드는 스파게티처럼 꼬이게 되어, ​  디버깅이 매우 어려울 뿐만 아니라, 의도하지 않은 영역  으로 점프하는 등 ​  go to는 해로운 컨트롤 스트럭처로 인식되고 있었다. ​    이를 해결하기 위해, ​    절(phrase) 수준의 컨트롤 스트럭처로서 if,   while, switch, for, until 등이 언어에 포함되었다. ​  뿐만 아니라, 이들 스트럭처를 사용하기 위한 프로그램 설계   방법으로 구조적 프로그래밍(structured progra  mming)이 제안되었다. ​    구조적 프로그램 스타일의 핵심은 위에 언급된 컨트롤   스트럭처를 적재적소에 적용하여, ​  하나의 프로그램을 여러 개의 블록을   나누고 이들 블록간의 컨트롤을 구조적으로 유지하자는 것이다.  ​  이렇게 하면 프로그램의 디버깅이 쉬울 뿐만 아니라, 프로그  램의 개발, 이해, 수정이 쉬워진다.    알골 언어는 프로그래밍할 때 기억해야 특별한 제약이 없다. ​ 따라서 포트란에 비해 프로그램 작성시 다음과 같은 면에서 자유롭다. ​          코딩할 때 고정된 포맷이 없다. 초기의 포트란은 레이블의위치 문장의 시작 위치 등이 지정되어 있다      변수명의 길이와 배열의 차원 수에 제한이 없다. 초기의 포트란은 변수명의 길이가 6자 이내이며, 차원수도 3개로 제한되어 있었다.  ​      독립성: 기본 개념의 결합에 제한이 없다. 허용되지 않는 결합 조건 등 특별한 금지 사항을 기억해야 할 필요가 없다.      알골은 1958년 이후에 개발된 모든 언어에 영향을 주었 으며, 이들 언어가 사용한 아이디어는 다음과 같다. ​  특정 포맷이 없는 lexical structure(어휘 구조) ​  변수명과 배열 차원의 길이에 제한이 없음 ​  BNF에 의한 구문 구조(신택스)​  타입 개념​  지역 변수의 허용에 의한 블록 구조 ​  Begin-end 및 if-then-else의 중첩 허용에 의한 복합 문장 ​  실행 시 스택 메모리 기반의 동적 배열 할당 ​  Call by value, call by reference, call by name ​  Recursion, 조건식(conditional expression) ​Call by value는 함수 호출 시 파라미터의 ‘값’을 넘겨주고, 이   ‘값’은 ‘새로운 공간’에 저장되어 호출된 함수에서 사용된다. ​call by reference는 함수 호출시 파라미터의 ‘주소’를 넘겨주고,  되돌려 받을 때도 이 ‘주소’를 이용한다. ​call by name는 함수 호출시 ‘함수’를 파라미터로 넘겨 주면, ‘실제 실행할 때’ 그 ‘함수를 호출’한다. ​Call by value와 call by reference는 값을 저장하는  공간을 다루고 있지만, Call by name은 ‘넘어간 함수의 호출 시점’을 다루고 있다. Call by name은 함수 프로그래밍에서 사용하는 방법이다.​   함수 호출시 파라미터를 call by value로 넘겨준다면, ​그 아웃풋 순서는 hi 다음에 call이지만, ​Call by name으로 한다면, ​그 순서는 call 다음에 hi가 된다. ​그 이유는 call(x)의 x에 함수 hou()의 name이 매치되고, ​call(x) 함수 내에서 x()가 실행되어야 비로소 함수 hou()를 실행하기 때문이다.  BASIC베이직은 개발 시기에 비해 늦게 대중화된 언어이다. MS의 베이직과 같은 언어이다. ​Basic의 특징은 한대의 컴퓨터에 연결된 다수의 원격 터미날을 통해 다수의 사용자가 시분 할 방식으로 동시에 접속하여 컴퓨터를 사용할 수 있는  개발 환경을 제공하였다.  COBOL코볼은 유니백이 개발한 플로우매틱을 모태로 대음과 같은 특성을 갖는 언어로 개발되었다. ​  변수명은 하이픈(-) 포함해서 30글자까지 ​  산술 연산자를 영어명으로 (산술식 표현이 없음) ​  모든 문장은 동사로 시작함 ​  계층적 데이터 구조(레코드) 제공​  If-then-else의 중첩 ​미국방부가 주도한 설계 고려사항은 다음과 같다. ​  영어처럼 단순하게 ​  사용하기 쉽게​  컴퓨터 사용자의 저변 확대 ​      기존 컴파일러 문제의 회피    PL/I​과학 분야의 계산은 포트란으로, 비’즈니스 응용 분야에서는 코볼로 프로그래밍을 하였으나, ​과학분야의 계산과 입출력이 복잡해 지면서 레코드 형태의 출력 구조를 요구하게 되었고, ​비즈니스 분야 응용에서도 부동점 계산이나 배열 등을 요구하게 되었다. ​IBM은 이러한 요구를 수용할 수 있는 하드웨어와 프로그래밍 언어를 동시에 개발하였다. ​IBM 360은 이들 응용을 모두 커버할 수 있는 하드웨어였고, ​PL/1은 이들 분야의 문제 해결을 위한 프로그래밍 언어였다. ​IBM은 다중 프로그래밍을 지원하는 시스템이었기 때문에, 컴퓨팅 및 저장 공간 단위의 동시성 제어, 인터럽트 처리, 예외 처리, 포인터 등에 대한 관리 메커니즘을 개발하였다. ​그러나 이들은 너무 복잡해서 시스템 오버헤드에 문제를 노출시켰다.여기 부터 언급하는 프로그래밍 언어에서는 데이터 추상화가프로그래밍 언어의 발전 요인이 된다.  SIMULA이번엔 데이터 추상화를 최초로 지원했던 시뮬라를 살펴보자.시뮬라는 시뮬레이션 프로그램 작성에 편리한 언어로 개발되었다. ​시뮬라의 가장 중요한 특성으로는 클래스와 코루틴을 들 수 있다. ​클래스는 데이터 추상화의 기본이 되는 구조로서, 로컬 데이터와 이에 대한 함수의 정의를 포함한다. ​시뮬라의 이와 같은 데이터 추상화는 객체 지향 프로그래밍의 객체와 유사하다.  ​코루틴은 서브루틴(서브 프로그램)을 일반화한 것으로, 서브프로그램 실행의 중단과 재시작을 허용한다.​   ​코루틴이 서브루틴의 일반화한 것이라고 했는데, 왜 그런지 서브루틴과 코루틴을 비교해 보자.  ​위 그림에서 볼 수 있듯이, 서브루틴은 호출(call)될 때마다 처음부터 실행하여 결과를 (return)돌려준다. ​반면, 코루틴은 여러 루틴들이 시작, 중지 및 양보(yield), 재시작을 반복하면서 동시에 실행되는 것을 말한다.  ​이때 재시작은 루틴의 처음부터 시작하는 것이 아니라, 이전에 양보했던 그 지점에서 재시작한다. ​루틴1이 실행되다가, 루틴2에게 양보하고, 루틴2가 실행되다가 루틴1에게 양보하기를 반복한다. ​왼쪽 코드를 봅시다. ​이 프로그램은 두개의 코루틴 producer, consumer과, main(즉, call producer)으로 구성되어 있다.프로듀서는 큐가 풀이 아니면, 새로운 아이템을 생산하여 큐에 넣는다. ​만일 큐가 풀이면, 컨슈머에게 양보한다. ​​컨슈머는 큐가 비어있지 않으면, 큐에서 아이템을 뽑아서 처리한다. ​만일 큐가 비어 있으면, 프로듀서에게 양보한다. ​이 프로그램은 프로듀서를 호출함으로써 시작되고, ​콜루틴의 조건에 따라 서로 양보하면서 반복적으로 실행된다. ​논리적으로 보면 이 프로그램은 끝나지 않는 프로그램이다. ​이러한 종류의 프로그램은 일반적인 응용 프로그램보다는 시스템 소프트웨어에서 많이 볼 수 있다.  Smalltalk스몰톡은 최초의 객체지향언어라고 한다.앞의 데이터 추상화에서 시뮬라가 최초의 객체지향언어라고 취급하기도 하지만, ​스몰톡이야말로 객체 지향 언어의 중요한 특성을 구현하였기 때문이다. ​그러면 스몰톡 언어의 특성을 살펴보자. ​변수, 상수, 레코드 실행, 클래스 등 모든 것이 객체로 취급된다.  ​모든 계산은 객체에 의한 메시지의 전송 및 수신에 의해 수행된다. ​데이터 추상화, 상속, 동적 타입 바인딩 등   ​스몰톡 언어는 데스크탑 환경을 가정하였는데, 이러한 데스크탑은 프로그래머가 아닌 사용자에 의해 사용될 것이며, 따라서 강력한 휴먼 인터페이스를 필요로 할 거라고 가정하였다.  이러한 이유로 스몰톡은 GUI 설계를 개척하게 되었던 것이다. 이러한 아이디어는 개발되어 Dynabook에 탑재되었다.  C++시뮬라 및 스몰톡의 클래스와 함께, 함수 파라미터 타입 검사 및 컨버전, constructor, 상속된 요소의 접근 통제, 예외 처리 등을 C에 추가하여 C++를 개발하였다. ​절차적(명령형) 프로그래밍과 객체 지향 프로그래밍을 동시에 지원하면서 C++ 언어는 대단히 복잡해졌다. ​C++은 컴파일러의 품질이 좋고 저렴했고 C와 컴패터블했기 때문에 널리 보급되어 지금도 널리 사용되고 있다.  Java자바는 객체지향 언어로, 명령형 프로그래밍 언어이다.자바는 가전제품의 임베디드 소프트웨어 개발에 적합하도록 ​다음과 같은 요구사항에 초점을 맞춰 설계되었다. ​  단순성​  객체지향 프로그래밍 지원​  포인터 대신에 레퍼런스 지원 -&gt; 클래스 정의, 사용자 정의 타입 ​  애플릿 및 동시성(동시처리) 지원 ​C++는 객체지향 프로그래밍을 지원하지만, ​임베디드 소프트웨어에 부적합하다고 평가되었다.그 이유는 절차적 언어를 지원하기 때문에 ​구현 시스템이 너무 크고 복잡하고, 신뢰도가 낮기 때문이다.   ​자바는 순수 객체 지향 언어이다.모든 처리로직은 객체의 메소드로 정의되기 때문에 ​서브 프로그램이 존재하지 않았다.  ​자바는 복잡도를 줄이기 위해 ​단일 상속만을 허용하고 동시성 형태도 단순화하였다. ​자바의 특징은 다음과 같다.  자바는 C++에 비해 실행 속도보다 안정성에 중점을 두고 있습니다. ​ 안전성은 다양한 면에서 언급될 수 있는데, ​  우선 자바 가상 머신을 통한 코드 실행과 배열 범위 검사를 들 수 있다. 자바 가상 머신은 하위 플랫폼을 추상화시키는 결과를 가져 오기 때문에 ​ 하드웨어 플랫폼의 차이점으로 인한 오류 발생을 해소한다. 그리고 실행시 배열 범위 검사는 배열 처리 상의  오류를 줄인다.    ​  동시성 지원(병렬 처리): thread, runnable task ​  애플릿, GUI, DB access 라이브러리​  컴파일러 및 자바 가상 머신에 의한 이식성​  웹 프로그래밍에 적용성 ​  Pascal(1971)파스칼은 알골의 후속작으로 구조적 프로그래밍을 가르치기 위해 설계되었다. ​작고 단순하고 전혀 새롭지 않은 언어를 지향하였다.  CC는 시스템 프로그래밍을 위해 개발되었으며, 연산자가 풍부한 반면, 타입 검사가 없는 언어이다. ​유닉스와 함께 보급되었으며, 다양한 응용 분야에서 사용되었다.  Ada에이다는 이제까지 언급한 프로그래밍 언어의 개념을 하나의 언어로 설계 및 구현하려는 시도였다. ​이 프로젝트를 통해 얻은 것은 다음과 같다. ​  패키지는 데이터 추상화를 지원​  예외 처리를 좀더 정교하게 발전​  서브 프로그램이나 패키지를 일반적인 단위 프로그램으로 생성하기때문에, ​  공통 속성을 갖는 알고리듬에 유용함. ​  타스크 간의 소통에 의한 동시성 통제를 통해 병렬 처리를 지원이후 새로운 버전으로 에이다95를 설계하였는데, ​  객체지향​  공유 변수(shared variable) 컨트롤 메커니즘​  사용성을 개선하기 위한 라이브러리 등이 포함되었다. ​​에이다는 들인 노력에 비해, 대중성에서 실패한 사례로 간주된다. ​비슷한 시기에 나온 C++에 그 자리를 내준 듯 하다. ​",
        "url": "/pl-07"
    }
    ,
    
    "pl-06": {
        "title": "PL-06",
            "author": "lee989898",
            "category": "",
            "content": "제 6장  프로그래밍 언어  프로그래밍 언어의 진화      1940 ~ 1950    초기 컴퓨터는 기계 코드로 직접 프로그램을 작성했었고 이로 인해 다음과 같은 제한이 있었다.하드웨어의 제한으로, 부동점 소수의 계산, 인덱싱 등이 지원되지 않았으며, ​계산과 직접 관련이 없는 시스템 소프트웨어의 사용도 제한적이었다. ​그래서 프로그래머 인건비보다 컴퓨터가 훨씬 비쌌다. ​    따라서 프로그램의 읽기 및 쓰기의 용이성, 수정 용이성, 표현력 등은 크게 문제되지 않았으며, ​프로그래밍은 주로 계산 흐름을 지시하는데 중점을 두었다.  이러한 여건 속에서, ​초기 프로그래머는 기계 코드로 프로그램을 작성하였다. ​  부동점 소수를 계산하기 위해, 프로그래머는 수동으로 지수를 추적해야 했다. ​  프로그램이 적재되는 메모리의 위치에 따라 상대 주소를 절대 주소로 직접 변환해야 했다. ​      배열에 대한 인덱스가 없기 때문에, 셀의 주소를 계산하려면,첫째 셀을 기준으로 셀의 길이만큼씩 더해가면서 주소를 계산하였다. ​        초기 프로그래머를 위해, 어셈블리 언어와 어셈블러가 개발되었다. ​ 어셈블리어는 이진수로 표현된 기계 언어를 일상적인 구절로일대일 매핑시킨 것이다.  ​    끝으로 복잡한 프로그램이 필요해지고 컴퓨터의값이 떨어지면서 프로그래머의 시간 절약이 매우 중요해졌다.  FORTRAN초기 프로그래밍은 주로 과학 계산에 집중되었으며, 이를 위해 가장 많이 사용된 포트란에 대해 알아보자. ​포트란은 최초의 대중적인 고급 프로그래밍 언어이다. ​당시의 컴퓨터는 가격이 매우 비쌌고, 계산 용량이 작고 신뢰성도 낮았다. ​따라서 기계의 효율이 가장 중요했다. ​컴퓨터는 주로 과학 분야의 숫자 계산에 치중되었다.따라서 배열 처리 및 counting loop 처리를 위한 수단을 필요로 했다.   ​포트란은 Formula Translating System에서 For와 Tran을 따온 것으로, ​과학 분야의 이같은 계산 요구를 만족시키도록 설계 및 구현되었다.포트란에서는 변수명이 6글자까지로 제한되고, 사용자 정의에 의한 서브프로그램은 허용된다. ​데이터 타입은 구현시스템에서 제공되는 정적 타입만 허용된다.  ​추후에 다른 언어의 영향으로 다양한 특성을 갖게 된다.포트란은 명령식 언어로, 포트란 프로그램은 본 뉴만 아키텍처를 따른다.  ​  변수는 메모리 셀을 가리키고, ​  Assignment 문장은 메모리와 CPU간의 데이터 이동을 수행하며, ​  연산과 표현식은 CPU에 의한 계산을 실행한다. ​  실행 흐름을 명시적으로 통제하며, ​  언어와 하드웨어 간 효율적 매핑을 통해, 실행 성능의 효율 화를 달성할 수 있지만, 본 뉴만 바틀넥에 의해 제한되기도 한다. ​포트란 프로그래밍 스타일은 큰 문제를 작은 문제로 쪼개고, ​작은 문제를 푸는 프로그램을 짜서 이들을 합치는 방식, ​즉 하향식(탑다운 방식)으로 프로그래밍을 한다. ​프로그램은 위에서 시작해서 차근차근 아래로 컨스트럭트를 따라서 실행되며, ​ go-to를 만나면 점프하기도 한다. ​구조적 프로그래밍 방식에서는 프로그램 디버깅을 어렵게 하는 go-to의 사용을 지극히 제한한다.  LISP함수 프로그래밍 언어 LISP는 링크드 리스트로 표현된 심볼릭(기호) 데이터의 처리를 위한 특성을 제공하기 위해 발명되었으며, 인공지능 응용(자연어 처리) 프로그램에서 유래되었다. ​심볼릭 데이터의 처리는 배열로 처리 불가하며, 배열의 셀을 지칭하기 위한 인덱스가 없으니 loop을 필요로 하지 않는다. 대신에 심볼 릭 데이터를 구성하는 심볼(글자) 하나하나를 처리하는 연산이 필요하다. ​이에 적합한 자료구조가 링크드 리스트이고, 이들에 대한 연산은 (+a(*b c)) 같은 형태의 함수로 표현된다. ​인풋과 함수는 모두 리스트로 표현되며, 데이터 타입은아톰과 리스트의 두가지 타입이 있다.Lisp는 배열과 이에 대한 인덱스가 없어서, 인덱스를 증감시키며 배열을 처리하는 loop이 필요하지 않다. ​물론 반복 처리는 필요하다. Lisp는 이를 위해, 순환 함수를 제공한다. ​​   Lisp에서는 X! 팩토리알 계산 프로그램은 위 그림과 같이 순환 함수로 표현한다. ​defun은 define function(함수 정의)를 의미한다. ​파란색 점선 상자는 x * fact(x – 1)을 리스트 형태로 나타낸 것입니다. ​함수 fact(x)를 정의할 때 x * fact(x – 1)에서 볼수 있듯이 fact()를 사용하고 있다. 이와 같이 무엇인가를 정의할 때 그 무엇을 사용하면, 이것을 recursion 또는 recursive function이라고 한다.  ​​링크드 리스트 처리를 목적으로 최초에 발명된 Lisp는 지금도 사용되고 있는 언어이다. ​​   리스트는 Lisp 구현 시스템의 내부에서 위와 같이 표현된다.(A B C D)는 선형적으로 연결된 링크드 리스트로 표현되는 반면, ​(A (B C) D (E F G))는 트리 구조의 링크드 리스트로 표현된다. ​그 이유는  A, (B C), D와 (E F G)가 같은 수준에 있어야 하고, ​B와 C가 같은 수준에, 그리고 E, F와 G가 같은 수준에 있어야 하기 때문이다. ​두 리스트가 같은지 검사하는 프로그램을 Lisp로 작성하면 다음과 같다.​(DEFUN equal_lists (lis1 lis2)​     (COND​         ((ATOM lis1) (EQ lis1 lis2))​         ((ATOM lis2) NIL)​         ((equal_lists (CAR lis1) (CAR lis2))​                          (equal_lists (CDR lis1) (CDR lis2)))​         (T NIL)​       )​    )​이 코드는 아톰(즉, 리스트의 말단) 수준에서 각 심볼에 대해 EQ(같은지 아닌지) 검사한다. ​현재 EQ 검사해야 할 리스트가 아톰이 아니면, 그 다음 수준으로 아톰을 만날때까지 내려가서 EQ 검사를 한다. ​이렇게 하려면 equal_lists하는 함수를 함수 내에서 반복적으로 호출해야 한다. 즉, recursion이다. ​여기서 CDR, CAR은 Lisp의 기본 연산자로서, ​CAR은 리스트의 맨 앞의 심볼을 반환하고, CDR은 CAR을 제외한 나머지(아톰이거나 리스트)를 반환한다.최초의 함수 언어 Lisp는 다음과 같은 특징을 가지고 있다.파라미터에 함수를 적용하는 방식으로 계산을 수행하며, ​계산에 필요한 중간 변수나 assignment 개념이 없어서,메모리에 이들을 미리 할당하지 않는다.Recursion(순환 함수)와 조건식을 통해 흐름을 컨트롤하며, ​링크드 리스트를 동적으로 필요시마다 메모리에 할당을 한다.​",
        "url": "/pl-06"
    }
    ,
    
    "pl-05": {
        "title": "PL-05",
            "author": "lee989898",
            "category": "",
            "content": "제 5장  프로그래밍 언어  프로그래밍 언어의 구현 시스템프로그래밍 언어의 각 특징과 컨스트럭트들이 ​어떻게 구현되는지 이해하는 것은 매우 중요하다. ​PL 컨스트럭트의 구현은 고급 언어를 어셈블리 언어와 같은 하위 언어로 번역한다.  ​프로그램의 문장을 번역하는 것을 컴파일이라고 하고, ​문장을 의미에 적합하게 매핑하는 것을 인터프리테이션이라고 한다. ​이와 같은 구현 시스템에 대해 왜 알아야 할까? ​ 컨스트럭트가 효율적으로 구현되고 있는지, ​ 더 좋은 구현 방법이 있는지, ​  이들간의 절충점이 있는지 등을 알아내기 위함이다.컴파일 방법은 컴파일러를 써서 고급 언어로 짠  프로그램을 기계 언어로 번역한다. 컴파일 프로세스는 어휘 분석, 구문 분석, 의 미 분석, 코드 생성, 링크 및 적재 단계로 구성되어 있다.위 그림은 컴파일러의 구성요소와 이들 요소간의 처리 순서에 의한 컴파일 과정을 ​플로우 차트로 보여주고 있다. ​어휘 분석기(lexical analyzer)는 소스 프로그램의 글자들을 어휘 단위로 모아 놓는다. ​프로그램의 어휘 단위는 변수, 키워드, 연산자 등을 의미한다.구문 분석기(syntax analyzer)는 어휘 단위를 받아서 파스 트리를 생성한다. ​파스 트리는 프로그램의 구문 구조를 나타낸다. ​중간 코드 생성기는 소스 프로그램과 기계 코드 사이의 중간 수준의 언어로 작성된 프로그램을 생성한다. ​중간 언어로 어셈블리 어가 쓰이기도 하고, 이보다 조금 더 고급 수준의 언어가 사용되기도 한다. ​의미 분석기(semantic analyzer)는 중간 코드 생성기(intermediate code generator)의 일부분으로 통합되어 있으며, ​구문 분석시에 탐지되지 않는 타입 오류 등을 검사한다. ​최적화 단계는 중간 코드의 프로그램을 좀더 작고 빠르게 만든다. ​기계 언어보다 중간 코드를 최적화하는 이유는 기계 코드가 바이너리 형태이기 때문에​ 중간코드(알파벳으로 표현된)에 비해 최적화가 더 어렵기 때문이다. ​코드 생성기는 중간 코드를받아서 컴퓨터가 직접 실행할 수 있는 기계 언어로 변환한다. ​심볼 테이블은 소스 프로그램내의 변수의 타입과 속성(길이 등)을 저장하고 있다. 이들 정보는 어휘 분석기와 구문 분석기에 의해 심볼 테이블에 저장되고, 의미 분석기와 중간 코 드 생성기 및 코드 생성기에 의해 사용된다. ​이렇게 컴파일된 사용자 코드는 실행 시 시스템 코드를 호출하여 ​시스템 소프트웨어의 도움을 받는다. ​이를 위해 실행 직전에 사용자 코드와 시스템 코드를 링크(연결)한다. ​이 과정을 linking 또는 linking and loading이라고 하고, ​이러한 역할을 하는 시스템 소프트웨어를 linker라고 한다. ​링킹에 의해 생성된 것을 executable image(실행 이미지) 또는 load module(적재 모듈)이라고 한다.인터프리터는 프로그램을 기계 언어로 번역하지 않고, ​문장의 의미에 적합하게 시뮬레이션하여 결과를 낸다. ​따라서 인터프러터는 고급 언어 처리를 위한 시뮬레이터 또는 ​고급언어를 기계어처럼 처리하는 가상 머신의 역할을 한다. ​인터프리터의 장점은, 프로그램의 실행 오류 발생시, ​소스 프로그램의 몇번 라인에서 오류가 발생했는지 오류 메시지가 알려주기 때문에 ​프로그램 개발에 매우 편리한다. ​단점은 컴파일 코드에 비해 10-100배 느리다는 것이며, ​프로그램의 인터프리테이션 동안에 심볼 테이블이 메모리에 적재되어 있어야 하기 때문에 ​메모리 공간을 많이 차지한다는 것이다. ​인터프리터를 이용하는 대표적인 언어로 자바스크립트, PHP, 파이썬 등이 있다.하이브리드 방식은 먼저 컴파일을 해서 중간 코드를 생성한 다음에, ​중간 코드를 인터프리터에 의해 실행한다. ​자바에서는 자바 가상 머신에서 실행되는 바이트 코드를 중간 코드로 생성한다.  ​바이트 코드는 이진 코드지만 CPU가 아닌 자바 가상 머신이 이해할 수 있는 언어이다.​자바 가상 머신은 바이트 코드 명령어를 하나씩 읽어 들여 실행한다. ​이와 같이 중간 코드를 생성하여 자바 가상 머신으로 실행하면, ​하드웨어의 특이 사항에 제한을 받지 않아서 portability가 높은 장점이 있다. ​​   클래스 및 변수를 선언하고 초기화하는 자바 소스 프로그램을 바이트 코드로 번역한 예는 위와 같다. ​빨간색 박스를 눈여겨 보시기 보자. ​메모리에 위치를 잡고, 초기화 함수를 호출하거나 조작하고 반환한다.​",
        "url": "/pl-05"
    }
    ,
    
    "pl-04": {
        "title": "PL-04",
            "author": "lee989898",
            "category": "",
            "content": "제 4장  프로그래밍 언어  언어 평가 기준과 언어 설계시 기준 간의 균형좋은 프로그래밍 언어가 갖춰야 할 기준은 무엇인가 살펴 보자. ​      Readability(읽기 쉬움): 프로그램을 읽고 이해하기 쉬운 정도를 프로그래밍 언어의 readability라고 한다. ​        Writability(쓰기쉬움): 프로그램을 작성하기 쉬운 정도를 프로그래밍 언어의 writability라고 한다. ​        Reliability(신뢰성): 프로그램이 다양한 조건 아래서 ‘원래 하기로 되어 있던’ 일을 수행하는 것을 reliability라고 한다. 즉, 인풋이 같으면 아웃풋이 같아야 한다. 만일 인풋이 같은데 조건에 따라 다른 아웃풋을 낸다면 이 프로그램은 신뢰성이 없는 것이다. ​        비용: 프로그램은 학습 비용, 개발 비용(인건비 등 포함), 실행 비용 등 여러 가지 비용을 수반한다. 이 모든 비용이 적으면 좋은 프로그래밍 언어인 것이다.  프로그래밍 언어의 Readability를 올리려면 다음과 같은 특성을 갖는 것이 바람직하다. ​      첫째, 단순성이다. 만일 프로그래밍 언어가, 언어의 고유 기능과 기본 컨스트럭트(constructs; control structure를 의미함)를 비교적 적게 갖고 있으며, ​고유 기능에 대한 다중성이 적을 수록,   ​연산의 오버로딩을 최소한으로 허용할 수록 읽기 쉽다.   ​여기서 다중성이란 동일한 연산을 수행하는 방법이 여러 가지가 있다는 것을 의미하며,충돌이 발생할 가능성에 대비하여 프로그래머에 의한 조치가 필요하다. 이러한 다중성은 객체 지향 언어에서 두드러지는데, ​C++에서는 허용되지만 Java에서는 허용되지 않는다.   ​오버로딩은 동일한 이름의 연산을 여러 개 정의하는 것을 의미하고, ​컴파일할 때 어느 연산을 실행할지 컴파일러가 결정한다. ​        둘째, 독립성입니다. ​독립성이란 컨스트럭트 결합 규칙이 문맥에 대해 종속되지 않고 독립적인 것을 의미합니다. ​컨스트럭트 간의 결합 규칙에 예외나 불규칙성이 비교적 적고, ​모든 결합(combination)이 구문적으로 적합하고 문맥에 독립적이어야 읽기 쉽습니다.  구조적 프로그래밍에 필요한 loop, if-then-else, begin-end와 같은 컨트롤 구조를 충분히 제공하면, ​프로그램을 위에서 아래로 읽어 내려가면서 이해할 수 있어서 readability에 기여한다. ​데이터 타입과 데이터 구조의 정의 기능 또한 프로그램의 readability에 기여한다. ​데이터 타입의 정의를 통해 데이터가 가질 수 있는 값의 범위와 ​이들 데이터에 허용되는 연산을 이해할 수 있다. ​데이터 구조의 정의 기능은 다양한 여러 복잡한 데이터 유형을 모아서, ​새로운 단순한 유형의 데이터를 정의할 수 있는 능력을 프로그래머에게 제공한다. ​프로그래머는 이와 같이 복잡한 것을 단순화시킬 수 있어서, ​프로그램을 쉽게 작성할 수 있는 동시에, 다른 프로그래머를 쉽게 이해시킬 수 있다.      Writablility: 프로그래밍 언어의 쓰기쉬움의 주요 평가 기준은 ​단순성과 독립성, 추상화 지원, 표현력을 들 수 있다. ​단순성이란 컨스트럭트의 수가 적다는 것을 의미하고, ​독립성이란 컨스트럭트 결합 규칙이 문맥에 대해 독립적이라는 것을 의미한다. ​그러나 컨스트럭트 결합 규칙이 문맥에 지나치게 독립적이면, ​실행시 발생하는 오류를 탐지할 수 없게 될 수도 있다. ​따라서 독립성은 프로그래밍 언어를 설계할 때 신중하게 고려해야 한다. ​복잡한 구조 또는 연산의 추상화도 프로그래밍 언어의 쓰기쉬움을 평가하는 기준이다. ​추상화에는 처리 절차의 추상화(서브 프로그램)와 데이터 추상화가 있다.For loop과 같이 편리한 표현 방식과 같은 표현력 또한 쓰기쉬움 평가의 기준입니다.        Reliablitiy:신뢰성은 타입 검사에 의한 오류 처리, ​프로그램 실행시에 발생하는 예외 처리, ​Aliasing(같은 메모리 주소를 다른 이름으로 레퍼런스하는 것), ​읽기쉬움과 쓰기쉬움 등은 모두 프로그래밍 언어의 신뢰성 평가의 기준이 된다.        Cost: 학습, 개발, 컴파일 및 실행, 컴파일러 및 인터프리터와 같은 언어 구현 시스템, 신뢰성, 유지 보수 등 ​프로그래밍 언어 사용에 관련된 모든 비용은 언어 평가 기준에 속한다.  이밖에 구현 시스템간의 이식성, 다양한 응용에 대한 적용성, 언어의 표준화에 의한 완결성 및 정확성, 전력 소비 효율 등도 ​프로그래밍 언어의 평가 기준이다언어 설계시 이들 모든 평가 기준을 최적화하기는 매우 어렵다. ​문제 해결에 필요한 기준을 먼저 설정하고 이들 간의 균형점을 찾는 것이 중요하다. ​레퍼런스 변수는 메모리 상에 있는 인스턴스를 가리키는 데 사용되는 변수이다. ​자바에서는 모든 레퍼런스 변수에 대해, ​이들이 가리키는 메모리에 대한 인덱싱이 적절한지 검사합니다. ​이것은 신뢰성을 높여 주지만 매우 높은 실행 비용을 유발한다. ​강력한 연산자가 많으면 프로그램 짜기는 쉽지만, ​읽고 이해하기 어려울 수도 있다. ​C++의 포인터는 매우 강력하고 유연하여 쓰기 쉬움을 높여주지만, ​주의를 기울이지 않으면 신뢰성에 문제를 일으킨다.",
        "url": "/pl-04"
    }
    ,
    
    "pl-03": {
        "title": "PL-03",
            "author": "lee989898",
            "category": "",
            "content": "제 3장  프로그래밍 언어  프로그래밍 언어가 프로그램 설계 방법에 준 영향역사적으로 프로그래밍 언어는 응용의 표현에 적합한 개념이 추가되면서 발전되어 왔으며,  ​그 개념의 활용에 필요한 프로그램 설계 방법이 개발되었다. ​이에 대해 간략히 간단히 살펴 보자.          50년대와 60년대 초반에는 숫자 계산을 주로 수행하는 수치 해석 등 비교적 단순한 응용이 컴퓨팅의 주류를 이루었고, 이들 프로그램은 수식 표현이 용이한 Fortran으로 작성되었다.  이러한 이유로 프로그램 설계 방법은 기계(컴퓨팅 자원)의 효율적 사용 방법을 찾는데 집중되었다.       60년대 후반에는 프로그램의 데이터 처리 절차가 복잡해지고 타인이 작성한 프로그램을 이해하고 수정하기가 어려워지면서, 기계의 효율적 사용보다 프로그래머의 효율(생산성)에 관심이 집중되었다. 따라서 프로그램의 가독성(readability), 다양한 컨트롤 스트럭처에 의한표현의 편리성이 언어의 중요한 요소로 인식되고, 이를 지원하는 ALGOL 언어가 등장했다. 이러한 언어를 통해 구조적 프로그래밍, 하향식 설계, 단계적 정련 기법 등 프로그래밍 기법 또는 설계 방법이 개발되었다.  여기서 컨트롤 스트럭처란 if-then, loop, {중괄호} 등과 같이 인풋의 처리 로직을 표현하는 데 사용되는 구조를 말한다.      1970년대 후반에는 데이터의 구조가 복잡해지면서, 처리 절차 중심의 프로그램 설계에서 데이터 중심의 프 로그램 설계로 옮겨갔다. 이를 위해 데이터 추상화 기법이 창안되었다 . 데이터 추상화 기법은 데이터를 구조화하고, 이 데이터에 대한 연산 을 정의한다. 이와 같은 데이터 추상화 기법은 추상 데이터 타입을 지 원하는 프로그래밍 언어를 탄생시켰다. 이것이 바로 ALGOL을 발전시 킨 Pascal의 등장이다. Pascal은 Java가 등장하기 전까지 모든 컴 퓨터 관련 학과에서 필수 언어로 가르쳤다.      1980년 중반에 데이터 추상화, 상속(속성, 메소드), 동적 바인딩을 특징으로 하는 객체 지향 언어가 등장하여 지금까지 이어오고 있다. C++, Java 등이 대표적인 언 어로, 이들 특징은 이후의 다른 언어에서도 지원할 수 있 을 정도로 일반적이다.      이 그림은 널리 사용되어 온 프로그래밍 언어의 족보를 보여주고 있다. ​ 많은 언어가 생멸하는 와중에 지속적인 발전이 있었음을 알 수 있다. ​ 눈여겨 볼만한 중요한 언어로는 FORTRAN, COBO L, COMMON LISP, Pascal, C, C++, Java 등이다.",
        "url": "/pl-03"
    }
    ,
    
    "pl-02": {
        "title": "PL-02",
            "author": "lee989898",
            "category": "",
            "content": "제 2장  프로그래밍 언어      왜 PL을 공부하는가?프로그래밍 언어는 알고리즘 또는 계산을 표현하는데 적합하도록 설계된 인공언어이다.프로그램은 알고리즘을 프로그래밍 언어로 코딩한 것으로, 데이터 입력,입력 데이터 처리, 데이터 출력으로 구성된다.언어의 특징을 이해하면, 효과적인 알고리즘의 개발 능력과 언어 활용 능력을개선 할 수 있다.대표적인 특성을 예를 들면, 객체지향성, recursion, call by value,call by reference 등이 있다.    응용의 특성에 더욱 적합한 PL을 선택할 수 있게 되고 새로운 언어 학습 능력을올려주고 새로운 언어를 더욱 쉽게 설계 할 수 있다. 또한 구현 시스템의 중요성을 이해할 수 있다.구현 이슈 예로는 아래 두가지가 있다. 구현 이슈에 관한 지식을 활용하면효율성이 더 좋은 것을 선택할 수 있다.           Recursion과 Loop 중에서 어느 것이 더욱 효율적인가?​      작은 서브프로그램을 자주 호출하는 것은 좋은 방법인가? ​                  Recursion이나 서브 프로그램 호출 비용에 비해 실행 시간이 너무 짧다면,성늘을 떨어뜨리기 때문에, Loop을 사용하거나 서브 프로그램을 일정 규모 이상으로 설계하는 것이 좋다.                    응용의 특성에 대한 적절한 PL의 선택의 예  Fortran          포트란은 부동점 소수를 4바이트로 표현하고, double precision은 8바이트로 표한하기 때문에 부동점 소수 계산에 강점이 있다. 또한 데이터 구조로배열을 지원하며, 2차원 배열로 매트릭스를 표현한다. 이러한 이유들로숫자 계산을 주로 수행하는 과학 응요에서 사용된다.        COBOL          입출력 데이터는 여러 데이터 필드로 구성된 레코드 구조이며, 각 필드는 숫자와 문자값을 갖는다. 십진수, 문자를 주로 처리하여  비즈니스 응용에 주로 사용된다.        Lisp          심볼릭 컴퓨팅을 주로 수행하는 인공 지능 응용에서 주로 사용된다. 데이터를 링크드 리스트로 표현하며 문자열의 조작에 특화되어 있다.      PL의 범주에는 세가지가 있다.  명령/절차적 언어(imperative, procedural)  함수적 언어  논리적 언어 etc) 객체지향 언어는 명령/절차적 언어에서 파생된 것으로서, 별도의 범주로 다루지 않는다.컴퓨터는 명령어를 받아서 연산을 수행한다. 따라서 프로그래밍은 컴퓨터에게 절차적 명령어를 보내는 것과 같다. 아래 코드를 보자.int fact(int n) {  int sofar = 1;  while (n&gt;0) sofar *= n--;  return sofar;}fact(n)은 n!을 계산하는 함수이며,  함수안에 정의된 sofar는 현재까지 계산된 n!값을 간직하는 변수이다. ​ While loop을 끝까지 돌려보면 n에서 시작하여 n=1일 때까지 계속 곱셈(*)을 실행한다. ​ 즉, sofar는 1에서 n까지 곱한 결과이다.  ​ 오늘날 모든 컴퓨터는 본 뉴만 아키텍처로 구성되어 있기 때문에, PL은 이 아키텍처를 모방하고 있다. ​아래 그림이 본 뉴만 아키텍처이다.본 뉴만 아키텍처 컴퓨터에서는 다음과 같이 프로그램을 실행한다.메모리는 프로그램과 메모리를 저장하고, CPU는 연산을 수행한다.   ​프로그램을 실행하려면, 먼저 프로그램과 데이터를 메모리에 저장해야한다.   ​PC(program counter)를 프로그램의 첫번째 명령어 위치로 초기화하고, ​PC가 가리키는 명령어를 Control unit(Decoder 포함)에 적재한다. ​Control unit(Decoder)는 명령어의 의미(무슨 연산을 해야할지)를 해석하고,​데이터를 레지스터에 적재하여 ALU에서 연산을 수행한다. ​연산이 끝나면 그 결과를 메모리에 저장하거나 출력 장치로 내보낸다. ​연산 뿐만 아니라 control structure(loop, if-then, etc)도 PC와 control unit에 의해 통제된다.메모리에서 인스트럭션을 CPU로 가져와서 실행하는 반복적인 절차를 Fetch-execute-cycle이라고 한다. ​Fetch-execution 사이클이 실행하는 인스트럭션은 어셈블리 코드 또는 머신 코드이다. ​머신 코드는 컴퓨터가 이해할 수 있는 명령어이고, 어셈블리 코드는 머신코드를 기호로 표현한 것이다.​Fetch-execution cycle은 다음과 같다. ​  PC를 초기화한다. ​  PC가 가리키는 명령어를 fetch하고 ​  PC를 증가시킨 다음, ​  Fetch한 명령어를 decod하여 ​  실행한다. ​더 이상 실행할 명령어가 없을 때까지 1~4를 반복적으로 실행한다. ​팩토리얼 함수를 예로 들어보자.여기서는 메모리와 CPU간의 데이터 이동에 대해 살펴보도록 하자.컴퓨터가 고급언어를 머신코드로 번역하지 않고 이해할 수는 없지만, ​설명을 위해 고급 언어를 컴퓨터가 직접 이해한다고 가정한다.변수 sofar과 n은 메모리에서 공간을 잡고 값을 저장하고 있으며, ​프로그램 코드는 메모리에 저장되어 있다.PC가 int sofar를 읽어 오면 Control unit은 =을 assignment로 해석하여 sofar에 1을 할당한다. PC가 while loop의 sofar *=n–를 읽어 오면 ALU에서 반복적으로 n!을 계산하고,PC가 return sofar를 읽어 오면 sofar 값을 메모리에 저장한다. ​이와 같이 명령/절차적 언어는 본 뉴만 아키텍처에 적합하게 다음과 같이 실행된다.    ​  프로그램의 변수는 메모리 셀을 지칭하고, 그 셀에 저장된 값을 대표한다. ​  Assignment 문장은 메모리와 CPU 간의 데이터를 이동시킨다. ​  연산과 표현식(expression)은 CPU에서 실행된다. ​  실행 흐름의 명시적 통제는 프로그램 카운터에 의한다. ​현재 널리 사용되고 있는 C, C++, Java는 이런 유형의 PL이다. ​명령/절차적 언어는 실행 성능의 최적화를 위한 언어와 하드웨어 간의 효율적 매핑을 허용하지만, ​본 뉴만 아키텍처에 의해 제한된다.고급어 프로그램은 컴파일러에 의해 어셈블리어 프로그램으로 번역되고 ​어셈블리어 프로그램은 어셈블러에 의해 기계어 프로그램으로 번역된다. ​기계어 프로그램은 인터프리터에 의해 ALU 연산으로 해석되어 실행된다.     ​어셈블리어 프로그램은 RISC 아키텍처의 인스트럭션을 포함하고 있다. ​RISC 아키텍처는 인스트럭션 집합을 가능한 줄이고 단순화시켜 성능 개선을 이룩한 사례로 남아 있다. ​함수적 프로그래밍은 수학 함수식과 유사하다. ​각 서브 프로그램은 함수의 구현이다.fun fact x =  if x &lt;= 0  then 1   else x * fact(x-1);​코드는 ML 언어로 팩토리얼을 구하는 프로그램을 보여주고 있다. ​Fact 내에서 fact를 호출하는 Recursion을 사용하고 있다.또 다른 함수 언어로 리스프를 들 수 있다.ML과 달리 변수와 assignment가 없다. ​이 말은 변수로 인해 고정적으로 소비되는 메모리가 없다는 말이다.즉, 필요시 동적으로 메모리를 할당하고 계산한다.ML과 마찬가지로 리커전을 컨트롤 구조로 갖고 있다.이후 리스프는 변화를 겪으면서 사용되고 있다.​로직 프로그래밍은 술어 논리(predicate logic)에 기반하고 있다. 로직 프로그램은 사실(fact), 규칙(rule), 목표(goal)로 구성되어 있으며,  로직 프로그램의 실행은 목표에 사실과 규칙을 적용하여 목표가 논리적으로 추론될 수 있는지, 다시 말하면 참인지 거짓인지 증명하는 절차이다.  ​ 이를 위해 추론 엔진이 필요한데, ​ 로직 프로그램의 추론은 resolution reputation에 의한 추론 엔진을 사용한다. 이 프로그램에서 grandparent(vern, kake)가 추론될 수 있는 살펴보자.​fact:  mother(joanne,jake).​  father(vern,joanne).​ rule:  grandparent(X,Z) :- parent(X,Y),​           parent(Y,Z).​goal:  grandparent(vern,jake). ​규칙 grandparent(X,Z) :- parent(X,Y), parent(Y,Z)에 X, Z에 각각 vern, jake를 대입하면,  ​ grandparent(vern,Z) :- parent(X,Y), parent(Y,jake)가 추론된다. 사실의 mother, father 모두 parent이므로, parent(joanne, jake), parent(vern, joanne)이다. ​로직 프로그래밍 언어는 프로그램에 입력 데이터에서 출력 데이터를 생성하는 절차를 서술하는 것이 아니라, ​ 사실과 규칙을 술어 논리로 선언하고, 원하는 것(목표)가 무엇인지 선언한다. ​ 따라서 로직 프로그래밍 언어는 비절차적(선언적)이다.로직 프로그래밍은 resolution을 해야 하기 때문에, 매우 비효율적(느리다)이다. ​ 따라서 응용 분야가 대단히 좁다.(DB, AI)  ​  팩토리알 계산하는 프로그램을 봅자.fact(X,1) :-  X =:= 1.fact(X,Fact) :-  X &gt; 1, NewX is X - 1,  fact(NewX,NF),  Fact is X * NF.보기엔 깔끔해 보일 수 있지만, 레졸루션해서 풀려면 오래걸린다.",
        "url": "/pl-02"
    }
    ,
    
    "pl-01": {
        "title": "PL-01",
            "author": "lee989898",
            "category": "",
            "content": "제 1장  프로그래밍 언어      프로그래밍 언어란?프로그래밍 언어는 인공적으로 설계된 언어로 컴퓨터가 실행할 수 있는 계산이나알고리즘을 표현하는 수단이다.인간의 언어는 타인에게 자신의 생각을 표현하듯이 프로그래밍 언어는자신의 생각을 컴퓨터에게 표현하는 수단이다.현재 프로그래밍 언어는 매우 다양할까?문제의 특성에 따라, 프로그램이 각기 요구하는 프로그래밍 언어의 표현력이다르기 때문이다. 표현력은 언어 선택에 있어 매우 중요하다.      문제해결에 적합한 언어를 선택하려면 아래 내용을 숙지해야 한다.                  언어가 다르면, 알고리즘의 표현이 어떻게 다른가? ​                    어떤 언어가 더 적합한가? 언어의 적합성(goodness)을 어떻게 평가할 것인가? ​                    왜 이렇게 다른 언어가 많은가? ​                    도대체 프로그래밍 언어가 뭔가? ​                    프로그래밍 언어의 특성이 왜 이렇게 많은가? ​                    이들 특성은 어떻게 구현시스템에서 실현되는가?​                  여기서 구현 시스템이란 컴파일러나 인터프리터 등 PL을 실행할 수 있는 소프트웨어를 말한다. ​                      프로그래밍 언어의 역사, 신택스 및 시맨틱스, 바인딩, 데이터 타입,컨트롤 구조, 서브 프로그램, 추상데이터 타입, 캡슐화, 예외 처리,함수 프로그래밍을 공부할 것이다.  PL의 트렌드에 따른 언어를 살펴보면 다음과 같은 특성을 갖고 있다.  타입의 안정성을 고려한 언어의 사용 증가: C,C++에 비해 Java, C# 타입이 안정적임  웹 응용을 위해 클라이언트 측의 기능성을 갖춘 스크립트 언어  신택스 보다 알고리즘의 표현력에 중점을 둔 언어  컴파일, 분석, 타입 검사 등 실행 환경과 가상화를 갖춘 언어  자동 오류 탐지 및 복구 등 프로그램 분석 능력을 갖춘 언어PL에 영향을 미치는 요인을 표현력과 구현 시스템의 효율 측면에서 살펴보면 다음과 같다.      표현력: 응용 도메인의 특성과 프로그래밍 방법을 들 수 있다.     다중 프로그래밍은 큰 작업(프로그램)이 여러 개의 작은 작업(서브프로그램)으로    나뉘어져서 서로 연관성을 가지고 동시에 실행되는 것을 말한다.    물론 동시라는 말은 특정 시간에는 작은 작업 하나가 실행되지만,     타임 피리어드 동안 여러 개의 작은 프로그램이     동시에 처리되는 것으로 보이게 된다.    이것은 CPU의 시분할과 메모리의 공간 분할에 의해 이루어진다.    이렇게 하여 큰 프로그램 하나가 다른 프로그램의 방해없이    여러 개의 작은 서브프로그램으로 나누어져 처리될 수 있는 것이다.  ​        언어 구현 시스템의 효율성: 즉 컴파일러나 인터프리터의 성능을 말한다.    컴파일러나 인터프리터의 성능은 주로 컴퓨터 구조, OS, 관련 도구, 라이브러리 등에 달려 있다.    ​    편의성은 비용을 수반한다. 추상적 관점을 지원하면 편의성은 좋아지지만, 이것을 머신에     표현하는데는 나름의 비용이 들어간다.   이러한 사실을 고려하여 편의성과 비용간에 균형을 잡는 것이     중요하다.   ​  ",
        "url": "/pl-01"
    }
    ,
    
    "kotlin-10": {
        "title": "클래스의 상속",
            "author": "lee989898",
            "category": "",
            "content": "클래스의 상속fun main() {    var intValue:Int = 1234    var LongValue:Long = 1234L    var intValueByHex:Int = 0x1af    var intValueByBin:Int = 0b10110110        var doubleValue:Double = 123.5    var doubleValueWithExp: Double = 123.5e10    var floatValue:Float = 123.5f        var charValue: Char = &#39;a&#39;    var koreanCharValue: Char = &#39;가&#39;        var booleanValue: Boolean = true        var stringValue = &quot;one line string test&quot;        val multiLineStringValue = &quot;&quot;&quot;multiline    string    test&quot;&quot;&quot;}",
        "url": "/kotlin-10"
    }
    ,
    
    "kotlin-09": {
        "title": "클래스의 생성",
            "author": "lee989898",
            "category": "",
            "content": "클래스의 생성fun main() {    var intValue:Int = 1234    var LongValue:Long = 1234L    var intValueByHex:Int = 0x1af    var intValueByBin:Int = 0b10110110        var doubleValue:Double = 123.5    var doubleValueWithExp: Double = 123.5e10    var floatValue:Float = 123.5f        var charValue: Char = &#39;a&#39;    var koreanCharValue: Char = &#39;가&#39;        var booleanValue: Boolean = true        var stringValue = &quot;one line string test&quot;        val multiLineStringValue = &quot;&quot;&quot;multiline    string    test&quot;&quot;&quot;}",
        "url": "/kotlin-09"
    }
    ,
    
    "kotlin-08": {
        "title": "클래스의 기본구조",
            "author": "lee989898",
            "category": "",
            "content": "클래스의 기본구조fun main() {    var intValue:Int = 1234    var LongValue:Long = 1234L    var intValueByHex:Int = 0x1af    var intValueByBin:Int = 0b10110110        var doubleValue:Double = 123.5    var doubleValueWithExp: Double = 123.5e10    var floatValue:Float = 123.5f        var charValue: Char = &#39;a&#39;    var koreanCharValue: Char = &#39;가&#39;        var booleanValue: Boolean = true        var stringValue = &quot;one line string test&quot;        val multiLineStringValue = &quot;&quot;&quot;multiline    string    test&quot;&quot;&quot;}",
        "url": "/kotlin-08"
    }
    ,
    
    "kotlin-07": {
        "title": "흐름제어와 논리연산자",
            "author": "lee989898",
            "category": "",
            "content": "흐름제어와 논리연산자fun main() {    var intValue:Int = 1234    var LongValue:Long = 1234L    var intValueByHex:Int = 0x1af    var intValueByBin:Int = 0b10110110        var doubleValue:Double = 123.5    var doubleValueWithExp: Double = 123.5e10    var floatValue:Float = 123.5f        var charValue: Char = &#39;a&#39;    var koreanCharValue: Char = &#39;가&#39;        var booleanValue: Boolean = true        var stringValue = &quot;one line string test&quot;        val multiLineStringValue = &quot;&quot;&quot;multiline    string    test&quot;&quot;&quot;}",
        "url": "/kotlin-07"
    }
    ,
    
    "kotlin-06": {
        "title": "반복문과 증감연산자",
            "author": "lee989898",
            "category": "",
            "content": "반복문과 증감연산자fun main() {    var intValue:Int = 1234    var LongValue:Long = 1234L    var intValueByHex:Int = 0x1af    var intValueByBin:Int = 0b10110110        var doubleValue:Double = 123.5    var doubleValueWithExp: Double = 123.5e10    var floatValue:Float = 123.5f        var charValue: Char = &#39;a&#39;    var koreanCharValue: Char = &#39;가&#39;        var booleanValue: Boolean = true        var stringValue = &quot;one line string test&quot;        val multiLineStringValue = &quot;&quot;&quot;multiline    string    test&quot;&quot;&quot;}",
        "url": "/kotlin-06"
    }
    ,
    
    "kotlin-05": {
        "title": "조건문과 비교연산자",
            "author": "lee989898",
            "category": "",
            "content": "조건문과 비교연산자fun main() {    var intValue:Int = 1234    var LongValue:Long = 1234L    var intValueByHex:Int = 0x1af    var intValueByBin:Int = 0b10110110        var doubleValue:Double = 123.5    var doubleValueWithExp: Double = 123.5e10    var floatValue:Float = 123.5f        var charValue: Char = &#39;a&#39;    var koreanCharValue: Char = &#39;가&#39;        var booleanValue: Boolean = true        var stringValue = &quot;one line string test&quot;        val multiLineStringValue = &quot;&quot;&quot;multiline    string    test&quot;&quot;&quot;}",
        "url": "/kotlin-05"
    }
    ,
    
    "kotlin-04": {
        "title": "타입추론과 함수",
            "author": "lee989898",
            "category": "",
            "content": "타입추론과 함수타입추론타입추론은 변수나 함수들을 선언할 때나 연산이 이루어 질 떄자료형을 코드에 명시하지 않아도 코틀린이 자동으로 자료형을 추론해주는기능입니다변수가 선언될 때 할당된 값의 형태로 해당 변수가 어떤 자료형을 가지는지 추론이 가능하기 때문입니다fun main() {       var a = 1234   var b = 1234L      var c = 12.45   var d = 12.45f       var e = 0xABCD   var f = 0b01010101       var g = true   var h = &#39;c&#39;}함수함수는 특정한 동작을 하거나 원하는 결과값을 연산하는데 사용합니다.함수안에서 return은 뒤에 오는 값을 반환하는 키워드로 return이 발생하면함수의 중간이더라도 값을 반환하고 함수를 종료합니다코틀린은 함수를 좀 더 간단하게 기술할 수 있도록 단일 표현식 함수를 지원합니다fun main() {        println(add(5,6,7))   }fun add(a: Int, b: Int, c: Int): Int{    return a+b+c    }fun add(a: Int, b: Int, c: Int) = a + b + c //위 함수와 동일합니다코틀린에서 함수는 내부적으로 기능을 가진 형태이지만 외부에서볼 때는 파라미터를 넣는다는 점 외에는 자료형이 결정된 변수라는 개념으로접근합니다",
        "url": "/kotlin-04"
    }
    ,
    
    "kotlin-03": {
        "title": "형변환과 배열",
            "author": "lee989898",
            "category": "",
            "content": "형변환과 배열형변환형변환은 하나의 변수에 지정된 자료형을 호환되는 다른 자료형으로 변경하는 기능입니다코틀린은 형변환시 발생할 수 있는 오류를 막기 위해 자동으로 형변환 해주는 암시적 형변환은 지원하지 않습니다명시적 형변환은 변환될 자료형을 개발자가 직접 지정하는 것입니다  형변환 함수          toByte()      toShort()      toInt()      toLong()      toFloat()      toDouble()      toChar()      fun main() {    var a: Int = 54321    var b: Long = a.toLong()}배열배열은 내부적으로 Array 클래스로 제공되는 기능입니다fun main() {        var intArr = arrayOf(1,2,3,4,5)        val nullArr = arrayOfNulls&lt;Int&gt;(5) //비어있는 배열 만들기        intArr[2] = 8        println(intArr[4])}",
        "url": "/kotlin-03"
    }
    ,
    
    "algorithm-01": {
        "title": "알고리즘 시작",
            "author": "lee989898",
            "category": "",
            "content": "알고리즘 시작 입니다.",
        "url": "/algorithm-01"
    }
    ,
    
    "git-02": {
        "title": "Git 1강",
            "author": "lee989898",
            "category": "",
            "content": "Git 공부는 여러 절로 구성되어 있습니다.     Git 시작    Git 1강 git 1강 입니다.",
        "url": "/git-02"
    }
    ,
    
    "kotlin-02": {
        "title": "변수와 자료형",
            "author": "lee989898",
            "category": "",
            "content": "변수와 자료형변수var: 일반적으로 통용되는 변수 언제든지 읽기 쓰기가 가능합니다val: 선언시에만 초기화 가능 중간에 값을 변경할 수 없습니다runtime시 변경되지 말아야 할 값은 안전하게 val로 선언하는 것이 좋습니다fun main() {    var a: Int = 123    val b: Int = 456    println(a)    println(b)}초기화 하지 않고 null을 허용하는 nullable 변수로 선언할 수 있습니다ex) var a: Int? = null자료형기본 자료형에는 숫자형,실수형,논리형인 8가지가 있습니다.  숫자형: Byte Short Int Long  실수형: Float Double  논리형: Boolean정수형의 리터럴은 10진수, 16진수, 2진수로 표기 가능합니다8진수의 표기는 지원하지 않습니다fun main() {    var intValue:Int = 1234    var LongValue:Long = 1234L    var intValueByHex:Int = 0x1af    var intValueByBin:Int = 0b10110110        var doubleValue:Double = 123.5    var doubleValueWithExp: Double = 123.5e10    var floatValue:Float = 123.5f        var charValue: Char = &#39;a&#39;    var koreanCharValue: Char = &#39;가&#39;        var booleanValue: Boolean = true        var stringValue = &quot;one line string test&quot;        val multiLineStringValue = &quot;&quot;&quot;multiline    string    test&quot;&quot;&quot;}",
        "url": "/kotlin-02"
    }
    ,
    
    "android-02": {
        "title": "android 1강",
            "author": "lee989898",
            "category": "",
            "content": "Android 공부는 여러 절로 구성되어 있습니다.     Android 시작    Android 1강 android 1강입니다.",
        "url": "/android-02"
    }
    ,
    
    "android-01": {
        "title": "android 시작",
            "author": "lee989898",
            "category": "",
            "content": "Android 공부는 여러 절로 구성되어 있습니다.     Android 시작    Android 1강 android 시작입니다.",
        "url": "/android-01"
    }
    ,
    
    "git-01": {
        "title": "git 시작",
            "author": "lee989898",
            "category": "",
            "content": "Git 공부는 여러 절로 구성되어 있습니다.     Git 시작    Git 1강 git 시작입니다.",
        "url": "/git-01"
    }
    ,
    
    "kotlin-01": {
        "title": "코틀린 규칙들",
            "author": "lee989898",
            "category": "",
            "content": "Kotlin 공부는 여러 절로 구성되어 있습니다.     코틀린 규칙들    변수와 자료형     형변환과 배열     타입추론과 함수     조건문과 비교연산자     반복문과 증감연산자     흐름제어와 논리연산자     클래스의 기본구조     클래스의 생성     클래스의 상속 코틀린 규칙들      한줄 짜리 주석 // 여러 줄 주석 /* */    fun main() {//안녕하세요  /*안 *녕 *하 *세 *요*/}        구문이 끝날때 세미콜론(;)을 붙이지 않아도 됩니다.  클래스 이름은 파스칼 표기법 ex) ClassName  함수나 변수 이름은 카멜 표기법 ex) functionName  warning: 불필요한 구문이 있거나 잠재적 문제가 있을 수 있습니다.  글자 하나하나가 2bytes의 메모리 공간을 사용합니다.+클래스에 선언된 변수 Property(속성) 이 외의 Scope 내에 선언된 변수 Local Variable(로컬변수)",
        "url": "/kotlin-01"
    }
    ,
    
    "gettysburg-address": {
        "title": "Gettysburg Address",
            "author": "abraham",
            "category": "",
            "content": "Kotlin 공부는 여러 절로 구성되어 있습니다.     코틀린 규칙들    변수와 자료형     형변환과 배열     타입추론과 함수     조건문과 비교연산자     반복문과 증감연산자     흐름제어와 논리연산자     클래스의 기본구조     클래스의 생성     클래스의 상속 function syntaxHighlight(code) {   var foo = 'Hello World';   var bar = 100;}# Jekyll configurationmarkdown: kramdown# kramdown : markdown의 개조판.# markdown에서 불편한 사항을 개선한 형태.# MyDataowner:  name:           JoonKyung Lee  avatar:         photo.jpg  bio:            &quot;student in mj&quot;  email:          wnsrud1352@gmail.com  # Social networking links used in footer. Update and remove as you like.  twitter:  facebook:  github:  stackexchange:  linkedin:  instagram:  flickr:  tumblr:  # google plus id, include the &#39;+&#39;, eg +mmistakes  google_plus:highlighter: rouge# text highlighter로 rouge이용# 2016.02월 이후로 syntax highlighter는 rouge만 지원.# Pygments 사용불가.paginate: 20# 작성한 모든 post를 하나의 페이지에 열거할 수 없으니# pagination이 필요하고 몇개의 post를 하나의 page에서# 보여줄 건지를 설정.language: &#39;en-uk&#39;# 언어 설정url: https://lee989898.github.io# Google Search Console에서 사용하는 sitemap.xml 생성시# 이 url key값이 존재하지 않으면 sitemap.xml이# 정상적으로 생성되지 않는다.# 또한 disqus(댓글시스템)를 이용하기 위해서도 필요.# 자신의 github page url을 입력# ( https://your_github_id.github.io 형식 )baseurl: /# Website infotitle: LEE# 자신의 blog title.description: 공부 블로그# blog home에 표시될 blog에 대한 전반적인 설명.cover: assets/built/images/blog-cover1.png# blog home에 표시될 blog cover image.logo:logo_dark:favicon: assets/built/images/favicon.jpg# favicon으로 사용할 imageproduction_url: https://lee989898.github.io/# 최종적으로 blog가 운영될 urlsource_url: https://github.com/lee989898/GitHubPageMaker/# blogmaker(jekyll source folder)에 대한 github repository# Social infonavigation: True# Navigation bar link를 보여줄건지 여부subscribers: True# subscriber 기능을 사용할건지의 여부# 저는 약간의 수정을 통해 subscriber 기능대신# lunr.js를 이용한 검색 기능으로 대체 사용했습니다.# 검색기능으로 대체하기 위해서# `_includes/subscribe-form.html` 파일의 수정이 필요합니다.twitter:facebook:# 만약 twitter와 facebook을 이용하면 username을 입력# Disqusdisqus: Truedisqus_shortname: xxxxxxxx# disqus는 온라인 댓글 시스템. 댓글 기능을 사용하기 위해# disqus를 이용할 것인지 여부와 만약 사용하면# disqus shortname을 입력 ( disqus username이 아님 )# Google Analyticsgoogle_analytics: UA-xxxxxxxx-x # replace with your GA tracking identifier# Google Analytics을 사용할 경우 GA tracking identifier를 입력# Permalinkspermalink: /:title# permalink: /author/:author# permalink: /tag/:title# 각각의 post에 고정주소를 어떤 방식으로 할당할 것인지를 결정# 이 값을 바꾸면 작성한 포스트의 저장위치나 파일이름이 변경된다.# gems and other configsplugins: [jekyll-paginate, jekyll-feed, jekyll-gist]feed:  path: feed.xml# Travis-CI 설정입니다.safe: Falselsi: Falseusername: lee989898repo: GitHubPageMaker# username : travis-ci와 연동하는 github의 username# repo: travis-ci와 연동하는 github의 repository이름# https://github.com/&lt;username&gt;/&lt;repository&gt;branch: master# 사용할 branch명relative_source:destination: ../[GitHubPage]/# compile된 결과가 생성되는 폴더# 이 폴더안의 내용이 우리가 운영하는 블로그 내용이 컴파일되서 들어간다.# 이 폴더안의 내용을 github repository(https://username.github.io)에 push# 만약 Travis-CI를 이용할 예정이면 이 부분을 git submodule로# github repository(https://username.github.io)에 연결해야 한다.# exclude는 Jekyll컴파일 시 destination에 포함될 필요가# 없는것들을 명시한다. (node_modules와 필요없는 것들은 제외)exclude:  - README.md  - Rakefile  - Gemfile  - Gemfile.lock  - changelog.md  - &quot;*.Rmd&quot;  - vendor  - .travis.yml  - node_modules  - assets/css  - assets/images  - _posts/angular  - _posts/et-cetera#  - _posts/kotlin  - _posts/typescript#  - _posts/git#  - _posts/android  - _posts/iot  - _posts/r  - _posts/economy제 4장 File Operation  1. 파일 시스템 구조          1.1 i-node      ",
        "url": "/gettysburg-address"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://lee989898.github.io/">LEE</a> &copy; 2021</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
        <div class="subscribe-overlay-content">
            
            <h1 class="subscribe-overlay-title">Search LEE</h1>
            <p class="subscribe-overlay-description">
                lunr.js를 이용한 posts 검색 </p>
            <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()"
               id="searchtext" type="text" name="searchtext"
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
        </div>
    </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
