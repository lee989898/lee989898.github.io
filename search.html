<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />
    <!-- highlight.js -->

    <!-- custom.css -->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css" />

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- 웹 폰트 -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!-- syntax.css -->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="공부 블로그" />
    <link rel="shortcut icon" href="https://lee989898.github.io/assets/built/images/favicon.jpg" type="image/png" />
    <link rel="canonical" href="https://lee989898.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

    


     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="LEE" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="공부 블로그" />
    <meta property="og:url" content="https://lee989898.github.io/search" />
    <meta property="og:image" content="https://lee989898.github.io/assets/built/images/blog-cover1.png" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="공부 블로그" />
    <meta name="twitter:url" content="https://lee989898.github.io/" />
    <meta name="twitter:image" content="https://lee989898.github.io/assets/built/images/blog-cover1.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="LEE" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "LEE",
        "logo": "https://lee989898.github.io/"
    },
    "url": "https://lee989898.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://lee989898.github.io/assets/built/images/blog-cover1.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://lee989898.github.io/search"
    },
    "description": "공부 블로그"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://lee989898.github.io/">LEE</a>
            
        
        
            
<ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-android" role="menuitem"><a href="/tag/android/">안드</a></li>
    <li class="nav-kotlin" role="menuitem"><a href="/tag/kotlin/">코틀린</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/python/">파이썬</a></li>
    <li class="nav-algorithm" role="menuitem"><a href="/tag/algorithm/">알고리즘</a></li>
    <li class="nav-pl" role="menuitem"><a href="/tag/pl/">프언</a></li>
    <li class="nav-security" role="menuitem"><a href="/tag/security/">컴퓨터보안</a></li>
    <li class="nav-system" role="menuitem"><a href="/tag/system/">시프</a></li>
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">All Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag별 Posts</a>
    </li>


</ul>



        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>


    </div>

</header>




<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "sc-12": {
        "title": "접근 제어",
            "author": "lee989898",
            "category": "",
            "content": "접근 제어  Access Control  허가되지 않은 사용자의 자원 접근 막고  정당한 사용자라도 허가되지 않은 방법으로 자원사용 막고  정당한 사용자가 허가된 방식으로만 자원에 접근하도록  Access control components  Authentication function: 사용자가 시스템에 접근할 수 있는지 결정  Access control function: 사용자의 요청이 허용되는지 결정  Security admin: 사용자의 요청이 자원에 어떻게 접근하는지를 명시한 권한 DB를 관리  Audit: 사용자가 시스템 자원에 접근하는 것을 기록, 감시  Access control architecture  Access Control Policy  접근 제어 정책  어떤 상황에서, 누구에게 어떤 종류의 접근이 허용되는지를 결정  권한 DB에 저장되며 보안 admin이 관리  종류 (동시에 사용가능)          Discretinoary access control(DAC)      Mandatory access control(MAC)      Role-based access control(RBAC)      Attribute-based access control(ABAC)        Discretinoary access control(DAC)  임의 접근 제어  요청자의 신분에 따라 무엇을 할 수 있는지 정의  Window, unix 등 컴퓨터 시스템 널리 사용  Access Matrix 사용          주체와 객체, 권한을 행렬로 표현        Access matrix          행: 자원접근 주체, subject      열: subject가 접근하는 대상자원, object      Entry: 허용되는 접근      -Matrix가 커질 수 있고, 희박해지면 메모리 낭비        방법1. ACL - Access control lists          Access matrix를 열로 분리      객체에 대한 권한을 가진 주체 파악에 유리        방법2. Capablility tickets          Access matrix 행으로 분리      특정 주체에 대해 승인된 객체와 권한 명시      특정 사용자에 허가된 객체/권한들을 정리하기 쉬움      다른 주체에서 티켓을 빌려 주거나 양도 -&gt; 보안문제 발생      티켓 무결성, 기밀성, 인증성      OS가 관리      분산, Cloud 환경에 적합        방법 3. authorization table          한 행에 한 주제의 한 자원에 대한 권한명시      RDB로 구현 용이        DAC 장단점 분석          장점                  객체별 세분화된 접근 제어가능                    단점                  Access Matrix 사용에 따른 메모리 낭비          주체나 객체별로 제어하기 때문에, 전체 자원의 일관성 있는 제어 어려움                      Role-based access control (RBAC)  각 사용자 대신에 역할에 접근 권할을 할당      상업적으로 회사,기관,조직에서 많이 쓰임    사용자 vs 역할 vs 자원의 관계는 다대다      관계는 동적이다    RBAC 장단점 분석          장점                  전체적으로 일관성있는 제어정책가능          직무분석 용이                    단점                  각 주체, 객체별 유연하게 하기 어려움                      Attribute-based access control(ABAC)  가장 최근  주체와 자원의 속성을 표현  DAC, RBAC의 기본개념 실형가능  유연성과 표현력이 우수  3요소 - 속성, 정책 모델, 아키텍처 모델  +유연하고 세분화 보안정책 설계      -설계자 과다업무, 비용    속성          주체, 객체, 환경, 권한에 의해 미리 정의되고 할당된 요구되는 동작의 특정 측면을 정의하는 성질​      주체 속성​                  주체는 정보가 객체사이에 이동하거나 시스템 상태를 변경하는 능동적 존재(User, application, process, device)​          주체의 이름, 소속, 직책 등​                    객체 속성​                  정보를 포함하거나 받는 수동적 시스템 존재 (file, device, table, record, process, program, network)​          MS Word문서는 이름, 저자, 날짜 등을 속성으로 가짐​                    환경 속성​                  운영, 기술, 상황, 환경 기술​          현재 날짜, 시간, 네트워크 보안 레벨                    ",
        "url": "/sc-12"
    }
    ,
    
    "pl-17": {
        "title": "ImplementSubprogram",
            "author": "lee989898",
            "category": "",
            "content": "ImplementSubprogram서브프로그램 호출과 반환의 구현, 이것을 서브프로그램 링키지(linkage)라고 합니다.​  Semantics of Calls and Returns서브프로그램 링키지는 호출과 반환에 관련된 액션들의 실행으로 구성된다. ​이러한 액션들을 호출 및 반환 시맨틱이라고 한다. ​일반적인 서브프로그램 호출 시맨틱은 다음을 포함한다. ​  파라미터 패싱 방법의 구현, ​  로컬 변수에 대한 스토리지 할당 및 바인딩 (로컬 변수가 정적 변수가 아닐 경우) ​  콜러의 실행 상태 저장: ​          실행상태는 콜러의 재실행(resume)에 필요한 레지스터 값, CPU 상태 비트, 환경 포인터(EP)를 포함하며,​      EP는 콜리의 실행 중에, 로컬 변수 및 파라미터를 접근하는데 사용된다.  ​        콘트롤을 콜리에게 이전​  콜리에 나타나는 난로컬 변수의 접근 메커니즘의 생성서브프로그램의 반환 시맨틱은 다음을 포함한다. ​  포말 파라미터의 로컬 값을 액추얼 파라미터에게 인아웃 또는 아웃 모드로 카피​  로컬 변수의 스토리지를 해제​  콜러 실행 상태의 재저장​  콜러에게 콘트롤 이전  Implementing “Simple” Subprograms단순 서브프로그램의 호출 및 반환을 어떻게 구현하는지 보자.  단순 서브프로그램에서는 ​서브프로그램의 중첩을 허용하지 않고, 모든 로컬 변수가 정적이다. ​  호출과 반환에 필요한 스토리지는 다음의 데이터를 포함한다. ​          콜러의 상태 정보, 파라미터, 복귀 주소, 함수의 반환값​        단순 서브프로그램은 서브프로그램 코드와 데이터로 구성되는데, ​          데이터 파트는 로컬 변수, 호출과 반환에 필요한 데이터(위에 언급된)를 포함한다.      단순 서브프로그램의 호출 시맨틱스(액션과 그 순서)은 다음과 같다. ​  현재 수행중인 프로그램(콜러)의 실행 상태를 저장 ​  파라미터의 계산 및 패스​  콜리에게 복귀 주소를 패스​  콜리에게 컨트롤을 이전단순 프로그램의 반환 시맨틱스(액션과 그 순서)는 다음과 같다. ​  포말 파라미터의 현재 값을 대응하는 액추얼 파라미터에게 카피 (만일 pass-by-value-result나 pass-by-value라면) ​  함수 값을 콜러에게 카피(만일 콜리가 함수라면) ​  콜러의 실행 상태를 재저장​  콜러에게 컨트롤을 재이전(되돌려줌)실행중인 서브프로그램의 데이터 파트를 위한 데이터 구조로 액티베이션 레코드를 정의한다.액티베이션 레코드는 로컬 변수, 파라미터, 복귀 주소로 구성된다.단순 서브프로그램의 액티베이션 레코드(AR)는 크기가 고정되어 있고, ​정적으로 할당된다.따라서 스택에 저장되지 않는다. ​이러한 액티베이션 레코드는 recursion을 지원할 수 없다.​위 그림은 단순 서브프로그램의 액티베이션 레코드의 예이다.예에서 단순 서브프로그램은 A, B, C이고, 이들의 코드와 액티베이션 레코드는 오른쪽 그림과 같이 메모리에 할당된다.메모리에 할당되는 A, B, C의 코드와 데이터의 위치는 ​정적으로 할당되기 때문에 호출되는 순서와 무관하다.A, B, C 모두 별개로 컴파일될 수 있으며, ​이 경우 링커에 의해 그림과 같이 모아진다.  Implementing Subprograms with Stack-Dynamic Local Variables서브프로그램의 로컬 변수가 스택-동적일 경우, ​서브프로그램의 호출 및 반환 구현에 대해 알아보자.스택 동적 로컬 변수는 런타임 스택에 할당된다. ​장점은 recursion의 지원이다.  ​스택-동적 로컬 변수가 있는 서브프로그램의 호출과 반환을 구현하려면 ​액티베이션 레코드가 더욱 복잡해진다.  ​  컴파일러는 ‘스택에서 로컬 변수의 암묵적인 할당과 해제’를 지원하기 위한 코드를 생성해야 한다.  ​      Recursion은 하나의 서브프로그램에 대해 여러 개의 액티베이션 레코드를 추가할 가능성이 있다. ​즉, 액티베이션 레코드 여러 개가 스택에 생성된다.    int AddTwo(int x,y){  int sum;  sum = x + y;  return sum;}      위 함수를 실행하려면 어떤 데이터가 필요할까?파라미터 x, y, 로컬 변수 sum, AddTwo 종료후 복귀할 return address이와 같이, 액티베이션 레코드는 함수를 한번 실행하는데 필요한 데이터로 구성된다. ​그러면… 스택에 저장된 이들 변수를 어떻게 접근할까? ​Caller의 스택 포인터를 이용하면 가능한가? 아니다.SP는 액티베이션 레코드를 스택에 저장하고자 할 때, ​스택 메모리를 할당하고(나중에 해제하는) ‘시스템이 사용하는’ 레지스터이다.따라서 서브프로그램이 사용할 수 있는 레지스터가 아니다.​액티베이션 레코드에 저장된 파라미터나 로컬 변수에 접근하려면, ​      액티베이션 레코드에 접근할 때, ​BP(베이스 포인터)를 사용한다.BP는 AR의 맨앞의 주소를 말하며, ​서브프로그램의 실행 중에 변경되지 않는다.BP는 지정된 레지스터에 저장되는데, 그림에서 이것을 BP라고 표시하자. ​        파라미터나 로컬 변수에 접근하려면, ​BP+옵셋을 계산하여 스택에 저장된 파라미터나 로컬 변수에 접근한다. ​        서브프로그램이 종료되어 반환될 때, ​BP는 ‘caller의 액티베이션 레코드의 BP’로 재저장된다.여기서 return addr는 복귀 주소로, ​서브프로그램의 종료후 되돌아갈 caller의 위치를 나타낸다.  BP는 항상 현재 실행 중인 프로그램의 액티베이션 레코드의 시작 주소를 가리킨다.서브 프로그램이 호출되면, 현재 BP는 callee의 액티베이션 레코드(dynamic link)에 저장되고 ​BP는 새로 생성된 callee의 액티베이션 레코드의 시작 주소를 가리키도록 새롭게 설정된다.즉, callee로부터 반환되자마자, BP는 callee의 액티베이션 레코드(dynamic link)의 값으로 재저장된다.​​위 그림은 코드와 데이터, 서브프로그램 링키지 코드(AddTwo PROC),그리고 액티베이션 레코드가 저장된 스택을 보여준다.esp, ebp는 각각 스택포인터, 베이스 포인터이며, eax는 반환값을 저장하는 장소이다AddTwo PROC은 스택에 할당된 액티베이션 레코드에 접근하여, ​스택에 저장된 두 수를 더하여 eax에 저장하여 반환하고, 반환후 5와 6이 저장되었던 8 바이트를 청소하고 종료하는 과정을 보여준다.이때 EBP, ESP를 caller의 것으로 변경한다.​Recursion이 없이, 여러 서브프로그램으로 구성된 프로그램에서, ​메인이 B를 호출하고, ​B가 C를 호출하고, ​A가 C를 호출한다고 하자. 그렇게 되면, 위와 같이 액티베이션 레코드가 스택 메모리에 할당된다.동적 링크는 바로 아래(caller)의 액티베이션 레코드를 가리킨다.이와 같이, 스택에 스택-동적 액티베이션 레코드가 연속적으로 쌓여진 것을 동적 체인(dynamic chain)이라고 한다.로컬 변수의 접근은 BP와 옵셋을 계산에 의하며, 이러한 옵셋을 로컬 옵셋이라고 한다.로컬 변수의 로컬 옵셋은 컴파일러에 의해 컴파일 타임에 결정된다.​​​Recursion이 있을 때, ​액티베이션 레코드는  위의 그림과 같다. ​여기서 파라미터는 n이다.첫째, 둘째, 셋째 recursion을 호출했을 때 function value가 모두 ?셋째 recursion을 종료되었을 때 둘째 호출이 종료되었을 때 function value가 모두 ?이 아니다.",
        "url": "/pl-17"
    }
    ,
    
    "st-02": {
        "title": "Signal",
            "author": "lee989898",
            "category": "",
            "content": "Signal",
        "url": "/st-02"
    }
    ,
    
    "st-01": {
        "title": "Process_Control",
            "author": "lee989898",
            "category": "",
            "content": "Process Control  exec프로세스가 exec 함수 중 하나를 호출할 때  프로세스는 새 프로그램으로 완전히 대체된다. 텍스트, 데이터, 힙 및 스택 세그먼트를 부모의 주소 공간에 로드한다.  새 program은 main function에서 시작한다.      새 program은 caller와 동일한 PID를 사용한다.    #include &lt;unistd.h&gt;main(){ printf(\"execiton ls\\n\")};execl(\"/bin/ls\",\"ls\",\"-l\", (char *)0);perror(\"execl failed to run ls\\n\");exit(1);}        exec: Program Execution  프로세스 실행을 맡고 있는 시스템 콜은 execve()이다  같은 기능을 하면서 라이브러리 함수로 분류되어 있는것으로 execv(), execvp(), execle(), execl(), execlp()가 있다 ​  이 6가지를 합쳐서 exec()시스템 콜이라 부른다exec() 이후에 오는 문자에 의해 구별되는 표시는 다음의 의미가 있다.  l -&gt; argv 정보를 개개의 문자열 데이터를 가르키는 포인터 arg0,arg1……. argn으로 전달한다  v -&gt; argv 정보를 개개의 문자열 데이터를 가리키는 포인터 배열의 ​선두주소 argv로 전달한다​  e -&gt; envp 정보를 전달한다​      p -&gt; p를 사용하는 경우, 실행할 파일이름을 환경 변수 PATH로 지정한 디렉토리 안에서 찾아내어 실행한다​    #include &lt;unistd.h&gt;int execl(const char *path, const char *arg0, ... *argn,(char *)0);        path: 실행 가능한 파일 경로  arg0~argn: 파일에 전달한 argv 정보(명령 인수)  (char*)0: 마지막임을 알리는 표시로 NULL 포인터  리턴값: 에러시 -1  execl.c#include&lt;unistd.h&gt;main(int argc, char *argv[]){    execl(\"/bin/ls\",\"ls\",argv[1],(char *)0);}  execv.c#include&lt;unistd.h&gt;main(){    char *av[3];    av[0]=\"ls\";    av[1]=\"-1\";    av[2]=(char *)0;    execv(\"/bin/ls\",av);}  execle() #include &lt;unistd.h&gt; int execle(const char *path, const char *arg0...*argn,                    (char *)0, char *const envp[]);  path: 파일의 경로명  arg0 ~ argn: 파일에 전달한 argv 정보(명령 인수)  envp[]: envp 정보(환경변수)  리턴 값: 에러시 -1  execl()에 환경 변수 정보를 전달하는 기능을 추가한 것  execve()#include &lt;unistd.h&gt;int execve(const char* path, char *const argv[],                char *const envp[]);  path: 파일의 경로명  argv: 파일에 전달한 argv 정보(명령 인수)  envp[]: envp 정보(환경변수)  리턴 값: 에러시 -1  execv()에 환경 변수 정보를 전달하는 기능을 추가한 것  execlp()#include &lt;unistd.h&gt;int execlp(const char *file, const char *arg0, .... *argn);  file: 실행하는 파일의 파일 이름  arg0 ~ argn: 파일에 전달한 argv 정보(명령 인수)  리턴 값: 에러시 -1  execlp()는 첫 번째 인자 file에서 지정한 파일 이름을 환경 변수 PATH에서 지정하고 있는 디렉토리 안에서 찾아 실행한다  execvp()#include &lt;unistd.h&gt;int execvp(const char *file, char *const argv[]);  file: 실행하는 파일의 파일 이름  argv: 파일에 전달한 argv 정보(명령 인수)  리턴 값: 에러시 -1  execlp()는 첫 번째 인자 file에서 지정한 파일 이름을 환경 변수 PATH에서 지정하고 있는 디렉토리 안에서 찾아 실행한다  Race Conditions  여러 프로세스가 일부 데이터를 공유  결과는 실행 순서(예: RACE)에 따라 다르다  fork() 후에는 부모 또는 자식이 먼저 실행되는지 예측할 수 없다  실행 순서는 다음에 따라 다르다          시스템 부하      커널의 스케줄링 알고리즘      Race condition 문제는 대부분의 시간 작동하기 때문에 감지하기 어렵다  after fork          parent,child 모두 스스로 무언가를 한다      예를 들어 parent: 로그 파일에 기록 쓰기      예를 들어 child: 로그 파일 생성        parent,child는 다음을 수행해야 한다          초기 작업 세트가 완료되면 서로 알리고      서로 완료될 때까지 기다린다        system()#include &lt;stdlib.h&gt;int system(const char *cmdstring);  문자열이 터미널에서 명령으로 입력된 것처럼 문자열이 sh(1)에 입력으로 제공한다. ex) system(“date &gt; file”);  fork, exec 및 waitpid를 호출하여 시스템을 구현한다.  반환 값:          -1 with errno: fork 또는 waitpid 실패      127 : 실행 실패      쉘 종료 상태: 3개 모두 성공        Process Times#include &lt;sys/times.h&gt;clock_t times(struct tms *buf);struct tms(    clock_t tms_utime;    clock_t tms_stime;    clock_t tms_cutime;    clock_t tms_cstime;)  wall clock time: 프로세스가 실행되는 데 걸리는 시간이며 시스템 부하에 따라 다르다.          반환된 wall clock time의 시간은 과거의 임의의 지점에서 측정된다. 상대 값을 사용한다.        사용자 CPU 시간: 사용자 지침에 기인  시스템 CPU 시간: 프로세스를 대신하여 실행될 때 커널에 귀속됨",
        "url": "/st-01"
    }
    ,
    
    "sc-11": {
        "title": "이메일 보안",
            "author": "lee989898",
            "category": "",
            "content": "이메일 보안  PGP  운영체제에 상관없이 확정성이 뛰어나다  S/MIME  공개키 기반의 프로토콜이다  RSA, El Gamel을 사용한다  대칭키 방식과도 연동된다(3DES)  Requirements of secure E-mail  기밀성  송신자 인증  메시지 무결성  수신자 인증  Secure e-mail: 기밀성  앨리스는 기밀성을 입증한 e-mail, m을 밥에게 보내고 싶다  랜덤 대칭키를 생성한다, KS  메시지를  KS로 encrypt한다  또한 KS를 밥의 공개키로 encrypt한다      밥에게 KS(m)과 KB(KS)를 보낸다    밥은 그의 private키로 decrypt하여 KS를 찾아낸다  KS로 KS(m)을 decrypt하여 m을 찾아낸다  Secure e-mail: 송신자 인증, 무결성  앨리스는 송신자 인증과 메시지 무결성을 지키고 싶다  앨리스는 메세지를 digitally 사인한다  메시지와 디지털 시그니처 모두 보낸다  Secure e-mail: all together  앨리스는 보안,송신자 인증,메시지 무결성을 지키고 싶다  앨리스는 3가지 키를 사용한다          그녀의 private key      밥의 public key      새로 만들어진 대칭키        Email 보안 표준  PGP  S/MIME          이메일을 위해 MIME에 보안서비스 제공 표준      인증,무결성,부인방지,기밀성 제공      ",
        "url": "/sc-11"
    }
    ,
    
    "sc-10": {
        "title": "signature",
            "author": "lee989898",
            "category": "",
            "content": "signature  서명  자기의 동일성을 표시하고 책임을 분명하기 하기 위하여 문서 따위에 자기 이름을 써넣음​  전자서명의 기본 아이디어  송신자(alice)는 자신의 비밀키로 암호화​  수신자는 송신자의 공개키로 복호화  시나리오:+ Bob은 public key를 공개된 장소에 두고, private key는 자신이 가지고 있다+ Alice는 Bob의 public key를 가져와, 메시지를 암호화해서 전송​+ 이 메시지는 다른 사람이 보더라도 풀 수 없다. 메시지를 복호화하려면 Bob의 private key가 필요하기 때문-&gt;기밀성보장​  문제점1. Bob은 Alice가 메시지를 작성했다는것을 확신할 수 있을까? NO​  문제점2. Bob은 메시지가 중간에 변경되지않았다는것을 확신할 수 있을까? NO​  해결법  Alice는 메시지로 MAC을 만들고, 이것을 Alice가 자신의 private key로 암호화 한다​     만들어진 것을 본래 메시지에 붙인다 -&gt; 서명​     이것을 Bob의 public key로 암호화 해서 전송  다른 사람은 Bob의 private key가 없으므로 볼수없다 -&gt; 기밀성​  Bob은 자신의 private key로 열면 평문과 시그니쳐가 나온다​     Bob은 다음과 같이 무결성,인증을 한다​   ",
        "url": "/sc-10"
    }
    ,
    
    "pl-16": {
        "title": "서브프로그램",
            "author": "lee989898",
            "category": "",
            "content": "서브프로그램  Fundamentals of Subprograms서브프로그램이 무엇인지 왜 필요한지 살펴 보자.동일한 코드 부분(segment)이 프로그램의 여러 곳에서 나타난다고 하면, 이 코드를 여러 곳에 중복해서 코딩하기보다는,​한번만 코딩하고, 필요할 때마다 그 코드 부분으로 점프했다가 끝나면 되돌아 오는 방식으로, 프로그램을 짤 수 있다.이러한 코드 부분을 서브프로그램이라고 한다.동일한 코드 부분이 프로그램의 여러 곳에 나타나고, ​나타나는 곳마다 사용되는 변수가 다르다고 가정해 보자.이때 파라미터를 갖는 서브프로그램을 사용할 수 있다.서브프로그램의 개념은 쓰레드와 같은 것으로 발전하고 있다.  서브프로그램은 다음과 같은 특징을 갖는다. ​  각 서브 프로그램은 단하나의 진입점을 갖는다. ​  호출한 서브프로그램(caller)는 호출된 서브프로그램(callee)의 실행 중에는 중지된다. ​  Callee가 종료되면, 컨트롤을 항상 caller에게 되돌려준다.  ​서브프로그램은 정의부와 선언부로 구성된다.서브프로그램 정의부는 서브프로그램의 인터페이스와 액션을 서술하고, ​정의부의 맨앞에는 서브프로그램의 헤더가 있다.헤더는 void adder(parameter) 처럼 서브프로그램 이름, 유형, 포말 파라미터 등을 포함한다. 포말 파라미터의 개수, 순서, 타입을 파라미터의 프로파일(시그니처, 요약)이라고 부른다. ​서브프로그램 선언부는 파라미터 프로파일과 반환 타입을 선언한다.서브프로그램 호출(call)은 서브프로그램으로 점프한다. ​서브프로그램에서 데이터에 접근하는 방법은 두가지가 있다. ​  난로컬 변수에 직접 접근하는 경우 ​  파라미터 패싱을 사용하는 경우 ​파라미터 패싱을 사용하여 데이터를 접근할 때에는 ​로컬 변수명을 사용한다.난로컬 변수에 직접 접근하는 것보다 융통성이 높아 파라미터화에 의한 계산이 가능하다.난로컬 변수에 대한 광범위한 접근은 부작용으로 인해 신뢰성을 감소시킨다. ​순수 함수 언어는 수정 가능한 데이터를 허용하지 않으며, 메모리 내용을 변경할 수 없도록 제한한다. ​포말 파라미터는 callee의 헤더에 있는 파라미터를 말한다.서브프로그램이 호출될 때만 메모리에 바인딩되고, ​액추얼 파라미터를 통해서 바인딩되기 때문에, ​종종 더미 변수로 취급되기도 한다.액추얼 파라미터는 caller에서 사용되는 값이나 주소를 나타낸다.액추얼 파라미터를 포말 파라미터에 바인딩하는 방법은 두 가지가 있다. ​  위치 파라미터: 파라미터의 순서가 중요 ​  키워드 파라미터: 파라미터의 이름이 중요, 순서는 중요하지 않음파이썬에서 sumer(my_length, list=my_array, sum = my_sum),  ​포말 파라미터는 length, list, sum이고, ​액추얼 파라미터는 my_length, my_array, my_sum 이라면, ​첫번째 파라미터는 위치 파라미터이고, ​두번째 세번째는 키워드 파라미터이다.  ​키워드 파라미터의 장점은 순서에 얽매이지 않는다는 것이고, ​단점은 사용자가 포말 파라미터의 이름을 알고 있어야 한다는 것이다.C++, 파이썬 등에서는 액추얼 파라미터가 모두 다 패스되지 않을 경우, ​포말 파라미터는 대응되지 않는 나머지 파라미터에 대해 디폴트 값을 가질 수 있다. ​C++에서 파라미터는 위치에 연관되기 때문에 ​디폴트 파라미터는 마지막에 나타나야 하며, ​디폴트값은 서브프로그램 헤더에 있다. ​서브프로그램 내에 정의된 변수는 모두 로컬이며, ​그들의 스코프는 항상 서브프로그램 안이다.로컬 변수는 정적 또는 스택-동적으로 바인딩된다. ​로컬 변수가 스택-동적이라면, ​서브프로그램의 실행이 시작될 때 메모리에 바인딩되고, ​실행이 끝나면 메모리에서 떨어진다. ​스택-동적 변수의 장점은, ​  Recursive 서브프로그램이 스택-동적 로컬 변수를 갖는다 -&gt; recursion 처리가 가능​  액티브 서브 프로그램의 로컬 변수가 ​액티브하지 않은 서브프로그램이 해제한 로컬 변수의 메모리를 사용할 수 있다. ​프로그램이 시작되고나서 아직 끝나지 않은 상태에서는 ​자주 호출되는 서브프로그램의 실행이 끝났다고 해도 ​그 서브 프로그램의 변수는 아직 메모리를 차지하고 있을 수 있다.이때 서브프로그램의 상태를 액티브라고 한다. ​현대 언어에서, 서브프로그램의 로컬 변수는 디폴트로서 스택-동적으로 바인딩된다. ​C, C++ 함수에서, 로컬 변수는 정적이라고 명시되어 있지 않으면 스택-동적이다. ​서브프로그램이 다른 서브프로그램안에만 있어야 한다면, ​이것을 중첩 서브프로그램이라고 한다. ​다른 서브프로그램 안에서 숨어서(hide) 다른 프로그램이 호출할 수 없게 만든다. ​서브프로그램의 중첩으로 처리 논리와 스코프의 계층구조를 생성할 수 있다. ​  정적 스코핑의 사용 ​  알골, 파스칼에서 허용 ​  C 계열 언어는 서브프로그램의 중첩을 허용하지 않음​  자바스크립트, 파이썬 등은 중첩 허용  Parameter-Passing Methods파라미터 패싱에 대한 시맨틱 모델은 3가지가 있다. ​  포말 파라미터가 대응하는 액추얼 파라미터로부터 데이터를 받는 것이다. 이것을 in mode라고 한다. ​  포말 파라미터가 액추얼 파라미터에게 데이터를 보내는 것이다. 이것을 out mode라고 한다. ​  포말 파라미터가 대응하는 액추얼 파라미터로부터 데이터를 받고, 액추얼 파라미터에게 데이터를 보내는 것이다. 이것을 inout mode라고 한다.  ​파라미터간에 데이터를 주고 받는 방법은 두가지가 있다.실제 값을 카피하여 주고 받는 방법과 액세스 패스(접근 경로)를 주고 받는 방법이다.파라미터 패싱 구현 모델에는 ​pass by value(in mode), pass by result(out mode), ​pass by value result(inout mode), pass by reference(inout mode)가 있다. ​Caller의 액추얼 파라미터를 Pass by value 모델로 callee에게 보낼때, 액추얼 파라미터의 값은 copy를 통해, ​대응되는 포말 파라미터의 초기화에 사용된다. ​단점은 다음과 같다. ​  copy 하면, ​  추가적인 메모리를 필요로하고, 실제 이동 비용이 발생한다. ​  만일 접근 경로(access path)에 의한다면, callee에서 쓰기 보호를 해야하는 동시에, ​간접 주소방식에 의한 접근 비용이 추가된다.Callee의 파라미터를 pass by result 모델로 caller에게 보낼 때, ​  대응되는 포말 파라미터는 로컬 변수처럼 행동한다. ​  Callee가 종료되어 컨트롤을 caller에게 돌려주면, 포말 파라미터의 값을 caller의 액추얼 파라미터로 전달한다. ​  추가적인 메모리 위치와 copy 연산이 필요하다. ​Pass by result에 내재하는 문제는 다음과 같다. ​Caller와 callee가 ​Caller: sub(p1, p1) actual parameter p1, p1​ Callee: sub(x, y) formal parameter x, y 라고 하자 액추얼 파라미터 두개가 p1으로 같고, ​대응하는 포말 파라미터 두개의 이름이 x, y로 다르다. ​Caller가 callee를 호출해서 callee가 실행 후 종료되고, ​Callee가 calle에게 결과값을 반환할 때, ​X, y 중 어느 것이 p1에 마지막으로 copy 되느냐에 따라, ​p1의 값이 달라진다. ​x거나 y이다. ​이것이 pass by result에 내재하는 문제이다.Pass by value result는 ​pass by value와 pass by result의 결합으로 ​pass by copy라고도 부른다. ​액추얼 파라미터의 값은 대응하는 포말 파라미터의 초기화에 쓰이고, ​포말 파라미터는 로컬 변수처럼 행동한다. ​포말 파라미터의 값은 액추얼 파라미터에게 반환된다. ​단점은 in, out 모두 카피에 의존. ​Pass by reference 모델은 접근 통로의 패스를 통해, ​파라미터를 패스한다. ​즉, callee에게 caller의 액추얼 파라미터를 접근하도록 허용한다. 따라서 pass by sharing이라고도 한다. ​장점은 패싱 프로세스가 효율적이다. ​Copy 연산, 메모리 모두 필요없다. ​단점은 느리고, 예기치 않았던 난로컬 변수를 접근할 수도 있다. ​대부분 언어에서, 파라미터 패싱의 구현은 런타임 스택을 통해 일어난다. ​C에서 파라미터 패싱은 pass by value를 지원한다.포인터를 사용하면, Pass by reference를 구현할 수 있다.자바는 모든 파라미터에 대해 pass by value를 지원하며,객체 파라미터에 대해 pass by reference를 지원한다.파라미터에 대한 타입 검사는 ​액추얼 파라미터와 포말 파라미터 간에 타입의 일관성을 검사하는 것이다. ​파라미터의 타입 검사는 소프트웨어의 신뢰성을 위해 매우 중요하다. ​포트란 77, 원시 C에는 파라미터 타입 검사가 없다.ANSI C, C++에는 선택적이며, ​파이썬, 루비에서는 변수가 타입을 갖지 않기 때문에 ​파라미터 타입 검사가 없다.파라미터의 타입이 다차원 배열일 경우, ​서브프로그램이 따로 컴파일되어 있고, ​다차원 배열이 서브프로그램으로 패스된다고 가정하자. ​컴파일러는 메모리 매핑을 위해, ​선언된 배열의 크기를 알 필요가 있다.  ​Row-major 매트릭스의 메모리 매핑 함수는 ​address(mat[i,j]) = address(mat[0,0]) + i * #_columns + j 이다. ​즉, 컬럼의 길이만 알면 전체 크기를 알 수 있다.현대 프로그래밍 언어에서 다차원 배열 파라미터를 어떻게 패스하는지 살펴 보자.​C, C++에서,1) 프로그래머가 액추얼 파라미터의 첫번째 서브스크립트를 제외하고, ​나머지 서브스크립트의 크기를 선언하는 방법. ​슬라이드의 프로그램에서 mat은 2차원 배열이고, ​함수 fun(mat)은 mat을 파라미터로 하는 함수이다.이와 같은 방식은 서브프로그램의 유연성을 불허한다는 것이다. ​2) 이에 대한 해결책으로, ​배열에 대한 포인터, 차원 크기를 파라미터로 패스하는 방법이 있다.다만, 배열 처리를 위해 ​사용자는 메모리 매핑 함수를 포함해야 하는 불편함이 있다.자바에서는 배열을 객체로 취급한다.이들은 모두 일차원 배열이지만 ​배열의 각 요소가 배열일 수 있어서 ​다차원 배열을 파라미터로 쓸 수 있다.자바에서 각 배열은 named constant(length와 같은)를 상속받는다.파라미터 패싱 방법의 구현시, 다음 두가지를 고려해야 한다. ​  효율성, ​  일방(in, out) 또는 쌍방(inout) 데이터 이동:caller-callee간에  ​그러나 이들 고려사항은 서로 상충된다. ​프로그래밍을 잘하려면, 변수에 대한 접근을 가능한한 일방(in, out)으로 제한하는 것이 좋다.pass by reference(inout)는 크기가 큰 데이터 스트럭처를 패스하는데 더욱 효율적인 반면, ​변수에 대한 접근을 제한하는데 문제를 일으킬 수 있다.  Parameters That Are Subprograms이번엔 서브프로그램 이름을 파라미터로 패스하는 경우를 살펴보자. 종종 서브프로그램 이름을 파라미터로 패스하는 것이 편리할 때도 있다.​즉, 계산을 서브프로그램으로 패스하는 것이다.파라미터 타입 검사? ​  C, C++ 함수 포인터로 패스함. ​-&gt; 함수 포인터의 타입은 파라미터 타입을 포함하므로 파라미터 타입 검사는 가능함 ​  자바는 메소드 이름을 파라미터로 패스하는 것을 불허함서브프로그램 중첩을 허용하는 언어에서, ​어떤 바인딩 방식에 의한 레퍼런싱 환경을 사용하는가? ​  쉘로우 바인딩: 패스된 서브프로그램을 실행시킨 call문(호출문)의 환경 ​  딥바인딩: 패스된 서브프로그램에 정의된 환경​  즉흥(ad hoc) 바인딩: 서브프로그램을 액추얼 파라미터로 패스한 호출문의 환경 function sub1() {​  var x;​  function sub2() { alert(x); };​  function sub3() {​    var x; x = 3;​    sub4(sub2); }​  function sub4(subx) {​    var x; x = 4;​    subx(); }​  x = 1;​  sub3(); }Sub4의 sub에 대해​쉘로우 바인딩을 했을 경우 ​실행시킨 call문의 환경은 sub4가 되고, ​sub4에서 x는 4이다. ​딥 바인딩을 했을 경우​Sub2가 정의된 환경은 sub2가 되고,  ​Sub2에서 x는 난로컬로서 sub1에 따른다. ​따라서 x는 1이다. ​즉흥 바인딩일 경우, ​Sub2를 파라미터로 넘긴 call문의 환경은 sub3가 되고, ​Sub3에서 x는 3이다. ​  Design Issues for Functions언어 설계시 고려사항은부작용 허용 여부? 부작용을 줄이려면 파라미터는 항상 in mode가 좋다. ​반환 값의 타입은? 대부분의 명령형 언어가 반환값의 타입을 제한함. ​  C는 배열과 함수를 제외하고 모든 타입을 허용함. ​  C++은 C와 유사하나 사용자 정의 타입을 허용​  자바는 모든 타입 허용. ​  파이썬, 루비는 반환값 타입으로 객체도 허용  Coroutines코루틴에서 중요한 것은 재시작(resume) 명령.프로그램 단위의 유사 동시 실행 기능을 제공함. 인터리빙.​위그림은 A가 먼저 시작하고, B를 재시작하고나서 스스로 중지했다가, ​B가 A를 재시작하고 나서 스스로 중지했다가, ​번갈아 가며 실행되는 형태를 보여주고 있습니다.​위 그림은 B가 먼저 시작하고, A를 재시작하면서 스스로 중지하고, ​번갈아가며 실행되는 형태를 보이고 있습니다.​위그림은 룹에서 서로 중지하고 상대방을 재시작하는 것을 반복함",
        "url": "/pl-16"
    }
    ,
    
    "algorithm-05": {
        "title": "탐욕 기법",
            "author": "lee989898",
            "category": "",
            "content": "탐욕 기법  탐욕 기법  매 번 선택할 때 마다 그 순간에 좋은 선택을 함으로써 최종적인 해에 도달한다.  최적인 해들을 모아서 최종 해를 만들었다고 해서, 그 해가 궁극 적으로 최적이라는 보장이 없다.  따라서 탐욕 기법은 항상 최적의 해를 만들어내는 지를 반드시 검증해야 한다.  선택 기준  선택이 실현 가능해야 한다.  모든 선택들 중에서 최적이라고 여겨지는 선택을 해야 한다.  한 번 선택하면 나중에 되돌릴 수 없다.  설계 전략  비어 있는 해 모음으로 시작한다.  탐욕적인 기준에 따라 해 모음에 추가할 다음 해를 선택한다.  새 해 모음이 실형 가능한지를 확인한다.실현 가능하다면 새 해 모음을 확정하고 아니면 선택한 해를 버린다.  새 해 모음이 최종 해라면 종료한다. 아니면 2번으로 간다.  거스름돈 주기거스름돈을 동전들의 수가 최소가 되도록 주어야 한다.  액면가가 다른 m(&gt;=1)개의 동전들이 있다.  동전 i,1&lt;=i&lt;=m,의 액면가는 $d_i$ 이고 $d_1$ &gt; $d_2$ &gt; … &gt; $d_m$ = 1이다.  액면가가 같은 동전들의 개수는 무한히 많이 있다.  거스름돈 n(&gt;=1)을 최소 개수의 동전들을 사용하여 주어야 한다.  탐욕 알고리즘의 아이디어주어야 할 거스름돈이 남아 있는 동안 다음을 반복한다.  남은 동전들 중 액면가가 가장 큰 동전을 선택한다.  선택한 동전을 거스름돈에 추가하면 거스름돈이 주어야 할 금액을 초과한다면 그 동전을 버린다. 아니면 그 동전을 거스름돈에 추가하고 주어야 할 거스름돈을 추가한 동전의 액면가만큼 감소시킨다.주: 최적의 알고리즘  탐욕적인 알고리즘coinChange(d[],m,n)//거스름돈에 포함되는 동전들의 수를 최소화한다.//입력: m - 액면가가 다른 동전들의 수//     d[1..m] - 동전들의 액면가를 저장하는 배열//     n - 거스름돈//출력(반환 값): 거스름돈에 포함된 동전들의 최소 개수1  count = 02  i = 13  while(n &gt; 0 &amp;&amp; i &lt;=m){4    count = count + $\\frac{n}{d[i]}$ 　//가치가 가장 큰 동전들을 최대한 많이 선택5    n = n mod d[i] 　　　 //남은 거스름돈을 계산6    i = i + 1 　　　　　　 //다음으로 가치가 큰 동전을 선택    }7  return count  시간 복잡도  입력의 크기: m(액면가가 다른 동전들의 수)  기본 연산: 4번의 배정문  기본 연산의 수행 횟수: 최대 m  시간 복잡도: m = $\\theta$(m)  최소 비용 신장 트리 찾기  n(&gt;1)개의 도시들을 최소한의 비용으로 연결하는 철도망을 새로 구축하려고 한다.  모든 도시들을 서로 연결하기 위해 도시간 철도를 최소한(n-1)개 깔아야 한다.  각 철도는 두 도시를 연결한다.  이 철도망들 중에서 철도 노선들의 총 길이가 최소가 되도록 철도망을 구축해야 한다.  최소 비용 신장 트리  신장트리: 연결된, 무방향 그래프 안에 있는 모든 정점을 다 포함하면서 트리가 되는 연결된 부분 그래프  산장트리는 순환을 포함하지 않으며 그래프 안에 있는 모든 정점들을 연결시칸다.  신장트리의 가중치: 모든 간선들의 가중치들의 합  최소 비용 신장 트리: 최소 가중치를 가진 신장트리​  억지 기법 알고리즘  모든 신장 트리를 찾은 후 그 중에서 최소 비용 신장 트리를 선택한다.  시간 복잡도 분석          최악의 경우, 지수 시간보다도 나쁘다.        탐욕적인 전략  신장 트리에 추가할 최선의 간선들을 반복적으로 한 번에 하나씩 선택한다. 선택 시점에서 추가할 최선의 간선을 쉽게 알 수 있다고 가정한다.  (n-1)개의 간선들이 신장 트리에 포함된다면 종료한다.  한 간선이 선택되면 그 간선의 정점들을 합친다.  적절한 이유정점 a와 b가 연결된다면 정점a에 연결하는 것은 정점 b에 연결하는 것과 같다.명제. n(&gt;0)개의 정점들을 가진 그래프 G는 (n-1)개의 간선들을 가지고 순환이 없으면 트리이다. 또한 G가 트리이면 (n-1)개의 간선들이 있고 비순환 그래프이다.정리. 간선 e가 정점 v에 접합한 가장 가중치가 작은 간선이라면 e를 포함하는 최소 비용 신장 트리가 있다.  최소 비용 신장트리 찾기 - 정점지향 전략  처음 시작할 때 한 정점 $v_0$를 선택한다.  $v_0$ 에서 나가는 가장 가중치가 작은 간선 ($v_0$, x)를 선택한다. 그 간선을 최소 비용 신장 트리 T에 추가하고 $v_0$와 x를 합친다. 모든 정점이 T에 포함될 때까지 이 과정을 반복한다.  프림 알고리즘  적색 정점: 처음에 선택된 정점 $v_0$와 합쳐진 정점      청색 정점: 그 외 다른 정점    아이디어다음을 (n-1)번 반복한다:          한 적색 정점과 한 청색 정점을 연결하는 가장 가중치가 작은 간선을 선택한다.      선택된 간선의 청색 정점을 적색으로 바꾸고 그 간선을 트리에 추가한다.        그래프의 표현: 비용 행렬 WR: 적색 정점들의 집합, B: 청색 정점들의 집합V: 그래프내의 모든 정점들의 집합T: 트리 내에 포함되는 간선들의 집합    R = {$v_0$}    B = V - {$v_0$}   T = $\\emptyset${공집합}   for(i = 1; i &lt; n; i++) {   　　w[ r,b ]가 최소인 $r \\in R$과 $b \\in B$를 선택한다.   　　T = T U {(r,b)}　　// 간선 (r,b)를 트리에 추가한다.   　　B = B - {b}   　　R = R U {b}　　　//정점 b를 적색으로 바꾼다.명확하게 청색 정점의 관점을 취해야 한다. 단순히 어느 적색 정점이 자신에게 가장 가까운지만 기억한다. 이는 한 정점이 적색이 될 때 쉽게 갱신될 수 있다.  시간 복잡도이 알고리즘은 중복 계산을 많이 한다. 매번 반복할 때마다 최소 간선을 거의 같은 집합에서 찾는다.$\\theta$($n^3$)  개선된 프림 알고리즘near[0 .. n - 1]: 각 청색 정점에 가장 가까운 적생 정점을 저장하는 배열isblue[0 .. n - 1]: 각 정점이 청색이면 true를 아니면 false를 저장하는 배열T: 트리 내에 포함되는 간선들의 집합   isblue[0] = false 　　　　//정점 0은 적색이다   T = $\\emptyset$   for(i = 1; i &lt; n; i++){   　　isblue[i] = true 　　　　//다른 정점들은 청색이다   　　near[i] = 0 } 　　　　　 // 가장 가까운 적색 정점은 0이다   for(i = 1; i &lt; n; i++){   　　minval = $\\infty$   　　for(b = 0; b &lt; n; b++)　//적색 정점들에 가장 가까운 청색 정점을 찾는다   　　　if(isblue[b] &amp;&amp; W[b,near[b]]&lt; minval){   　　　　minval = W[b,near[b]]   　　　　newred = b }   　isblue[newred] = fasle 　　　//정점 newred를 적색으로 바꾼다   　T = T $\\cup$ { (newred, near[newred])}　//가장 가중치가 작은 간선을 T에 추가한다   　for(b = 0; b &lt; n; b++)   　　　if(isblue[b] &amp;&amp; W[b,newred] &lt; W[b,near[b]])near[b] = newred　　}  시간 복잡도  입력 크기: n(정점들의 수)  기본 연산: isblue의 요소들에 대한 참조 횟수  참조 횟수          각 i, 1&lt;= i &lt; n, 에 대해 항상 n이다.      따라서 총 참조 횟수 = (n-1) x n $\\in$ $\\theta$($n^2$)        최소 비용 신장 트리 찾기 - 간선 지향 전략  그래프에 남아 있는 가장 가중치가 작은 간선을 선택한다.  선택된 간선이 합쳐진 두 개의 정덤들 사이에 있다면 그 간선을 버리고 아니면 최소 비용 신장 트리에 추가한다.  (n - 1)개의 간선들이 추가될 때까지 과정 1과 2를 반복한다.  크루스칼 알고리즘//e: 간선들의 수    간선들을 가중치 순서로 오름차순으로 정렬하여 배열 EDGELIST[1 .. e]에 저장한다    T = $\\emptyset$    ecount = 0  　 　 　 　//최소 비용 신장 트리에 추가된 간선들의 수    k = 0  　 　 　 　 　 　 　//처리된 간선들의 수    while (ecount &lt; n - 1){    　k = k + 1    　(v, w) = EDGELIST[k]    　if(! together(v,w)){    　　T = T U {(v,W)}    　　v와 w를 합친다    　  ecount = ecount + 1 }} 주: together(v,w) : v와 w가 이미 합쳐졌으면 true이다.분삭: (n-1)번의 통합과 최대 e번의 together를 수행한다.정렬시간 = $\\theta$( e log e)  단일 출발점 최단 경로 찾기연결된 가중 그래프에서 한 특정 정점에서 다른 모든 정점으로 가는 최단 경로를 찾아라.  다익스트라 알고리즘  아이디어: 출방 정점 $v_0$로 부터 가까운 순서로 다른 정점들까지의 최단 경로를 찾는다.  진행 과정          i번째 반복이 시작되기 전에 $v_0$에 가장 가까운 (i - 1)개의 정점들까지의 최단 경로들을 찾았다.      $v_0$, 이 정점들과 최단 경로들 상의 간선들은 주어진 그래프의 부분 트리 $T_i$를 형성한다.      $T_i$내에 있는 정덤들에 인접한 ‘가장자리 정점’들 중에서 찾는다.      $T_i$내에 있는 정점들에 인접한 ‘가장자리 정접’들 중에서 찾는다.      모든 가장자리 정점 u에 대해서 u에 인접한 트리내의 정점 v까지의 거리, W(u,v)와 출발 정점에서 v까지의 최단 경로의 길이, $d_v$의 합을 계산한다.      u에 인접한 트리 내의 정점들이 2개 이상인 경우에는 각 인접 정점에 대해 합을 계산한다. 그러한 합들 중 가장 작은 합을 갖는 가장자리 정점을 트리에 추가할 다음 정점으로 선택한다.      ​위 그림은 트리 $T_i$이다.  n( &gt; 0): 정점들의 수  i, 0 &lt;= i &lt; n: 정덤의 번호  출발 정점: 0  정점 i에 d[i]와 p[i]를 저장한다.                  d[i]: 출발 정점에서 각 정점까지의 최단 겅로의 거리  d[0] = 0  d[i] = $\\infty$ ,i는 최단 경로 트리 내에 포함되지 않은 정점                    p[i]: 출발 정점에서 각 정점까지의 최단 경로 상의 마지막에서 두 번째 정점(트리에서 부모 노드)의 번호  i = 0혹은 트리안에 포함되지 않은 정점이면 p[i] = -1              주어진 그래프는 인접 행렬 w로 나타낸다  트리에 추가할 정점 $u^*$를 선택한 후의 연산  $u^*$를 가장자리 정점에서 트리내에 포함되는 정점으로 바꾼다.  $u^$에 인접한 트리에 포함되지 않은 각 가장자리 정점 v에 대해 다음 조건을 확인한다.d[$u^$]  + w($u^$ ,v) &lt; d[v]위 조건이 만족된다면 다음을 수행한다d[v] = d[$u^$] + w($u^$, v)p[v] = $u^$  다익스트라 알고리즘    T = $\\emptyset$    //트리에 포함된 정점들의 집합을 공집합으로 초기화한다    for( i = 0; i &lt; n; i++){    d[i] = $\\infty$    //정점 i의 최단 거리를 $\\infty$ 로 초기화 한다    p[i] = -1 }    //정점 i의 부모 노드를 -1(없음)으로 초기화한다    d[0] = 0    //출발 정점 0의 최단 거리를 0으로 한다                                while(          T          &lt; n){}                        T에 포함되지 않은 정점들 중에서 배열 d의 요소값이 가장 작은 정점 u를 선택한다    T = T U { u}    //선택된 정점을 트리에 추가한다// 트리에 새로 추가된 정점의 인접 정점들의 출발 정점으로부터 최단 거리를 갱신한다    for( v = 0; v &lt; n; v++)    if(v $\\notin$ T and w[u,v]  0 and d[u] &lt; $\\infty$ and d[u] + w[u,v] &lt; d[v] ){    d[v] = d[u] + w[u,v]     p[v] = u }}시간복잡도    +  기본 연산: 10번 조건 확인    +  9 ~ 12번의 반복문내에서 기본 연산의 수행 횟수 = n    +  트리에 모든 정점이 포함되어야 하므로 $\\theta$($n^2$)",
        "url": "/algorithm-05"
    }
    ,
    
    "sc-09": {
        "title": "Hash",
            "author": "lee989898",
            "category": "",
            "content": "HashHash와 관련된 Key Concepts인 Integrity와 Authentication을 다시 한번 살펴보자  Integrity  무결성  원본 그대로임을 보장  변조가 없다는 것 혹은 변경이 있었음을 알게 됨  주요 공격: modification  Integrity를 지키기 위한 Solution : hash  Authentication  인증  송수신자 서로간의 신원 확인  주요 공격 : impersonation  Authentication을 지키기 위환 solution : 전자서명, 공인인증서  Hash Functions  임의의 긴 입력 값을 적절하게 처리하여 고정된 길이의 짧은 값을 출력하는 함수  Message Authentication Code로 무결성 제공  전자 서명으로 sender authentication 제공  공인인증서, 가상화폐 등에 사용  컴퓨터보안에서 대표적인 hash function은 MD2,4,5 SHA1, HAS160  http://www.miraclesalad.com/webtools/md5.php위 사이트에서 임의의ㅣ 입력값에 대한 해쉬값을 관찰할 수 있다.해쉬의 특징으로는 대표적으로 3가지가 있다.  입력길이에 상관없이 출력길이가 일정  조금이라도 입력값이 다르면 출력값은 완전히 다름  revers가 어렵다(일방향성)위 성질중 integrity는 2번에 의해서 보장된다.Encrypt/decrypt와의 차이점은 3번이다. 복호화가 어렵기 때문이다.예를 들어보자 h(x): x/23해서 소수점 7~10자리 수를 추출h(345689) = xx.95652177391출력값은 일정하나, reverse는 불가능하다.그러나 h(232.8395049993) = 7391 처럼 다른 값을 넣었음에도 값이 같은 일명 collision이 일어날 수 있다.Collison은 서로 다른 입력값이 같은 해시값을 계산하는 것을 의미한다.충동저항성은 collision이 일어날 확률이 작음을 의미한다.  MAC  메시지 무결성: 변경되지 않은 원본이 맞음​   메시지와 해쉬값을 붙어서 보낸다.받는사람은 비교해서 같으면 원본 다르면 원본이 아닌걸 알 수 있다.하지만 여기서 sender authenticationd은 제공되지 않는다.Digital Signature에서 이문제를 해결한다.  Digital Signature  무결성과 인증을 동시에 제공  키를 사용한다(키를 모르는 사용자는 생성불가)​   비교하여 같으면 변조되지 않고 보낸사람을 인증해준다.하지만 mac도 한계가 있는데 제 3자에 대한 sender authentication이 불가능 하다.키를 모르면 인증을 못하기 때문이다.  Replay Attack​   위 그림은 MAC 공격방법이다.Attacker는 고객이 보낸 똑같은 패킷을 복사하여 고객으로 위장하는 공격 방법이다.이러한 공격을 막는 방법은 패킷에 추가정보로 시간을 알려주는 time stamp를 넣어 해결할 수 있다.대표적인 해쉬 함수로는 두가지 계열이 있는데 MD와 SHA 계열이다.  MD (Message Digest)  MD2,4,5,6​  Ron Rivest (RSA), 1990~92​  Merkle structure기반​  128bit hash 값​  512 bit block size ​  MD4는 32bit CPU 전용 (MS)​  MD5는 SHA1등 최신 해시들의 기초가됨​  2005 강한 충돌 내성 깨짐  SHA (Secure Hash Algorithm)  NIST 1993​  Merkle structure기반​  SHA0,1은 160bit hash 값, SHA2는 224~512bit​  512 bit block size ​  최대 2^64-1 bit 메시지처리​  가장 많이 사용​  2005 강한 충돌 내성 깨짐​   위 그림은 Merkle structure의 예시이다.MD, SHA 두가지 모두 Merkle structure기반인데 이것은Message를 block으로 나누어서 고정된 길이의 입력값을 받아들여 고정된 길이로 출력하는 압축함수를 반복 사용하여 긴 길이의 입력을 처리할 수 있는 해쉬 함수로 학대하여 설계하는 방식이다.  Hash attack  같은 해시값을 갖는 다른 입력값을 찾아낸다​  예를 들면, (ID, PWD)값은 해시값으로 저장되어 있다.​  만일 같은 해시값을 갖는 (ID2, PWD2)를 찾는다면, (ID, PWD)로 로그인 가능​하다  (ID, PWD), (ID2, PWD2)를 충돌쌍(collision pairs)라 한다​",
        "url": "/sc-09"
    }
    ,
    
    "pl-15": {
        "title": "컨트롤 스트럭처",
            "author": "lee989898",
            "category": "",
            "content": "컨트롤 스트럭처프로그램의 컨트롤 스트럭처에는 3가지가 있다.  sequence(begin-end)  selection(if-else, case)  iteration(loop)각 컨트롤 스트럭처는 여러 개의 문장으로 구성된다. ​스트럭처는 여러 문장의 묶음으로, ​실행 제어 방법에 따라 각각 키워드(begin, if, while,…)를 포함한다여기서 컨트롤 스트럭처의 if, while 문을 제어문이라고 하고, ​제어문의 실행 결과에 따라 실행되는 문장을 실행문이라고 한다. ​시퀀스는 순차적으로 실행되는 문장들의 연속을 말하며, ​실행 제어가 순차적이라서 시작과 끝만 명시하면 된다.Selection은 제어문이 참이냐 거짓이냐에 따라 실행문이 다르며,하나의 selection 스트럭처에 제어문과 실행문을 여럿 포함하기도 한다. ​Iteration도 제어문과 실행문의 반복으로 구성되는데,for, while, repeat 등 목적에 따라 그 신택스와 시맨틱스가 다양하다. ​프로그래머는 이들 컨트롤 스트럭처를 사용하여 쉽게 프로그램을 구조화한다.프로그램은 나름의 로직을 갖고 있어서, 이에 따른 실행 제어(flow control)가 필요하다. ​명령형 프로그램에서 계산은 다음과 같이 진행된다.변수를 읽고 연산자를 실행하여 표현식을 계산하여, ​변수에 결과 값을 부여한다.또, 여러 경로 중에서 선택하여 실행을 제어하거나, ​반복 실행한다. ​컨트롤 스트럭처는 제어문과 실행문으로 구성된다. ​이 표현은 문제가 있다. 시퀀스는 제어문이 없다.Selection StatementsSelection문은 2개 이상의 실행 경로 중에서 선택하는 것이다. ​두가지 범주가 있는데, 둘 중에 하나 선택하는 것과 여럿 중에 선택하는 것이 있다.  If StatementsIf문의 일반적 형식은 if 제어 표현식 then 실행문1 else 실행문2 이다. ​제어 표현식은 산술식이거나 부울식이다. ​프로그래밍 언어에서 실행문1과 실행문2는 단순문이거나 복합문이다. ​C, C++에서 복합문을 { }로 둘러싼다.펄에서 모든 실행문을 { }로 구분하고, 파이썬에서는 indentation으로 구분한다.자바에서는 중첩 if문을 허용한다.dangling else 문제가 발생할 수 있으니 If에 대응되는 else가 어느 것인지 살펴가며 신중하게 써야 한다.자바를 비롯한 대부분의 언어에서는 else를 가장 가까운 if에 대응시킨다.  ​C, C++에서는 가장 가까운 if에 else를 대응시키는 것의 대안으로서,{}로 둘러싼 복합문을 사용할 수도 있다. ​​복합문 대신에 end를 사용하기도 한다.  Switch Statements​Switch는 여러 대안 중에 하나 선택하여 실행할 경우이다. ​전형적인 형식은 아래와 같다 ​Switch 표현식 {​case 상수 표현식1 : 실행문1   ​…​default … }이다. 스위치문의 case는 동시에 상수 표현식을 비교하는 것이 아니라 상수 표현식을 순차적으로 비교하여 끝까지 실행한다.  ​이것을 피하려면, break 사용해야 한다.C에서는 스위치문의 제어 표현식으로 정수 타입만 허용한다. 실행문은 시퀀스, 블록, 복합문을 모두 허용한다. 조건이 맞으면 여러 case가 실행가능하다. 디폴트시에, ​If문에 의한 제어가 가능하다.파이썬에서는 스위치 대신에 if elif를 사용할 수 있다.Iterative StatementsIteration, recursion은 문장이나 복합문의 반복 실행한다.​  카운터로 제어하는 counter-controlled loop은 반복문의 실행 횟수를 세는 변수를 갖는다. ​초기값, 종료값, 증분(반복할 때마다 더해지는 값)설계할 때 고려사항은 Loop 변수의 유형과 스코프를 정의해야 하며,Loop에서 변화하는 Loop변수의 값이 룹 제어에 영향을 미치는지 확인해야 한다.  for StatenebtsC의 for 반복문을 보면, ​for ([expr_1] ; [expr_2] ; [expr_3]) ​loop body… 와 같습니다. ​다음과 같이 카운터 변수가 여럿일 수 있고, ​부울식을 포함할 수 있다. ​For (count1 = 0, count2 = 1.0;​     count1 &lt;= 10 &amp;&amp; count2 &lt;= 100.0;​    sum = ++count1 + count2, count2 *= 2); ​자바에서 컨트롤 표현식은 부울식이어야 한다.  while Loops​While Loop은 부울식에 의해 제어된다.Ctrl_expr는 부울식으로, Loop의 맨앞에 또는 맨뒤에 위치한다. ​while (ctrl_expr) ​loop body… ​do ​loop body ​while (ctrl_expr) ​ ​   User-Located Loop ControlBreak 처럼 loop 컨트롤이 loop body의 중간에 위치하기도 한다.이것을 user-located loop control이라고 부른다.Break 외에도 continue가 있다.자료구조를 구성하는 요소에 의해 제어되는 반복 처리가 있다. ​Iterator를 호출하면, 자료구조에서 다음 요소를 반환해준다. ​이밖에 for에서도 자료구조에 의한 반복처리를 제어할 수 있다.  ​  Unconditional Branching앞에서 언급했듯이 goto는 가독성 문제를 일으킨다.자바는 goto가 없다.Guarded Commands각 문장 앞에 부울식이 있는 것을 가디드 코멘드라고 한다. 즉 가디드 코멘드는 ​selection 문장의 각 라인이 ​부울식과 ‘하나의 문장 또는 문장의 시퀀스＇로 구성된다. ​이렇게 하는 목적은 ​프로그램 개발 중에도 프로그램의 correctness(올바름)를 증명하기 위한 것으로, ​Concurrent 프로그래밍의 기초가 된다. ​기존의 언어는 개발(코딩)을 마치고 테스트를 통해 프로그램의 올바름을 확인한다.  Selection Guarded CommandSelection의 가디드 코멘드는 ​If 안의 각 문장마다 부울식이 있다. ​이 가디드 코멘드의 시맨틱은 다음과 같다.부울식을 계산해서, ​나 이상이 참이면, 그 중에 아무거나 선택한다.아무것도 참이 아니면, 실행 오류로 처리한다.​프로그램의 correctness는 선택된 문장에 종속되지 않는다.if x &gt;= y -&gt; max := x​[] y &gt;= x =&gt; max := y​fiif (x &gt;= y)​      max = x;​else​    max = y;X, y가 같을 때, 전자는 아무거나 선택되어 수행되나, ​후자는 max=x가 수행됨.따라서, non-deterministic vs. deterministic  Loop Guarded Commanddo &lt;Boolean&gt; -&gt; &lt;statement&gt;​[] &lt;Boolean&gt; -&gt; &lt;statement&gt;​...​[] &lt;Boolean&gt; -&gt; &lt;statement&gt;​od​Loop 가디드 코멘드에서, ​Do 다음에 나오는 모든 문장의 앞에 부울식이 있다. ​​룹 가디드 코멘드의 시맥틱스는 다음과 같다.부울식을 계산하고, ​하나 이상이 참이면, ​아무거나 선택하여 룹을 시작한다.아무것도 참이 아니면, 룹에서 나온다.",
        "url": "/pl-15"
    }
    ,
    
    "pl-14": {
        "title": "표현식과 대입문",
            "author": "lee989898",
            "category": "",
            "content": "표현식과 대입문표현식(expression)은 프로그래밍 언어에서 계산을 상술(상세히 서술)하는 수단이다. ​대입문은 변수의 값을 변화시키는 문장으로, 모든 명령형 언어의 필수적 요소이다. ​대입문은 독립적으로 실행 가능한 문장인 반면, ​표현식은 대입문의 일부분으로서, 독립적으로 실행될 수 있는 문장이 아니다. ​대입문과 표현식의 차이를 좀더 살펴 보자.  ​변수가 메모리의 일정 부분임을 상술하는 수단이라는 것과, ​대입문의 BNF 형식이 =임을 알고 있다. ​BNF의 형식으로부터, ​표현식()은 대입문의 일부분임을 알 수 있고, ​대입문의 변수()가 가리키는 메모리에 저장된 값을 ​표현식의 계산 결과로 변경시킨다는 것을 알 수 있다. ​그런데, 표현식의 계산 방식에 따라 계산 결과는 달라질 수 있다.  ​표현식의 계산 방식을 이해하려면, ​연산자와 오퍼랜드의 계산 순서에 대한 규칙을 알 필요가 있다.  ​이들 순서는 결합 법칙과 우선순위 규칙에 의하며, ​오퍼랜드 계산 순서는 오퍼랜드의 부수효과(부작용)때문에 중요하다.  산술식산술식은 연산자, 오퍼랜드, 괄호, 함수 호출로 구성된다. ​연산자는 단항 연산자, 이진 연산자, 삼항 조건 연산자(?:) 등이 있다. ​표현식의 구현은, ​메모리에서 오퍼랜드를 가지고 와서, ​그 오퍼랜드에 산술 연산자를 실행한다. ​산술식 설계시 고려사항 ​연산자 우선 순위, 결합 법칙 등 ​오퍼랜드 계산 순서와 부작용(부수효과) ​연산자 오버로딩 ​표현식에서 오퍼랜드 타입의 혼합연산자 우선순위 규칙은 우선 순위가 다르면서 이웃하는 연산자의 계산 순서를 정의한다. ​전형적인 우선순위 규칙은 괄호&gt;단항연산&gt;지수&gt;곱셈과 나눗셈&gt;덧셈과 뺄셈 ​연산자 결합 법칙은 우선 순위가 같으면서 이웃하는 연산자의 순서를 정의한다. ​전형적인 결합법칙은 좌에서 우로(단, 지수는 우에서 좌로) 적용된다.  ​괄호는 우선순위와 결합 법칙에 앞선다. ​C, C++에서 조건 표현식은 삼항 조건 연산자 ?:를 사용한다. ​average = (count == 0)? 0 : sum / count와 같이 표현한다. ​이것의 의미는 다음과 같다. ​if (count == 0), average = 0​else average = sum / count ​이 문장을 이해하려면, 대입문의 BNF 형식 =을 떠올리면 쉽다. ​그러니까 이 average이고, ​가 삼항 조건 표현식인 (count==0) ? 0 : sum/count이다. 표현식에서 오퍼랜드는 어떻게 계산되는지 살펴 보면, ​변수는 메모리에서 값을 가져온다.  ​상수는 메모리에서 값을 가져오기도 하지만, 기계 언어에 내재되기도 한다. ​괄호가 있는 표현식은 괄호속에 있는 모든 오퍼랜드와 연산자를 먼저 계산하고, 괄호 전체를 계산한다. ​오퍼랜드가 아무런 부작용(부수효과)가 없을 때, 오퍼랜드 계산 순서는 결과에 무관하다. ​그러나 함수가 오퍼랜드일 때, 계산 순서는 다른 결과를 가져온다.  함수는 다수의 파라미터 또는 글로벌 변수를 변경시킬 수 있고,  ​이때 함수 부수효과가 발생할 수 있다. ​이로 인해 표현식의 계산 결과에 영향을 미칠 수 있다. ​--- ​---위 그림에서 함수 부수효과 문제의 예를 보자. ​다음 프로그램에서, ​Main의 a = a + fun1( )의 값은 ​먼저 a를 계산하느냐, fun1( )을 먼저 계산하느냐에 따라 달라진다. ​1. 먼저 a를 계산(메모리에서 가져오는 fetch)하면, ​a가 5이고, fun1()이 3이므로, 둘을 더하면 a는 8이다. ​2. 먼저 fun1을 계산하면, ​fun1은 3이지만 부수효과로서 a가 17이므로, ​둘을 더하면 a는 20이 된다. 수학에서 함수는 x에 대응하는 y값을 찾는 것이므로, 부수 효과가 없다.​함수 언어에서도 마찬가지다. ​부수효과는 본 뉴만 아키텍처 및 이에 기반한 명령형 언어의 계산 모형으로 인해 발생한다. ​본 뉴만 아키텍처 및 이를 그대로 본뜬 명령형 언어의 계산 모형은 ​계산하여 변화된 값의 상태를 항상 메모리에 저장하도록 설계되어 있기 때문이다. ​함수 부수효과의 해결책은 다음 두가지가 있다. ​+ C, C++ 처럼 함수 부수 효과를 허용하지 않도록 언어를 설계하는 것이다. ​    함수에서 단일 파라미터만 허용하여, 단일 값을 반환한다. ​    만일 다수의 파라미터가 필요하면, struct를 사용하여 하나의 파라미터로 만든다. ​    함수에서 글로벌 변수를 접근 불허한다. ​    단점은 파라미터 및 글로벌 변수에 융통성이 없다. ​2. 자바처럼 오퍼랜드 계산 순서를 고정시킨다. ​    좌에서 우로… ​    단점은 컴파일러 최적화를 제한한다.  ​최적화를 위해 표현식을 reordering하기도 하는데 고정 순서는 이를 불허한다. ---+ 과적 연산자기계어에서는 정수의 덧셈 연산자와 부동점 소수의 덧셈 연산자를 구분한다. 부동점 소수의 덧셈: FADD, ​정수의 덧셈: ADD ​프로그래머는 정수의 덧셈과, 부동점 소수의 덧셈에 모두 +를 쓰고 싶어한다.  ​1. 그러면서, 컴파일러가 알아서 이들을 구분하여 번역하기 바란다. ​2. 두개의 배열 변수의 덧셈도 +로 간단히 쓰고 싶어 한다.  ​이와 같이 하나의 연산자를 여러가지 목적으로 사용하는 것을 ​연산자의 과적(오버로딩)이라고 한다. 정수와 부동점에 대한 +의 과적은 ​일상적으로 허용되지만, C와 C++에서는 문제를 일으키기도 한다. ___+ 타입 변환정수와 부동점 소수 간의 덧셈에서, ​데이터를 어떤 유형으로, 그리고 어떤 포맷으로 변환할 것인가? ​유형: 정수, 부동점 소수 ​포맷: 십진수 vs 이진수, 부동점의 (싸인,지수부분,소수부분) 각 몇 비트? Narrowing conversion은 ‘원래 유형의 모든 값’을 포함할 수 없는 유형으로 변환하는 것을 의미한다. ​예를 들어, 더블 부동점 소수를 싱글 부동점 소수로 변환하는 경우. ​이때 항상 safe하지는 않다. -&gt; 값의 크기가 바뀐다. 짤린다. ​​Widening conversion은 원래 유형의 근사값을 포함하는 유형으로 변환하는 것을 의미한다. ​예를 들어 정수를 부동점 소수로 변환하는 경우. ​이때, safe하다. 즉, 근사값으로 바뀌므로 크기가 바뀌지 않는다. ​다만 포맷(내부 표현 방식)의 차이로 인해 정확하게 같지 않을 경우도 있다.   오퍼랜드의 타입이 혼합되어 있을 때, ​명시적이거나 암묵적으로 타입 변환이 필요하다. ​컴파일러에 의한 암묵적 타입 변환을 코어젼이라고 한다. -&gt; 대부분의 언어에서…   ​프로그래머에 의한 명시적 타입 변환을 캐스팅이라고 한다. ​C에서는 (int) angle과 같이 캐스팅을 괄호로 표시한다.  ​___+ 비교 및 부울 표현식비교 표현식은 두개의 오퍼랜드를 비교하기 위해 비교 연산자를 사용한다. 부울 표현식은 부울 연산자 and, or, not를 사용한다. 표현식의 Short-circuit evaluation에 대해 살펴 본다.Short-circuit evaluation은 ​표현식의 결과를 도출하는데 충분한 계산이 완료되면, ​그 이후의 표현식 계산을 중단한다는 의미이다. ​따라서, 표현식의 최소 계산이라고 번역하겠다.  표현식에서 여러 오퍼랜드 중에서 몇 개만 해보고 그 결과를 알 수 있다면 ​모든 오퍼랜드를 계산할 필요가 없다. ​이것을 표현식의 최소 계산이라고 한다. ​간단한 예를 보자. ​(13 * a) * (b/13–1)에서, a가 0이면, 13*a가 0이므로 더 이상 계산할 필요가 없다. ​만일 최소 계산을 채택하지 않을 경우, ​다음 프로그램에서 예상치 않은 문제를 발생시킨다. ​index = 0;​while ((index &lt; listlen) &amp;&amp; (LIST[index]!= key)) index = index + 1; 이고, ​LIST 배열의 인덱스가 0에서 listlen-1까지 라고 가정하자. ​index==listlen일 때, (index &lt; listlen)을 만족시키지 못한다. ​그런데 최소 계산을 채택하지 않기때문에 여기서 중단되지 않고, ​그 이후의 (LIST[index]!= key))를 계산하게 되며, ​이때, LIST[index]에서 인덱싱 문제가 발생하게 된다. ​이와 같이 최소 계산을 채택하지 않을 경우 ​불필요한 오류를 발생시키기도 한다. 최소 계산은 표현식의 부작용에 영향을 받을 수도 있다. ​(a &gt; b) || (b++ / 3)에서 ​||의 두번째 오퍼랜드를 먼저 계산하면 ​b가 증가하여 첫째 오퍼랜드의 결과에 영향을 준다.   ---+ 대입문과 혼합 타입의 대입문대입문의 일반적 형식은  = 이다. ​대입 연산자 = 대신에 :=를 쓰기도 한다. ​= 대신에 :=을 쓰는 이유는 =의 의미가 ‘같다＇의 의미와 혼동되기 때문이다. ​=를 대입 연산자로 사용하는 경우, ‘같다＇의 연산자로 ==를 사용한다. 조건 타겟은 조건에 따라 타겟 변수가 결정된다. ​펄에서 조건 타겟이 포함된 대입문의 예를 보자. ​대입문 ($flag ? $total : $subtotal) = 0에서 ​대입 연산자 =의 왼쪽에 조건식이 포함되어 있는데, ​이 뜻은 만일 ($flag)이 참이면 $total = 0이고, ​거짓이면 $subtotal = 0이다 ​복합 대입문 연산자는 대입문의 =과 연산자를 연결한 것이다. 단항 대입문 연산자는 ++과 같은 것을 의미한다. 표현식에 대입문을 쓰기도 한다. ​while ((ch = getchar())!= EOF){…}​  ch = getchar()위의 while 문의 조건식에 ch = getchar()라는 대입문이 들어가 있다. ​이 대입문이 먼저 실행되고 나서, 조건식이 계산된다. ​그러면 getchar 값이 ch에 할당되고, ​ch!=eof가 참이면 {…}가 실행된다. ​a=b+(c=d/b)-1의 경우처럼, ​표현식에 대입문을 쓰는 것은 대입문의 이해를 어렵게 한다.  ​($first, $second, $third) = (20, 30, 40)와 같이 다수의 값을 할당할 수도 있고, ​  Interchange를 ($first, $second) =($second, $first)와 같이 쓸 수도 있다. 함수 언어에서 identifier는 값의 이름에 불과하며, ​변수를 나타내는 것이 아니기때문에 이들의 값은 바뀔 수 없다. ​val fruit = apples + oranges;에서 ​이름 fruit는 apples와 oranges의 값을 더해서 나온 결과 값의 이름이다.  ​대입문에서 혼합 타입이 가능하다. ​이때 타입 변환이 발생한다. ​---",
        "url": "/pl-14"
    }
    ,
    
    "pl-13": {
        "title": "복잡한 데이터 타입",
            "author": "lee989898",
            "category": "",
            "content": "복잡한 데이터 타입배열과 레코드 타입을 살펴보자  배열배열은 동일한 유형의 데이터 요소의 모임으로, ​각 요소의 위치에 의해 지칭된다(식별된다). ​각 요소의 위치를 나타내는 방식은 ​‘배열의 맨앞에서 시작하여 각 요소의 상대적 위치를 지칭하는 인덱스(서브스크립트, subscript)’에 의한다. ​이와 같이 상대적 위치를 지칭하기 위해서는, ​인덱스와 요소 간의 매핑이 필요한데, ​이러한 매핑을 배열 인덱싱 또는 subscripting이라고 한다. ​1차원 배열 인덱싱은 사소한 문제에 불과하지만, ​배열의 차원이 증가하고 각 차원의 범위가 다양해지면서 ​배열의 인덱싱 문제는 복잡해진다.배열 인덱스 유형은 주로 정수형을 사용하나 언어에 따라 약간 다르다. ​포트란, C, 자바는 정수형만을 지원하나, ​파스칼은 모든 서수 유형(정수, 부울리언, 글자)을 지원한다. ​C, C++, 펄, 포트란은 인덱스에 대해 범위 검사를 하지 않지만, ​자바, ML, C#은 인덱스의 범위를 검사한다. ​배열의 범주를 서브스크립트의 범위와 메모리 할당 시기를 기준으로 나누면,  ​정적 배열, 고정 스택-동적 배열, 고정 힙-동적 배열, 힙-동적 배열로 구분한다. ​정적 배열은 서브스크립트의 범위가 정적으로 고정되어 있고, ​런타임 이전에 메모리가 정적으로 할당된다.  ​장점은 효율적이지만, ​단점은 실행중 필요시마다 동적 할당이 불가능하여 융통성이 없다. ​C, C++에서 static modifier를 포함하는 배열은 정적 배열이다. ​고정 스택-동적 배열은 서브스크립트의 범위가 정적으로 고정되어 있지만, ​메모리는 미리 할당되지 않고, 선언문 실행 중에 할당된다. ​장점은 실행되지 않는 서브프로그램에서 정의된 배열에 대해 ​메모리가 미리 할당되지 않아, 메모리 공간 활용이 효율적이다. ​C, C++에서 static modifier를 포함하지 않는 배열은 고정 스택-동적 배열이다.고정 힙-동적 배열은 스토리지 바인딩이 동적이지만, ​힙에 할당된 후에는 서브스크립트의 범위가 고정된다. ​C, C++에서 malloc에 의해 할당된 배열은 고정 힙-동적 배열이다. ​힙-동적 배열은 서브스크립트 범위와 스토리지의 바인딩이 ​모두 동적이면서 변경 가능하다. ​장점은 배열이 실행 중에 늘어나거나 줄어 들 수 있어서 융통성이 있다. ​C#에서 ArrayList에 의해 정의된 배열은 힙-동적 배열이다. ​배열의 요소없이 생성되고 나중에 add를 써서 배열을 늘인다.C, C++, C#, 자바에서는 ​스토리지 할당시에 배열이 초기화된다. ​포트란은 배열에 대한 연산을 지원한다. ​두 배열의 합(+)은 위치가 같은 배열의 각 요소들간의 합을 배열로 나타낸 것이다. ​A = B + C ——- A, B, C 모두 배열…  ​배열에 대한 연산을 지원하지 않는다면, ​loop을 써서 반복적으로 ​각 요소마다 합을 구해야 함 (A[i] = B[i] + C[i]에 의해)순서를 무시한 데이터 요소의 모임을 associative array라고 하며, ​사용자가 정의한 Key를 인덱스로 사용한다. ​따라서, associative array는 키와 값의 쌍을 나열한 것이다.  ​펄에서 associative array를 다음과 같이 정의하고, ​%hi_temps = (“Mon” =&gt; 77, “Tue” =&gt; 79, “Wed” =&gt; 65, …);​다음과 같이 배열에서 값을 찾는다.  ​$hi_temps{“Wed”} = 83; 여기서 Wed가 키이다. ​다음 명령어는 배열에서 값을 삭제한다.  ​delete $hi_temps{“Tue”};  레코드배열은 동일한 유현의 데이터 요소의 모임인 반면, ​레코드는 다른 유형의 데이터 요소의 모임이다. ​레코드에서는 그 요소의 이름으로 요소를 식별(지칭, 언급)한다. ​레코드 타입에서 각 필드를 지칭(언급)하는 방법은 필드명에 의하며, ​서브 필드를 명확히 지칭하기 위해,  ​코볼에서는 of를 키워드로 하고, ​다른 언어에서는 dot(.)을 쓰기도 한다. ​레코드 타입의 연산은 assignment(필드명에 값 할당), ​레코드간의 필드값 카피 등이다.  ​튜플 타입은 레코드와 유사하나, 각 요소의 이름이 없다는 것이 다르다. ​파이썬의 튜플은 튜플의 값을 변경할 수 없다. ​만일 변경하고자 한다면, ​List 함수를 써서 튜플을 배열로 변환한 다음에, ​배열의 값을 변경한다. ​변경한 후에, tuple 함수를 써서, 튜플로 재변환한다. ​myTuple = (3, 5.8, ‘apple’)은 튜플을 생성한다. ​myTuple[1]은 첫째 요소를 가리킨다. ​+는 튜플 간의 concatenation을 실행하고, ​del은 튜플을 삭제한다.리스트 타입은 튜플과 유사하나, ​각 요소의 값을 변경 가능하다는 것이 다르다. ​파이썬은 리스트 타입을 지원하며, 배열처럼 취급된다. ​배열과 차이점은 각 요소의 값이 어떤 유형이든 상관없다는 것이다.  ​생성, 지칭, 삭제 연산 등을 보면 튜플과 유사함을 알 수 있다.​리스트 포함(comprehension)은 컨스트럭트에 리스트를 포함시키는 것을 말한다. ​이것은 리스트를 필요시 정의할 수 있는 편리한 기능이다. ​형식은 [expression for iterate_var in array if condition]을 취한다.  ​예를 들면, [x*x for x in range(12) if x%3==0]과 같다. ​range(12)는 0에서 12까지의 배열을 생성하는 함수이고, ​x%3은 x를 3으로 나눈 나머지를 말한다. ​이 문장은 0에서 12로 구성된 배열을 생성하고 ​0,3,6,9,12를 제곱하라는 뜻이다. ​포인터와 레퍼런스 타입에 대해 살펴보자.  포인터포인터 타입 변수가 가질 수 있는 값의 범위는 ​메모리 주소와 영(nil)이다.  ​포인터는 간접 주소 지정 방식과 동적 메모리 관리 방식을 제공한다. ​포인터는 힙에 있는 메모리 위치를 접근할 때 사용된다.기본적 연산으로 assignment와 dereferencing이 있다. ​Assignment는 포인터 변수의 값에 주소를 넣어 두는 것이다. ​디레퍼런싱은 포인터의 값이 가리키는 주소에 저장된 값을 산출하는 것이다. ​디레퍼런싱은 명시적이거나 암묵적이다. ​C, C++에서는 명시적인 디레퍼런싱 연산자로 를 사용한다. ​j=ptr는 ptr의 값이 가리키는 주소에 저장된 값을 ​변수 j의 메모리 위치에 넣어 두라는 의미이다. ​아래 그림은 이것을 그림으로 나타낸 것이다.​포인터 사용할 때 나타나는 문제는 다음의 두가지가 있다. ​​      허상 포인터(dangling pointer)는 ​힙-동적 변수에 할당된 메모리를 가리키지 않고 있는 포인터를 말한다.  ​자세히 설명하면, ​힙에 의해 변수에 메모리가 할당되면, ​포인터는 이 메모리를 가리키고 있겠지만,  ​이후 메모리가 해제되었다면, ​이 포인터는 메모리를 가리키지 못하게 된다. ​이러한 포인터를 허상 포인터라고 한다. ​즉, 메모리는 없지만 포인터는 남아 있는 경우이다. ​        memory leakage(기억 상실)​힙-동적 변수의 상실은 힙-동적 변수가 이미 메모리에 할당되어 있지만, ​포인터가 상실되어 ​사용자 프로그램에서 이 동적 변수에 더 이상 접근 가능하지 않은 경우를 말한다. ​즉, 포인터는 없지만 할당된 메모리는 남아 있는 경우이다.  포인터는 언제 메모리에 할당되든지 어떤 변수든 가리킬 수 있으며,  ​동적 스토리지 관리에서 사용된다. ​포인터 산술 연산이 가능하고, ​디레퍼런싱과 ‘무엇의 주소’ 연산이 가능하다.    float stuff[100];​    float *p;​    p = stuff;​    *(p+5) is equivalent to stuff[5] and  p[5]​    *(p+i) is equivalent to stuff[i] and  p[i]C, C++에서는 포인터에 대한 산술 연산이 가능하다. ​5번째값, i번째값  레퍼런스레퍼런스는 포인터와 유사하나, ​기본적으로 다른점은 ​      포인터는 메모리의 주소를 가리키지만, ​  (주소에 대한 연산이 나름의 의미를 갖지만)​        레퍼런스는 메모리의 값을 가리킨다. ​  (주소에 대한 연산이 무의미)  허상 포인터와 허상 객체는 힙 관리 상의 문제이다. ​포인터는 변수가 가리킬 수 있는 범위를 확장시킨다는 면에서 goto와 비슷하다. ​레퍼런스는 포인터의 기능과 유연성을 제공하면서, 위험은 제거한다. ​포인터와 레퍼런스는 동적 데이터 구조를 위해 프로그래밍 언어의 필수적인 요소이다.​이 그림에서는 허상 포인터의 예를 보여주고 있다. ​프로그램 코드가 이와 같을 때, ​*q=30은 이미 해제된 메모리가 남아 있다고 착각한다.  ​Q는 결국 아무것도 가리키지 않는 허상 포인터이다.",
        "url": "/pl-13"
    }
    ,
    
    "sc-08": {
        "title": "ECC",
            "author": "lee989898",
            "category": "",
            "content": "ECC  ECC  Public key  RSA의 대안  암호화는 잘 안 쓰인다 대신 전자서명과 키교환에서 주로 사용  회의적 시각 많다  ECC vs RSA  ECC는 이산대수문제 기반  A = $B^c$, c 찾기문제  RSA보다 작은 길이의 키로 비슷한 보안 제공  RSA보다 작은 키를 사용하지만 수학적 계산량 많다  타원곡선  타원곡선은 타원이 아니다  타원곡선 방정식을 만족하는 점들의 집합          $y^2$ = $x^3$ + ax + b        타원 곡선 모양​  타원곡선의 덧셈          곡선상의 두점 P,Q      P + Q는 두 점을 잇는 직선과 타원곡서의 접점을 x축에 대칭      여기에 mod p를 한다      ​  EC Discrete Log Problem  주어진 조건 ​          E: an EC over (field of modulo p), p:prime​      P: a point in E(Fp), and suppose that P has prime order n​        키 생성(Key generation)​          Private key d: selected in random in [1,n-1]​      Public key Q =dP, 소수 p, P​        ECDLP: The problem of finding d given the domain parameters and Q  (Q = dP일때, P, Q, p를 알더라도 d를 구하기 어렵다)​  ElGamal EC Encryption  Input​          EC domain para (p,E,P,n), Public key Q,  Plaintext m​        OutPut          Ciphertext (C1, C2)​                  Represent the message m as a point M in E​          Select k in [1,n-1],  ​          Compute C1 = kP, ​          Compute   C2 = M + kQ​          Return(C1, C2)​                      Q = dp일때, P,Q를 알더라도 d를 구하기 어렵다",
        "url": "/sc-08"
    }
    ,
    
    "sc-07": {
        "title": "ElGamal",
            "author": "lee989898",
            "category": "",
            "content": "ElGamal  ElGamal  Taher Elgamal, 1985 NSF  이산대수의 어려움을 이용  RSA보다 안전성향상  A = $B^c$, c찾기  Key genetation  큰 소수 p, p보다 작은 임의의 g,x 선택  Y = $g^x$ mod p를 계산  공개키: Y,p,g  비밀키: x  Encryptin/decryption  공개키: Y,p,g  비밀키: x  Encrypt: p-1과 relative prime인 임의의 k(1&lt; k &lt; p-1)a = $g^k$  mod p, b = $Y^k$ M mod p 를 계산          여기서, k를 임의로 선택하기 때문에 동일한 M에 대해서 매번 다르게 암호화된다. (RSA와 차이점)      Ciphertext는 dnjsfo M 길이의 2배가 된다.        Decrypt: b/$a^x$ mod p = $y^k$ M / $a^x$ mod p = M  ElGamal 서명 기법  RSA와 달리 서명만을 위해 설계됨  ElGamal 서명기법은 약간 변형된 형태로 NIST의 디지털 서명 표준(DSS)으로 채택",
        "url": "/sc-07"
    }
    ,
    
    "pl-12": {
        "title": "데이터 타입",
            "author": "lee989898",
            "category": "",
            "content": "데이터 타입선언문 int n으로부터 n에 대해 무엇을 알 수 있을까? ​  n이 취할 수 있는 값의 범위는? (모든 정수) ​  n에 적용 가능한 연산자는? (닫혀 있는 모든 연산자, +, -, *) ​데이터 타입의 개념에 대해 살펴 보면, 특정 타입의 변수를 선언하면,  ​그 변수가 취할 수 있는 값은 특정 집합이고, ​그 값들에 적용 가능한 연산자 집합이 존재한다는 의미이다.  ​PL 설계자가 마주하는 기본적인 설계 이슈는 ​목적에 적합한 충분한 데이터 타입으로 구성된 집합을 어떻게 정의할 것인가? ​무슨 연산자들을 정의하고 이들 연산자를 데이터 타입에 어떻게 지정(specify)할 것인가?데이터 타입은 다음과 같이 진화해 왔다. ​초기 PL에서는, 많은 데이터 타입으로 다양한 응용을 지원하였다. ​PL/1이 이러한 예이다. ​ALGOL68에서 얻은 지혜: ​소수의 기본 타입과 이를 위한 소수의 연산자를 정의하고, ​필요에 따라, 사용자 정의(user-defined) 데이터 타입을 지원하자! ​사용자 정의 타입으로부터 추상 데이터 타입으로 발전하였다.​예를 들어, 스택, 큐, 링크드 리스트 등이 이에 속한다. ​타입의 유용성은 다음과 같다.  ​  프로그램 구조화 및 문서화에 유용​  오류 식별 및 방지에 유용​  최적화 지원에 유용 ​​먼저 비교적 단순한 형태로서, 원시형, 문자열형, 사용자 정의 나열형부터 살펴 보자  원시 타입원시 타입은 거의 모든 언어가 제공하고 있는 기본적인 데이터 타입으로, ​다른 데이터 타입을 사용해서 정의되지 않는 데이터 타입이다. ​Integer, floating-point, Boolean, character ​원시 타입은 하드웨어 구조를 직접 반영한 것도 있다. ​부동점 소수는 4바이트의 싱글 프리시전과 8바이트의 더블 프리시전이 있는데, ​각각의 비트 구성은 ​싱글 프리시전: 싸인 1비트, 지수부분 8비트, 소수부분 23비트이거나 ​더블 프리시전: 싸인 1비트, 지수부분 11비트, 소수부분 52비트이다.    ​​+ 문자열 형문자열 타입의 값은 문자열이다. ​설계 이슈: ​  원시 타입으로? 아니면 배열의 특수형으로? ​  스트링의 길이를 정적으로? 아니면 동적으로?​  스트링 연산자는? assignment, copy, comparison, concatenation, substring, pattern matching, etc문자열을 비교할 때, &gt;의 의미는 사전식 순서의 앞뒤 관계를 의미한다.  ​​C, C++에서 문자열은 원시 타입이 아니라, char 타입을 사용하여 정의한다.  이를 위해 라이브러리 함수를 제공한다. ​  C 스트링 라이브러리의 문제는 제공되는  함수가 오버플로우를 처리하지 못한다는 것이다. ​ 예를 들어, strcopy (src, dest); 에서 ​ src가 50바이트이고, dest가 20바이트이면 어떤 일이 일어날까?  ​자바의 문자열 타입은 원시 타입으로 String,  StringBuffer 클래스를 지원한다.문자열 길이 옵션은 3가지(정적, 제한적 동적, 동적) 옵션이 있다.  ​먼저 정적 옵션을 보면… ​COBOL, Java String 클래스는 정적이다. ​스트링이 생성될 때 길이가 정해진다. ​제한적 동적 옵션은… ​C, C++에서는 동적이나 제한적이다. ​  길이는 최대 길이까지 가변적이다. ​  C에서는 최대 길이로 제한하기 보다, ​스트링에 특수 문자를 사용하여 스트링의 끝을 나타내기도 한다. ​동적 옵션은… Perl, Javascript​Ada는 모든 옵션을 지원한다.문자열 옵션의 구현 방법은 다음과 같다. ​정적 옵션의 구현 방법은 컴파일 시에 문자열의 서술을 위해 ​3개의 필드(타입 이름(static string), 길이, 첫글자의 주소)를 필요로 한다. ​제한적 동적 옵션 구현 방법은 런타임 때 문자열의 서술을 위해 ​4개의 필드(타입이름(limited dynamic string), 최대 길이, 현재 길이, 첫글자의 주소)를 필요로 한다.  ​동적 옵션의 구현 방법은 런타임 때 문자열의 서술을 위해, ​3개의 필드(타입 이름(dynamic string), 현재길이, 첫글자의 주소)를 필요로 한다. ​동적 문자열은 문자열의 증가와 감소에 따라 ​저장 공간을 동적 관리(allocate, deallocate)해야 한다.  ​  사용자 정의 서수 타입서수 타입은 ‘데이터를 모아 놓은 것인데 순서가 중요한’ 데이터의 모임이라고 볼 수 있다. ​Enumeration(나열형)과 subrange(범위형)가 대표적인 서수 타입이다.나열형을 살펴 보면, 속성과 값이 정의되어 있음을 볼 수 있다. ​Coin은 페니, 니켈, 다임, 쿼터를 각각 1, 5, 10, 25로 정의하고, ​Escapes는 각 키마다 아스키 코드의 컨트롤 문자가 대응되어 있음을 볼 수 있다. ​연산자에 대해, 표현의 특성이 integer면, integer 연산을 수행한다.",
        "url": "/pl-12"
    }
    ,
    
    "algorithm-04": {
        "title": "동적 계획",
            "author": "lee989898",
            "category": "",
            "content": "동적 계획  분할 정복과 같이 주어진 문제를 더 작은 부분 문제들로나눈 후 부분 문제들의 해들을 합병하여 해결한다.  분할 정복과 달리 부분 문제들이 서로 겹친다.  많은 해들 중 최적의 해를 찾는 최적화 문제에 적용한다.​위 그림은 분할 정복과 동적 계획의 분할 과정의 예이다.  동적 계획 전략  문제를 더 작은 부분 문제들로 분할한다.  작은 부분 문제들을 해결하고 해들을 표에 저장한다.  나중에 다른 (부분) 문제를 해결할 때 이미 해결한 부분 문제가 나오면다시 해결하는 대신에 표에서 해를 찾아 사용한다.막대 자르기  막대의 길이는 n(양의 정수)이다.  막대의 길이가 i(양의 정수), 1 &lt;= i &lt;= n-1,인 조각막대로 자를 수 있다.  길이가 i, 1 &lt;= i &lt;= n, 인 (조각) 막대의 판매 가격은 $p_i$이다.      길이가 n인 막대를 여러 개의 양의 정수 길이의 조각 막대들로잘라서 판매할 때 얻을 수 있는 최대 판매 금액을 구해야 한다.물론 막대를 자르지 않고 통째로 팔 수도 있다.    억기 기법 알고리즘          막대를 자르는 모든 경우들을 찾아낸다.      각 경우에서 얻을 수 있는 판매 금액을 계산한 후 그 중 최대 판매금액을 구한다.      ​위 그림은 막대를 자르는 모든 방법들과 판매 금액이다.시간 복잡도: $\\theta$($2^n$)  분할 정복 알고리즘          길이가 n인 막대를 처음에 길이 i, 1&lt;=i&lt;=n-1, 인 막대와 길이 (n-i)인 막대로 자른다.      길이 i인 막대는 그대로 팔고 길이 (n-i)인 막대는 최대 판매 금액을얻을 수 있도록 통째로 팔거나 여러 개의 양의 정수 길이의 조각 막대들로 잘라서 판다.      R(n): 길이가 n인 막대를 판매할 때 얻을 수 있는 최대 판매금액      R(n) = MAX($p_i$, R(n-i))          1 &lt;= i &lt;= n       R(0) = 0$p_i$: 길이가 i인 막대의 판매 가격R(n-i): 길이 (n - i)의 막대를 판매할 때 얻을 수 있는 최대 판매 금액    cutRod_DC(p[], i)//길이 i의 막대를 판매할 때 얻을 수 있는 최대 판매 금액, R[i]를 계산한다.//입력: p[i..n] - 막대들의 판매 가격        i - 막대의 길이//출력(반환값): 최대 판매 금액if(i = 0) return 0else{      maxSell = 0      for(j = 1; j &lt;= i; j++)          maxSell = MAX(maxSell, p[j] + cutRod_DC(p,i-j))      return maxSell}최초 호출 maxSellValue = cutRod_DC(p,n)      ​위 그림은 cutRod_DC(p,4) 호출시 실행 트리 이다.시간 복잡도: $\\theta$($2^n$)      동적 계획 알고리즘 설계 과정     cutRod_DP(p[], n) // 길이 n의 막대를 판매할 때 얻을 수 있는 최대 판매 금액을 계산 // 입력: p[1 .. n] - 막대들의 판매 가격, n: 막대의 길이 // 출력(반환값): 최대 판매 금액 배열 maxSell[0 .. n]을 선언한다. maxSell[0] = 0 for(j = 1; j&lt;=n; j++){      maxVal = 0      for(k = 1; k &lt;= j; k++)          maxVal = MAX(maxVal, p[k] + maxSell[j - k])      maxSell[j] = maxVal  }  return maxSell[n]      시간복잡도: $\\theta$($n^2$)모든 쌍 최단 경로 찾기​위 그림은 한 그래프 내의 각 정점에서 모든 다른 정점으로 가는 가장 짧은 경로를 찾는 문제이다.가중치를 포함한 방향(혹은 무방향)그래프 G = (V,E)가 주어지면 각 정점에서 모든 다른 정점으로 가는 최단 경로의 거리를 찾아라.  경로의 거리 = 경로 상의 모든 간선의 가중치들의 합  정점들의 수 = n      정점들을 각각 1,2,3, …., n으로 나타낸다.    동적 계획 Floyd 알고리즘문제: 행렬 W가 주어지면 최단 거리 행령 D를 구한다.주 아이디어  최단 경로들을 단계적으로 만든다.  최단 경로들을 경유 가능한 정점들의 집합 L을 이용하여 만든다.최단 경로는 L 내에 있는 정점(들)만을 이용한다.  L에 정점들을 한 번에 하나씩 정점의 번호 순서대로 추가한다.  최단 거리 행렬들을 다음과 같은 순서대로 계산한다.     $D_0$,$D_1$,$D_2$, …, $D_n$​위 그림은 Floyd 알고리즘 예이다.  Floyd 알고리즘AllPairShortestPath(W[])//입력: 가중치 행렬 W [1..n, 1..n]//출력: $D^(i)$ [1..n, 1..n], 0&lt;=i&lt;=n     $D^0$ = W     for(k = 1; k &lt;= n; k++){         n x n 행렬 $D^(k)$ = (dij(k))를 선언한다         for(i = 1; i &lt;= n; i++)           for(j = 1; j &lt;=n; j++)             dij(k) = MIN(dij(k-1),di,k(k-1)+dk,j(k-1)    }",
        "url": "/algorithm-04"
    }
    ,
    
    "pl-11": {
        "title": "변수와 시맨틱스",
            "author": "lee989898",
            "category": "",
            "content": "변수와 시맨틱스변수는 변수명, 데이터 타입, 값, 메모리 주소 등의 속성을 갖는다. ​이들 속성을 변수에 결합하는 것을 바인딩이라고 한다. ​바인딩이 되는 때를 바인딩 타임이라고 하는데, ​주로 컴파일 할 때, 링크할 때, 메모리에 적재할때, 실행할 때가 바인딩 타임이다.값이 assign될 때(assignment statement) 타입이 바인딩 되는 것을 동적 바인딩이라고 한다. ​정적(static) 바인딩은 변수가 정의되거나 맨처음 나타날 때 타입이 바인딩된다. ​바인딩 타임에 따라 변수의 값, 타입 등 ‘변수의 시맨틱’이 달라진다.  ​스코프는 해당 변수가 정의 및 언급(reference)된 문장의 범위를 말한다.  ​프로그램에서 선언(정의)문을 기준으로 하는 방법이 있고, ​값의 할당문 하는(정해지는 순간을 기준으로 하는 방법이 있다. ​전자를 static scope(정적 스코프)라고 하고, ​후자를 dynamic scope(동적 스코프)라고 한다. ​이제 상세히 알아보자  변수우선 변수의 개념을 살펴 보자.변수는 이름, 값, 타입, 주소(메모리)를 속성으로 갖는다. ​이름은 identifier라고 하며, 언어에 따라 정의 방법에 제한이 있는 경우도 있다. ​변수의 값은 변수에 연관된 메모리 위치에 저장된 컨텐트(내용)으로, ​프로그램 실행시 시시각각으로 바뀐다.변수의 타입은 데이터 타입을 말하는 것으로, ​변수가 취할 수 있는 값의 범위와 이에 대한 연산자 집합을 결정한다. ​변수의 타입은 선언문에 의해 정의되거나, ​명명법(naming convention)에 따라 유추 가능하다. ​타입 시스템을 적용하면, 타입 검사 및 프로그램모듈화를 통한 오류 탐지가 가능하다. ​같은 이름의 변수가 서브 프로그램의 스코프에 따라 다른 타입을 가질 수 있으며,  ​이종 타입 간의 연산이 가능할 수도 있다.변수는 메모리의 지정된 주소에 바인딩된다. ​변수가 메모리 주소에 바인딩되면, ​끝날 때까지 그 변수는 살아 있으며(active), ​프로그램이 종료되면 그 메모리는 더 이상 그 변수에 바인딩되지 않는다. ​이와 같이 바인딩이 시작되서 끝날 때까지의 시간을 lifetime이라고 한다.​—​위 그림에서 변수 i는 맨앞과 foo 함수에서 정의되고 있는데,  ​이들 i는 변수명과 타입이 같으나, 메모리 위치는 서로 다르다. ​변수 i는 foo 함수와 bar 함수에서 나타나는 변수 i의 메모리 위치는 ​Foo의 isms foo에 정의된 i를 언급하지만, ​Bar의 i는 맨앞의 i를 언급한다.  ​이들 i가 갖는 값은 변수의 스코프 규칙에 따라다르다.​  바인딩​바인딩은 변수와 주소/타입 간의 매핑을 말한다. ​이들 바인딩에는 정적 바인딩과 동적 바인딩이 있다. ​정적 바인딩은 실행 전(컴파일, 링킹)에 바인딩이 완료되며, ​프로그램 실행 동안에 그 속성이 변경되지 않는다. ​동적 바인딩은 실행 중에 바인딩이 일어나며, ​실행 중에 바뀔 수 있다.변수가 언급(referenced)되기 전에 그 변수는 데이터 타입에 바인딩되어야 한다. ​정적 바인딩에서, 타입 바인딩은 명시적 선언에 의하거나 암묵적 선언에 의한다. ​암묵적 선언이란 선언문 또는 정의문에 의한 것이 아니라 ​변수의 명명법에 의해 타입을 부여하는 것을 말한다. ​Perl에서 변수명이 시작되는 특수문자에 따라 타입이 결정된다. ​$ is a scalar(numeric, character), @ is an array, % is a hash structure ​정적 타입 바인딩에서, 타입과 변수명은 동시에 변수에 바인딩된다.동적 바인딩은 값이 변수에 부여될 때, 값의 타입을 변수에 부여한다. ​동적 바인딩은 파이썬, 자바 스크립트 등에서 사용된다.  ​예를 들어, 프로그램에서 다음과 같이 쓸 수 있다.    ​List = [2, 4.33, 6, 8];​List = 17.3;​이것의 의미는 ​List = [2, 4.33, 6, 8]; -&gt; 이때는 벡터이고, ​List = 17.3; -&gt; 이때는 스칼라이다.  타입 검사연산자의 오퍼랜드가 서로 호환적인 타입인지 ​확인하는 행위를 타입 검사라고 한다. ​호환적인 타입의 의미는 ​두 오퍼랜드의 타입이 연산자에 적합하거나 ​타입 변환이 가능한 경우이다.  ​Int는 real로 자동 변환되는데, 이를 coercion(자동 변환)이라고 한다. ​정적인 타입 바인딩을 적용하면, 정적 타입 검사를 실시하고, ​동적인 타입 바인딩을 적용하면 동적 타입 검사를 실시한다.스토리지(메모리) 바인딩은 ​메모리 풀에서 메모리 셀을 얻어서 변수에 할당하고(allocation), ​메모리를 다 쓰고 나면, 메모리 풀로 반납한다(deallocation). ​변수의 Lifetime은 특정 메모리 셀에 바인딩되어 있는 동안의 시간을 말한다. ​변수가 특정 셀에 바인딩될 때 시작되서, 바인딩이 해제될 때 끝난다.   ​스칼라 변수는 lifetim에 따라 4가지 종류가 있다. ​  정적 변수(Static)  정적 변수는 실행 전에 메모리 셀이 바인딩 되서,   실행이 끝날때까지 그대로 차지한다. ​    포트란77, C의 글로벌 및 정적 변수가 이에 해당 ​  장점은 인스트럭션의 주소 필드가 (데이터가  저장된) 메모리 위치를 직접 가리킬 수 있어서 ​  직접 주소 방식(direct addressing)으로  데이터를 접근할 수 있을 뿐만 아니라, ​  실행시 allocation으로 인한 오버헤드가 없어서, 효율적이다. ​  데이터 구조를 동적으로 생성하거나 객체의 크기를 컴파일   할 때 미리 알아야 한다.  정적 메모리 모델은 recursion을 지원할 수 없다.  스택 동적 변수(stack dynamic)  스택 동적 변수는 다음과 같이 바인딩을 수행한다.  ​          선언문에 정의된 타입은 정적으로 바인딩되지만, ​      스토리지 할당과 초기값 할당 등은 선언문에 정의  된 대로 실행시에 바인딩된다. ​  이것을 elaboration이라고 함) ​예를 들어, 스칼라 변수에 대해 주소를 제외한 모든 속성은 정적으로 바인딩되지만, ​서브 프로그램의 로컬 변수나 자바의 메소드 등은 ​런타임 스택으로부터 메모리가 할당되어 동적으로 바인딩된다. ​장점은 recursion, 서브프로그램 메모리 보존 등이며, ​단점은 allocation, deallocation으로 인한 오버헤드, 간접 주소 방식(indirect addressing)에 의한 비효율 등이다.  ​      간접 주소 방식이란 인스트럭션의 주소 필드가 레지스터를 가리키고, ​그 레지스터 안에 메모리 위치가 저장되어 있어서, ​레지스터를 거쳐야 원하는 데이터를 접근하게 되는 방식이다.      명시적 힙 동적 변수(explicit heap dynamic) 힙은 가상 주소 공간의 일부분으로 동적 메모리 할당을 위해 예약되어 있다. ​명시적 연산자 new, delete에 의해 할당되고 해제된다. ​타입은 정적으로 바인딩되고, ​스토리지는 실행시 변수가 생성될 때 바인딩된다. ​힙에 접근할 때에는 힙 포인터나 레퍼런스를 통해서 접근하게 된다.      Person *p;​  p=(Person *) malloc(sizeof Person);​  p-&gt;name = “Mike”; p-&gt;age = 40;​  free(p);​      위 코드는 C++의 명시적 힙 동적 변수의 예를 보여주고 있다. ​자바 객체는 명시적 힙 동적 변수이다. ​명시적 힙동적 변수의 장점은 동적인 구조를 생성할 수 있다. ​단점은 포인터와 레퍼런스 변수를 올바르게 쓰기가 어려워 프로그램의 신뢰도가 떨어질 수 있고, ​    변수에 대한 레퍼런스 비용과 스트로지 관리의 복잡도가 높다.  ​  암묵적 힙 동적 변수(implicit heap dynamic)값이 할당될 때, 힙 스토리지에 바인딩된다. ​장점은 융통성이 높다.  ​단점은 동적 속성을 유지하기 위한 런타임 비용이 높고, ​컴파일러에 의한 오류 탐지가 매우 낮다.  스코프속성이 바인딩된 변수에 대해, ​그 바인딩이 유효한 또는 영향을 미치는 프로그램의 범위, 이것을 스코프라고 한다.하나의 프로그램을 구성하는 여러 함수에서 ​  동일한 이름의 변수들을 다른 타입으로 선언할 수 있다. ​  이때 이들 변수는 각각 다른 타입으로 바인딩된다. ​  이러한 이유로, 어떤 변수에 언제 어느 타입을 ​  바인딩하는 것이 옳은지 결정하려면, ​  어느 타입의 변수가 프로그램의 어디부터 어디까지 유효한지 ​  구분이 필요하다. ​  이와 같이 변수의 타입이 유효한 프로그램의 영역을 스코프라고 한다. ​​위 그림의 main에서 foo(x)를 호출할 때, ​  이때 x는 int인가 float인가? (int이다)변수의 스코프에 대한 정의를 살펴 보자  스코프는 변수가 visible한(나타나는) 문장의 범위이다. ​  ‘변수가 어떤 문장에서 visible하다(나타난다)’의 의미는 ​  바인딩된 변수가 그 속성을 그대로 유지한 채, ​  그 문장에서 언급(reference)되거나 그 변수에 값이 할당된다는 것이다. ​스코프를 변수가 영향을 미치는 범위라고 했는데, ​  좀더 정확히 말하면, ​  변수가 자신의 속성을 문장의 계산에 반영한다는 의미이다.C++이나 자바에서 포인터, 레퍼런스 타입 등을 설명할 때 ​  Reference란 말이 사용되는데, ​  여기서 설명하는 refence의 의미와 다르다.여기서, ‘문장에 X가 reference된다’는 말은 ‘x가 문장에   ‘언급된다(씌여있다)’는 것을 의미하고, ​    레퍼런스 타입의 레퍼런스를 의미하지 않는다  ​  프로그램에서 nonlocal 변수는 ​    그 변수가 그 프로그램에서 visible하지만 ​  그 프로그램에서 선언(declaration)되지는 않았다는 뜻이다. ​  nonlocal 변수의 선언문은,  ​  프로그램의 공간적 구조(정적 스코프)나 ​  프로그램 호출의 역순(동적 스코프)으로 찾아가면, ​  공간적으로 가깝거나 가까운 호출 함수에서 선언문을 찾을 수 있다. ​언어의 스코프 규칙은, 같은 이름의 변수가 여러 개 선언되었을 때, ​  언급된 이름이 어느 선언문에 의한 변수에 관련되어 있는지 결정한다.  정적 스코프정적 스코프는 변수의 스코프를 ​  프로그램 텍스트 구조에 따라 공간적 개념에 의해 정적으로 결정한다. ​    언급된 이름을 변수에 매핑하려면, ​  프로그래머(또는 컴파일러)는 선언문을 찾아야 한다. ​  먼저 로컬에서 찾은 후, 없으면 스코프를 넓혀가면서, ​  같은 이름을 정의한 선언문을 찾거나 선언  문이 더 이상 없을 때까지 찾는다.   C에서 블록 스코프는 텍스트 레이아웃에 의한 ​  공간적 개념으로 결정된다.  동적 스코프동적 스코프는 프로그램의 텍스트 레이아웃이 아니라, ​  컨스트럭트의 호출 순서에 근거하므로, 런타임 때 결정된다. ​    동적 스코프는 프로그램 실행 중, ​    변수가 언급될 때마다 그 변수의 선언문을 찾아서 동적으로 매핑한다. ​    언급된 변수에 대한 선언문이 어느 함수에 있는지 찾기 위해, ​    함수 호출 순서의 역순으로 해당 변수의 선언문을 찾는다.동적 스코프의 장점은 서브 프로그램을 호출할 때 ​     파라미터를 패스하지 않아도 되니 편리하다. ​    단점은 자주 실행되는 서브 프로그램의 로컬 변수는 ​      역시 자주 실행되는 다른 서브 프로그램에서 자주 나타나기 때문에 ​      계산이 잘못될 가능성이 높다. (신뢰성 문제)​    정적 타입으로 선언된 난로컬 변수의 타입 검사는 불가하여 오류 탐지가 어렵다.  ​   게다가 읽고 이해하기 어렵다.  라이프 타임라이프타임(수명)은 ​변수에 메모리가 할당(allocate)되서 해제(deallocate)될 때까지의 시간을 말한다. ​라이프타임은 스코프와 밀접한 관계가 있지만, 개념적으로는 다르다.​위 그림 C 프로그램에서 로컬 정적 변수 count를 살펴 보자. ​Main에서 fun을 1차 호출하면, count는 1이고, ​2차 호출하면 count는 2이다. ​count의 스코프만 따지면, ​count가 로컬 정적변수이기 때문에 1차, 2차 호출 모두 1, 1이어야 한다.  ​그러나 count의 lifetime이 전체 프로그램의 실행이 끝날 때까지 ​연장되기 때문에, 1,2가 된다.변수의 개념을 좀더 상세히 알아보면, ​x=1, x=x+1의 의미를 따져 보자.여기서 =은 수학의 equal 사인이 아니라, ​x에 1을 할당(assign)한다는 말이다. ​x는 변수의 이름이거나 변수의 위치를 지칭한다. ​즉, 변수는 메모리 셀의 추상화이다. ​따라서, x는 이름(고유식별자)이고, ​x는 어떤 값이 저장된 위치를 지칭한다.  Stack함수가 호출되면, 스택 프레임을 스택의 꼭대기에 push 하고, ​함수 실행이 끝나면, 스택 프레임을 꼭대기로부터 pop한다. ​스택 프레임은 호출되는 함수에 넘겨지는 파라미터 값, ​호출함수가 호출된 함수로부터 값을 넘겨받는 반환 주소, ​호출된 함수의 로컬 변수를 위한 저장 공간을 포함한다.  Heap힙은 동적 메모리 할당이 일어나는 메모리의 일부분이다. ​할당/해제 함수로는 malloc/free(pointer), new(pointer)/delete(pointer)가 있다. ​힙에 대한 메모리 할당은,    ​메모리 일부분이 런타임에 동적으로 할당되고, ​여러 함수에서 언급한 변수는 스코프에 제한이 없다할당된 메모리 크기가 크다.명령형 언어는 본뉴만 아키텍처를 흉내낸 것이다.본뉴만 아키텍처의 주요 구성요소는 메모리와 프로세서이다메모리는 데이터와 명령어를 저장하고, ​프로세서는 메모리 컨텐트를 수정하는 연산을 실행한다이에 대응되는 명령형 언어의 추상화는 변수와 산술식이다변수는 메모리셀에 대응하고, 산술식은 CPU 실행에 대응된다.컴퓨터에 실재로 존재하는 메모리(이것을 물리적 메모리 또는 메모리라고 한다)는 ​때때로 프로그래머의 프로그램을 한꺼번에 메모리에 모두 올려 놓지 않는다.그 이유는 다른 프로그램과 메모리를 나누어 쓰기도 하고, ​프로그램이 메모리 사이즈를 넘어가기도 하기 때문이다.프로그래머가 제한된 물리적 메모리 공간을 고려하면서 ​변수나 배열에 메모리 공간을 할당한다는 것은 매우 복잡하고 어렵다. ​따라서 프로그램을 전부 저장할 수 있는 가상 메모리를 프로그램에 할당하고, ​사용 가능한 메모리에 그만큼의 프로그램을 올렸다 내렸다 하면서 프로그램을 실행한다. ​이와 같이 프로그램을 올렸다 내렸다 하는 작업은 OS가 한다.​가상 메모리에서,  ​변수 i와 배열 a[100]은 메모리에 오렌지 색으로 할당된다. ​함수 foo에서 적용되는 변수 i, j는 연두색으로 할당된다. ​이중에서 적재 가능한 만큼의 프로그램을 메모리에 올려서, ​프로세서에서 실행하고, ​실행이 끝나면, 프로그램의 다음 부분을 올려서 실행하게 된다.이때 가상 메모리를 쓰면, ​전체적인 상대 주소가 변하지 않기 때문에 ​물리적 메모리에 적재할 때 ​프로그램의 주소 변환이 매우 간단해 지는 장점이 있다.​변수의 타입에 따라 할당되는 메모리 공간이 다르다. ​개략적으로 설명하면, ​스택은 프로시져에 대한 정보를 저장하는 공간으로, ​이들 프로시져에서 사용되는 파라미터, 변수 등의 속성 정보 등을 저장한다. ​스택은 중첩 프로시져(함수) 호출, 순환 프로시져(함수) 호출 등을 ​올바르게 처리하기 위한 목적으로 사용된다. ​힙은 malloc, free에 의해 명시적으로 메모리의 동적 할당 및 해제를 위한 메모리 풀(pool)이다.   ​Static에는 정적, 글로벌 변수가 저장된다.Code는 프로그램이 저장된다.  래퍼런싱 환경문장의 레퍼런싱 환경은 문장에 visible한(나타난) 모든 변수명의 집합이다. ​정적 스코프 규칙을 적용하는 언어에서, 레퍼런싱 환경은, ​로컬 변수와 그 안에 공간 구조적으로 포함된 서브 프로그램에 언급된(나타난) 변수를 합친 것이다. ​동적 스코프 규칙을 적용하는 언어에서, 레퍼런싱 환경은, ​로컬 변수와 그 안에서 호출되어 실행 중인(active) 서브 프로그램에 언급된(나타난) 변수를 합친 것이다. ​실행중인 서브 프로그램의 어떤 변수는 레퍼런싱 환경에서 hidden(숨겨질)일 수 있다. ​Hidden이란 active이지만, 나타나지 않는 것을 의미한다. ​이와 같은 hidden 변수는, ​동일한 이름의 변수가 여러 함수에서 선언된 상황에서,  ​앞에서 선언된 같은 이름의 변수가 여전히 active하지만 ​나중에 선언된 같은 이름의 변수가 나타날 때 발생한다.​실제로 동적 스코프는 현대 프로그래밍 언어에서 일반적이지 않고, ​C에서도 지원하지 않는다. ​따라서, 위 그림은 C이지만, ​동적 스코프를 지원한다고 가정하고 레퍼런싱 환경을 따져 보자. ​호출되는 순서는 main -&gt; sub2 -&gt; sub1이다. ​포인트1에서 나타날 수 있는 변수는 main의 d, sub2의 c, sub1의 a와 b, 이다. ​여기서 main의 c, sub2의 c는 hidden이다. ​포인트2에서 나타날 수 있는 변수는 main의 d, sub2의 b와 c이다. ​여기서 main의 c는 hidden 이다. ​포인트3에서 나타날 수 있는 변수는 main의 c와 d이다.  지정 상수이름 지정 상수는 상수인데, 변수명처럼 이름을 부여한 것을 말한다. 이렇게 하는 이유는 읽기 쉽고, 수정하기 쉽도록 하기 위한 것이다. ​스토리지에 바인딩될 때 값이 결정된다.",
        "url": "/pl-11"
    }
    ,
    
    "sc-06": {
        "title": "RSA",
            "author": "lee989898",
            "category": "",
            "content": "RSA  RSA  1978, MIT  가장 널리 사용 (공인인증서 등)  Key size = 1024 ~ 4096 bits  DES is 100 times faster in S/W and 10000 times faster in H/W  RSA Algorithm      키 생성 부분과 암/복호화 부분으로 구성    Part 1. 키생성          Public key : e, n      Private key: d      2개 큰 소수 p,q 선정 n = p * q , p , q는 secret, n은 공개      Public key e는 φ(n) = (p-1)(q-1)과 relative prime하게 선정(유클리드 algorithm), e는 공개      e * d mod φ(n) = 1 인 private key d를 계산(extended euclid algorithm) d는 secret            Part 2. 암호화/복호화    Encryption  Receiver의 public key (e,n)을 받는다  Message M을 정수로 전환하여      E(M) = $M^e$(mod n) = C를 계산    Decryption  D(c) = $C^d$ (mod n) = M (fermat, ouler)  RSA 안정성  해커는 공개키(E,N), 암호문 C를 쉽게 얻을 수 있음  비밀키 D를 얻으려면 N을 인수분해하여 φ(N)를 구해야함  큰 수에 대한 인수분해는 매무 많은 수행시간 요구 (현재 brute force외에 방법없음)  양자 컴퓨터",
        "url": "/sc-06"
    }
    ,
    
    "pl-10": {
        "title": "신택스 분석방법",
            "author": "lee989898",
            "category": "",
            "content": "신택스 분석 방법프로그램이 문법에 적합한지 확인하기 위한 신택스 분석 방법에대해 알아보자.​신택스 분석의 목표는 파스 트리(parse tree)를 생성하는 것이다.신택스 분석은 프로그램의 각 문장을 토큰으로 쪼개는 일부터 시작한다.이렇게 쪼개는 것을 렉시칼 어낼리시스라고 하고, ​이것을 수행하는 프로그램을 렉시칼 애널라이저 또는 스캐너라고 한다. ​이렇게 쪼갠 후에 문법적으로 타당한지 확인하는데, ​이것을 신택스 어낼리시스라고 하고, ​이와 같은 일을 수행하는 프로그램을 신택스 애널라이저 또는 파서라고 한다.다시 말하지만 렉시칼 어낼리시스와 신택스 어낼리시스의 궁극적인 목표는 파스 트리를 생성하는 것이다. ​파스 트리로부터 중간 코드가 생성되고, 최적화되어, 최종적으로 코드 생성이 이루어지기 때문에  ​파스 트리의 생성이 PL 구현 시스템에서 가장 중요한 부분이다. ​파스 트리의 생성은 문법에 의존한다.즉, 문법에 적합한 프로그램만 파스 트리로 생성된다. ​문법은 신택스와 시맨틱스를 표현한 규칙의 집합으로, 프로그램이 PL의 문법에 적합한지 판단하는 기준이 된다. ​문장 A=B(A+C)에 대해, 문법(규칙 집합)에 따라 Leftmost derivation을 하려면, ​문장 A=B(A+C)가 문법의 규칙 중에서 어느 규칙에 해당되고, ​이 문장을 구성하는 A, =, B, (, A, +, C, )가 어느 규칙의 어느 심볼에 해당되는지 알 수 있어야 한다.이것을 신택스 어낼리시스라고 한다.이를 위해 A=B*(A+C) 문장을 A, =, B, (, A, +, C, )로 잘라내고, ​이들이 각각 문법이 허용하는 문장 요소 중의 무엇을 나타내는지(연산자, 변수명, assignment 기호 등) 구별해야 하는데, ​이것을 렉시칼 어낼리시스라고 한다.잘라낸 A, =, B, (, A, +, ) 각각을 토큰이라고 한다.언어의 구현은 컴파일러, 인터프리터, 하이브리드 방식, 세가지 중의 하나이다. ​이들 모두 lexical analysis와 syntax analysis를 거친다.렉시칼 애널라이저는 스캐너라고도 하는데, 소스 프로그램을 인풋으로 받아 토큰으로 잘라낸다.신택스 애널라이저는 파서라고도 하는데, 토큰을 인풋으로 받아 문법에 따라 파스 트리를 만든다.​렉시칼 애널라이저는 신택스 애널라이저의 일부분으로 구현된다. ​이러한 이유로 모든 토큰을 한꺼번에 생성하지 않고 필요할 때마다 토큰을 생성하기도 한다.토큰 중에는 변수에 대한 변수명, 타입 등의 속성이 있는데, 이들은 심볼 테이블 안에 저장된다.이들 정보는 신택스 어낼리시스 동안에 lookup되기도 하고 새로운 속성이 매핑되기도 한다.  Lexical analysis렉시칼 애널라이저는 문장에서 각 단어를 추출하고 이들이 어느 범주(문장에서 허용되는 개념의 범주)에 해당되는지구별하는 것이다.추출된 단어에 대해 범주를 매핑시킨 것을 토큰이라고 한다. ​교과서에서는 일반적인 표현보다는 이들 요소를 구분하여 각각 lexeme, token이라고 하는데, ​일반적인 표현을 쓰면, 이들은 각각 word, category이며, 이들을 합친 것을 토큰이라고 한다. ​렉시칼 애널라이저는 이와 같은 토큰을 식별하는 패턴 매처로서, ​주어진 스트링에서, 주어진 패턴에 매치되는 서브스트링을 찾는다. ​이 설명은 매우 정확하지만 매우 까다로와서 렉시칼 애널라이저를 잘못 이해할 수도 있다.​소스 프로그램을 위와 같이 1차원 배열로 표현되어 있다고 치자. ​주어진 스트링에 해당한다. ​‘주어진 패턴’이란 identifier, reserved word 등에 해당되는 스트링을 의미한다. ​Identifier, reserved word 등은 오른쪽 아래의 상태 전이 다이어그램으로 정의된다. ​렉시칼 어낼리시스가 어떻게 진행되는지 설명하기 전에 ​먼저 상태 전이 다이어그램에 대해 알아 보자.렉시칼 애널라이저를 구현하려면, 상태 전이 다이어그램을 그리는 것부터 시작한다. ​​위의 그림은 상태전이 다이어그램을 나타내고 있다.상태전이 다이어그램은 directed graph로, ​노드는 상태를 나타내며 상태명으로 레이블이 붙어 있다.아크는 상태 전이를 나타내며, 인풋 문자로 레이블이 붙어 있다.아크의 레이블은 상태 전이를 발생시키는 인풋 문자로서, ​아크의 이전 상태에서 해당 인풋 글자가 들어오면 아크의 다음 상태로 전이한다는 의미이다.아크는 전이가 일어날 때 수행되어야 할 액션을 포함하기도 한다.그림에서 아크의 위에 있는 Letter, Digit 등은 상태 전이를 일으키는 문자를 나타내고, ​아래쪽의 addChar, getChar 등은 액션을 나타낸다.  ​상태 다이어그램을 단순화하기 위해, reserved word나 identifier을 별도로 인식하기보다 함께 인식할 수 있다.그림에서 두겹의 타원은 identifier와 integer를 인식하기 위한 상태이다. ​identifie가 변수명으로서의 identifier인지 reserved word인지 구별하기 위해 ​심볼 테이블 lookup을 통해 결정한다.상태 전이 다이어그램을 규칙으로 표현할 수도 있는데 이것을 regular grammar라고 한다.그렇다면 ‘주어진 패턴’이란 상태 전이 다이어그램으로 정의되는 것이다.​그러니까 렉시칼 애널라이저는 input file을 하나의 긴 스트링으로 간주하고, ​한글자씩 읽어 들여 상태 전이 다이어그램을 따라 가면서, ​reserved word, identifier 등의 토큰을 긴 스트링 중의 서브 스트링으로서 인식하는 것이다.위 그리에서 Input file을 읽어 들여 코멘트를 무시하고, 렉시칼 어낼리시스를 하면, ​오른쪽의 토큰들을 얻게 된다.정리하면, 주어진 스트링에서, 주어진 패턴에 매치되는 서브스트링을 찾는 역할을 하는 것이 ​바로 상태 전이 다이어그램이고, ​이것을 프로그래밍하면 렉시칼 애널라이저가 된다.​A=B*(A+C)와 같은 간단한 산술식에서 토큰을 추출하는 렉시칼 애널라이저를 구현하기 위해, ​먼저 상태 전이 다이어그램을 그리면 위 그림과 같다. ​unknown은 identifier와 integer 이외의 것을 인식하는데, ​이들은 주로 산술식을 구성하는 연산자나 괄호 등에 해당된다.​이들은 하나의 문자로 구성되어 있기 때문에 싱글 캐릭터 토큰이라고 하는데, ​이들이 산술식의 연산자나 괄호인지 아닌지 결정하기 위해 심볼 테이블을 lookup한다.아크 아래의 액션을 나타내는 함수의 역할에 대해 알아 보자.getChar는 인풋 스트링에서 다음 글자를 가져와서 변수 nextChar에 넣고 ​그 유형을 판단해서 변수 charClass에 그 유형을 넣는다. ​addChar는 nextChar의 글자를 배열 lexeme에 넣는다. ​Lookup은 배열 lexeme에 있는 스트링이 reserved word인지 아닌지 결정한다.  Syntax Analysis우선 신택스 어낼리시스 즉, 파싱이 뭔지, 파서가 뭘하는지 알아보자.파서는 주어진 프로그램에 대해 파스 트리를 생성한다. ​파스 트리는 명시적으로 생성되기도 하지만 ​트리 순회(traversal) 흔적이 생성되기도 한다.(이러한 트리 순회 흔적을 유래(파생, derivation)이라고 합니다.) ​파스 트리와 유래 모두 컴파일러나 인터프리터가 필요로 하는 모든 신택스(구문 구조적) 정보를 포함한다. ​신택스 어낼리시스의 목표는 인풋 프로그램이 문법적으로 올바른지 검사하고, ​문법적으로 올바른 인풋에 대한 파스 트리를 생성한다. ​도중에 오류가 발견되면 오류 진단 메시지를 생성하고, ​인풋 프로그램의 신택스 어낼리시스를 계속한다. ​물론 신택스 어낼리시스 도중에 오류가 발생하면, ​신택스 어낼리시스만 계속하면서 문법적으로 잘못된 부분을 식별할 뿐이지, ​파스 트리를 생성하지는 않는다.파싱 방법은 하향식(탑다운)과 상향식(바텀업) 방식이 있다. ​  Top -down parsing탑다운 파싱은 start 심볼에서 시작하여, 인풋 스트링을 derivation에 어느 BNF 규칙을 적용하는 게 좋을지 따져 보고 ​규칙을 선택하여 derivation한다.이러한 derivation을 트리로 간주하면, 위에서 아래로 내려오면서 ​반복적으로 규칙을 선택하고 적용하여 ​궁극적으로 인풋 스트링(프로그램)이 생성될 때까지 계속한다. ​그래서 이것을 recursive-descent parser(반복적 하강식 파서)라고 한다. ​이와 같은 방식의 파싱 알고리즘을 LL 알고리즘이라고 하는데, ​인풋을 왼쪽에서 오른쪽으로 스캔하고, ​Leftmost derivation을 생성한다. ​Leftmost derivation이란 sentential form(문형식)의 가장 왼쪽에 있는 난터미날에 대해, ​그 난터미날을 LHS로 갖고 있는 규칙을 선정하여, ​그 규칙의 RHS로 바꾸는 것을 의미한다. ​LL의 앞에 있는 L은 ‘왼쪽에서 오른쪽으로’를 나타내고,  ​뒤의 L은 ‘leftmost derivation’을 나타낸다.탑다운 파서의 파싱 결정 문제 ​Preorder에 의해 파스 트리를 생성한다.Preorder 순회는 root, left, right 순서로 트리를 방문한다.​좌선 유도 중인 문형식이 주어졌을 때, 파서는 ​주어진 문형식에서 가장 왼쪽의 난터미날 심볼에 대해, ​그 난터미날 심볼을 LHS로 갖고 있는 규칙을 찾아서, ​그 규칙의 오른쪽 부분으로 문형식의 난 터미날 심볼을 교체한다.(이것을 expand라고 함)이렇게 하여, 좌선 유도에 의한 다음 문형식을 생성한다.​문형식에서 xAa에서, x는 터미날 심볼로 구성된 스트링을, ​A는 난터미날 심볼을, a는 터미날과 난터미날 심볼의 혼합 스트링을 나타낸다.Expand할 때는 적용할 규칙을 선택하여 ​주어진 스트링의 난터미날 심볼을 규칙의 오른쪽으로 교체하여 확장한다.​예를 들어 보자. ​현재 문형식이 xAa이고, ​A에 적용 가능한 규칙이 A→bB | cBb | a 라고 하면, ​탑다운 파서는 어느 규칙을 선택하느냐에 따라, ​다음 문형식으로 xbBa, xcBba, or xaa 중의 하나를 생성한다.이것이 바로 탑다운 파서의 파싱 결정 문제이며, ​백트래킹 비용을 수반한다.  Bottom-up parsing바텀업 파싱은 인풋 스트링을 스캐닝하면서, ​규칙의 RHS에 해당되는 스트링이 발견되면, ​이 스트링을 발견된 규칙의 왼쪽 스트링으로 바꾼다. ​이러한 과정을 반복해서 인풋 스트링이 ​궁극적으로 starting 심볼로 바뀌면 파싱이 끝나는 것이다. ​이렇게 하려면 탑다운 방식과 달리 스택이라는 자료 구조를 필요로 하는데, ​스택에 넣고 빼고 하는 과정을 포함하기 때문에 이것을 shift-reduce 파서라고 한다. ​Shift는 스택에 심볼을 넣는 것, reduce는 스택의 서브 스트링을 규칙의 LHS로 바꾸는 것을 말한다. ​  ​이러한 알고리즘을 LR 알고리즘이라고 하는데, ​L은 왼쪽에서 오른쪽으로 인풋을 스캐닝하고, ​R은 rightmost derivation을 생성한다는 것을 나타낸다.바텀업 파싱의 기본 아이디어는 ​주어진 스트링을 처리할 때, 규칙의 RHS에 해당되는 서브 스트링을 찾아서, ​그 서브스트링을 규칙의 LHS로 교체하는 과정을,  ​주어진 스트링이 start 심볼이 될 때까지 반복하는 것이다. ​바텀업 파싱의 기술적인 이슈는 ​어느 규칙을 적용해서 어느 서브스트링을 교체할 것인지, ​미리 따져보는 것이다.쉬프트-리듀스 파싱은 바텀업 파싱의 일종이다.​예를 보면서, 바텀업 파싱을 알아 보자.문법과 인풋 스트링이 이와 같을 때, ​인풋 스트링의 왼쪽에서부터 시작해서, ​서브스트링에 적용할 수 있는 규칙을 찾아 본다.RHS에 b가 있는 규칙 A → b를 적용할 수 있다. ​빨간색 b에 A-&gt;b를 적용하면,  ​빨간색 b가 규칙 A-&gt;b의 LHS인 A로 교체되어 ​aAbcde가 된다.다음, 빨간색 Abc가 A-&gt;Abc에 의해 A로 교체되어 ​aAde가 되고, ​빨간색 d가 B-&gt;d에 의해, A로 교체되어 ​aABe가 된다.빨간색 aABe가 S-&gt;aABe에 의해 start 심볼 S로 교체되어 ​파싱이 종료된다.위의 그림을 잘 살펴보면, reduce의 의미와 derivarion의 의미가 반대임을 알 수 있다.      바텀업 파싱은 규칙이 허용하는 바에 따라 인풋 스트링의 서브스트링을 ​LHS의 난터미날 심볼로 교체한다. ​이러한 교체는 인풋 스트링이 S로 교체될 때까지 계속된다. ​여기서 교체되는 서브스트링은 ​처음에는 터미날 심볼로 구성되지만, ​점차 터미날 심볼로 구성된 서브스트링이 난터미날로 교체되면서, ​터미날 심볼과 난터미날 심볼로 구성된다.  ​LHS로 교체하는 과정을 보면, ​인풋 스트링의 길이가 점점 줄어들고 있음(즉, reduce되고 있음)을 볼 수 있다.  ​        탑다운 파싱과 비교를 해 보면, ​탑다운 파싱은 S에서 인풋 스트링이 생성될 때까지 규칙을 적용해서 ​가장 왼쪽의(leftmost) 난터미날 심볼을 RHS로 expand한다. ​이것을 좌선 유도(leftmost derivation)이라고 하는데… ​위의 파싱 과정을 거꾸로 살펴 보면, ​가장 오른쪽의 난터미날이 먼저 RHS로 expand됨을 볼 수 있다. ​즉, 우선 유도(rightmost derivation)가 되고 있는 것이다. ​        따라서, 탑다운과 바텀업 파싱의 과정을 보면 서로 반대임을 알 수 있다. ​즉, 바텀업 파싱은 탑다운 우선 유도의 역순과 같다.   ​  바텀업 파싱에서는 어느 서브 스트링에 어떤 규칙을 적용하느냐가 중요하다.앞의 예에서 abbcde(b에 A-&gt;b를 적용) =&gt; aAbcde(d에 B-&gt;d를 적용) =&gt; aAbcBe이 생성되면, ​이후 어떠한 규칙을 적용해도 S로 리듀스되지 않는다.규칙의 LHS로 교체할 수 있는 ‘인풋 스트링 S의 서브스트링 a’를 핸들이라고 한다. ​a가 A → a의 RHS에 매치되면, ​a를 A(규칙의 LHS)로 교체한다.이때 이러한 교체 과정은 탑다운 방식의 우선 유도(rightmost derivation)의 역순으로 나타난다.   ​쉬프트-리듀스 파싱에서 리듀스 연산은 핸들에만 적용 가능하다.쉬프트-리듀스 파싱의 구현 방법에 대해 알아 보자.바텀업 파싱은 쉬프트와 리듀스라는 두개의 액션으로 설명되기 때문에, ​쉬프트-리듀스 파싱으로 불리며, ​이를 위한 자료구조로 스택을 사용한다.  ​​쉬프트 액션은 다음 인풋 토큰을 스택의 꼭대기에 옮겨 넣는 것을 의미하며, ​리듀스 액션은 스택의 꼭대기에 있는 핸들(규칙의 RHS)를 규칙의 LHS로 교체하는 것을 의미한다. ​이 과정을 start 심볼로 리듀스 될 때까지 반복한다.쉬프트할 때 스택을 사용하면, ​현재 처리 중인 스트링에서 리듀스 가능한 서브스트링(핸들)을 찾기 쉬운 경향이 있다.​위 그림은 쉬프트-리듀스의 예이다.쉬프트와 리듀스 둘다 가능할 때, 쉬프트-리듀스 컨플릭트가 발생한다. ​스택에 핸들 if E then S가 있을 때, 문법에 의하면 쉬프트, 리듀스 모두 가능하다. ​그러나, 이것은 그 다음에 나오는 심볼이 무엇이냐에 달려 있다. ​다음에 else가 나온다면 리듀스하면 안되고 쉬프트해야 한다.  ​반대로 else가 나오지 않는다면 리듀스해도 된다.  ​리듀스에 적용할 규칙이 여럿일 때, 리듀스-리듀스 컨플릭트 발생한다.스택에 핸들 id(arg)가 있을 때, Stmt로 리듀스할지, Expr로 리듀스할지?  ​이것 역시 다음에 나오는 심볼에 달려 있다.앞에 언급한 문제를 해결하려면, ​인풋 스트링에서 현재 심볼의 다음에 오는 k개의 심볼을 먼저 본다면 ​현재 어느 규칙을 써서 무엇을 할지 쉽게 결정할 수 있을 것이다이것을 LR(k) 파서라고 하고, 여기서 k는 lookahead라고 한다.​장점은 일반적인 방법이면서 많은 유형의 문법을 다룰 수 있고, 효율적이라는 것이다단점은 구현하기 어렵다는 것이다.컴파일러가 각 단게별로 소모하는 처리 비용을 시간의 비율로 나타내면 다음과 같다. ​  ~ 35-40% of time spent in I/O​  ~ 30% in lexical analysis​  ~ 10% in symbol table management​  ~ 7-15% in parsing and other control​가장 많은 비용을 소모하는 것이 바로 IO이다렉시칼 애널라이저가 그 만큼의 시간을 소모하고, ​정착 알고리듬 측면에서 가장 복잡한 파싱이 비용소모가 적다. ​",
        "url": "/pl-10"
    }
    ,
    
    "pl-09": {
        "title": "정적 시맨틱과 동적 시맨틱",
            "author": "lee989898",
            "category": "",
            "content": "정적 시맨틱과 동적 시맨틱시맨틱에는 정적 시맨틱과 동적 시맨틱이 있다.정적인 시맨틱은 컴파일 시에 확인할 수 있는 시맨틱 규칙을 말한다.이들 시맨틱 규칙은 ​타입 검사, 프로그램에서 변수가 언급되기 전에 이에 대한 정의가 되어 있는지, ​서브 프로그램에서 어느 선언 이 어느 변수에 적용되어야 하는지, ​서브 프로그램과 메소드가 호출될 때 호출 순서를 올바르게 지키는지 등을 포함한다.  ​동적 시맨틱스는 프로그램이 실행될 때 ​프로그램 컨스트럭트가 언제 어떤 행태(계산 결과)를 생성해야 하는지 정의하는 것이다.  BNF로 시맨틱을 표현할 수 있을까?타입 호환성 규칙은 BNF로 서술할 수 있지만, ​새로운 난터미널 심볼과 규칙을 추가로 요구하기 때문에, ​문법이 너무 커지고 신택스 애널라이저(구문 해석기)가 비대해져 유용하지 않다. ​프로그래밍 언어에 공통적으로 적용되고 있는 ​‘모든 변수는 언급되기(reference) 이전에 선언(정의)되어야 한다’는 규칙은 BNF로 서술이 불가하다. ​이러한 종류의 규칙을 정적인(static) 시맨틱스라고 부른다.정적인 시맨틱스는 프로그램 실행시 프로그램의 의미에 간접적으로 관련이 있을 뿐이고, 오히려, 프로그램의 올바른 형태(신택 스)와 직접 관련이 있다. ​따라서, 정적인 시맨틱스의 검사는 컴파일 시에 가능하다.이 말은 정적인 시맨틱스는 컴파일러의 구현시 고려되어야 한다는 의미이다. ​그러면 정적인 시맨틱스를 어떻게 서술할 수 있을까? ​바로 속성 문법(attribute grammar)으로 서술한다. ​속성 문법은, ‘프로그래밍 언어가 만족해야 할’ 정적인 시맨틱 규칙을 서술하고 검사하기 위해 사용되는 ​BNF와 유사한 형태의 문법이다.  속성 문법이 단순한 assignment 문장의 타입 검사에 어떻게 사용 될까?이 assignment 문장의 신택스와 정적 시맨틱스는 다음과 같다. ​  변수명은 A, B, C 뿐이다.​  Assignment의 우변은 변수거나 ‘변수 + 변수’의 표현식이다. ​  변수의 타입은 int거나 real이다.​  우변에 변수 2개가 있을 때, 이들의 타입은 같을 필요가 없다. ​  두 오퍼랜드가 같은 타입이 아닐 때 표현식의 타입은 real이다.(여기서 표현식의 타입이란 표현식을 계산한 결과값의 타입을 말한다.) ​  이들의 타입이 같을 때, 표현식의 타입은 오퍼랜드의 타입과 같다. ​  좌변의 타입은 우변의 타입과 같아야 한다. ​  그래서, 우변의 오퍼랜드의 타입이 mix될 수 있으나, 우변의 계산 결과값과 좌변의 타겟이 같을 때만 assignment는 타당하다.  ​속성 문법은 위와 같은 정적 시맨틱 규칙을 명세한다.​간단한 assignment를 속성문법으로 서술하면 위 그림과 같다. ​속성 문법에는 신택스 규칙과 함께 데이터 타입에 관한 시맨틱 규칙, 그리고 판단식이 서술되어 있다.룩업 함수는 심볼 테이블에서 변수명을 찾아서 변수의 타입을 반환한다.심볼 테이블은 컴파일러가 구문 분석 단계에서 ​변수에 대한 이름, 타입 등을 저장하기 위해 생성한 ​테이블 구조를 말한다. ​실제 타입은 var, expr의 실제 타입을 말한다.실제 타입은 선언되어 있거나 변수명으로부터 유추 가능하다.예를 들어, Perl에서 $, @, %는 ​각각 스칼라(스티링, 숫자), 벡터(배열), 해쉬 구조를 나타낸다.이로부터 변수의 타입을 유추할 수 있다. ​예상 타입은 expr와 관련된 속성으로부터 상속된 타입으로 ​좌변의 변수의 실제 타입에 의해 결정된다.​왼쪽 그림은 속성의 흐름, ​즉 속성이 파스 트리를 따라 상속(pass up, pass down)되는 흐름을 나타내고 있고, ​오른쪽 그림은 속성 문법에 의한 ​attributed parse tree(속성이 부여된 파스 트리)를 보여준다.  ​이와 같이 부여된 속성에 근거하여, 컴파일러는 타입 검사를 할 수 있다.동적 시맨틱스를 서술하는 방법은 여러 가지가 있으나, operational semantics에 대해 살펴 보기로 한다. ​Operational semantics는 연산의 의미에 의해 표현식, 문장, 단위 프로그램의 의미를 서술하는 방식이다. ​시맨틱스 서술의 중요성을 각 사용자별로 따져 보면 다음과 같다.  ​  프로그래머는 원하는 프로그램을 짜기 위해 프로그래밍 언어의 각 문장이 무엇을 하는지 알 필요가 있다. ​  컴파일러 개발자는 프로그래밍 언어에서 각 컨스트럭트의 의미를 정확히 알아야 한다. ​  프로그래밍 언어 설계자는 설계 상의 모호성과 불일치를 발견할 수 있다.Operational semantics는 문장이나 단위 프로그램을 컴퓨터에서 실행한 효과를 명세하여, ​문장이나 프로그램의 의미를 서술한다. ​Operational semantics는 머신 상태의 일련의 변화로 볼 수 있다.여기서 머신의 상태란 프로그램 수행에 따라 변화하는 각 변수 값의 콜렉션(집합)이다.​위의 그림과 같이, operational semantics는 ​문장에 대한 의미를 intermediate code처럼 정해진 방식으로 서술한 것으로 볼 수 있다.Intermediate 언어는 가상 머신에서 실행되는 언어 또는 어셈블리 언어를 말한다.Operational semantics 서술을 위해 intermediate 언어와 가상 머신을 사용하기도 한다. ​​",
        "url": "/pl-09"
    }
    ,
    
    "sc-05": {
        "title": "Number Theory for RSA",
            "author": "lee989898",
            "category": "",
            "content": "Number Theory for RSA–  Introduction  number theory = 정수론  a branch of pure mathematics devoted primarily to the study of the integers  숫자의 성질을 탐구  수학은 과학의 여왕, 정수론은 수학의 여왕(여기서는 양의 정수만 다룬다)  약수  어던 수 m에 대해서 a = mb 라면          b $\\neq$ 0 일때 b는 a를 나눈다 =&gt; 약수      여기서 a,b,m은 정수      나눗셈에서 나머지가 없을 때 약수라고 함        예) 24의 양의 약수          1,2,3,4,6,8,12,24        소수 (Prime numbers)  어떤 수 p의 약수가 $\\pm$ 1과 $\\pm$ p만을 가진다면 p는 소수이다.  1과 자신이외의 자연수로 나눌수 없는 1보다 큰 자연수  고대 이집트 파피루스에도 기록  소수 찾기  어떤 자연수 n이 소수인지는 root(n)까지의 수 중 1을 제외한 약수가 있는지 확인소수의 분포에 규칙성이 있을까? (리만의 가설)  소인수 분해  어떠한 정수 a&gt;1은 다음과 같이 유일하게 소수의 곱으로 표현가능          a = $p_1^{a1}$ $p_2^{a2}$ … $p_t^{at}$      $p_t$ &gt; $p_{t-1}$ &gt; … $p_1$ 는 소수, $a_1$ &gt; 0      예) 91 = 7x13, 3600 = $2^4$ x $3^2$ x $5^2$ , 10164 = 7 x $11^2$ x 12      하지만, 여기서 7 x $11^2$ x 12 -&gt; 10164는 쉽지만 역은 어렵다        서로소 (relatively prime number)  어떤 두 수가 공통적인 소인수를 갖지 못할 때 두 수는 서로소  두 수의 최대 공약수가 1이면 서로소  8과 15는 서로소인가? 서로소이다  모든 정수의 솟수 표현법을 이용하면 최대 공약수 결정이 쉬워짐          300 = $2^2$ x $3^1$ x $5^2$, 18 = $2^1$ x $3^2$      GCD(300,18) = $2^1$ x $3^1$ x $5^0$ = 6        모듈러 연산 (mod)  나머지 연산  a mod b: a를 b로 나눈 나머지  어떤 양의 정수 n과 a가 주어지고, 만약 a를 n으로 나눈다면 다음과 같은 관계를 가지고 몫 q와 나머지 r을 얻는다          a = qn + r      a = r mod n        example: a =11, n = 7          11 = 1 x 7 + 4 = 4 mod 7      11 = 4 mod 7        모듈러 연산자 특성          [(a mod n) + (b mod n)] mod n = (a+b) mod n      [(a mod n) x (b mod n)] mod n = (axb) mod n      (w + x) mod n = (x+w) mod n (교환법칙)      (w * x) mod n = (x * w) mod n (교환법칙)      [ (w+x)+y ] mod n = [ w + (x+y) ] mod n (결합법칙)      [ (w * x) * y ] mod n = [ w * (x * y) ] mod n (결합법칙)      [ w *  (x + y) ] mod n = [( w * x) + (w * y)] mod n (분배법칙)      (0 + w) mod n = w mod n      (1 * w) mod n = w mod n        모듈러 연산의 항등원과 역원          항등원                  어떤 원소와 연산을 해도 자기 자신이 되게 하는 원소          항등원을 만들어 주는 유일한 원소가 역원          모듈러 연산의 역원은?          mod 5 연산, 3의 곱셉의 역원은?                          (3 * ?) mod 5 = 1 ?는 mod 5 연산에 대한 3의 곱셉의  역원                                            합동 (Congruent)  (a mod n) = (b mod n), e두 정수 a와 b는 modulo n에 대해 합동  a $\\equiv$ b mod n으로 표기  예를 들어, 14와 20은 mod 6에 대하여 합동  페르마 정리 (Fermat Theorem)  만약 p가 소수라면 a는 p에 의해 나누어지지 않는 양의 정수이면, 다음이 성립한다          $a^{p-1}$ $\\equiv$ 1 mod p        페르마 정리의 다른 유용한 형태          만약 p가 소수이고 a가 양의 정수라면 $a^p$ $\\equiv$ a mod p가 성립한다        오일러 정리 (Euler Theorem)  오일러의 Totient 함수          정수론에서 오일러의 totient 함수는 φ(n)라고 표기된다      φ(n): n보다 작고 n과 서로 소인 양의 정수의 개수        오일러 함수의 특성          φ(1) = 1      소수n에 대해서 φ(n) = n - 1      소수 p와 q에 대해서 n = pq                  φ(n) = φ(pq) = φ(p) * φ(q) = (p-1)(q-1)                      오일러 정리          서로소인 모든 a와 n에 대한 관계를 나타낸다ㅏ                  $a^{φ(n)}$ $\\equiv$ 1 mod n                      오일러 정리의 추가적인 특성          $a^{φ(n)+1}$ $\\equiv$ a mod n        이러한 속성은 RSA 알고리즘의 유용성을 증명할 수 있음  확장된 유클리드 알고리즘  유클리드 알고리즘          두 양의 정수들에 대한 최대 공약수 찾기        확장된 유클리드 알고리즘          한 수에 대한 곱셈의 역원 결정      만약 GCD(d,f)=1이라면 그때 d는 modulo f 상에서 곱셉에 대한 역원을 갖는다      양의 정수 d &lt; f에 대해, d $d^{-1}$ = 1 mod f인 $d^{-1}$ &lt; f가 유일하게 존재      알고리즘은 $d^{-1}$를 찾아주는 것이다      ",
        "url": "/sc-05"
    }
    ,
    
    "sc-04": {
        "title": "Public Key Cipher",
            "author": "lee989898",
            "category": "",
            "content": "Public Key Cipher  Symmetric vs public key  Encryption key와 decryption key 동일 여부  같으면 symmetric, 다르면 public key  Why no Symmetric key?  Symmetric은 빠르고, 안전하다  동일한 키를 나눠 갖기 어렵다  인터넷에서 키를 나눠 갖기 어렵다  Public key Cipher  송신자, 수신자가 키를 나누어 가지 필요가 없다  private,public키 2가지를 나눠 갖는다  Public key로 잠그면 private key로 열고, private key로 잠그면 public key로 열린다  Internet환경에서 대표적으로 사용  RSA(99%), ECC, El Gammal  주로 수학적 이론에 바탕 -&gt; 정수론 필요",
        "url": "/sc-04"
    }
    ,
    
    "algorithm-03": {
        "title": "분할 정복",
            "author": "lee989898",
            "category": "",
            "content": "분할 정복  분할 정복 설계 전략  분할 단계          문제를 같은 유형의 여러 개의 더 작은 부분 문제들로 나눈다.      부분 문제는 풀기 쉬울 때까지 계속 나눈다.        정복 단계          부분 문제들을 보통 재귀적으로 해결하여 해를 구한다.        합병 단계          문제에 대한 해를 구하기 위해 부분 문제들의 해를 합친다.      최댓값과 최솟값 찾기  문제: 크기가 n인 배열내의 요소들 중 최댓값과 최솟값을 찾는다.  쉬운 전략          최댓값을 찾는다      남은 배열 요소들의 최솟값을 찾는다      총 비교 횟수 = 2n - 3  분할 정복 전략          배열을 반으로 나눈다.      양쪽 절반들의 최댓값과 최솟값을 찾는다.      2에서 찾은 두개의 최댓값들과 두 개의최솟값들을 비교하여 전체 배열의 최댓값과 최솟값을 구한다.            의사코드    findMaxMin(A[],i,j,min,max)// A[i..j]의 최댓값과 최솟값을 찾는다// 입력: 배열 A[i..j]// 출력: min(최솟값), max(최댓값)1. if(i == j) { min = A[i]; max = A[j]}2. else if(i = j - 1){3.     if(A[i] &lt; A[j]){          min = A[i]; max = A[j]}4.     else{ min = A[j]; max = A[i])}   }5. else{6. mid = (i+j)/27. findMaxMin(A,i,mid,min1,max1)8. findMaxMin(A,mid+1,j,min2,max2)9. if(min1 &lt; min2) min = min110.else min = min211.if(max1 &lt; max2) max = max212.else max = max1최초 호출: findMaxMin(A,0,n-1,min,max)      ​위 그림은 실행 트리이다.합병 정렬  쉬운 전략          최솟값을 찾는다.      남은 요소들을 같은 방법을 사용하여 재귀적으로 정렬한다.      총 비교횟수 $\\theta$(n2)  분할 정복 전략          배열을 반으로 나눈다.      왼쪽 반과 오른쪽 반을 각각 정렬한다.      정렬된 왼쪽 반과 오른쪽 반을 합병한다..      ​위 그림은 합병 정렬의 진행 과정이다.      합병 정렬 알고리즘    알고리즘 mergeSort(A[], low, high)// 배열 A[low .. high]를 합병 정렬을 이용하여 정렬한다.if(low &lt; high){      mid = (low+high)/2      mergeSort(A,low,mid)      mergeSort(A,mid+1,high)      merge(A,low,mid,high)}최초 호출: mergeSort(A,0,n-1)            Merge 메소드    //정렬된 부분 배열 A[low .. mid]와 A[mid+1 .. high]를 합병한다.MERGE(A[],low,mid,high){  크기가 (high + 1)인 배열 B를 만든다  h = low; i = low; j = mid + 1  while(i &lt;= mid &amp;&amp; j &lt;=high){      if(A[i] &lt;= A[j] { B[h] = A[i]; i = i + 1}      else{B[h] = A[j]; j = j + 1}      h = h + 1  }  if( i &gt; mid)      for(k = j; k &lt;= high; k++) { B[h] = A[k]; h = h + 1}  else      for(k = i; k &lt;= mid; k++) {B[h] = A[k]; h = h + 1}  for(k = low; k &lt;= high; k++) A[k] = B[k];  }      시간 복잡도 $\\theta$(n $log n$)      비재귀 합병 정렬 알고리즘    mergeSort2(A[], n)//배열 A[0 .. n-1]를 비재귀 합병 정렬을 이용하여 정렬size = 1while(size &lt; n){  for(i = 0; i &lt; n; i = i + 2*size)      Merge(A,i,i+size-1,i+2*size-1)  size = size * 2}      합병 정렬의 단점  합병 정렬의 공간 복잡도: $\\theta$(n)  입력을 위한 메모리 공간 외에 추가로 입력과 같은 크기의 공간이 별도로 필요  2개의 정렬된 부분을 하나로 합병하기 위해 합병된 결과를 저장할 공간이 필요하기 때문이다빠른 정렬절대적으로 가장 빠른 정렬 알고리즘은 아니지만 평균적으로 매우 효율적이다평균 시간복잡도: $\\theta$(n $log n$)최악 시간복잡도: $\\theta$(n2)  기본 아이디어  배열을 두 부분으로 분할한다.          배열내의 한 기준 요소보다 작거나 같은 요소들은 앞부분에 놓는다.      기준 요소보다 큰 요소들은 모두 뒷부분에 놓는다.        각 분할된 부분을 재귀적으로 정렬한다.​위 그림은 빠른 정렬의 진행과정이다.      빠른 정렬 알고리즘    quickSort(A[], low, high)// 배열: A[low .. high]를 빠른 정렬을 이용하여 정렬한다.// 입력: 정렬할 수 있는 요소들의 배열 A[low .. high]// 출력: 오름차순으로 정렬된 요소돌의 배열 A[low .. high]if(low &lt; high){      s = partition(A,low,high) // 기준 요소 A[low]를 기준으로 분할      quickSort(A,low,s-1)      quickSort(A,s+1,high) } //최초 호출: quickSort(A,0,n-1)            분할 알고리즘    partition(A[], low, high)//입력: 배열 A[0 .. n-1]의 부분 배열 A[low .. high], low &lt; high//출력: A[low .. high]의 분할 후 기준 요소의 최종 위치(지수)를 반환i = low + 1j = highwhile( i &lt;= j){      if(A[i] &lt;= A[low]) i = i + 1      else if( A[j] &gt; A[low]) j = j -1      else { A[i] &lt;-&gt; A[j]              i = i + 1              j = j - 1      } } A[low] &lt;-&gt; A[j] return j      분할 정복이 부적절한 경우문제가 분할될 때만다 분할된 부분 문제들의 입력 크기의 합이 분할되기 전의 입력크기보다 매우 커지는 경우",
        "url": "/algorithm-03"
    }
    ,
    
    "pl-08": {
        "title": "프로그래밍 언어의 신택스와 시맨틱스",
            "author": "lee989898",
            "category": "",
            "content": "프로그래밍 언어의 신택스와 시맨틱스프로그래밍 언어의 신택스는 산술식, 문, 프로그램 단위의 형태를 말한다.문은 statement 또는 sentence를 말한다.   ​프로그램 단위는 컨스트럭트(컨트롤 스트럭처)를 말하는데, ​앞으로 명확한 설명을 위해 프로그램 단위라는 추상적인 말을 쓰지 않고, ​가급적 컨스트럭스 또는 컨트롤 스트럭처라는 말을 쓰겠다. ​시맨틱스는 신택스에 맞게 작성된 표현식, 문, 컨스트럭트의 의미를 말합니다. ​자바 while 문에 대해, ​신택스는 while (Boolean_expr) statement 의 형태를 띄어야 하고, ​그 시맨틱스는 부울 표현식이 참일 때, statement를 실행하고, ​컨트롤은 부울 표현식으로 되돌아가서 이 프로세스를 반복하는데, ​부울 표현식이 거짓이면 ​while 컨스트럭트의 실행이 끝난다는 의미이다.​시맨틱스의 서술 방법은 여러 가지가 있지만, ​컴퓨터에서 실행되는 ‘연산의 의미’로 시맨틱스를 서술하는 것을 ​operational semantics라고 하는데, ​위에 서술된 while문의 시맨틱스는 operational semantics의 예이다.​잘 설계된 프로그래밍 언어에서, 시맨틱스는 신택스를 따릅니다. ​이것은 위에 설명된 자바 while 문의 신택스와 시맨틱스의 예를 보면 직관적으로 알 수 있다.그럼 신택스를 어떻게 서술하는지 살펴 보자.신택스 서술 방법으로 BNF가 널리 사용되고 있다.BNF를 메타 언어라고 하는데, 메타 언어란 언어를 서술하는데 사용되는 언어라는 뜻이다.즉, BNF는 프로그래밍 언어의 신택스를 서술하는데 사용되는 메타 언어이다.BNF는 신택스 구조를 위한 추상적 개념을 사용하는 규칙 언어이다.규칙은 화살표 왼편(LHS)과 오른편(RHS)으로 나누어지는데, ​문을 생성하면서, 왼편이 오른편으로 대체된다.BNF가 사용하는 추상적 개념들에는 무엇이 있는지 ​자바의 예를 보면서 알아 보자​자바의 assign과 if 문은 다음과 같이 서술된다.​assign, var, expression, 화살표(-&gt;), =(이퀄 사인)​if_stmt, logic_expr, stmt, if, (괄호), |(세로줄, or의 뜻) 등을 볼 수 있다.화살표를 제외하고, 이들은 각각 BNF를 구성하는 non-terminal/terminal 심볼이다.꺽쇠 괄호로 싸여 있는 것이 non-terminal이다.하나의 왼편에 대해 여러 개의 규칙을 가질 수 있는데, ​이때 여러 개의 규칙에 대해 |를 사용하여 각각의 오른편을 구분합니다. ​List를 보면, 의 오른편에 두개의 규칙이 있음을 알 수 있는데, ​두번째 규칙은 가 identifier와 로 대체하는 것입이다. ​이 규칙의 오른편을 보면, 가 또 들어 있는데,  ​이러한 규칙을 recursive rule(순환 규칙)이라고 한다.문법은 언어를 정의하기 위한 생성 장치이다.문은 문법에 있는 일련의 규칙 적용을 통해 생성되며, ​이러한 일련의 규칙 적용을 유도(derivation)이라고 한다.유도에 의해 생성된 결과를 문형식(sentential form)이라고 한다. ​문형식(sentential form)에서,  ​가장 왼쪽의 난터미날을 먼저 대체하는 것을 좌선유도(leftmost derivation)이라고 하고, ​그 반대를 우선유도(rightmost derivation)이라고 한다.​위 사례는 덧셈과 뺄셈으로 구성된 산술식을 서술하기 위한 문법과 ​그 문법에 의한 산술식의 유도(derivation) 과정을 보여주고 있다.오른쪽에 나열된 일련의 문형식(sentential form)들은 ​program이라는 난터미날 심볼에서 시작하여, ​왼쪽의 문법을 적용하여 좌선유도(Leftmost derivation)된 결과이다.  ​=&gt;의 오른쪽에 있는 begin stmt_list end, ​begin stmt ; stmt_list end, 등은 모두 문형식의 예들이다.마지막에 있는 begin A = B + C ; B = C end 은 문(sentence)이다.그러니까 문과 문형식의 차이는 난터미날 심볼의 유무에 달려 있다. ​​위 사례는 Assignment 문을 위한 문법과 ​그 문법에 의한 assignment 문의 유도를 보여주고 있다. ​왼쪽 아래는 난터미날 심볼 에서 시작하여 leftmostderivation을 보여주고 있고,  ​이것을 트리로 나타내 보면 오른쪽 그림과 같다. ​이 트리를 파스(parse) 트리라고 한다. ​당연한 말이지만 leftmost derivation을 하면, ​파스 트리의 가장 왼쪽 노드부터 터미날 심볼로 바뀌는 것을 볼 수 있다.​이 문법을 가지고 expr에서 시작해서 산술식을 유도할 때, ​+이 포함된 RHS를 먼저 적용하느냐, 이 포함된 RHS를 먼저 적용하느냐에 따라, ​A=B+CA를 위한 파스 트리가 두개 생성된다. ​이와 같이, 문형식에 문법을 적용할 때, ​동일한 문형식에 대해 파스 트리가 여러 개 생성되면, ​이 문법을 모호한 문법이라고 한다. ​문법의 모호성은 중대한 문제를 야기한다.일반적으로 preorder에 따라 산술식을 계산하는데, ​이들 트리는 실행 결과가 서로 다르다. ​왜냐하면, 왼쪽의 트리는 덧셈이 먼저, 오른쪽의 트리는 곱셈이 먼저 계산되기 때문이다.즉, 동일한 문에 대해 어떤 규칙을 먼저 적용하였느냐에 따라 파스 트리가 다르고, ​그 트리의 실행 결과가 항상 같지 않다는 것이다.이러한 이유로 문법의 모호성은 제거되어야 한다.문의 실행 결과가 항상 같지 않을 수 있기 때문에 모호성은 제거되어야 함을 알게 되었다. ​  이러한 모호성을 어떻게 제거할 수 있을까?  ​      연산자에 대한 우선순위를 둔다.즉, 파스 트리의 가장 아래에 있는 연산자부터 먼저 실행한다.따라서, 아래에 있는 연산자가 위의 연산자보다 우선 순위가 높다. ​        우선순위에 따라 연산자 출현 순서를 지정한다.이와 같은 출현 순서의 지정은 별도의 난터미널 심볼을 사용하여 명세할 수 있다.난터미널 심볼은 우선순위가 다른 연산자의 오퍼랜드를 표현하기 위해 사용한다. ​  모호성 제거 방법을 종합하면, 문법을 서술할 때,  ​파스 트리에서 낮은 우선순위의 연산자가 ​높은 우선순위의 연산자보다 위에 나타날 수 있도록, ​낮은 우선순위의 오른쪽 오퍼랜드를 ​새로운 난터미널 심볼로 대체한다.  ​예를 들어 살펴 보자.​+는 *에 비해 트리의 아래에 위치해야 한다.따라서,  -&gt;  + 의 RHS에서 ​오른쪽 오퍼랜드 를 으로 대체한다.  그러면 이제  -&gt;  * 는 ​ -&gt;  * 으로 잠정적으로 바뀐다.  이 규칙의 RHS에서 오른쪽 오퍼랜드는 ​곱셈 다음에 나 (괄호속의 식)을 나타날 수 있다.  (괄호속 식)을 서술할 수 있도록 하기 위해 ​곱셈의 오른쪽 오퍼랜드 을 ​난터미날 심볼 를 사용하여 대체한다.  그러면, 잠정적으로 바뀐  -&gt;  * 은 ​ -&gt;  * 가 된다.원래 는 없었는데, ​곱셈의 오른쪽 오퍼랜드로 (괄호속 식) 또는 를 나타낼 수 있도록 하기 위해 ​라는 난터미날을 새로 도입한 것이다. ​이러한 목적에 의해 가 (괄호속 식) 또는 를 생성하는 규칙을 서술해야 한다.   이 규칙은  -&gt; () | 로 쓸 수 있다.연산자 우선순위와 연산자 출현 순서의 지정에 의해 모호성을 제거하여 ​트리를 생성하면 유일하게 생성된다.그러나 만일 우선순위가 같은 곱셈과 나눗셈이 포함된 산술식을 위한 문법이라면, ​모호성을 어떻게 제거해야 할까? ​이와 긑은 문제는 시맨틱 규칙으로 지정해서 해결해야 한다. ​​A / B * C와 같이 동일한 우선순위를 가진 곱셈과 나눗셈으로 이루어진 식에서, ​이들 연산자간의 계산 순서를 정하기 위해 어떤 시맨틱 규칙을 쓸 수 있을까?  바로 결합 법칙을 이용할 수 있다. ​그런데 결합 법칙에는, ​왼쪽부터 결합하는 방식과 오른쪽부터 결합하는 방식, ​두 가지가 있다.A / B * C 은 어느 방식을 쓰느냐에 따라 계산 결과가 달라진다.  ​    또한 if-else 문법의 모호성 문제도 있다.  ​--- ​---if (logic_expr) if (logic_expr) stmt else stmt에 대해, 위의 문법은 두개의 파스 트리를 생성한다.  따라서 이 문법은 모호성이 있다.  --- ​---  If-else의 모호성 제거는 ‘가장 가까운 then에 else를 매치시킨다’는 규칙으로 해소된다.If문은 then과 else가 모두 있는 것과 ​then만 있고 else는 없는 것으로 구분된다. ​즉 난터미날 는 난터미날 이거나 로 대체된다.는 if… else…를 모두 갖춘 것이고, 는 if… 로 구성되어 있다.는 else 다음에 if… else를 허용하기 위해, 규칙에 else 를 추가한다. ​모호성을 제거한 새로운 문법은 오른쪽 아래와 같다.---&gt; Extended BNF ​---&lt;…&gt;는 난터미날 심볼, x, y, z는 터미날 심볼​( )는 그룹으로 묶기(일상적인 괄호의 의미), ​{ }와 [ ]는 일상적인 의미가 아니고, ​{ }는 0번 이상 반복, ​[ ]는 생략 가능(이 예제에는 없음), ​“ ”는 터미날 심볼을 나타내는 규칙의 표현 기호이며, ​( )는 규칙 표기에 사용되는 기호이기 때문에, ​산술식의 일부로서 표현되는 소괄호는 “(“  “)”로 표기함  --- ​   ---위 그림에서 왼쪽의 BNF를 EBNF로 나타내면 오른쪽과 같다고 되어 있다.  그러나 이 문법은 산술식에서 우선순위를 나타낼 때 사용하는 소괄호와EBNF로 표기법의 소괄호의 의미를 구분하지 못하고 있다.  이를 바로 잡으면, 오른쪽 아래의 문법과 같다.  EBNF에서 ( )를 산술식의 괄호로 쓰려면, “(“, “)”로 써야 한다.---",
        "url": "/pl-08"
    }
    ,
    
    "pl-07": {
        "title": "프로그래밍 언어의 정교화",
            "author": "lee989898",
            "category": "",
            "content": "프로그래밍 언어의 정교화  ALGOL초기 포트란은 IBM 704를 타겟으로 개발되었다.마찬가지로, 많은 언어가 특정 하드웨어에 최적화하도록 개발되었고, ​이들 언어 간의 소통은 불가능했다. ​LISP를 포함한 초기의 다른 여러 프로그래밍 언어도 마찬가지였다.Lisp의 기본 연산자 CAR(content of the address register), CDR(content of decrement register)은 ​IBM 704 하드웨어 아키텍처와 매치되지는 않지만, 연산자 이름에서 ​당시의 프로그래밍 언어가 하드웨어 아키텍처와 밀접한 관련성이 있었다는 흔적임을 알 수 있다. ​이러한 문제를 해결하고자, ALGOL을 개발하였다.ALGOL은 과학 알고리듬의 표현을 위한, 하드웨어구조에 독립적인 명령식 언어이다.    GO TO 27​27 IF (A-B) 5,6,7​알골 이전의 컨트롤 스트럭처는 go to 하나뿐이었다.go to 27은, 위 코드에서 보듯이, 27이라는 레이블이 붙은 문장으로 점프한다.  ​Go to는 레이블 중심의 컨트롤을 하기 때문에, 그 레이블이 어디든 점프하게 된다.이로 인해 프로그램 코드는 스파게티처럼 꼬이게 되어,디버깅이 매우 어려울 뿐만 아니라, 의도하지 않은 영역으로 점프하는 등go to는 해로운 컨트롤 스트럭처로 인식되고 있었다. ​이를 해결하기 위해, ​절(phrase) 수준의 컨트롤 스트럭처로서 if,while, switch, for, until 등이 언어에 포함되었다.뿐만 아니라, 이들 스트럭처를 사용하기 위한 프로그램 설계 방법으로 구조적 프로그래밍(structured programming)이 제안되었다. ​구조적 프로그램 스타일의 핵심은 위에 언급된 컨트롤스트럭처를 적재적소에 적용하여, ​하나의 프로그램을 여러 개의 블록을나누고 이들 블록간의 컨트롤을 구조적으로 유지하자는 것이다.이렇게 하면 프로그램의 디버깅이 쉬울 뿐만 아니라, 프로그램의 개발, 이해, 수정이 쉬워진다.알골 언어는 프로그래밍할 때 기억해야 특별한 제약이 없다.따라서 포트란에 비해 프로그램 작성시 다음과 같은 면에서 자유롭다. ​  코딩할 때 고정된 포맷이 없다. 초기의 포트란은 레이블의 위치 문장의 시작 위치 등이 지정되어 있다  변수명의 길이와 배열의 차원 수에 제한이 없다.초기의 포트란은 변수명의 길이가 6자 이내이며, 차원수도 3개로 제한되어 있었다.  독립성: 기본 개념의 결합에 제한이 없다.허용되지 않는 결합 조건 등 특별한 금지 사항을 기억해야 할 필요가 없다.알골은 1958년 이후에 개발된 모든 언어에 영향을 주었으며, 이들 언어가 사용한 아이디어는 다음과 같다. ​  특정 포맷이 없는 lexical structure(어휘 구조) ​  변수명과 배열 차원의 길이에 제한이 없음 ​  BNF에 의한 구문 구조(신택스)​  타입 개념​  지역 변수의 허용에 의한 블록 구조 ​  Begin-end 및 if-then-else의 중첩 허용에 의한 복합 문장 ​  실행 시 스택 메모리 기반의 동적 배열 할당 ​  Call by value, call by reference, call by name ​  Recursion, 조건식(conditional expression) ​Call by value는 함수 호출 시 파라미터의 ‘값’을 넘겨주고, 이‘값’은 ‘새로운 공간’에 저장되어 호출된 함수에서 사용된다. ​Call by reference는 함수 호출시 파라미터의 ‘주소’를 넘겨주고,되돌려 받을 때도 이 ‘주소’를 이용한다. ​Call by name는 함수 호출시 ‘함수’를 파라미터로 넘겨주면, ‘실제 실행할 때’ 그 ‘함수를 호출’한다. ​Call by value와 call by reference는 값을 저장하는공간을 다루고 있지만,Call by name은 ‘넘어간 함수의 호출 시점’을 다루고 있다.Call by name은 함수 프로그래밍에서 사용하는 방법이다.함수 호출시 파라미터를 call by value로 넘겨준다면, ​그 아웃풋 순서는 hi 다음에 call이지만, ​Call by name으로 한다면, ​그 순서는 call 다음에 hi가 된다. ​그 이유는 call(x)의 x에 함수 hou()의 name이 매치되고, ​call(x) 함수 내에서 x()가 실행되어야 비로소 함수 hou()를 실행하기 때문이다.  BASIC베이직은 개발 시기에 비해 늦게 대중화된 언어이다.MS의 베이직과 같은 언어이다.Basic의 특징은 한대의 컴퓨터에 연결된 다수의 원격 터미날을 통해 다수의 사용자가 시분 할 방식으로 동시에 접속하여 컴퓨터를 사용할 수 있는  개발 환경을 제공하였다.  COBOL코볼은 유니백이 개발한 플로우매틱을 모태로 대음과 같은 특성을 갖는 언어로 개발되었다. ​  변수명은 하이픈(-) 포함해서 30글자까지 ​  산술 연산자를 영어명으로 (산술식 표현이 없음) ​  모든 문장은 동사로 시작함 ​  계층적 데이터 구조(레코드) 제공​  If-then-else의 중첩 ​미국방부가 주도한 설계 고려사항은 다음과 같다. ​  영어처럼 단순하게 ​  사용하기 쉽게​  컴퓨터 사용자의 저변 확대 ​  기존 컴파일러 문제의 회피  PL/I​과학 분야의 계산은 포트란으로, 비즈니스 응용 분야에서는 코볼로 프로그래밍을 하였으나, ​과학분야의 계산과 입출력이 복잡해 지면서 레코드 형태의 출력 구조를 요구하게 되었고, ​비즈니스 분야 응용에서도 부동점 계산이나 배열 등을 요구하게 되었다. ​IBM은 이러한 요구를 수용할 수 있는 하드웨어와 프로그래밍 언어를 동시에 개발하였다.IBM 360은 이들 응용을 모두 커버할 수 있는 하드웨어였고, ​PL/1은 이들 분야의 문제 해결을 위한 프로그래밍 언어였다. ​IBM은 다중 프로그래밍을 지원하는 시스템이었기 때문에, 컴퓨팅 및 저장 공간 단위의 동시성 제어, 인터럽트 처리, 예외 처리, 포인터 등에 대한 관리 메커니즘을 개발하였다. ​그러나 이들은 너무 복잡해서 시스템 오버헤드에 문제를 노출시켰다.여기 부터 언급하는 프로그래밍 언어에서는 데이터 추상화가프로그래밍 언어의 발전 요인이 된다.      SIMULA  이번엔 데이터 추상화를 최초로 지원했던 시뮬라를 살펴보자.시뮬라는 시뮬레이션 프로그램 작성에 편리한 언어로 개발되었다.시뮬라의 가장 중요한 특성으로는 클래스와 코루틴을 들 수 있다. ​클래스는 데이터 추상화의 기본이 되는 구조로서, 로컬 데이터와 이에 대한 함수의 정의를 포함한다. ​시뮬라의 이와 같은 데이터 추상화는 객체 지향 프로그래밍의 객체와 유사하다.  ​코루틴은 서브루틴(서브 프로그램)을 일반화한 것으로, 서브프로그램 실행의 중단과 재시작을 허용한다.​   ​코루틴이 서브루틴의 일반화한 것이라고 했는데, 왜 그런지 서브루틴과 코루틴을 비교해 보자.  ​위 그림에서 볼 수 있듯이, 서브루틴은 호출(call)될 때마다 처음부터 실행하여 결과를 (return)돌려준다.반면, 코루틴은 여러 루틴들이 시작, 중지 및 양보(yield), 재시작을 반복하면서 동시에 실행되는 것을 말한다.  ​이때 재시작은 루틴의 처음부터 시작하는 것이 아니라, 이전에 양보했던 그 지점에서 재시작한다. ​루틴1이 실행되다가, 루틴2에게 양보하고, 루틴2가 실행되다가 루틴1에게 양보하기를 반복한다. ​왼쪽 코드를 보자.이 프로그램은 두개의 코루틴 producer, consumer과, main(즉, call producer)으로 구성되어 있다.프로듀서는 큐가 풀이 아니면, 새로운 아이템을 생산하여 큐에 넣는다. ​만일 큐가 풀이면, 컨슈머에게 양보한다. ​​컨슈머는 큐가 비어있지 않으면, 큐에서 아이템을 뽑아서 처리한다. ​만일 큐가 비어 있으면, 프로듀서에게 양보한다. ​이 프로그램은 프로듀서를 호출함으로써 시작되고, ​콜루틴의 조건에 따라 서로 양보하면서 반복적으로 실행된다. ​논리적으로 보면 이 프로그램은 끝나지 않는 프로그램이다. ​이러한 종류의 프로그램은 일반적인 응용 프로그램보다는 시스템 소프트웨어에서 많이 볼 수 있다.  Smalltalk스몰톡은 최초의 객체지향언어라고 한다.앞의 데이터 추상화에서 시뮬라가 최초의 객체지향언어라고 취급하기도 하지만, ​스몰톡이야말로 객체 지향 언어의 중요한 특성을 구현하였기 때문이다. ​그러면 스몰톡 언어의 특성을 살펴보자.변수, 상수, 레코드 실행, 클래스 등 모든 것이 객체로 취급된다.모든 계산은 객체에 의한 메시지의 전송 및 수신에 의해 수행된다.데이터 추상화, 상속, 동적 타입 바인딩 등   ​스몰톡 언어는 데스크탑 환경을 가정하였는데, 이러한 데스크탑은 프로그래머가 아닌 사용자에 의해 사용될 것이며, 따라서 강력한 휴먼 인터페이스를 필요로 할 거라고 가정하였다. 이러한 이유로 스몰톡은 GUI 설계를 개척하게 되었던 것이다. 이러한 아이디어는 개발되어 Dynabook에 탑재되었다.  C++시뮬라 및 스몰톡의 클래스와 함께, 함수 파라미터 타입 검사 및 컨버전, constructor, 상속된 요소의 접근 통제, 예외 처리 등을 C에 추가하여 C++를 개발하였다. ​절차적(명령형) 프로그래밍과 객체 지향 프로그래밍을 동시에 지원하면서 C++ 언어는 대단히 복잡해졌다. ​C++은 컴파일러의 품질이 좋고 저렴했고 C와 컴패터블했기 때문에 널리 보급되어 지금도 널리 사용되고 있다.  Java자바는 객체지향 언어로, 명령형 프로그래밍 언어이다.자바는 가전제품의 임베디드 소프트웨어 개발에 적합하도록 ​다음과 같은 요구사항에 초점을 맞춰 설계되었다. ​  단순성​  객체지향 프로그래밍 지원​  포인터 대신에 레퍼런스 지원 -&gt; 클래스 정의, 사용자 정의 타입 ​  애플릿 및 동시성(동시처리) 지원 ​C++는 객체지향 프로그래밍을 지원하지만, ​임베디드 소프트웨어에 부적합하다고 평가되었다.그 이유는 절차적 언어를 지원하기 때문에 ​구현 시스템이 너무 크고 복잡하고, 신뢰도가 낮기 때문이다.   ​자바는 순수 객체 지향 언어이다.모든 처리로직은 객체의 메소드로 정의되기 때문에 ​서브 프로그램이 존재하지 않았다.  ​자바는 복잡도를 줄이기 위해 ​단일 상속만을 허용하고 동시성 형태도 단순화하였다. ​자바의 특징은 다음과 같다.  자바는 C++에 비해 실행 속도보다 안정성에 중점을 두고 있다. ​ 안전성은 다양한 면에서 언급될 수 있는데, ​우선 자바 가상 머신을 통한 코드 실행과 배열 범위 검사를 들 수 있다.자바 가상 머신은 하위 플랫폼을 추상화시키는 결과를 가져 오기 때문에 ​하드웨어 플랫폼의 차이점으로 인한 오류 발생을 해소한다.그리고 실행시 배열 범위 검사는 배열 처리 상의  오류를 줄인다.    ​동시성 지원(병렬 처리): thread, runnable task ​  애플릿, GUI, DB access 라이브러리​  컴파일러 및 자바 가상 머신에 의한 이식성​  웹 프로그래밍에 적용성 ​  Pascal(1971)파스칼은 알골의 후속작으로 구조적 프로그래밍을 가르치기 위해 설계되었다.작고 단순하고 전혀 새롭지 않은 언어를 지향하였다.  CC는 시스템 프로그래밍을 위해 개발되었으며, 연산자가 풍부한 반면, 타입 검사가 없는 언어이다.유닉스와 함께 보급되었으며, 다양한 응용 분야에서 사용되었다.  Ada에이다는 이제까지 언급한 프로그래밍 언어의 개념을 하나의 언어로설계 및 구현하려는 시도였다. ​이 프로젝트를 통해 얻은 것은 다음과 같다. ​  패키지는 데이터 추상화를 지원​  예외 처리를 좀더 정교하게 발전​  서브 프로그램이나 패키지를 일반적인 단위 프로그램으로 생성하기때문에, ​  공통 속성을 갖는 알고리듬에 유용함. ​  타스크 간의 소통에 의한 동시성 통제를 통해 병렬 처리를 지원이후 새로운 버전으로 에이다95를 설계하였는데, ​  객체지향​  공유 변수(shared variable) 컨트롤 메커니즘​  사용성을 개선하기 위한 라이브러리 등이 포함되었다. ​​에이다는 들인 노력에 비해, 대중성에서 실패한 사례로 간주된다.비슷한 시기에 나온 C++에 그 자리를 내준 듯 하다. ​",
        "url": "/pl-07"
    }
    ,
    
    "sc-03": {
        "title": "Symmetric Key Cipher",
            "author": "lee989898",
            "category": "",
            "content": "Symmetric Key Cipher  현대암호의 분류​  Symmetric vs public key  Encryption key와 decryption key 동일 여부  같으면 symmetric, 다르면 public key  Block vs Stream cypher  Block          긴 평문을 일정한 길이의 블록으로 나누어 블록단위 암호화하는 방식​      DES, AES 등        Stream          Bit 혹은 byte 단위로 암호화​      키를 키스트림 생성기라는 알고리즘에 입력하여 발생되는 1비트 키의 무한수열로 평문을 암호화​      eStream, RC4 등​        Block vs Stream  암호화할 데이터 type  다음 상황의 데이터 특징은?  영화 파일 다운로드(Block) vs 실시간 방송, 카카오 채팅(Stream)  Block Cipher  긴 평문을 일정한 길이의 블록으로 나누어 블록단위로 암호화하는 방식  SW 구현이 쉽다  Round를 사용하여 반복적으로 암호화하므로 안전  대부분 Feistel cipher structure에 기반  DES, AES, SEED, ARIA, Bluefish, Serpent 등​​  Feistel Cipher Structure란  대부분 Block cipher에 사용  입력 block을 반으로 나눈다      왼,오른쪽 바꿔가며 여러 round수행    Feistel cipher parameters          Block size: 크면 안전해지나 느려짐      Key size: 크면 안전해지나 느려짐      Round 회수: 크면 안전해지나 느려짐      Function으 복잡도: 크면 안전해지나 느려짐        DES (Data Encryprtion Standard)  가장 많이 쓰임  1972 NIST cipher 곰모  1974 IBM Lucifer 선정      1977 미정부 사용결정    Feistel cipher structure  Block size 64bit, key size 56bit      16round    Declared insecure in 1998  변형버전 - 2DES, 3DES(2~3개 key로 3회 암복호화)  AES (Advanced Encryption Standard)  1997 NIST 공모  Rijndael, 2001 NIST 표준선정  Block size 128bit, key size 128,192,256bit  각 키 크기에 따라 10,12,14 rounds  Block Operation Mode  Idea: Block 들을 어떻게 운용하느냐로 안전성 향상  4가지 mode          ECB(Electronic Code Block)      CBC(Cipher Block Chaining)      CFB(Cipher Feedback)      OFB(Output Feedback)        ECB(Electronic Code Block)  각 block이 서로 독립적  +simple  +병렬처리용이  -같은 평문에 대해 동일한 암호문 생성  CBC(Cipher Block Chaining)  Chain: 뒤에 것을 앞에 연결  최초의 평문 blk은 IV와 XOR  결과는 다음 평문 blk와 XOR해서 암호화한다  +같은 평문 blk라도 다른 암호문 blk생성  -Error propagation  Ipsec,Kerberos5 등에서 사용  CFB(Cipher Feedback)  Feddback: 출력을 입력으로  초기 blk을 암호화하여 결과를 평문 blk와 XOR  결과는 다음 encrypt시에 입력으로 사용  평문을 직접 암호화하는것이 아니다  +같은 plaintext blk라도 다른 cipher blk생성  -Error propagation  OFB(Output Feedback)  장단점은 CFB와 동일  CFB에 비해 빠름  스트림 암호  stream: 시내,냇가,흐름  Block을 만들 수 없는 경우  평문을 1 bit(or byte, word)씩 순차적으로 암호화하는 방식  평문과 난수 키 스트림을 1bit씩 단순 XOR  빠름 (XOR 연산)  일반적으로 block cipher에 비해 보안성 낮다  무선통신, 실시간 음성, 영상 스트림 서비스  RC4, ChCha, A5/1, SEAL, SOBER 등",
        "url": "/sc-03"
    }
    ,
    
    "algorithm-02": {
        "title": "알고리즘의 효율성 분석",
            "author": "lee989898",
            "category": "",
            "content": "알고리즘 분석 체계  입력 크기ex) 배열의 크기, 연결 목록의 길이, 행렬에서 행과 열의 크기, 그래프에서 정점과 간선의 수  실행 시간 측정 단위          기본 연산: 알고리즘의 실행 시간에 가장 많이 기여하는 연산      실행 시간은 입력 크기가 작으면 거의 차이가 없다.        증가 차수          시간 복잡도 함수의 입력 크기(N)에 따른 증가율                  로그 함수: N의 값이 4배 증가할 때 2만큼 증가          1차 선형 함수: N의 값에 비례하여 증가          2차 선형 함수: N의 값이 4배 증가할 때 16배 증가          지수 함수: N의 값이 4배 증가할 때 2의 4 제곱배 증가                    시간 복잡도공간 복잡도: 알고리즘이 수행되는 동안 요구되는 메모리 공간의 크기를 나타낸다.시간 복잡도: 알고리즘이 얼마나 빨리 수행되는지를 나타낸다.  알고리즘의 기본 연산의 수행 횟수를 입력 크기의 함수로 표현  입력 크기뿐만이 아니라 특정 입력 값에도 좌우  복잡도는 입력 크기인 N의 함수로 나타낸다  복잡도 함수는 보통 여러 개의 항들을 갖는 다항식이다.  고차 항이 시간복잡도를 궁극적으로 지배한다.시간 복잡도의 분류  최악 경우 시간 복잡도          모든 입력에 대해서 기본 연산이 수행되는 최대 횟수        최선 경우 시간 복잡도          모든 입력에 대해서 기본 연산이 수행되는 최소 횟수        평균 경우 시간 복잡도          모든 입력에 대해서 기본 연산이 수행되는 평균 횟수      일반적으로 최악 경우보다 구하기가 어려움      복잡도를 간단한 함수로 표현하기 위해 점근적 표기 사용  O(Big O)-표기: 점근적 상한​  Ω(Big Ω)-표기: 점근적 하한​  $\\theta$(Big $\\theta$)-표기: 점근적 상한이면서 점근적 하한​​위 그림은 주요 복잡도 함수의 증가율이다.",
        "url": "/algorithm-02"
    }
    ,
    
    "pl-06": {
        "title": "프로그래밍 언어의 진화",
            "author": "lee989898",
            "category": "",
            "content": "프로그래밍 언어의 진화  1940 ~ 1950초기 컴퓨터는 기계 코드로 직접 프로그램을 작성했었고 이로인해 다음과 같은 제한이 있었다.하드웨어의 제한으로, 부동점 소수의 계산, 인덱싱 등이 지원되지 않았으며, ​계산과 직접 관련이 없는 시스템 소프트웨어의 사용도 제한적이었다.그래서 프로그래머 인건비보다 컴퓨터가 훨씬 비쌌다. ​따라서 프로그램의 읽기 및 쓰기의 용이성, 수정 용이성, 표현력 등은 크게 문제되지 않았으며, ​프로그래밍은 주로 계산 흐름을 지시하는데 중점을 두었다.이러한 여건 속에서, ​초기 프로그래머는 기계 코드로 프로그램을 작성하였다. ​  부동점 소수를 계산하기 위해, 프로그래머는 수동으로 지수를 추적해야 했다.  프로그램이 적재되는 메모리의 위치에 따라 상대 주소를 절대 주소로 직접 변환해야 했다.  배열에 대한 인덱스가 없기 때문에, 셀의 주소를 계산하려면,첫째 셀을 기준으로 셀의 길이만큼씩 더해가면서 주소를 계산하였다.  초기 프로그래머를 위해, 어셈블리 언어와 어셈블러가 개발되었다. ​ 어셈블리어는 이진수로 표현된 기계 언어를 일상적인 구절로일대일 매핑시킨 것이다.  끝으로 복잡한 프로그램이 필요해지고 컴퓨터의값이 떨어지면서 프로그래머의 시간 절약이 매우 중요해졌다.  FORTRAN초기 프로그래밍은 주로 과학 계산에 집중되었으며, 이를 위해 가장 많이 사용된 포트란에 대해 알아보자. ​포트란은 최초의 대중적인 고급 프로그래밍 언어이다.당시의 컴퓨터는 가격이 매우 비쌌고, 계산 용량이 작고 신뢰성도 낮았다.따라서 기계의 효율이 가장 중요했다. ​컴퓨터는 주로 과학 분야의 숫자 계산에 치중되었다.따라서 배열 처리 및 counting loop 처리를 위한 수단을 필요로 했다.   ​포트란은 Formula Translating System에서 For와 Tran을 따온 것으로, ​과학 분야의 이같은 계산 요구를 만족시키도록 설계 및 구현되었다.포트란에서는 변수명이 6글자까지로 제한되고, 사용자 정의에 의한 서브프로그램은 허용된다.데이터 타입은 구현시스템에서 제공되는 정적 타입만 허용된다.추후에 다른 언어의 영향으로 다양한 특성을 갖게 된다.포트란은 명령식 언어로, 포트란 프로그램은 본 뉴만 아키텍처를 따른다.  ​  변수는 메모리 셀을 가리키고, ​  Assignment 문장은 메모리와 CPU간의 데이터 이동을 수행하며, ​  연산과 표현식은 CPU에 의한 계산을 실행한다. ​  실행 흐름을 명시적으로 통제하며, ​  언어와 하드웨어 간 효율적 매핑을 통해, 실행 성능의 효율화를 달성할 수 있지만, 본 뉴만 바틀넥에 의해 제한되기도 한다. ​포트란 프로그래밍 스타일은 큰 문제를 작은 문제로 쪼개고, ​작은 문제를 푸는 프로그램을 짜서 이들을 합치는 방식, ​즉 하향식(탑다운 방식)으로 프로그래밍을 한다. ​프로그램은 위에서 시작해서 차근차근 아래로 컨스트럭트를 따라서 실행되며, ​ go-to를 만나면 점프하기도 한다. ​구조적 프로그래밍 방식에서는 프로그램 디버깅을 어렵게 하는 go-to의 사용을 지극히 제한한다.  LISP함수 프로그래밍 언어 LISP는 링크드 리스트로 표현된 심볼릭(기호) 데이터의 처리를 위한 특성을 제공하기 위해 발명되었으며,인공지능 응용(자연어 처리) 프로그램에서 유래되었다. ​심볼릭 데이터의 처리는 배열로 처리 불가하며, 배열의 셀을 지칭하기위한 인덱스가 없으니 loop을 필요로 하지 않는다.대신에 심볼릭 데이터를 구성하는 심볼(글자) 하나하나를 처리하는 연산이 필요하다. ​이에 적합한 자료구조가 링크드 리스트이고, 이들에 대한 연산은 (+a(*b c)) 같은 형태의 함수로 표현된다. ​인풋과 함수는 모두 리스트로 표현되며, 데이터 타입은아톰과 리스트의 두가지 타입이 있다.Lisp는 배열과 이에 대한 인덱스가 없어서, 인덱스를 증감시키며 배열을 처리하는 loop이 필요하지 않다.물론 반복 처리는 필요하다.Lisp는 이를 위해, 순환 함수를 제공한다. ​​   Lisp에서는 X! 팩토리알 계산 프로그램은 위 그림과 같이 순환 함수로 표현한다.defun은 define function(함수 정의)를 의미한다.파란색 점선 상자는 x * fact(x – 1)을 리스트 형태로 나타낸 것입니다. ​함수 fact(x)를 정의할 때 x * fact(x – 1)에서 볼수 있듯이 fact()를 사용하고 있다.이와 같이 무엇인가를 정의할 때 그 무엇을 사용하면, 이것을 recursion 또는 recursive function이라고 한다.  ​​링크드 리스트 처리를 목적으로 최초에 발명된 Lisp는 지금도 사용되고 있는 언어이다. ​​   리스트는 Lisp 구현 시스템의 내부에서 위와 같이 표현된다.(A B C D)는 선형적으로 연결된 링크드 리스트로 표현되는 반면, ​(A (B C) D (E F G))는 트리 구조의 링크드 리스트로 표현된다. ​그 이유는  A, (B C), D와 (E F G)가 같은 수준에 있어야 하고, ​B와 C가 같은 수준에, 그리고 E, F와 G가 같은 수준에 있어야 하기 때문이다. ​두 리스트가 같은지 검사하는 프로그램을 Lisp로 작성하면 다음과 같다.​(DEFUN equal_lists (lis1 lis2)​     (COND​         ((ATOM lis1) (EQ lis1 lis2))​         ((ATOM lis2) NIL)​         ((equal_lists (CAR lis1) (CAR lis2))​                          (equal_lists (CDR lis1) (CDR lis2)))​         (T NIL)​       )​    )​이 코드는 아톰(즉, 리스트의 말단) 수준에서 각 심볼에 대해 EQ(같은지 아닌지) 검사한다. ​현재 EQ 검사해야 할 리스트가 아톰이 아니면, 그 다음 수준으로 아톰을 만날때까지 내려가서 EQ 검사를 한다. ​이렇게 하려면 equal_lists하는 함수를 함수 내에서 반복적으로 호출해야 한다. 즉, recursion이다. ​여기서 CDR, CAR은 Lisp의 기본 연산자로서, ​CAR은 리스트의 맨 앞의 심볼을 반환하고, CDR은 CAR을 제외한 나머지(아톰이거나 리스트)를 반환한다.최초의 함수 언어 Lisp는 다음과 같은 특징을 가지고 있다.파라미터에 함수를 적용하는 방식으로 계산을 수행하며, ​계산에 필요한 중간 변수나 assignment 개념이 없어서,메모리에 이들을 미리 할당하지 않는다.Recursion(순환 함수)와 조건식을 통해 흐름을 컨트롤하며, ​링크드 리스트를 동적으로 필요시마다 메모리에 할당을 한다.​",
        "url": "/pl-06"
    }
    ,
    
    "pl-05": {
        "title": "프로그래밍 언어의 구현 시스템",
            "author": "lee989898",
            "category": "",
            "content": "프로그래밍 언어의 구현 시스템프로그래밍 언어의 각 특징과 컨스트럭트들이 ​어떻게 구현되는지 이해하는 것은 매우 중요하다.PL 컨스트럭트의 구현은 고급 언어를 어셈블리 언어와 같은 하위 언어로 번역한다.프로그램의 문장을 번역하는 것을 컴파일이라고 하고, ​문장을 의미에 적합하게 매핑하는 것을 인터프리테이션이라고 한다. ​이와 같은 구현 시스템에 대해 왜 알아야 할까? ​컨스트럭트가 효율적으로 구현되고 있는지, ​더 좋은 구현 방법이 있는지, ​이들간의 절충점이 있는지 등을 알아내기 위함이다.컴파일 방법은 컴파일러를 써서 고급 언어로 짠 프로그램을 기계 언어로 번역한다.컴파일 프로세스는 어휘 분석, 구문 분석, 의미 분석, 코드 생성, 링크 및 적재 단계로 구성되어 있다.위 그림은 컴파일러의 구성요소와 이들 요소간의 처리 순서에 의한 컴파일 과정을 ​플로우 차트로 보여주고 있다. ​어휘 분석기(lexical analyzer)는 소스 프로그램의 글자들을 어휘 단위로 모아 놓는다.프로그램의 어휘 단위는 변수, 키워드, 연산자 등을 의미한다.구문 분석기(syntax analyzer)는 어휘 단위를 받아서 파스 트리를 생성한다.파스 트리는 프로그램의 구문 구조를 나타낸다. ​중간 코드 생성기는 소스 프로그램과 기계 코드 사이의 중간 수준의 언어로 작성된 프로그램을 생성한다.중간 언어로 어셈블리 어가 쓰이기도 하고, 이보다 조금 더 고급 수준의 언어가 사용되기도 한다. ​의미 분석기(semantic analyzer)는 중간 코드 생성기(intermediate code generator)의 일부분으로 통합되어 있으며, ​구문 분석시에 탐지되지 않는 타입 오류 등을 검사한다. ​최적화 단계는 중간 코드의 프로그램을 좀더 작고 빠르게 만든다.기계 언어보다 중간 코드를 최적화하는 이유는 기계 코드가 바이너리 형태이기 때문에​ 중간코드(알파벳으로 표현된)에 비해 최적화가 더 어렵기 때문이다. ​코드 생성기는 중간 코드를받아서 컴퓨터가 직접 실행할 수 있는 기계 언어로 변환한다. ​심볼 테이블은 소스 프로그램내의 변수의 타입과 속성(길이 등)을 저장하고 있다. 이들 정보는 어휘 분석기와 구문 분석기에 의해 심볼 테이블에 저장되고, 의미 분석기와 중간 코 드 생성기 및 코드 생성기에 의해 사용된다. ​이렇게 컴파일된 사용자 코드는 실행 시 시스템 코드를 호출하여 ​시스템 소프트웨어의 도움을 받는다. ​이를 위해 실행 직전에 사용자 코드와 시스템 코드를 링크(연결)한다.이 과정을 linking 또는 linking and loading이라고 하고, ​이러한 역할을 하는 시스템 소프트웨어를 linker라고 한다.링킹에 의해 생성된 것을 executable image(실행 이미지) 또는 load module(적재 모듈)이라고 한다.인터프리터는 프로그램을 기계 언어로 번역하지 않고, ​문장의 의미에 적합하게 시뮬레이션하여 결과를 낸다. ​따라서 인터프러터는 고급 언어 처리를 위한 시뮬레이터 또는 ​고급언어를 기계어처럼 처리하는 가상 머신의 역할을 한다. ​인터프리터의 장점은, 프로그램의 실행 오류 발생시, ​소스 프로그램의 몇번 라인에서 오류가 발생했는지 오류 메시지가 알려주기 때문에 ​프로그램 개발에 매우 편리한다. ​단점은 컴파일 코드에 비해 10-100배 느리다는 것이며, ​프로그램의 인터프리테이션 동안에 심볼 테이블이 메모리에 적재되어 있어야 하기 때문에 ​메모리 공간을 많이 차지한다는 것이다. ​인터프리터를 이용하는 대표적인 언어로 자바스크립트, PHP, 파이썬 등이 있다.하이브리드 방식은 먼저 컴파일을 해서 중간 코드를 생성한 다음에, ​중간 코드를 인터프리터에 의해 실행한다. ​자바에서는 자바 가상 머신에서 실행되는 바이트 코드를 중간 코드로 생성한다.  ​바이트 코드는 이진 코드지만 CPU가 아닌 자바 가상 머신이 이해할 수 있는 언어이다.​자바 가상 머신은 바이트 코드 명령어를 하나씩 읽어 들여 실행한다. ​이와 같이 중간 코드를 생성하여 자바 가상 머신으로 실행하면, ​하드웨어의 특이 사항에 제한을 받지 않아서 portability가 높은 장점이 있다. ​​   클래스 및 변수를 선언하고 초기화하는 자바 소스 프로그램을 바이트 코드로 번역한 예는 위와 같다.빨간색 박스를 눈여겨 보시기 보자.메모리에 위치를 잡고, 초기화 함수를 호출하거나 조작하고 반환한다.​",
        "url": "/pl-05"
    }
    ,
    
    "pl-04": {
        "title": "언어 평가 기준과 언어 설계시 기준 간의 균형",
            "author": "lee989898",
            "category": "",
            "content": "언어 평가 기준과 언어 설계시 기준 간의 균형좋은 프로그래밍 언어가 갖춰야 할 기준은 무엇인가 살펴 보자. ​      Readability(읽기 쉬움): 프로그램을 읽고 이해하기 쉬운 정도를 프로그래밍 언어의 readability라고 한다. ​        Writability(쓰기쉬움): 프로그램을 작성하기 쉬운 정도를 프로그래밍 언어의 writability라고 한다. ​        Reliability(신뢰성): 프로그램이 다양한 조건 아래서 ‘원래 하기로 되어 있던’ 일을 수행하는 것을 reliability라고 한다. 즉, 인풋이 같으면 아웃풋이 같아야 한다. 만일 인풋이 같은데 조건에 따라 다른 아웃풋을 낸다면 이 프로그램은 신뢰성이 없는 것이다. ​        비용: 프로그램은 학습 비용, 개발 비용(인건비 등 포함), 실행 비용 등 여러 가지 비용을 수반한다. 이 모든 비용이 적으면 좋은 프로그래밍 언어인 것이다.    Readability를 올리려면 다음과 같은 특성을 갖는 것이 바람직하다.      첫째, 단순성이다. 만일 프로그래밍 언어가, 언어의 고유 기능과 기본 컨스트럭트(constructs; control structure를 의미함)를 비교적 적게 갖고 있으며, ​고유 기능에 대한 다중성이 적을 수록,   ​연산의 오버로딩을 최소한으로 허용할 수록 읽기 쉽다. 여기서 다중성이란 동일한 연산을 수행하는 방법이 여러 가지가 있다는 것을 의미하며,충돌이 발생할 가능성에 대비하여 프로그래머에 의한 조치가 필요하다. 이러한 다중성은 객체 지향 언어에서 두드러지는데, ​C++에서는 허용되지만 Java에서는 허용되지 않는다. 오버로딩은 동일한 이름의 연산을 여러 개 정의하는 것을 의미하고, ​컴파일할 때 어느 연산을 실행할지 컴파일러가 결정한다. ​        둘째, 독립성이다.독립성이란 컨스트럭트 결합 규칙이 문맥에 대해 종속되지 않고 독립적인 것을 의미한다.컨스트럭트 간의 결합 규칙에 예외나 불규칙성이 비교적 적고, ​모든 결합(combination)이 구문적으로 적합하고 문맥에 독립적이어야 읽기 쉽습니다.  구조적 프로그래밍에 필요한 loop, if-then-else, begin-end와 같은 컨트롤 구조를 충분히 제공하면, ​프로그램을 위에서 아래로 읽어 내려가면서 이해할 수 있어서 readability에 기여한다. ​데이터 타입과 데이터 구조의 정의 기능 또한 프로그램의 readability에 기여한다. 데이터 타입의 정의를 통해 데이터가 가질 수 있는 값의 범위와 ​이들 데이터에 허용되는 연산을 이해할 수 있다. 데이터 구조의 정의 기능은 다양한 여러 복잡한 데이터 유형을 모아서, ​새로운 단순한 유형의 데이터를 정의할 수 있는 능력을 프로그래머에게 제공한다. 프로그래머는 이와 같이 복잡한 것을 단순화시킬 수 있어서, ​프로그램을 쉽게 작성할 수 있는 동시에, 다른 프로그래머를 쉽게 이해시킬 수 있다.  Writablility프로그래밍 언어의 쓰기쉬움의 주요 평가 기준은 ​단순성과 독립성, 추상화 지원, 표현력을 들 수 있다. 단순성이란 컨스트럭트의 수가 적다는 것을 의미하고, ​독립성이란 컨스트럭트 결합 규칙이 문맥에 대해 독립적이라는 것을 의미한다. 그러나 컨스트럭트 결합 규칙이 문맥에 지나치게 독립적이면, ​실행시 발생하는 오류를 탐지할 수 없게 될 수도 있다. 따라서 독립성은 프로그래밍 언어를 설계할 때 신중하게 고려해야 한다. 복잡한 구조 또는 연산의 추상화도 프로그래밍 언어의 쓰기쉬움을 평가하는 기준이다. 추상화에는 처리 절차의 추상화(서브 프로그램)와 데이터 추상화가 있다. For loop과 같이 편리한 표현 방식과 같은 표현력 또한 쓰기쉬움 평가의 기준입니다.  Reliablitiy:신뢰성은 타입 검사에 의한 오류 처리, ​프로그램 실행시에 발생하는 예외 처리, ​Aliasing(같은 메모리 주소를 다른 이름으로 레퍼런스하는 것), ​읽기쉬움과 쓰기쉬움 등은 모두 프로그래밍 언어의 신뢰성 평가의 기준이 된다.  Cost:학습, 개발, 컴파일 및 실행, 컴파일러 및 인터프리터와 같은 언어 구현 시스템, 신뢰성, 유지 보수 등 ​프로그래밍 언어 사용에 관련된 모든 비용은 언어 평가 기준에 속한다.이밖에 구현 시스템간의 이식성, 다양한 응용에 대한 적용성, 언어의 표준화에 의한 완결성 및 정확성, 전력 소비 효율 등도 ​프로그래밍 언어의 평가 기준이다언어 설계시 이들 모든 평가 기준을 최적화하기는 매우 어렵다. 문제 해결에 필요한 기준을 먼저 설정하고 이들 간의 균형점을 찾는 것이 중요하다. ​레퍼런스 변수는 메모리 상에 있는 인스턴스를 가리키는 데 사용되는 변수이다. 자바에서는 모든 레퍼런스 변수에 대해, ​이들이 가리키는 메모리에 대한 인덱싱이 적절한지 검사한다.이것은 신뢰성을 높여 주지만 매우 높은 실행 비용을 유발한다. ​강력한 연산자가 많으면 프로그램 짜기는 쉽지만, ​읽고 이해하기 어려울 수도 있다. ​C++의 포인터는 매우 강력하고 유연하여 쓰기 쉬움을 높여주지만, ​주의를 기울이지 않으면 신뢰성에 문제를 일으킨다.",
        "url": "/pl-04"
    }
    ,
    
    "sc-02": {
        "title": "Cryptograpghy",
            "author": "lee989898",
            "category": "",
            "content": "Cryptography  Cryptography?  Cryptography: 안전한 암호 만드는 학문  Cryptoanalysis: 암호 해독      Cryptology: 암호학    Steganography: 메시지 존재자체를 숨기는 것  암호(Encrypt/Decrypt)란?  암호(cryptography)  비밀정보의 교환을 위해 생겨남          처음에는 군사용으로 주로 사용      현재 전자상거래, 전자우편, 무선통신 등에 널리 쓰임        4차산업혁명시대: 정보의 관리, 보호의 중요성 증대          국가, 회사, 단체, 개인에 막대한 영향        암호체계의 효용성 및 안전성 분석          고급 수학이론에 기반        용어 및 등장인물  인터넷은 공개망이다  등장인물: Alice,Bob,hacker  평문(plaintext): 암호화전 문장  암호문(ciphertext): 암호화된 문장  암호화(encryption): 평문을 암호문으로 바꾸는 과정  복호화(decryption): 암호문을 평문으로 바꾸는 과정  암호 알고리즘: 암호와 알고리즘과 복호화 알고리즘  키(key): 암호 알고리즘에 사용되는 정보  History of Cryptography  제1세대 암호          고대 그리스 ~ 19세기 말        제2세대 암호          20세기 전반부(전신의 발명 ~ 제2차 세계대전 이전)        제3세대 암호 - 현대암호          제2차 세계대전 종전 이후 ~ 현재        Shift Cipher  Substitution Cipher  대치, 치환  각 글자를 다른 글자로 대치  키 space는 26!  초당 1010 개 키 계산해도 1011 년 소요  Vigenere Cipher      비게네르 암호  암호화 키를 선택: 키 = (5,22,3,14)  평문: (crypto) = (2,17,24,15,19,14)    암호화: (2,17,24,15,19,14) + (5,22,3,14,5,22) ≡ (7,13,1,3,24,10) = (hnbdyk)​  복호화: (7,13,1,3,24,10) - (5,22,3,14,5,22) ≡ (2,17,24,15,19,14) = (crypto)​  Alan Turing  Enigma 해독  최초의 컴퓨터 colossus 제작  인공지능 시조  컴퓨터 이론 확립  튜링테스트, 튜링머신",
        "url": "/sc-02"
    }
    ,
    
    "pl-03": {
        "title": "프로그래밍 언어가 프로그램 설계 방법에 준 영향",
            "author": "lee989898",
            "category": "",
            "content": "프로그래밍 언어가 프로그램 설계 방법에 준 영향역사적으로 프로그래밍 언어는 응용의 표현에 적합한 개념이 추가되면서 발전되어 왔으며,  ​그 개념의 활용에 필요한 프로그램 설계 방법이 개발되었다. 이에 대해 간략히 간단히 살펴 보자.      50년대와 60년대 초반에는 숫자 계산을 주로 수행하는 수치 해석 등 비교적 단순한 응용이 컴퓨팅의 주류를 이루었고, 이들 프로그램은 수식 표현이 용이한 Fortra n으로 작성되었다. 이러한 이유로 프로그램 설계 방법은 기계(컴퓨팅 자원)의 효율적 사용 방법을 찾는데 집중되었다.        60년대 후반에는 프로그램의 데이터 처리 절차가 복잡해지고 타인이 작성한 프로그램을 이해하고 수정하기가 어려워지면서, 기계의 효율적 사용보다 프로그래머의 효율(생산성)에 관심이 집중되었다. 따라서 프로그램의 가독성(readability), 다양한 컨트롤 스트럭처에 의한표현의 편리성이 언어의 중요한 요소로 인식되고, 이를 지원하는 ALGOL 언어가 등장했다. 이러한 언어를 통해 구조적 프로그래밍, 하향식 설계, 단계적 정련 기법 등 프로그래밍 기법 또는 설계 방법이개발되었다. 여기서 컨트롤 스트럭처란 if-then, loop, {중괄호} 등과 같이 인풋의 처리 로직을 표현하는 데 사용되는 구조를 말한다.        1970년대 후반에는 데이터의 구조가 복잡해지면서,처리 절차 중심의 프로그램 설계에서 데이터 중심의 프로그램 설계로 옮겨갔다.이를 위해 데이터 추상화 기법이 창안되었다.데이터 추상화 기법은 데이터를 구조화하고, 이 데이터에 대한 연산을 정의한다. 이와 같은 데이터 추상화 기법은 추상 데이터 타입을 지원하는 프로그래밍 언어를 탄생시켰다.이것이 바로 ALGOL을 발전시킨 Pascal의 등장이다.Pascal은 Java가 등장하기 전까지 모든 컴퓨터 관련 학과에서 필수 언어로 가르쳤다.        1980년 중반에 데이터 추상화, 상속(속성, 메소드), 동적 바인딩을 특징으로 하는 객체 지향 언어가 등장하여지금까지 이어오고 있다.C++, Java 등이 대표적인 언어로, 이들 특징은 이후의 다른 언어에서도 지원할 수 있을 정도로 일반적이다.  이 그림은 널리 사용되어 온 프로그래밍 언어의 족보를 보여주고 있다.  많은 언어가 생멸하는 와중에 지속적인 발전이 있었음을 알 수 있다.  눈여겨 볼만한 중요한 언어로는 FORTRAN, COBO L, COMMON LISP, Pascal, C, C++, Java 등이다.",
        "url": "/pl-03"
    }
    ,
    
    "pl-02": {
        "title": "왜 PL을 공부하는가?",
            "author": "lee989898",
            "category": "",
            "content": "왜 PL을 공부하는가?프로그래밍 언어는 알고리즘 또는 계산을 표현하는데 적합하도록 설계된 인공  언어이다.  프로그램은 알고리즘을 프로그래밍 언어로 코딩한 것으로, 데이터 입력,  입력 데이터 처리, 데이터 출력으로 구성된다.언어의 특징을 이해하면, 효과적인 알고리즘의 개발 능력과 언어 활용 능력을  개선 할 수 있다.  대표적인 특성을 예를 들면, 객체지향성, recursion, call by value,  call by reference 등이 있다.응용의 특성에 더욱 적합한 PL을 선택할 수 있게 되고 새로운 언어 학습 능력을  올려주고 새로운 언어를 더욱 쉽게 설계 할 수 있다.  또한 구현 시스템의 중요성을 이해할 수 있다.  구현 이슈 예로는 아래 두가지가 있다.  Recursion과 Loop 중에서 어느 것이 더욱 효율적인가?  작은 서브프로그램을 자주 호출하는 것은 좋은 방법인가?   (Recursion이나 서브 프로그램 호출 비용에 비해 실행 시간이 너무 짧다면,성능을 떨어뜨리기 때문에, Loop을 사용하거나 서브 프로그램을 일정 규모 이상으로 설계하는 것이 좋다.)응용의 특성에 대한 적절한 PL의 선택의 예  Fortran포트란은 부동점 소수를 4바이트로 표현하고, double precision은 8 바이트로 표한하기 때문에 부동점 소수 계산에 강점이 있다. 또한 데이터 구조로 배열을 지원하며, 2차원 배열로 매트릭스를 표현한다. 이러한 이유들로 숫자 계산을 주로 수행하는 과학 응용에서 사용된다.  COBOL입출력 데이터는 여러 데이터 필드로 구성된 레코드 구조이며, 각 필드는 숫자와 문자값을 갖는다. 십진수, 문자를 주로 처리하여  비즈니스 응용에 주로 사용된다.  Lisp심볼릭 컴퓨팅을 주로 수행하는 인공 지능 응용에서 주로 사용된다. 데이터를 링크드 리스트로 표현하며 문자열의 조작에 특화되어 있다.PL의 범주에는 세가지가 있다.  명령/절차적 언어(imperative, procedural)  함수적 언어  논리적 언어 etc) 객체지향 언어는 명령/절차적 언어에서 파생된 것으로서, 별도의 범주로 다루지 않는다.컴퓨터는 명령어를 받아서 연산을 수행한다. 따라서 프로그래밍은 컴퓨터에게 절차적 명령어를 보내는 것과 같다. 아래 코드를 보자.int fact(int n) {    int sofar = 1;    while(n &gt; 0) sofar *= n--;    return sofar;}fact(n)은 n!을 계산하는 함수이며,  함수안에 정의된 sofar는 현재까지 계산된 n!값을 간직하는 변수이다. ​ while loop을 끝까지 돌려보면 n에서 시작하여 n=1일 때까지 계속 곱셈을 실행한다. ​ 즉, sofar는 1에서 n까지 곱한 결과이다.오늘날 모든 컴퓨터는 본 뉴만 아키텍처로 구성되어 있기 때문에, PL은 이 아키텍처를 모방하고 있다. ​아래 그림이 본 뉴만 아키텍처이다.  본 뉴만 아키텍처 컴퓨터에서는 다음과 같이 프로그램을 실행한다.메모리는 프로그램과 메모리를 저장하고, CPU는 연산을 수행한다.프로그램을 실행하려면, 먼저 프로그램과 데이터를 메모리에 저장해야한다. PC(program counter)를 프로그램의 첫번째 명령어 위치로 초기화하고, ​PC가 가리키는 명령어를 Control unit(Decoder 포함)에 적재한다.Control unit(Decoder)는 명령어의 의미(무슨 연산을 해야할지)를 해석하고,​데이터를 레지스터에 적재하여 ALU에서 연산을 수행한다. 연산이 끝나면 그 결과를 메모리에 저장하거나 출력 장치로 내보낸다. 연산 뿐만 아니라 control structure(loop, if-then, etc)도 PC와 control unit에 의해 통제된다.메모리에서 인스트럭션을 CPU로 가져와서 실행하는 반복적인 절차를 Fetch-execute-cycle이라고 한다.Fetch-execution 사이클이 실행하는 인스트럭션은 어셈블리 코드 또는 머신 코드이다. 머신 코드는 컴퓨터가 이해할 수 있는 명령어이고, 어셈블리 코드는 머신코드를 기호로 표현한 것이다.​  Fetch-execution cycle은 다음과 같다. ​  PC를 초기화한다. ​  PC가 가리키는 명령어를 fetch하고 ​  PC를 증가시킨 다음, ​  Fetch한 명령어를 decod하여 ​  실행한다. ​더 이상 실행할 명령어가 없을 때까지 1~4를 반복적으로 실행한다. ​팩토리얼 함수를 예로 들어보자. 여기서는 메모리와 CPU간의 데이터 이동에 대해 살펴보도록 하자.컴퓨터가 고급언어를 머신코드로 번역하지 않고 이해할 수는 없지만, ​설명을 위해 고급 언어를 컴퓨터가 직접 이해한다고 가정한다.변수 sofar과 n은 메모리에서 공간을 잡고 값을 저장하고 있으며, ​프로그램 코드는 메모리에 저장되어 있다. PC가 int sofar를 읽어 오면 Control unit은 =을 assignment로 해석하여 sofar에 1을 할당한다. PC가 while loop의 sofar *=n–를 읽어 오면 ALU에서 반복적으로 n!을 계산하고,PC가 return sofar를 읽어 오면 sofar 값을 메모리에 저장한다. ​  이와 같이 명령/절차적 언어는 본 뉴만 아키텍처에 적합하게 다음과 같이 실행된다.    ​  프로그램의 변수는 메모리 셀을 지칭하고, 그 셀에 저장된 값을 대표한다. ​  Assignment 문장은 메모리와 CPU 간의 데이터를 이동시킨다. ​  연산과 표현식(expression)은 CPU에서 실행된다. ​  실행 흐름의 명시적 통제는 프로그램 카운터에 의한다. ​현재 널리 사용되고 있는 C, C++, Java는 이런 유형의 PL이다. ​명령/절차적 언어는 실행 성능의 최적화를 위한 언어와 하드웨어 간의 효율적 매핑을 허용하지만,본 뉴만 아키텍처에 의해 제한된다.고급어 프로그램은 컴파일러에 의해 어셈블리어 프로그램으로 번역되고 ​어셈블리어 프로그램은 어셈블러에 의해 기계어 프로그램으로 번역된다. 기계어 프로그램은 인터프리터에 의해 ALU 연산으로 해석되어 실행된다.     ​어셈블리어 프로그램은 RISC 아키텍처의 인스트럭션을 포함하고 있다. RISC 아키텍처는 인스트럭션 집합을 가능한 줄이고 단순화시켜 성능 개선을 이룩한 사례로 남아 있다. ​함수적 프로그래밍은 수학 함수식과 유사하다. ​각 서브 프로그램은 함수의 구현이다.fun fact x =    if x &lt;= 0    then 1    else x * fact(x-1); ​코드는 ML 언어로 팩토리얼을 구하는 프로그램을 보여주고 있다. Fact 내에서 fact를 호출하는 Recursion을 사용하고 있다.또 다른 함수 언어로 리스프를 들 수 있다. ML과 달리 변수와 assignment가 없다. 이 말은 변수로 인해 고정적으로 소비되는 메모리가 없다는 말이다. 즉, 필요시 동적으로 메모리를 할당하고 계산한다. ML과 마찬가지로 리커전을 컨트롤 구조로 갖고 있다. 이후 리스프는 변화를 겪으면서 사용되고 있다.​로직 프로그래밍은 술어 논리(predicate logic)에 기반하고 있다. 로직 프로그램은 사실(fact), 규칙(rule), 목표(goal)로 구성되어 있으며,로직 프로그램의 실행은 목표에 사실과 규칙을 적용하여 목표가 논리적으로 추론될수 있는지, 다시 말하면 참인지 거짓인지 증명하는 절차이다. 이를 위해 추론 엔진이 필요한데, ​로직 프로그램의 추론은 resolutionreputation에 의한 추론 엔진을 사용한다. 이 프로그램에서 grandparent(vern, kake)가 추론될 수 있는 살펴보자.​fact:  mother(joanne,jake).​  father(vern,joanne).​ rule:  grandparent(X,Z) :- parent(X,Y),​           parent(Y,Z).​goal:  grandparent(vern,jake). ​규칙 grandparent(X,Z) :- parent(X,Y), parent(Y,Z)에 X, Z에 각각 vern, jake를 대입하면,  ​ grandparent(vern,Z) :- parent(X,Y), parent(Y,jake)가 추론된다.  사실의 mother, father 모두 parent이므로, parent(joanne, jake), parent(vern, joanne)이다. ​로직 프로그래밍 언어는 프로그램에 입력 데이터에서 출력 데이터를 생성하는 절차를 서술하는 것이 아니라, ​ 사실과 규칙을 술어 논리로 선언하고, 원하는 것(목표)가 무엇인지 선언한다. ​ 따라서 로직 프로그래밍 언어는 비절차적(선언적)이다.로직 프로그래밍은 resolution을 해야 하기 때문에, 매우 비효율적(느리다)이다. 따라서 응용 분야가 대단히 좁다.(DB, AI)factorial 계산하는 프로그램을 보자fact(X,1) :- X =:= 1.fact(X, Fact) :-    X &gt; 1, NewX is X - 1,    fact(NewX, NF),    Fact is X * NF보기엔 깔끔해 보일 수 있지만, resolution해서 풀려면 오래걸린다.",
        "url": "/pl-02"
    }
    ,
    
    "pl-01": {
        "title": "프로그래밍 언어란?",
            "author": "lee989898",
            "category": "",
            "content": "프로그래밍 언어란?프로그래밍 언어는 인공적으로 설계된 언어로 컴퓨터가 실행할 수 있는 계산이나  알고리즘을 표현하는 수단이다.인간은 언어로 타인에게 자신의 생각을 표현하듯이 프로그래밍 언어는  자신의 생각을 컴퓨터에게 표현하는 수단이다.  프로그래밍 언어는 왜 이렇게 다양할까?그 이유는 문제의 특성에 따라, 프로그램이 각기 요구하는 프로그래밍  언어의 표현력이 다르기 때문이다.  표현력은 언어 선택에 있어 매우 중요하다.  문제해결에 적합한 언어를 선택하려면 아래 내용을 숙지해야 한다.  언어가 다르면, 알고리즘의 표현이 어떻게 다른가? ​  어떤 언어가 더 적합한가? 언어의 적합성(goodness)을 어떻게 평가할 것인가? ​  왜 이렇게 다른 언어가 많은가? ​  도대체 프로그래밍 언어가 뭔가? ​  프로그래밍 언어의 특성이 왜 이렇게 많은가? ​  이들 특성은 어떻게 구현시스템에서 실현되는가?​ (여기서 구현 시스템이란   컴파일러나 인터프리터 등 PL을 실행   할 수 있는 소프트웨어를 말한다.) ​  위 그림 PL의 트렌드에 따른 언어를 살펴보면 다음과 같은 특성을 갖고 있다.  타입의 안정성을 고려한 언어의 사용 증가: C,C++에 비해 Java, C# 타입이 안정적임  웹 응용을 위해 클라이언트 측의 기능성을 갖춘 스크립트 언어  신택스 보다 알고리즘의 표현력에 중점을 둔 언어  컴파일, 분석, 타입 검사 등 실행 환경과 가상화를 갖춘 언어  자동 오류 탐지 및 복구 등 프로그램 분석 능력을 갖춘 언어  PL에 영향을 미치는 요인을 표현력과 구현 시스템의 효율 측면에서 살펴보면 다음과 같다.      표현력: 응용 도메인의 특성과 프로그래밍 방법을 들 수 있다.     다중 프로그래밍은 큰 작업(프로그램)이 여러 개의 작은 작업(서브프로그램)으로    나뉘어져서 서로 연관성을 가지고 동시에 실행되는 것을 말한다.    물론 동시라는 말은 특정 시간에는 작은 작업 하나가 실행되지만,     타임 피리어드 동안 여러 개의 작은 프로그램이     동시에 처리되는 것으로 보이게 된다.    이것은 CPU의 시분할과 메모리의 공간 분할에 의해 이루어진다.     이렇게 하여 큰 프로그램 하나가 다른 프로그램의 방해없이    여러 개의 작은 서브프로그램으로 나누어져 처리될 수 있는 것이다.  ​        언어 구현 시스템의 효율성: 즉 컴파일러나 인터프리터의 성능을 말한다.    컴파일러나 인터프리터의 성능은 주로 컴퓨터 구조, OS, 관련 도구, 라이브러리 등에 달려 있다.     편의성은 비용을 수반한다.     추상적 관점을 지원하면 편의성은 좋아지지만, 이것을 머신에     표현하는데는 나름의 비용이 들어간다.    이러한 사실을 고려하여 편의성과 비용간에 균형을 잡는 것이     중요하다.   ​  ",
        "url": "/pl-01"
    }
    ,
    
    "algorithm-01": {
        "title": "알고리즘",
            "author": "lee989898",
            "category": "",
            "content": "알고리즘  알고리즘  문제를 해결하기 위한 단계적 절차 또는 방법  순서대로 구체적이고 명확하게 기술해야 함  유효한 입력을 받아 실행한 결과인 해(답)를 출력​  알고리즘의 3가지 조건  명확성          알고리즘의 각 단계는 애매모호하지 않고 명확해야 한다.        정확성          모든 유효한 입력에 대해 올바른 해를 출력해야 한다.        정지성          유효한 입력이 주어지면 유한한 시간 내에 종료되어야 한다.        알고리즘의 효율성  시간 효율성          얼마나 빨리 실행되는 지를 나타낸다.        공간 효율성          컴퓨터 메모리를 얼마나 사용하는지를 나타낸다.        코드 효율성          코드가 얼마나 이해하기 쉬운가를 나타낸다.      알고리즘적 문제 해결 과정​알고리즘의 표현  알고리즘의 표현  자연어(한글 또는 영어)  의사 코드(Pseudocode)  순서도(Flowchart)  프로그래밍 언어(자바, C 또는 파이선 등)  예: 최댓값 찾기 알고리즘  한글          배열의 첫 번째 요소를 최댓값으로 정한다.      배열의 다음 요소가 최댓값보다 크다면 최댓값을 그 요소로 바꾼다.      배열 내에 비교할 요소가 남아 있으면 2단계로 가고 아니면 종료한다.            의사 코드    FindMaximum(A[0 . . N - 1])​      // 배열 내의 최댓값을 찾는다.​      // 입력: 크기가 N(&gt; 1)인 숫자들의 배열 A​// 출력: 배열 A내의 최댓값​max = A[0]​  for (i = 1; i &lt; N; i++)​       if (A[i] &gt; max) max = A[i]​      ​     return max​            프로그래밍 언어(자바)    public class FindMaximum {​             public static void main(String[] args) {​          int[ ] intArray  =  {72, 60, 83, 47, 89, 95};​          int   maximum;​          maximum =  findMaximum(intArray);​          System.out.println(\"최댓값 = \" + maximum);​         }​        public static int findMaximum(int[ ] A) {​          int i, max;​          max = A[0]; ​      for (i = 1 ; i &lt; A.length ; i++)​                if (A[i] &gt; max) max = A[i];​      return  max;​      }​   }​      알고리즘의 분류  알고리즘 설계 기법  분할 정복(Divide-and-Conquer)​  동적 계획(Dynamic Programming)​  탐욕 기법(Greedy Technique)​  되추적(Backtracking)​  분기한정(Branch-and-Bound)​  억지 기법(brute-force technique)​  무작위(random) 알고리즘​  근사(approximate) 알고리즘​  병렬(parallel) 알고리즘​  분산(distributed) 알고리즘​  양자(quantum) 알고리즘​  유전자(genetic) 알고리즘​  문제 유형에 따른 알고리즘의 분류  정렬(sorting) 알고리즘​  탐색(searching) 알고리즘​  문자열 처리(string processing) 알고리즘​  그래프(graph) 알고리즘​  조합(combinatorial) 알고리즘​  기하학적(geometric) 알고리즘​  수치(numerical) 알고리즘​",
        "url": "/algorithm-01"
    }
    ,
    
    "sc-01": {
        "title": "Intro",
            "author": "lee989898",
            "category": "",
            "content": "Intro  컴퓨터 보안이란?컴퓨터 hw,sw, 데이터의 도난이나 손상, 컴퓨터가 제공하는 서비스의 중단 또는 오용으로부터 컴퓨터 시스템을 보호보안의 대상: information system resource (hardware, software,data,communication facilities and network)보안의 목표: CIA Triad + Authentication  Key Concepts 1: Confidentiality  Secrecy이라고도 함  기밀성,비밀성  송신자와 수신자만이 내용을 알 수 있게 하는 것  허가된 사용자, 장비만이 data 내용을 알 수 있도록 하는 것  주요 공격: eavesdrop(도청), interception  Confidentiality를 지키기 위한 Solution : Encrypt,decrypt  Key Concepts 2: Integrity  무결성  원본 그대로임을 보장. 변조가 없다는 것 혹은 변경이 있었음을 알게 됨  주요 공격: modification  Integrity를 지키기 위한 Solution: hash  Key Concepts 3: Availablilty  가용성  합법적인 사용자가 허가된 시간에 데이터나 서비스에 access 가능하게 하는것  주요공격: interruption, DDos attack  Key Concepts 4: Authentication  인증  송수신자 서로간의 신원확인  주요공격: impersonation  Authentication을 지키기 위한 Solution: 전자서명, 공인인증서",
        "url": "/sc-01"
    }
    ,
    
    "kotlin-23": {
        "title": "코루틴",
            "author": "lee989898",
            "category": "",
            "content": "코루틴코루틴을 사용할 때는 import kotlinx.coroutines.* 모두 import해야 합니다.코루틴은 제어범위 및 실행범위를 지정할 수 있는데 이것을 스코프라고 합니다.  GlobalScope: 프로그램 어디서나 제어,동작이 가능한 기본범위      CoroutineScope: 특정한 목적의 Dispatcher를 지정하여 제어 및 동작이 가능한 범위    Dispatchers.Default: 기본적인 백그라운드 동작  Dispatchers.Io: I/O에 최적화 된 동작  Dispatchers.Main: 메인(UI) 스레드에서 동작모든 플랫폼에서 지원되지는 않는다  launch: 반환값이 없는 Job객체      async: 반환값이 있는 Deffered 객체    delay(milisecond: Long): milisecond단위로 루틴을 잠시 대기시키는 함수  Job.join(): Job의 실행이 끝날때까지 대기하는 함수      Deferred.await(): Defferred의 실행이 끝날때까지 대기하는 함수, Deferred의 결과도 반환함    cancel: 코루틴에 cancel()을 걸어주면 두가지 조건이 발생하며 코루틴을 중단시킬 수 있습니다.          코루틴 내부의 delay()함수 또는 yield()함수가 사용된 위치까지 수행된 뒤 종료됨      cancel()로 인해 속성인 isActive가 false가 되므로 이를 확인하여 수동으로 종료함      import kotlinx.coroutines.*fun main(){        runBlocking{         val a = launch{        for(i in 1..5)        {            println(i)            delay(10)        }    }        val b = async{            &quot;async 종료&quot;        }                println(&quot;async 대기&quot;)        println(b.await())                println(&quot;launch 취소&quot;)        a.cancel()        println(&quot;launch 종료&quot;)            }   }  withTimeoutOrNull: blocking함수이다.import kotlinx.coroutines.*fun main(){     runBlocking{        val result = withTimeoutOrNull(50){            for(i in 1..10){                println(i)                delay(10)            }            &quot;Finish&quot;        }        println(result)    }    }",
        "url": "/kotlin-23"
    }
    ,
    
    "kotlin-22": {
        "title": "변수의 고급 기술",
            "author": "lee989898",
            "category": "",
            "content": "상수, lateinit, lazyval은 할당된 객체를 바꿀 수 없을 뿐이지 객체 내부의 속성을 변경할 수 없는 것은 아닙니다.  상수컴파일 시점에 결정되어 절대 바꿀 수 없는 값입니다.상수로 선언될 수 있는 값은 String자료형을 포함한 기본 자료형만 가능합니다.상수는 클래스의 속성이나 지역변수 등으로는 사용할 수 없습니다.반드시 companion object안에서 사용해야 합니다.ex) const val CONST_A = 1234fun main(){    val foodCourt = FoodCourt()        foodCourt.searchPrice(FoodCourt.FOOD_CREAM_PASTA)    foodCourt.searchPrice(FoodCourt.FOOD_STEAK)    foodCourt.searchPrice(FoodCourt.FOOD_PIZZA)    }class FoodCourt{    fun searchPrice(foodName: String){        val price = when(foodName)        {            FOOD_CREAM_PASTA -&gt; 13000            FOOD_STEAK -&gt; 25000            FOOD_PIZZA -&gt; 15000            else -&gt; 0        }                println(&quot;${foodName}의 가격은 ${price}원 입니다&quot;)    }        companion object{        const val FOOD_CREAM_PASTA = &quot;크림파스타&quot;        const val FOOD_STEAK = &quot;스테이크&quot;        const val FOOD_PIZZA = &quot;피자&quot;    }}  lateinitlateinit var 변수의 제한사항  초기값 할당 전까지 변수를 사용할 수 없음(에러 발생)  기본 자료형에는 사용할 수 없음(String 클래스에는 사용가능)fun main(){    val a = LateInitSample()        println(a.getLateInitText())    a.text = &quot;새로 할당한 값&quot;    println(a.getLateInitText())}class LateInitSample{    lateinit var text: String        fun getLateInitText(): String{        if(::text.isInitialized){            return text        }else{            return &quot;기본값&quot;        }    }}  lazy코드에서는 선언시 즉기 객체를 생성 및 할당하여 변수를 초기화하는 형태를 갖고 있지만 실제 실행시에는 변수를 사용하는 시점에 초기화 과정을 진행합니다.fun main(){    val number: Int by lazy{        println(&quot;초기화를 합니다&quot;)        7    }        println(&quot;코드를 시작합니다&quot;)    println(number)    println(number)    }",
        "url": "/kotlin-22"
    }
    ,
    
    "kotlin-21": {
        "title": "컬렉션 함수",
            "author": "lee989898",
            "category": "",
            "content": "컬렉션 함수컬렉션 함수란 list나 set,map과 같은 컬렉션 또는 배열에 일반 함수 또는 람다 함수 형태를 사용하여 for문 없이도 아이템을 순회하며 참조하거나 조건을 걸고, 구조의 변경까지 가능한 여러가지 함수를 지칭합니다.  컬렉션 함수      forEach: 리스트에 있는 모든 객체를 순서대로 출력합니다.     collection.forEach{     println(it) }            filter: 조건에 맞는 객체만 다시 컬렉션으로 만들어서 반환합니다.    collection.filter{    it &lt; 4}            map: 값을 변경하여 다시 컬렉션으로 만들어서 반환합니다.    collection.map{    it * 2}        any: 하나라도 조건에 맞으면 true ex) collection.any{it == 0}  all: 모두 조건에 맞으면 true ex) collection.all{it == 0}  none: 하나도 조건에 맞지 않으면 true ex) collection.none{it == 0}  collection.first(): 컬렉션의 첫번째 아이템 반환  collection.first{it &gt; 3} 조건에 맞는 첫번째 아이템을 반환  collection.last{it &gt; 3} 조건에 맞는 마지막 아이템을 반환first는 find로 대체 가능하고 last는 findLast로 대체 가능합니다.first와 last함수를 사용할 때 조건에 맞는 객체가 없는 경우 NoSuchElementException이 발생할 수 있습니다.이럴때 firstOrNull이나 lastOrNull을 사용하면 객체가 없는 경우 null을 반환해 줍니다.  collection.count(): 컬렉션의 모든 아이템의 개수 반환  collection.count(it &gt; 7): 조건에 맞는 아이템의 개수 반환fun main(){     val nameList= listOf(&quot;박수영&quot;, &quot;김지수&quot;, &quot;김다현&quot;, &quot;신유나&quot;, &quot;김지우&quot;)        nameList.forEach{print(it + &quot; &quot;)}    println()        println(nameList.filter{it.startsWith(&quot;김&quot;)})        println(nameList.map{&quot;이름 : &quot; + it})        println(nameList.any{it == &quot;김지연&quot;})    println(nameList.all{it.length == 3})    println(nameList.none{it.startsWith(&quot;이&quot;)})        println(nameList.first{it.startsWith(&quot;김&quot;)})    println(nameList.last{it.startsWith(&quot;김&quot;)})    println(nameList.count{it.contains(&quot;지&quot;)})}  collection.associateBy{it.name}: 아이템에서 key를 추출하여 map으로 변환하는 함수  collection.groupBy: key가 같은 아이템 끼리 배열로 묶어 map으로 만드는 함수  collection.partition{it.birthYear &gt; 2002}: 두 컬렉션으로 나누어줍니다.fun main(){        data class Person(val name: String, val birthYear: Int)        val personList = listOf(Person(&quot;유나&quot;, 1992),                           Person(&quot;조이&quot;, 1996),                           Person(&quot;츄&quot;, 1999),                           Person(&quot;유나&quot;, 2003))        println(personList.associateBy{it.birthYear})    println(personList.groupBy{it.name})        val (over98, under98) = personList.partition{it.birthYear &gt; 1998}    println(over98)    println(under98)}  collection.flatMap{listOf(it*3, it+3)}: 아이템마다 만들어진 컬렉션을 합쳐서 반환하는 함수  collection.getOrElse(1){50}: 인덱스 위취에 아이템이 있으면 아이템을 반환하고 아닌 경우 지정한 기본값을 반환하는 함수  collectionAzipcollectionB: 컬렉션 두 개의 아이템을 1:1로 매칭하여 새 컬렉션을 만들어 줌fun main(){        val numbers = listOf(-3,7,2,-10,1)        println(numbers.flatMap{listOf(it*10, it+10)})        println(numbers.getOrElse(1){50})    println(numbers.getOrElse(10){50})        val names = listOf(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;)        println(names zip numbers)}",
        "url": "/kotlin-21"
    }
    ,
    
    "kotlin-20": {
        "title": "Set과 Map",
            "author": "lee989898",
            "category": "",
            "content": "Set과 Map  Set순서가 정렬 되지 않으며 중복이 허용되지 않습니다.fun main(){        val a = mutableSetOf(&quot;귤&quot;,&quot;바나나&quot;, &quot;키위&quot;)        for(item in a)    {        println(&quot;${item}&quot;)    }        a.add(&quot;자몽&quot;)    println(a)        a.remove(&quot;바나나&quot;)    println(a)    println(a.contains(&quot;귤&quot;))       }  Map객체를 넣을 때 그 객체를 찾아낼 수 있는 Key를 쌍으로 넣어주는 컬렉션입니다.같은 Key에 다른 객체를 넣으면 대체됩니다.fun main(){        val a = mutableMapOf(&quot;레드벨벳&quot; to &quot;음파음파&quot;,                        &quot;트와이스&quot; to &quot;FANCY&quot;,                        &quot;ITZY&quot; to &quot;ICY&quot;)        for(entry in a){        println(&quot;${entry.key}:${entry.value}&quot;)    }        a.put(&quot;오마이걸&quot;,&quot;번지&quot;)    println(a)        a.remove(&quot;ITZY&quot;)    println(a)        println(a[&quot;레드벨벳&quot;])       }",
        "url": "/kotlin-20"
    }
    ,
    
    "kotlin-19": {
        "title": "Data Class, Enum Class",
            "author": "lee989898",
            "category": "",
            "content": "Data class, Enum class  Data class데이터를 다루는 데에 최적화된 class로 5가지 기능을 내부적으로 자동으로 생성해줍니다.  내용의 동일성을 판단하는 equals()의 자동구현  객체의 내용에서 고유한 코드를 생성하는 hashcode()의 자동구현  포함된 속성을 보기쉽게 나타내는 toString()의 자동구현  객체를 복사형 똑깥은 내용의 새 객체를 만드는 copy()의 자동구현 (아무 패러미터가 없으면 똑같은 내용으로 생성합니다.)  속성을 순서대로 반환하는 componentX()의 자동구현fun main(){       val a = General(&quot;보영&quot;, 212)        println(a == General(&quot;보영&quot;,212))    println(a.hashCode())    println(a)        val b = Data(&quot;루다&quot;, 306)        println(b == Data(&quot;보영&quot;,306))    println(b.hashCode())    println(b)        println(b.copy())    println(b.copy(&quot;아린&quot;))    println(b.copy(id = 618))        val list = listOf(Data(&quot;보영&quot;,212),                     Data(&quot;루다&quot;, 306),                     Data(&quot;아린&quot;, 618))        for((a,b) in list){        println(&quot;${a}, ${b}&quot;)    }    }class General(val name: String, val id: Int)data class Data(val name: String, val id: Int)  Enum classenum 클래스 안의 객체들은 관행적으로 상수를 나타낼 때 사용하는 대문자로 기술합니다일반 클래스처럼 함수도 추가할 수 있습니다.fun main(){       var state = State.SING    println(state)        state = State.SLEEP    println(state.isSleeping())        state = State.EAT    println(state.message)   }enum class State(val message: String){    SING(&quot;노래를 부릅니다&quot;),    EAT(&quot;밥을 먹습니다&quot;),    SLEEP(&quot;잠을 잡니다&quot;);        fun isSleeping() = this == State.SLEEP}",
        "url": "/kotlin-19"
    }
    ,
    
    "kotlin-18": {
        "title": "중첩클래스와 내부클래스",
            "author": "lee989898",
            "category": "",
            "content": "중첩클래스와 내부클래스  중첩클래스하나의 클래스가 다른 클래스의 기능과 강하게 연관되어 있다는 의미를 전달하기 위해 만들어진 형식입니다.외부 클래스의 내용을 공유할 수 없습니다.  내부클래스혼자서 객체를 만들 수 는 없고 외부 클래스의 객체가 있어야만 생성과 사용이 가능한 클래스입니다.외부 클래스의 속성과 함수의 사용이 가능합니다.fun main(){    Outer.Nested().introduce()        val outer = Outer()    val inner = outer.Inner()        inner.introduceInner()    inner.introduceOuter()        outer.text = &quot;Changed Outer Class&quot;    inner.introduceOuter()    }class Outer{    var text = &quot;Outer Class&quot;        class Nested{        fun introduce(){            println(&quot;Nested Class&quot;)        }    }        inner class Inner{        var text = &quot;Inner Class&quot;                fun introduceInner(){            println(text)        }                fun introduceOuter(){            println(this@Outer.text)        }    }    }",
        "url": "/kotlin-18"
    }
    ,
    
    "kotlin-17": {
        "title": "함수의 argument",
            "author": "lee989898",
            "category": "",
            "content": "함수의 argument를 다루는 방법과 infix 함수  오버로딩fun main() {        read(7)    read(&quot;감사합니다&quot;)    }fun read(x: Int){    println(&quot;숫자 $x 입니다&quot;)}fun read(x: String){    println(x)}  default argumentsfun main(){        deliveryItem(&quot;짬뽕&quot;)    deliveryItem(&quot;책&quot;,3)    deliveryItem(&quot;노트북&quot;,30,&quot;학교&quot;)    }fun deliveryItem(name: String, count: Int = 1, destination: String = &quot;집&quot;){    println(&quot;${name}, ${count}개를 ${destination}에 배달하였습니다&quot;)}  named argumentsfun main(){        deliveryItem(&quot;짬뽕&quot;)    deliveryItem(&quot;책&quot;,3)    deliveryItem(&quot;노트북&quot;,30,&quot;학교&quot;)        deliveryItem(&quot;선물&quot;, destination = &quot;친구집&quot;)    }fun deliveryItem(name: String, count: Int = 1, destination: String = &quot;집&quot;){    println(&quot;${name}, ${count}개를 ${destination}에 배달하였습니다&quot;)}  variable number of arguments(vararg)다른 패러미터랑 같이 쓸때는 맨 마지막에 위치해야 합니다.fun main(){        sum(1,2,3,4)    }fun sum(vararg numbers: Int){    var sum = 0        for(n in numbers)    {        sum += n    }        print(sum)}  infix functionfun main(){        println(6 multiply 4)        println(6.multiply(4))    }infix fun Int.multiply(x: Int): Int = this * x",
        "url": "/kotlin-17"
    }
    ,
    
    "kotlin-16": {
        "title": "문자열을 다루는 법",
            "author": "lee989898",
            "category": "",
            "content": "문자열을 다루는 법  유용한 문자열 함수fun main(){        val test1 = &quot;Test.Kotlin.String&quot;        println(test1.length)        println(test1.toLowerCase())    println(test1.toUpperCase())        val test2 = test1.split(&quot;.&quot;)    println(test2)        println(test2.joinToString())    println(test2.joinToString(&quot;-&quot;))        println(test1.substring(5..10))}fun main(){        val nullString: String? = null    val emptyString = &quot;&quot;    val blankString = &quot; &quot;    val normalString = &quot;A&quot;        println(nullString.isNullOrEmpty())    println(emptyString.isNullOrEmpty())    println(blankString.isNullOrEmpty())    println(normalString.isNullOrEmpty())        println()        println(nullString.isNullOrBlank())    println(emptyString.isNullOrBlank())    println(blankString.isNullOrBlank())    println(normalString.isNullOrBlank())        }fun main(){        var test3 = &quot;kotlin.kt&quot;    var test4 = &quot;java.java&quot;        println(test3.startsWith(&quot;java&quot;))    println(test4.startsWith(&quot;java&quot;))        println(test3.endsWith(&quot;.kt&quot;))    println(test4.endsWith(&quot;.kt&quot;))        println(test3.contains(&quot;lin&quot;))    println(test4.contains(&quot;lin&quot;))    }  null 값 처리하는 방법nullable 변수는 null 상태로 속성이나 함수를 쓰려고 하면 null pointer excption이 발생합니다.null체크를 하기 위해 일일히 if문으로 조건을 체크할 수 있습니다  ?. (null safe operator): 참조연산자를 실행하기 전에 먼저 객체가 null인지를 확인부터 하고 객체가 null이라면 뒤 따라오는 구문을 실행하지 않습니다.  ?: (elvis operator): 객체가 null이 아니라면 그대로 사용하지만 null이라면 연산자가 우측의 객체로 대체됩니다.  !!.(non-null assertion operator): 참조연산자를 사용할때 null 여부를 컴파일시 확인하지 않도록 하여 런타임시 null pointer exeception이 나도록 의도적으로 방치하는 연산자입니다.fun main() {        var a: String? = null        println(a?.toUpperCase())    println(a?:&quot;default&quot;.toUpperCase())    println(a!!.toUpperCase())    }null safe 연산자는 스코프 함수와 사용하면 더욱 편리합니다.fun main() {        var a: String? = &quot;Kotlin Exam&quot;        a?.run{        println(toUpperCase())        println(toUpperCase())    }    }  변수의 동일성 체크동일성에는 두가지 개념이 있습니다.  내용의 동일성: 메모리상의 서로 다른 곳에 할당된 객체라고 해도 그 내용이 같으면 동일 하다고 판단합니다ex) a == b  객체의 동일성: 서로다른 변수가 메모리 상의 같은 객체를 가리키고 있을때만 동일 하다고 판단합니다ex) a === bfun main() {        var a = Product(&quot;콜라&quot;, 1000)    var b = Product(&quot;콜라&quot;, 1000)    var c = a    var d = Product(&quot;사이다&quot;, 1000)        println(a == b)    println(a === b)        println(a == c)    println(a === c)        println(a == d)    println(a === d)     }class Product(val name: String, val price: Int){    override fun equals(other: Any?): Boolean{        if(other is Product)        {            return other.name == name &amp;&amp; other.price == price        }else{            return false        }    }}",
        "url": "/kotlin-16"
    }
    ,
    
    "kotlin-15": {
        "title": "리스트",
            "author": "lee989898",
            "category": "",
            "content": "리스트  List데이터를 모아 관리하는 Collection 클래스를 상속받는 서브 클래스중 가장 단순한 형태입니다.리스트에는 2가지가 있습니다.  List&lt;out T&gt;  MutableList&lt;T&gt;fun main(){        val a = listOf(&quot;사과&quot;, &quot;딸기&quot;, &quot;배&quot;)    println(a[1])        for(fruit in a)    {        print(&quot;${fruit}&quot;)    }        println()        val b = mutableListOf(6,3,1)    println(b)        b.add(4)    println(b)        b.add(2,8)    println(b)        b.removeAt(1)    println(b)        b.shuffle()    println(b)        b.sort()    println(b)      }",
        "url": "/kotlin-15"
    }
    ,
    
    "kotlin-14": {
        "title": "제너릭",
            "author": "lee989898",
            "category": "",
            "content": "제너릭  제너릭함수나 클래스를 선언할때 고정적인 자료형 대신 실제 자료형으로 대체되는 타입 패러미터를 받아 사용하는 방법입니다.(T,U,V)fun main(){        UsingGeneric(A()).doShouting()    UsingGeneric(B()).doShouting()    UsingGeneric(C()).doShouting()        doShouting(B())}fun &lt;T: A&gt; doShouting(t: T){    t.shout()}open class A{    open fun shout(){        println(&quot;A가 소리칩니다.&quot;)    }}class B: A(){    override open fun shout(){        println(&quot;B가 소리칩니다.&quot;)    }}class C: A(){    override open fun shout(){        println(&quot;C가 소리칩니다.&quot;)    }}class UsingGeneric&lt;T: A&gt; (val t: T){    fun doShouting(){        t.shout()    }}",
        "url": "/kotlin-14"
    }
    ,
    
    "kotlin-13": {
        "title": "클래스의 다형성",
            "author": "lee989898",
            "category": "",
            "content": "클래스의 다형성  다형성업캐스팅은 상위 자료형에 담는 것으로 동작합니다.다운캐스팅 하려면 as나 is 키워드가 필요합니다.  as: 변수를 호환되는 자료형으로 변환해주는 캐스팅 연산자 입니다.  is: 변수가 자료형에 호환되는지를 체크하고 변환해줍니다.조건문 안에서 사용되는 특징이 있습니다.fun main(){        var a = Drink()    a.drink()        var b: Drink = Cola()    b.drink()        if(b is Cola)    {        b.washDishes()    }        var c = b as Cola    c.washDishes()    b.washDishes()    }open class Drink{    var name = &quot;음료&quot;        open fun drink(){        println(&quot;${name}를 마십니다&quot;)    }}class Cola: Drink(){    var type = &quot;콜라&quot;        override fun drink(){        println(&quot;${name}중에 ${type}를 마십니다&quot;)    }        fun washDishes(){        println(&quot;${type}로 설거지를 합니다&quot;)    }}",
        "url": "/kotlin-13"
    }
    ,
    
    "kotlin-12": {
        "title": "익명객체와 옵저버 패턴",
            "author": "lee989898",
            "category": "",
            "content": "익명객체와 옵저버 패턴  옵저버이벤트가 일어나는 것을 감시하는 감시자 역할  옵저버 패턴키의 입력, 터치의 발생 등 시스템 또는 루틴에 의해서 발생되는 동작을 이벤트라고 하며 즉각적으로 처리 할 수 있도록 만드는 프로그래밍 패턴을 옵저버 패턴이라고 합니다.이벤트를 수신하는 클래스이벤트의 발생 및 전달하는 클래스가 필요합니다.이 두개의 클래스를 연결해주는 인터페이스도 필요합니다.fun main(){        EventPrinter().start()        }interface EventListener{    fun onEvent(count: Int)}class Counter(var listener: EventListener){        fun count(){        for(i in 1..100){            if(i % 5 == 0)listener.onEvent(i)        }    }}class EventPrinter: EventListener{    override fun onEvent(count: Int){        print(&quot;${count}-&quot;)    }    fun start(){        val counter = Counter(this)        counter.count()    }    }  익명객체fun main(){        EventPrinter().start()        }interface EventListener{    fun onEvent(count: Int)}class Counter(var listener: EventListener){        fun count(){        for(i in 1..100){            if(i % 5 == 0)listener.onEvent(i)        }    }}class EventPrinter{   fun start(){       val counter = Counter(object: EventListener{           override fun onEvent(count: Int){               print(&quot;${count}-&quot;)           }       })       counter.count()   }    }",
        "url": "/kotlin-12"
    }
    ,
    
    "kotlin-11": {
        "title": "오브젝트",
            "author": "lee989898",
            "category": "",
            "content": "오브젝트  Objectobject로 선언된 객체는 최초 사용시 자동으로 생성되며이후에는 코드 전체에서 공용으로 사용될 수 있습니다.fun main(){        println(Counter.count)        Counter.countUp()    Counter.countUp()        println(Counter.count)        Counter.clear()        println(Counter.count)}object Counter{    var count = 0        fun countUp(){        count++    }        fun clear(){        count = 0    }}  Companion objectStatic멤버와 비슷합니다.fun main(){        var a = FoodPoll(&quot;짜장&quot;)    var b = FoodPoll(&quot;짬뽕&quot;)        a.vote()    a.vote()        b.vote()    b.vote()    b.vote()        println(&quot;${a.name}: ${a.count} &quot;)    println(&quot;${b.name}: ${b.count}&quot;)    println(&quot;총계: ${FoodPoll.total}&quot;)}class FoodPoll(val name: String){    companion object {        var total = 0    }        var count = 0        fun vote(){        total++        count++    }}",
        "url": "/kotlin-11"
    }
    ,
    
    "kotlin-10": {
        "title": "고차함수와 람다함수",
            "author": "lee989898",
            "category": "",
            "content": "고차함수와 람다함수  고차함수고차함수란 함수를 마치 클래스에 만들어낸 인스턴스처럼 취급하는 방법입니다.함수를 패러미터로 넘겨줄 수 도 있고, 결과값으로 반환 받을 수 도 있는 방법입니다.코틀린에서는 모든 함수를 고차 함수로 구현 가능합니다.fun main(){    b(::a)}fun a (str: String){    println(&quot;$str 함수 a&quot;)}fun b (function: (String)-&gt;Unit){    function(&quot;b가 호출한&quot;)}  람다함수fun main(){    b(::a)        val c: (String)-&gt;Unit = {str -&gt; println(&quot;$str 람다함수&quot;)}    val d = {str: String -&gt; println(&quot;$str 람다함수&quot;)}    b(c)    b(d)}fun a (str: String){    println(&quot;$str 함수 a&quot;)}fun b (function: (String)-&gt;Unit){    function(&quot;b가 호출한&quot;)}람다함수도 여러 구문이 가능합니다.마지막 구문이 결과값으로 반환됩니다.val c: (String) -&gt; Unit = {str -&gt;         println(\"$str 람다함수\")        println(\"여러 구문을\")        println(\"사용가능합니다\")}파라미터가 없는 람다함수는 실행할 구문들만 나열하면 됩니다.val a:() -&gt; Unit = {println(\"패러미터가 없어요\")}패러미터가 하나뿐이라면 it 사용val c:(String) -&gt; Unit = {println(\"$it 람다함수\")}  스코프 함수스코프 함수는 함수형 언어의 특징을 좀 더 편리하게 사용할 수 있도록 기본 제공하는 함수들 입니다.  apply: 인스턴스를 생성한 후 변수에 담기전에 초기화 과정을 수행할 때 많이 쓰입니다.  run: apply와 비슷하지만 인스턴스 대신 마지막 구문의 결과값을 반환합니다. 인스턴스가 만들어진 후에 인스턴스의 함수나 속성을 scope내에서 사용해야 할때 유용합니다.  with: run과 동일한 기능을 가지지만 인스턴스를 패러미터로 받습니다.  also: apply와 같지만 it을 통해서 인스턴스를 사용할 수 있습니다.  let: run과 같지만 it을 통해서 인스턴스를 사용할 수 있습니다.fun main(){        var price = 5000        var a = Book(&quot;준경의 코틀린&quot;, 10000).apply{        name = &quot;[초특가]&quot; + name        discount()    }        a.run{        println(&quot;상품명: ${name}, 가격: ${price}원&quot;)    }        a.let{        println(&quot;상품명: ${it.name}, 가격: ${it.price}원&quot;)            }    }class Book(var name: String, var price: Int){    fun discount()    {        price -= 2000    }    }",
        "url": "/kotlin-10"
    }
    ,
    
    "kotlin-09": {
        "title": "변수, 함수, 클래스의 접근범위와 접근제한자",
            "author": "lee989898",
            "category": "",
            "content": "변수, 함수, 클래스의 접근범위와 접근제한자  스코프범위라는 뜻 그대로 언어차원에서 변수나 함수, 클래스 같은 멤버들을 서로 공유하여 사용할 수 있는 범위를 지정해 둔 단위입니다.스코프가 지정되는 범위는 패키지 내부 클래스 내부 함수 내부 등이 있습니다.세가지 규칙  스코프 외부에서는 스코프 내부의 멤버를 참조연산자로만 참조가 가능합니다.  동일 스코프 내에서는 멤버들을 공유할 수 있습니다.  하위 스코프에서는 상위 스코프의 멤버를 재정의 할 수 있습니다.val a = &quot;패키지 스코프&quot;class B{    val a = &quot;클래스 스코프&quot;        fun print(){        println(a)    }}fun main(){    val a = &quot;함수 스코프&quot;    println(a)    B().print()}  접근제한자스코프 외부에서 스코프 내부에 접근할 때 그 권할을 개발자가 제한할 수 있는 기능입니다.  public  private  protected  internal상황에 따라 두가지 경우로 나뉩니다.  패키지 스코프  public : 어떤 패키지 에서도 접근가능  internal: 같은 모듈 내에서만 접근 가능  private: 같은 파일 내에서만 접근 가능  클래스 스코프  public : 클래스 외부에서 늘 접근가능  protected: 클래스 자신과 상속받은 클래스에서 접근 가능  private: 클래스 내부에서만 접근 가능",
        "url": "/kotlin-09"
    }
    ,
    
    "kotlin-08": {
        "title": "클래스의 기본구조",
            "author": "lee989898",
            "category": "",
            "content": "클래스  클래스클래스는 ‘값’과 그 값을 사용하는 ‘기능’들을 묶어놓은 것입니다.클래스는 고유의 특징값을 담는 속성과 기능을 구현한 함수로 이루어져 있습니다.또한 클래스는 인스턴스를 만드는 틀입니다.인스턴스란 클래스를 이용해서 만들어내는 서로 다른 속성의 객체를 지칭하는 용어입니다.fun main(){        var a = Person(&quot;박보영&quot;,1990)    var b = Person(&quot;전정국&quot;,1997)    var c = Person(&quot;장원영&quot;,2004)        a.introduce()    b.introduce()    c.introduce()        }class Person(var name: String, val birthYear: Int){    fun introduce(){    println(&quot;안녕하세요, ${birthYear}년생 ${name}입니다.&quot;)    }}  클래스의 생성자생성자란 새로운 인스턴스를 만들기 위해 호출하는 특수한 함수입니다.생성자는 인스턴스의 속성을 초기화 및 인스턴스 생성시 구문을 수행하는 역할을 할 수 있습니다.  기본 생성자: 클래스를 만들 때 기본으로 선언  보조 생성자: 필요에 따라 추가적으로 선언fun main(){        var a = Person(&quot;박보영&quot;,1990)    var b = Person(&quot;전정국&quot;,1997)    var c = Person(&quot;장원영&quot;,2004)        var d = Person(&quot;이루다&quot;)    var e = Person(&quot;차은우&quot;)    var f = Person(&quot;류수정&quot;) }class Person(var name: String, val birthYear: Int = 1997){    init{        println(&quot;${this.birthYear}년생 ${this.name}님이 생성되었습니다.&quot;)    }        constructor(name:String) : this(name, 1997){        println(&quot;보조 생성자가 사용되었습니다.&quot;)    }}  클래스의 상속  수퍼클래스: 속성과 함수를 물려주는 클래스  서브클래스: 속성과 함수를 물려받는 클래스상속시 서브클래스는 수퍼클래스에 존재하는 속성과 같은이름의 속성을 가질 수 없다.서브클래스가 생성될때는 반드시 수퍼클래스의 생성자도 호출해야합니다.fun main(){        var a = Animal(&quot;별이&quot;,5,&quot;개&quot;)    var b = Dog(&quot;별이&quot;,5)        a.introduce()    b.introduce()        b.bark()        var c = Cat(&quot;루이&quot;, 1)        c.introduce()    c.meow()}open class Animal(var name: String, var age: Int, var type: String){    fun introduce(){        println(&quot;저는 ${type} ${name}이고, ${age}살 입니다.&quot;)    }    }class Dog(name: String, age: Int): Animal(name,age,&quot;개&quot;){    fun bark(){        println(&quot;멍멍&quot;)    }}class Cat(name: String, age: Int): Animal(name,age,&quot;고양이&quot;){    fun meow(){        println(&quot;냐옹&quot;)    }}  오버라이딩수퍼클래스에서 허용해주면 서브클래스에서 같은 이름과 형태로 된 함수의 내용을 구현할 수 있습니다.fun main(){       var t = Tiger()        t.eat()    }open class Animal{    open fun eat(){        println(&quot;음식을 먹습니다&quot;)    }}class Tiger: Animal(){    override fun eat(){        println(&quot;고기를 먹습니다&quot;)    }}  추상화선언부만 있고 기능이 구현되지 않은 추상함수와 추상함수를 포함하는 추상클래스fun main(){       var r = Rabbit()        r.eat()    r.sniff()}abstract class Animal(){    abstract fun eat()    fun sniff(){        println(&quot;킁킁&quot;)    }}class Rabbit : Animal(){    override fun eat(){        println(&quot;당근을 먹습니다.&quot;)    }}  인터페이스인터페이스는 추상함수,일반함수,속성을 가집니다.인터페이스는 생성자를 가질 수 없습니다.인터페이스에서 구현부가 있는 함수는 open함수로 간주하고 구현부가 없는 함수는 abstract 함수로 간주합니다.별도의 키워드가 없어도 포함된 모든 함수를 서브클래스에서 구현 및 재정의가 가능합니다.또한 여러 인터페이스를 상속 받을 수 있습니다.fun main(){    var d = Dog()        d.run()    d.eat()    }interface Runner{    fun run()}interface Eater{    fun eat(){        println(&quot;음식을 먹습니다&quot;)    }}class Dog: Runner, Eater{    override fun run(){        println(&quot;우다다다 뜁니다&quot;)    }        override fun eat(){        println(&quot;허겁지겁 먹습니다&quot;)    }}",
        "url": "/kotlin-08"
    }
    ,
    
    "kotlin-07": {
        "title": "흐름제어와 논리연산자",
            "author": "lee989898",
            "category": "",
            "content": "흐름제어와 논리연산자  흐름을 제어하는 키워드  break: 반복문 내의 구문이 실행되는 중간에 즉시 반복문을 종료하고 다음 구문으로 넘어가는 역할을 한다.  continue: 다음 반복조건으로 즉시 넘어가는 역할을 합니다.fun main(){       for(i in 1..10){       if(i == 3) break       print(i)   }      for(j in 1..10){       if(j == 3) continue       print(j)   }    }코틀린은 다중 반복문에서 break나 continue가 적용되는 반복문을 label을 통해 지정할 수 있는 기능이 있습니다.fun main(){       loop@for(i in 1..10){       for(j in 1..10){           if(i == 1 &amp;&amp; j == 2) break@loop           println(&quot;i : $i, j : $j&quot;)       }   }    }  논리연산자논리 값을 연산하여 새로운 논리값을 도출할 떄 쓰는 연산자입니다  &amp;&amp; : 둘다 true인 경우 결과값이 true입니다.  || : 하나라도 true이면 결과값이 true입니다.  ! : 뒤에 붙는 값을 반전시킵니다.fun main(){        println(true &amp;&amp; false)    println(true || false)    println(!false)    println(!true)        var a = 6    var b = 4        println(a &gt; 5 &amp;&amp; b &gt; 5)     }",
        "url": "/kotlin-07"
    }
    ,
    
    "kotlin-06": {
        "title": "반복문과 증감연산자",
            "author": "lee989898",
            "category": "",
            "content": "반복문과 증감연산자  증가연산자변수의 값을 ‘1’ 증가시켜주는 역할을 합니다. ex)++a, a++  감소연산자변수의 값을 ‘1’ 감소시켜주는 역할을 합니다. ex)–a, a–반복문은 크게 두가지로 조건형 반복문과 범위형 반복문 형태가 있습니다.  조건형 반복문조건형 반복문에는 while, do..while이 있다.fun main(){        var a = 0    var b = 0        while(a &lt; 5){        println(a++)    }        do{        println(++b)    }while(b &lt; 5)    }  범위형 반복문범위형 반복문에는 for가 있다.fun main(){       for(i in 0..9 step 3){       print(i)   }      for(j in 9 downTo 0){       print(j)   }    }",
        "url": "/kotlin-06"
    }
    ,
    
    "kotlin-05": {
        "title": "조건문과 비교연산자",
            "author": "lee989898",
            "category": "",
            "content": "조건문과 비교연산자  if만약 ~ 한다면 if문에 주어진 값이 ‘참’이라면 따라오는 구문을 실행하는 기능입니다.fun main(){    var a = 11        if(a &gt; 10){        println(&quot;a는 10보다 크다&quot;)    }else{        println(&quot;a는 10보다 작거나 같다&quot;)    }}  비교연산자  부등호  등호  is연산자, !is연산자 (자료형이 호환되는지 체크하고 형변환까지 해줍니다)ex) a is Int  whenwhen은 하나의 변수를 여러개의 값과 비교할 수 있는 장점이있습니다.여러개의 조건이 부합되도 먼저 부합하는 조건이 실행됩니다.fun main(){        doWhen(1)    doWhen(&quot;LEE&quot;)    doWhen(12L)    doWhen(3.14159)    doWhen(&quot;Kotlin&quot;)}fun doWhen(a: Any){    when(a){        1 -&gt; println(&quot;정수 1입니다&quot;)        &quot;LEE&quot; -&gt; println(&quot;LEE의 코틀린입니다.&quot;)        is Long -&gt; println(&quot;Long 타입 입니다&quot;)        !is String -&gt; println(&quot;String 타입이 아닙니다&quot;)        else -&gt; println(&quot;어떤 조건도 만족하지 않습니다&quot;)    }    }when의 조건이 맞을때 동작 대신 값을 반환하려면 아래 같이 써주면 됩니다.fun main(){        doWhen(1)    doWhen(&quot;LEE&quot;)    doWhen(12L)    doWhen(3.14159)    doWhen(&quot;Kotlin&quot;)}fun doWhen(a: Any){    var result = when(a){        1 -&gt; &quot;정수 1입니다&quot;        &quot;LEE&quot; -&gt; &quot;LEE의 코틀린입니다.&quot;        is Long -&gt; &quot;Long 타입 입니다&quot;        !is String -&gt; &quot;String 타입이 아닙니다&quot;        else -&gt; &quot;어떤 조건도 만족하지 않습니다&quot;    }    println(result)}",
        "url": "/kotlin-05"
    }
    ,
    
    "kotlin-04": {
        "title": "타입추론과 함수",
            "author": "lee989898",
            "category": "",
            "content": "타입추론과 함수타입추론타입추론은 변수나 함수들을 선언할 때나 연산이 이루어 질 떄자료형을 코드에 명시하지 않아도 코틀린이 자동으로 자료형을 추론해주는기능입니다변수가 선언될 때 할당된 값의 형태로 해당 변수가 어떤 자료형을 가지는지 추론이 가능하기 때문입니다fun main() {       var a = 1234   var b = 1234L      var c = 12.45   var d = 12.45f       var e = 0xABCD   var f = 0b01010101       var g = true   var h = &#39;c&#39;}함수함수는 특정한 동작을 하거나 원하는 결과값을 연산하는데 사용합니다.함수안에서 return은 뒤에 오는 값을 반환하는 키워드로 return이 발생하면함수의 중간이더라도 값을 반환하고 함수를 종료합니다코틀린은 함수를 좀 더 간단하게 기술할 수 있도록 단일 표현식 함수를 지원합니다fun main() {        println(add(5,6,7))   }fun add(a: Int, b: Int, c: Int): Int{    return a+b+c    }fun add(a: Int, b: Int, c: Int) = a + b + c //위 함수와 동일합니다코틀린에서 함수는 내부적으로 기능을 가진 형태이지만 외부에서볼 때는 파라미터를 넣는다는 점 외에는 자료형이 결정된 변수라는 개념으로접근합니다",
        "url": "/kotlin-04"
    }
    ,
    
    "kotlin-03": {
        "title": "형변환과 배열",
            "author": "lee989898",
            "category": "",
            "content": "형변환과 배열형변환형변환은 하나의 변수에 지정된 자료형을 호환되는 다른 자료형으로 변경하는 기능입니다코틀린은 형변환시 발생할 수 있는 오류를 막기 위해 자동으로 형변환 해주는 암시적 형변환은 지원하지 않습니다명시적 형변환은 변환될 자료형을 개발자가 직접 지정하는 것입니다  형변환 함수          toByte()      toShort()      toInt()      toLong()      toFloat()      toDouble()      toChar()      fun main() {    var a: Int = 54321    var b: Long = a.toLong()}배열배열은 내부적으로 Array 클래스로 제공되는 기능입니다fun main() {        var intArr = arrayOf(1,2,3,4,5)        val nullArr = arrayOfNulls&lt;Int&gt;(5) //비어있는 배열 만들기        intArr[2] = 8        println(intArr[4])}",
        "url": "/kotlin-03"
    }
    ,
    
    "python-13": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-13"
    }
    ,
    
    "python-12": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-12"
    }
    ,
    
    "python-11": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-11"
    }
    ,
    
    "python-10": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-10"
    }
    ,
    
    "python-09": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-09"
    }
    ,
    
    "python-08": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-08"
    }
    ,
    
    "python-07": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-07"
    }
    ,
    
    "python-06": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-06"
    }
    ,
    
    "python-05": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-05"
    }
    ,
    
    "python-04": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-04"
    }
    ,
    
    "python-03": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-03"
    }
    ,
    
    "kotlin-02": {
        "title": "변수와 자료형",
            "author": "lee989898",
            "category": "",
            "content": "변수와 자료형변수var: 일반적으로 통용되는 변수 언제든지 읽기 쓰기가 가능합니다val: 선언시에만 초기화 가능 중간에 값을 변경할 수 없습니다runtime시 변경되지 말아야 할 값은 안전하게 val로 선언하는 것이 좋습니다fun main() {    var a: Int = 123    val b: Int = 456    println(a)    println(b)}초기화 하지 않고 null을 허용하는 nullable 변수로 선언할 수 있습니다ex) var a: Int? = null자료형기본 자료형에는 숫자형,실수형,논리형인 8가지가 있습니다.  숫자형: Byte Short Int Long  실수형: Float Double  논리형: Boolean정수형의 리터럴은 10진수, 16진수, 2진수로 표기 가능합니다8진수의 표기는 지원하지 않습니다fun main() {    var intValue:Int = 1234    var LongValue:Long = 1234L    var intValueByHex:Int = 0x1af    var intValueByBin:Int = 0b10110110        var doubleValue:Double = 123.5    var doubleValueWithExp: Double = 123.5e10    var floatValue:Float = 123.5f        var charValue: Char = &#39;a&#39;    var koreanCharValue: Char = &#39;가&#39;        var booleanValue: Boolean = true        var stringValue = &quot;one line string test&quot;        val multiLineStringValue = &quot;&quot;&quot;multiline    string    test&quot;&quot;&quot;}",
        "url": "/kotlin-02"
    }
    ,
    
    "android-01": {
        "title": "android 시작",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/android-01"
    }
    ,
    
    "python-02": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-02"
    }
    ,
    
    "python-01": {
        "title": "PYTHON",
            "author": "lee989898",
            "category": "",
            "content": "",
        "url": "/python-01"
    }
    ,
    
    "kotlin-01": {
        "title": "코틀린 규칙들",
            "author": "lee989898",
            "category": "",
            "content": "Kotlin 공부는 여러 절로 구성되어 있습니다.     코틀린 규칙들    변수와 자료형     형변환과 배열     타입추론과 함수     조건문과 비교연산자     반복문과 증감연산자     흐름제어와 논리연산자     클래스의 기본구조 코틀린 규칙들      한줄 짜리 주석 // 여러 줄 주석 /* */    fun main() {//안녕하세요  /*안 *녕 *하 *세 *요*/}        구문이 끝날때 세미콜론(;)을 붙이지 않아도 됩니다.  클래스 이름은 파스칼 표기법 ex) ClassName  함수나 변수 이름은 카멜 표기법 ex) functionName  warning: 불필요한 구문이 있거나 잠재적 문제가 있을 수 있습니다.  글자 하나하나가 2bytes의 메모리 공간을 사용합니다.  클래스에 선언된 변수 Property(속성) 이 외의 Scope 내에 선언된 변수 Local Variable(로컬변수)  Any어떤 자료형이든 상관없이 호환되는 코틀린의 최상위 자료형입니다.  initinit 함수는 패러미터나 반환형이 없는 특수한 함수입니다.  open클래스가 상속될 수 있도록 클래스 선언시 붙여주는 키워드입니다.  기본 프로젝트 구조  물리적인구조  프로젝트: 코틀린으로 어플을 짤때 관련한 모든 내용을 담는 큰틀입니다.  모듈: 편리한 기능 단위, 모듈안에는 다양한 폴더와 파일이 들어갈 수 있습니다.  논리적인 구조      패키지: 소스 코드의 소속을 지정하기 위한 단위입니다. ex) package com.youtube.lee패키지를 설정하지 않으면 자동으로 default패키지로 묶입니다.        import: 사용할 외부 패키지 이름을 쓰면 다른 패키지의 함수,변수,클래스 등을 사용할 수 있습니다.  ",
        "url": "/kotlin-01"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://lee989898.github.io/">LEE</a> &copy; 2021</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
        <div class="subscribe-overlay-content">
            
            <h1 class="subscribe-overlay-title">Search LEE</h1>
            <p class="subscribe-overlay-description">
                lunr.js를 이용한 posts 검색 </p>
            <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()"
               id="searchtext" type="text" name="searchtext"
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
        </div>
    </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
