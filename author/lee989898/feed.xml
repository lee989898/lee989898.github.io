<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://lee989898.github.io/author/lee989898/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://lee989898.github.io/" rel="alternate" type="text/html" />
  <updated>2021-11-05T23:39:59+09:00</updated>
  <id>https://lee989898.github.io/author/lee989898/feed.xml</id>

  
  
  

  
    <title type="html">LEE | </title>
  

  
    <subtitle>공부 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">접근 제어</title>
      <link href="https://lee989898.github.io/sc-12" rel="alternate" type="text/html" title="접근 제어" />
      <published>2021-11-04T01:06:00+09:00</published>
      <updated>2021-11-04T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-12</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-12">&lt;h3 id=&quot;접근-제어&quot;&gt;&lt;strong&gt;접근 제어&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Access Control&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;허가되지 않은 사용자의 자원 접근 막고&lt;/li&gt;
  &lt;li&gt;정당한 사용자라도 허가되지 않은 방법으로 자원사용 막고&lt;/li&gt;
  &lt;li&gt;정당한 사용자가 허가된 방식으로만 자원에 접근하도록&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Access control components&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc17.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Authentication function: 사용자가 시스템에 접근할 수 있는지 결정&lt;/li&gt;
  &lt;li&gt;Access control function: 사용자의 요청이 허용되는지 결정&lt;/li&gt;
  &lt;li&gt;Security admin: 사용자의 요청이 자원에 어떻게 접근하는지를 명시한 권한 DB를 관리&lt;/li&gt;
  &lt;li&gt;Audit: 사용자가 시스템 자원에 접근하는 것을 기록, 감시&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Access control architecture&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc18.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Access Control Policy&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;접근 제어 정책&lt;/li&gt;
  &lt;li&gt;어떤 상황에서, 누구에게 어떤 종류의 접근이 허용되는지를 결정&lt;/li&gt;
  &lt;li&gt;권한 DB에 저장되며 보안 admin이 관리&lt;/li&gt;
  &lt;li&gt;종류 (동시에 사용가능)
    &lt;ul&gt;
      &lt;li&gt;Discretinoary access control(DAC)&lt;/li&gt;
      &lt;li&gt;Mandatory access control(MAC)&lt;/li&gt;
      &lt;li&gt;Role-based access control(RBAC)&lt;/li&gt;
      &lt;li&gt;Attribute-based access control(ABAC)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Discretinoary access control(DAC)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;임의 접근 제어&lt;/li&gt;
  &lt;li&gt;요청자의 신분에 따라 무엇을 할 수 있는지 정의&lt;/li&gt;
  &lt;li&gt;Window, unix 등 컴퓨터 시스템 널리 사용&lt;/li&gt;
  &lt;li&gt;Access Matrix 사용
    &lt;ul&gt;
      &lt;li&gt;주체와 객체, 권한을 행렬로 표현&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Access matrix
    &lt;ul&gt;
      &lt;li&gt;행: 자원접근 주체, subject&lt;/li&gt;
      &lt;li&gt;열: subject가 접근하는 대상자원, object&lt;/li&gt;
      &lt;li&gt;Entry: 허용되는 접근&lt;/li&gt;
      &lt;li&gt;-Matrix가 커질 수 있고, 희박해지면 메모리 낭비&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc19.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;방법1. ACL - Access control lists
    &lt;ul&gt;
      &lt;li&gt;Access matrix를 열로 분리&lt;/li&gt;
      &lt;li&gt;객체에 대한 권한을 가진 주체 파악에 유리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc20.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;방법2. Capablility tickets
    &lt;ul&gt;
      &lt;li&gt;Access matrix 행으로 분리&lt;/li&gt;
      &lt;li&gt;특정 주체에 대해 승인된 객체와 권한 명시&lt;/li&gt;
      &lt;li&gt;특정 사용자에 허가된 객체/권한들을 정리하기 쉬움&lt;/li&gt;
      &lt;li&gt;다른 주체에서 티켓을 빌려 주거나 양도 -&amp;gt; 보안문제 발생&lt;/li&gt;
      &lt;li&gt;티켓 무결성, 기밀성, 인증성&lt;/li&gt;
      &lt;li&gt;OS가 관리&lt;/li&gt;
      &lt;li&gt;분산, Cloud 환경에 적합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc21.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;방법 3. authorization table
    &lt;ul&gt;
      &lt;li&gt;한 행에 한 주제의 한 자원에 대한 권한명시&lt;/li&gt;
      &lt;li&gt;RDB로 구현 용이&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc22.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;DAC 장단점 분석
    &lt;ul&gt;
      &lt;li&gt;장점
        &lt;ul&gt;
          &lt;li&gt;객체별 세분화된 접근 제어가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;단점
        &lt;ul&gt;
          &lt;li&gt;Access Matrix 사용에 따른 메모리 낭비&lt;/li&gt;
          &lt;li&gt;주체나 객체별로 제어하기 때문에, 전체 자원의 일관성 있는 제어 어려움&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Role-based access control (RBAC)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;각 사용자 대신에 역할에 접근 권할을 할당&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;상업적으로 회사,기관,조직에서 많이 쓰임&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자 vs 역할 vs 자원의 관계는 다대다&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;관계는 동적이다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;RBAC 장단점 분석
    &lt;ul&gt;
      &lt;li&gt;장점
        &lt;ul&gt;
          &lt;li&gt;전체적으로 일관성있는 제어정책가능&lt;/li&gt;
          &lt;li&gt;직무분석 용이&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;단점
        &lt;ul&gt;
          &lt;li&gt;각 주체, 객체별 유연하게 하기 어려움&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Attribute-based access control(ABAC)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;가장 최근&lt;/li&gt;
  &lt;li&gt;주체와 자원의 속성을 표현&lt;/li&gt;
  &lt;li&gt;DAC, RBAC의 기본개념 실형가능&lt;/li&gt;
  &lt;li&gt;유연성과 표현력이 우수&lt;/li&gt;
  &lt;li&gt;3요소 - 속성, 정책 모델, 아키텍처 모델&lt;/li&gt;
  &lt;li&gt;+유연하고 세분화 보안정책 설계&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-설계자 과다업무, 비용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;속성
    &lt;ul&gt;
      &lt;li&gt;주체, 객체, 환경, 권한에 의해 미리 정의되고 할당된 요구되는 동작의 특정 측면을 정의하는 성질​&lt;/li&gt;
      &lt;li&gt;주체 속성​
        &lt;ul&gt;
          &lt;li&gt;주체는 정보가 객체사이에 이동하거나 시스템 상태를 변경하는 능동적 존재(User, application, process, device)​&lt;/li&gt;
          &lt;li&gt;주체의 이름, 소속, 직책 등​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;객체 속성​
        &lt;ul&gt;
          &lt;li&gt;정보를 포함하거나 받는 수동적 시스템 존재 (file, device, table, record, process, program, network)​&lt;/li&gt;
          &lt;li&gt;MS Word문서는 이름, 저자, 날짜 등을 속성으로 가짐​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;환경 속성​
        &lt;ul&gt;
          &lt;li&gt;운영, 기술, 상황, 환경 기술​&lt;/li&gt;
          &lt;li&gt;현재 날짜, 시간, 네트워크 보안 레벨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">접근 제어</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">ImplementSubprogram</title>
      <link href="https://lee989898.github.io/pl-17" rel="alternate" type="text/html" title="ImplementSubprogram" />
      <published>2021-11-03T19:18:00+09:00</published>
      <updated>2021-11-03T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-17</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-17">&lt;h3 id=&quot;implementsubprogram&quot;&gt;&lt;strong&gt;ImplementSubprogram&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;서브프로그램 호출과 반환의 구현, 이것을 서브프로그램 링키지(linkage)라고 합니다.​&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Semantics of Calls and Returns&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;서브프로그램 링키지는 호출과 반환에 관련된 액션들의 실행으로 구성된다. ​&lt;br /&gt;
이러한 액션들을 호출 및 반환 시맨틱이라고 한다. ​&lt;/p&gt;

&lt;p&gt;일반적인 서브프로그램 호출 시맨틱은 다음을 포함한다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;파라미터 패싱 방법의 구현, ​&lt;/li&gt;
  &lt;li&gt;로컬 변수에 대한 스토리지 할당 및 바인딩 (로컬 변수가 정적 변수가 아닐 경우) ​&lt;/li&gt;
  &lt;li&gt;콜러의 실행 상태 저장: ​
    &lt;ul&gt;
      &lt;li&gt;실행상태는 콜러의 재실행(resume)에 필요한 레지스터 값, CPU 상태 비트, 환경 포인터(EP)를 포함하며,​&lt;/li&gt;
      &lt;li&gt;EP는 콜리의 실행 중에, 로컬 변수 및 파라미터를 접근하는데 사용된다.  ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;콘트롤을 콜리에게 이전​&lt;/li&gt;
  &lt;li&gt;콜리에 나타나는 난로컬 변수의 접근 메커니즘의 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서브프로그램의 반환 시맨틱은 다음을 포함한다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;포말 파라미터의 로컬 값을 액추얼 파라미터에게 인아웃 또는 아웃 모드로 카피​&lt;/li&gt;
  &lt;li&gt;로컬 변수의 스토리지를 해제​&lt;/li&gt;
  &lt;li&gt;콜러 실행 상태의 재저장​&lt;/li&gt;
  &lt;li&gt;콜러에게 콘트롤 이전&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Implementing “Simple” Subprograms&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;단순 서브프로그램의 호출 및 반환을 어떻게 구현하는지 보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;단순 서브프로그램에서는 ​서브프로그램의 중첩을 허용하지 않고, 모든 로컬 변수가 정적이다. ​&lt;/li&gt;
  &lt;li&gt;호출과 반환에 필요한 스토리지는 다음의 데이터를 포함한다. ​
    &lt;ul&gt;
      &lt;li&gt;콜러의 상태 정보, 파라미터, 복귀 주소, 함수의 반환값​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단순 서브프로그램은 서브프로그램 코드와 데이터로 구성되는데, ​
    &lt;ul&gt;
      &lt;li&gt;데이터 파트는 로컬 변수, 호출과 반환에 필요한 데이터(위에 언급된)를 포함한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;단순 서브프로그램의 호출 시맨틱스(액션과 그 순서)은 다음과 같다. ​&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;현재 수행중인 프로그램(콜러)의 실행 상태를 저장 ​&lt;/li&gt;
  &lt;li&gt;파라미터의 계산 및 패스​&lt;/li&gt;
  &lt;li&gt;콜리에게 복귀 주소를 패스​&lt;/li&gt;
  &lt;li&gt;콜리에게 컨트롤을 이전&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;단순 프로그램의 반환 시맨틱스(액션과 그 순서)는 다음과 같다. ​&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;포말 파라미터의 현재 값을 대응하는 액추얼 파라미터에게 카피 (만일 pass-by-value-result나 pass-by-value라면) ​&lt;/li&gt;
  &lt;li&gt;함수 값을 콜러에게 카피(만일 콜리가 함수라면) ​&lt;/li&gt;
  &lt;li&gt;콜러의 실행 상태를 재저장​&lt;/li&gt;
  &lt;li&gt;콜러에게 컨트롤을 재이전(되돌려줌)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;실행중인 서브프로그램의 데이터 파트를 위한 데이터 구조로 액티베이션 레코드를 정의한다.&lt;br /&gt;
액티베이션 레코드는 로컬 변수, 파라미터, 복귀 주소로 구성된다.&lt;br /&gt;
단순 서브프로그램의 액티베이션 레코드(AR)는 크기가 고정되어 있고, ​정적으로 할당된다.&lt;br /&gt;
따라서 스택에 저장되지 않는다. ​이러한 액티베이션 레코드는 recursion을 지원할 수 없다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl41.png&quot; width=&quot;25%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 단순 서브프로그램의 액티베이션 레코드의 예이다.&lt;br /&gt;
예에서 단순 서브프로그램은 A, B, C이고, 이들의 코드와 액티베이션 레코드는 오른쪽 그림과 같이 메모리에 할당된다.&lt;br /&gt;
메모리에 할당되는 A, B, C의 코드와 데이터의 위치는 ​정적으로 할당되기 때문에 호출되는 순서와 무관하다.&lt;br /&gt;
A, B, C 모두 별개로 컴파일될 수 있으며, ​이 경우 링커에 의해 그림과 같이 모아진다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Implementing Subprograms with Stack-Dynamic Local Variables&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;서브프로그램의 로컬 변수가 스택-동적일 경우, ​서브프로그램의 호출 및 반환 구현에 대해 알아보자.&lt;/p&gt;

&lt;p&gt;스택 동적 로컬 변수는 런타임 스택에 할당된다. ​장점은 recursion의 지원이다.  ​&lt;/p&gt;

&lt;p&gt;스택-동적 로컬 변수가 있는 서브프로그램의 호출과 반환을 구현하려면 ​액티베이션 레코드가 더욱 복잡해진다.  ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;컴파일러는 ‘스택에서 로컬 변수의 암묵적인 할당과 해제’를 지원하기 위한 코드를 생성해야 한다.  ​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Recursion은 하나의 서브프로그램에 대해 여러 개의 액티베이션 레코드를 추가할 가능성이 있다. ​즉, 액티베이션 레코드 여러 개가 스택에 생성된다.&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int AddTwo(int x,y)
{
  int sum;
  sum = x + y;
  return sum;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 함수를 실행하려면 어떤 데이터가 필요할까?&lt;br /&gt;
파라미터 x, y, 로컬 변수 sum, AddTwo 종료후 복귀할 return address&lt;br /&gt;
이와 같이, 액티베이션 레코드는 함수를 한번 실행하는데 필요한 데이터로 구성된다. ​&lt;/p&gt;

&lt;p&gt;그러면… 스택에 저장된 이들 변수를 어떻게 접근할까? ​&lt;br /&gt;
Caller의 스택 포인터를 이용하면 가능한가? 아니다.&lt;br /&gt;
SP는 액티베이션 레코드를 스택에 저장하고자 할 때, ​스택 메모리를 할당하고(나중에 해제하는) ‘시스템이 사용하는’ 레지스터이다.&lt;br /&gt;
따라서 서브프로그램이 사용할 수 있는 레지스터가 아니다.&lt;/p&gt;

&lt;p&gt;​액티베이션 레코드에 저장된 파라미터나 로컬 변수에 접근하려면, ​&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;액티베이션 레코드에 접근할 때, ​BP(베이스 포인터)를 사용한다.&lt;br /&gt;
BP는 AR의 맨앞의 주소를 말하며, ​서브프로그램의 실행 중에 변경되지 않는다.&lt;br /&gt;
BP는 지정된 레지스터에 저장되는데, 그림에서 이것을 BP라고 표시하자. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;파라미터나 로컬 변수에 접근하려면, ​BP+옵셋을 계산하여 스택에 저장된 파라미터나 로컬 변수에 접근한다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서브프로그램이 종료되어 반환될 때, ​BP는 ‘caller의 액티베이션 레코드의 BP’로 재저장된다.&lt;br /&gt;
여기서 return addr는 복귀 주소로, ​서브프로그램의 종료후 되돌아갈 caller의 위치를 나타낸다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;BP는 항상 현재 실행 중인 프로그램의 액티베이션 레코드의 시작 주소를 가리킨다.&lt;br /&gt;
서브 프로그램이 호출되면, 현재 BP는 callee의 액티베이션 레코드(dynamic link)에 저장되고 ​BP는 새로 생성된 callee의 액티베이션 레코드의 시작 주소를 가리키도록 새롭게 설정된다.&lt;br /&gt;
즉, callee로부터 반환되자마자, BP는 callee의 액티베이션 레코드(dynamic link)의 값으로 재저장된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl42.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl43.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 코드와 데이터, 서브프로그램 링키지 코드(AddTwo PROC),그리고 액티베이션 레코드가 저장된 스택을 보여준다.&lt;br /&gt;
esp, ebp는 각각 스택포인터, 베이스 포인터이며, eax는 반환값을 저장하는 장소이다&lt;/p&gt;

&lt;p&gt;AddTwo PROC은 스택에 할당된 액티베이션 레코드에 접근하여, ​스택에 저장된 두 수를 더하여 eax에 저장하여 반환하고, 반환후 5와 6이 저장되었던 8 바이트를 청소하고 종료하는 과정을 보여준다.&lt;br /&gt;
이때 EBP, ESP를 caller의 것으로 변경한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl44.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Recursion이 없이, 여러 서브프로그램으로 구성된 프로그램에서, ​메인이 B를 호출하고, ​B가 C를 호출하고, ​A가 C를 호출한다고 하자. &lt;br /&gt;
그렇게 되면, 위와 같이 액티베이션 레코드가 스택 메모리에 할당된다.&lt;br /&gt;
동적 링크는 바로 아래(caller)의 액티베이션 레코드를 가리킨다.&lt;/p&gt;

&lt;p&gt;이와 같이, 스택에 스택-동적 액티베이션 레코드가 연속적으로 쌓여진 것을 동적 체인(dynamic chain)이라고 한다.&lt;br /&gt;
로컬 변수의 접근은 BP와 옵셋을 계산에 의하며, 이러한 옵셋을 로컬 옵셋이라고 한다.&lt;br /&gt;
로컬 변수의 로컬 옵셋은 컴파일러에 의해 컴파일 타임에 결정된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl45.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl46.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl47.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Recursion이 있을 때, ​액티베이션 레코드는  위의 그림과 같다. ​
여기서 파라미터는 n이다.&lt;/p&gt;

&lt;p&gt;첫째, 둘째, 셋째 recursion을 호출했을 때 function value가 모두 ?
셋째 recursion을 종료되었을 때 둘째 호출이 종료되었을 때 function value가 모두 ?이 아니다.&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">ImplementSubprogram</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Signal</title>
      <link href="https://lee989898.github.io/st-02" rel="alternate" type="text/html" title="Signal" />
      <published>2021-10-31T01:06:00+09:00</published>
      <updated>2021-10-31T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/st-02</id>
      <content type="html" xml:base="https://lee989898.github.io/st-02">&lt;h3 id=&quot;signal&quot;&gt;&lt;strong&gt;Signal&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="system" />
      

      
        <summary type="html">Signal</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Process_Control</title>
      <link href="https://lee989898.github.io/st-01" rel="alternate" type="text/html" title="Process_Control" />
      <published>2021-10-31T01:06:00+09:00</published>
      <updated>2021-10-31T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/st-01</id>
      <content type="html" xml:base="https://lee989898.github.io/st-01">&lt;h3 id=&quot;process-control&quot;&gt;&lt;strong&gt;Process Control&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;exec&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;프로세스가 exec 함수 중 하나를 호출할 때&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로세스는 새 프로그램으로 완전히 대체된다. 텍스트, 데이터, 힙 및 스택 세그먼트를 부모의 주소 공간에 로드한다.&lt;/li&gt;
  &lt;li&gt;새 program은 main function에서 시작한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;새 program은 caller와 동일한 PID를 사용한다.&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;
main()
{ printf(&quot;execiton ls\n&quot;)};
execl(&quot;/bin/ls&quot;,&quot;ls&quot;,&quot;-l&quot;, (char *)0);
perror(&quot;execl failed to run ls\n&quot;);
exit(1);}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;exec: Program Execution&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스 실행을 맡고 있는 시스템 콜은 execve()이다&lt;/li&gt;
  &lt;li&gt;같은 기능을 하면서 라이브러리 함수로 분류되어 있는것으로 execv(), execvp(), execle(), execl(), execlp()가 있다 ​&lt;/li&gt;
  &lt;li&gt;이 6가지를 합쳐서 exec()시스템 콜이라 부른다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;exec() 이후에 오는 문자에 의해 구별되는 표시는 다음의 의미가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;l -&amp;gt; argv 정보를 개개의 문자열 데이터를 가르키는 포인터 arg0,arg1……. argn으로 전달한다&lt;/li&gt;
  &lt;li&gt;v -&amp;gt; argv 정보를 개개의 문자열 데이터를 가리키는 포인터 배열의 ​
선두주소 argv로 전달한다​&lt;/li&gt;
  &lt;li&gt;e -&amp;gt; envp 정보를 전달한다​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;p -&amp;gt; p를 사용하는 경우, 실행할 파일이름을 환경 변수 PATH로 지정한 디렉토리 안에서 찾아내어 실행한다​&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int execl(const char *path, const char *arg0, ... *argn,
(char *)0);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;path: 실행 가능한 파일 경로&lt;/li&gt;
  &lt;li&gt;arg0~argn: 파일에 전달한 argv 정보(명령 인수)&lt;/li&gt;
  &lt;li&gt;(char*)0: 마지막임을 알리는 표시로 NULL 포인터&lt;/li&gt;
  &lt;li&gt;리턴값: 에러시 -1&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;execl.c&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include&amp;lt;unistd.h&amp;gt;

main(int argc, char *argv[]){
    execl(&quot;/bin/ls&quot;,&quot;ls&quot;,argv[1],(char *)0);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;execv.c&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include&amp;lt;unistd.h&amp;gt;
main(){
    char *av[3];

    av[0]=&quot;ls&quot;;
    av[1]=&quot;-1&quot;;
    av[2]=(char *)0;

    execv(&quot;/bin/ls&quot;,av);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;execle()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; #include &amp;lt;unistd.h&amp;gt;

 int execle(const char *path, const char *arg0...*argn,
                    (char *)0, char *const envp[]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;path: 파일의 경로명&lt;/li&gt;
  &lt;li&gt;arg0 ~ argn: 파일에 전달한 argv 정보(명령 인수)&lt;/li&gt;
  &lt;li&gt;envp[]: envp 정보(환경변수)&lt;/li&gt;
  &lt;li&gt;리턴 값: 에러시 -1&lt;/li&gt;
  &lt;li&gt;execl()에 환경 변수 정보를 전달하는 기능을 추가한 것&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;execve()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int execve(const char* path, char *const argv[],
                char *const envp[]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;path: 파일의 경로명&lt;/li&gt;
  &lt;li&gt;argv: 파일에 전달한 argv 정보(명령 인수)&lt;/li&gt;
  &lt;li&gt;envp[]: envp 정보(환경변수)&lt;/li&gt;
  &lt;li&gt;리턴 값: 에러시 -1&lt;/li&gt;
  &lt;li&gt;execv()에 환경 변수 정보를 전달하는 기능을 추가한 것&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;execlp()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int execlp(const char *file, const char *arg0, .... *argn);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;file: 실행하는 파일의 파일 이름&lt;/li&gt;
  &lt;li&gt;arg0 ~ argn: 파일에 전달한 argv 정보(명령 인수)&lt;/li&gt;
  &lt;li&gt;리턴 값: 에러시 -1&lt;/li&gt;
  &lt;li&gt;execlp()는 첫 번째 인자 file에서 지정한 파일 이름을 환경 변수 PATH에서 지정하고 있는 디렉토리 안에서 찾아 실행한다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;execvp()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int execvp(const char *file, char *const argv[]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;file: 실행하는 파일의 파일 이름&lt;/li&gt;
  &lt;li&gt;argv: 파일에 전달한 argv 정보(명령 인수)&lt;/li&gt;
  &lt;li&gt;리턴 값: 에러시 -1&lt;/li&gt;
  &lt;li&gt;execlp()는 첫 번째 인자 file에서 지정한 파일 이름을 환경 변수 PATH에서 지정하고 있는 디렉토리 안에서 찾아 실행한다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Race Conditions&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;여러 프로세스가 일부 데이터를 공유&lt;/li&gt;
  &lt;li&gt;결과는 실행 순서(예: RACE)에 따라 다르다&lt;/li&gt;
  &lt;li&gt;fork() 후에는 부모 또는 자식이 먼저 실행되는지 예측할 수 없다&lt;/li&gt;
  &lt;li&gt;실행 순서는 다음에 따라 다르다
    &lt;ul&gt;
      &lt;li&gt;시스템 부하&lt;/li&gt;
      &lt;li&gt;커널의 스케줄링 알고리즘&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Race condition 문제는 대부분의 시간 작동하기 때문에 감지하기 어렵다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;after fork
    &lt;ul&gt;
      &lt;li&gt;parent,child 모두 스스로 무언가를 한다&lt;/li&gt;
      &lt;li&gt;예를 들어 parent: 로그 파일에 기록 쓰기&lt;/li&gt;
      &lt;li&gt;예를 들어 child: 로그 파일 생성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;parent,child는 다음을 수행해야 한다
    &lt;ul&gt;
      &lt;li&gt;초기 작업 세트가 완료되면 서로 알리고&lt;/li&gt;
      &lt;li&gt;서로 완료될 때까지 기다린다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;system()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;

int system(const char *cmdstring);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;문자열이 터미널에서 명령으로 입력된 것처럼 문자열이 sh(1)에 입력으로 제공한다. ex) system(“date &amp;gt; file”);&lt;/li&gt;
  &lt;li&gt;fork, exec 및 waitpid를 호출하여 시스템을 구현한다.&lt;/li&gt;
  &lt;li&gt;반환 값:
    &lt;ul&gt;
      &lt;li&gt;-1 with errno: fork 또는 waitpid 실패&lt;/li&gt;
      &lt;li&gt;127 : 실행 실패&lt;/li&gt;
      &lt;li&gt;쉘 종료 상태: 3개 모두 성공&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Process Times&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/times.h&amp;gt;

clock_t times(struct tms *buf);

struct tms(
    clock_t tms_utime;
    clock_t tms_stime;
    clock_t tms_cutime;
    clock_t tms_cstime;
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;wall clock time: 프로세스가 실행되는 데 걸리는 시간이며 시스템 부하에 따라 다르다.
    &lt;ul&gt;
      &lt;li&gt;반환된 wall clock time의 시간은 과거의 임의의 지점에서 측정된다. 상대 값을 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자 CPU 시간: 사용자 지침에 기인&lt;/li&gt;
  &lt;li&gt;시스템 CPU 시간: 프로세스를 대신하여 실행될 때 커널에 귀속됨&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="system" />
      

      
        <summary type="html">Process Control</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">이메일 보안</title>
      <link href="https://lee989898.github.io/sc-11" rel="alternate" type="text/html" title="이메일 보안" />
      <published>2021-10-31T01:06:00+09:00</published>
      <updated>2021-10-31T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-11</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-11">&lt;h3 id=&quot;이메일-보안&quot;&gt;&lt;strong&gt;이메일 보안&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;PGP&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;운영체제에 상관없이 확정성이 뛰어나다&lt;/li&gt;
  &lt;li&gt;S/MIME&lt;/li&gt;
  &lt;li&gt;공개키 기반의 프로토콜이다&lt;/li&gt;
  &lt;li&gt;RSA, El Gamel을 사용한다&lt;/li&gt;
  &lt;li&gt;대칭키 방식과도 연동된다(3DES)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Requirements of secure E-mail&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;기밀성&lt;/li&gt;
  &lt;li&gt;송신자 인증&lt;/li&gt;
  &lt;li&gt;메시지 무결성&lt;/li&gt;
  &lt;li&gt;수신자 인증&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Secure e-mail: 기밀성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc10.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;앨리스는 기밀성을 입증한 e-mail, m을 밥에게 보내고 싶다&lt;/li&gt;
  &lt;li&gt;랜덤 대칭키를 생성한다, K&lt;sub&gt;S&lt;/sub&gt;&lt;/li&gt;
  &lt;li&gt;메시지를  K&lt;sub&gt;S&lt;/sub&gt;로 encrypt한다&lt;/li&gt;
  &lt;li&gt;또한 K&lt;sub&gt;S&lt;/sub&gt;를 밥의 공개키로 encrypt한다&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;밥에게 K&lt;sub&gt;S&lt;/sub&gt;(m)과 K&lt;sub&gt;B&lt;/sub&gt;(K&lt;sub&gt;S&lt;/sub&gt;)를 보낸다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;밥은 그의 private키로 decrypt하여 K&lt;sub&gt;S&lt;/sub&gt;를 찾아낸다&lt;/li&gt;
  &lt;li&gt;K&lt;sub&gt;S&lt;/sub&gt;로 K&lt;sub&gt;S&lt;/sub&gt;(m)을 decrypt하여 m을 찾아낸다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Secure e-mail: 송신자 인증, 무결성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc11.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;앨리스는 송신자 인증과 메시지 무결성을 지키고 싶다&lt;/li&gt;
  &lt;li&gt;앨리스는 메세지를 digitally 사인한다&lt;/li&gt;
  &lt;li&gt;메시지와 디지털 시그니처 모두 보낸다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Secure e-mail: all together&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc12.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;앨리스는 보안,송신자 인증,메시지 무결성을 지키고 싶다&lt;/li&gt;
  &lt;li&gt;앨리스는 3가지 키를 사용한다
    &lt;ul&gt;
      &lt;li&gt;그녀의 private key&lt;/li&gt;
      &lt;li&gt;밥의 public key&lt;/li&gt;
      &lt;li&gt;새로 만들어진 대칭키&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Email 보안 표준&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;PGP&lt;/li&gt;
  &lt;li&gt;S/MIME
    &lt;ul&gt;
      &lt;li&gt;이메일을 위해 MIME에 보안서비스 제공 표준&lt;/li&gt;
      &lt;li&gt;인증,무결성,부인방지,기밀성 제공&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc09.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">이메일 보안</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">signature</title>
      <link href="https://lee989898.github.io/sc-10" rel="alternate" type="text/html" title="signature" />
      <published>2021-10-31T01:06:00+09:00</published>
      <updated>2021-10-31T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-10</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-10">&lt;h3 id=&quot;signature&quot;&gt;&lt;strong&gt;signature&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;서명&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;자기의 동일성을 표시하고 책임을 분명하기 하기 위하여 문서 따위에 자기 이름을 써넣음​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;전자서명의 기본 아이디어&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;송신자(alice)는 자신의 비밀키로 암호화​&lt;/li&gt;
  &lt;li&gt;수신자는 송신자의 공개키로 복호화&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;시나리오:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ Bob은 public key를 공개된 장소에 두고, private key는 자신이 가지고 있다
+ Alice는 Bob의 public key를 가져와, 메시지를 암호화해서 전송​
+ 이 메시지는 다른 사람이 보더라도 풀 수 없다. 메시지를 복호화하려면 Bob의 private key가 필요하기 때문-&amp;gt;기밀성보장​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;문제점1. Bob은 Alice가 메시지를 작성했다는것을 확신할 수 있을까? NO​&lt;/li&gt;
  &lt;li&gt;문제점2. Bob은 메시지가 중간에 변경되지않았다는것을 확신할 수 있을까? NO​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;해결법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Alice는 메시지로 MAC을 만들고, 이것을 Alice가 자신의 private key로 암호화 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc05.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;만들어진 것을 본래 메시지에 붙인다 -&amp;gt; 서명&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc06.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이것을 Bob의 public key로 암호화 해서 전송&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;다른 사람은 Bob의 private key가 없으므로 볼수없다 -&amp;gt; 기밀성​&lt;/li&gt;
  &lt;li&gt;Bob은 자신의 private key로 열면 평문과 시그니쳐가 나온다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc07.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Bob은 다음과 같이 무결성,인증을 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc08.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">signature</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">서브프로그램</title>
      <link href="https://lee989898.github.io/pl-16" rel="alternate" type="text/html" title="서브프로그램" />
      <published>2021-10-29T19:18:00+09:00</published>
      <updated>2021-10-29T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-16</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-16">&lt;h3 id=&quot;서브프로그램&quot;&gt;&lt;strong&gt;서브프로그램&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Fundamentals of Subprograms&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서브프로그램이 무엇인지 왜 필요한지 살펴 보자.&lt;br /&gt;
동일한 코드 부분(segment)이 프로그램의 여러 곳에서 나타난다고 하면, 이 코드를 여러 곳에 중복해서 코딩하기보다는,​
한번만 코딩하고, 필요할 때마다 그 코드 부분으로 점프했다가 끝나면 되돌아 오는 방식으로, 프로그램을 짤 수 있다.&lt;br /&gt;
이러한 코드 부분을 서브프로그램이라고 한다.&lt;br /&gt;
동일한 코드 부분이 프로그램의 여러 곳에 나타나고, ​나타나는 곳마다 사용되는 변수가 다르다고 가정해 보자.&lt;br /&gt;
이때 파라미터를 갖는 서브프로그램을 사용할 수 있다.&lt;br /&gt;
서브프로그램의 개념은 쓰레드와 같은 것으로 발전하고 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;서브프로그램은 다음과 같은 특징을 갖는다. ​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;각 서브 프로그램은 단하나의 진입점을 갖는다. ​&lt;/li&gt;
  &lt;li&gt;호출한 서브프로그램(caller)는 호출된 서브프로그램(callee)의 실행 중에는 중지된다. ​&lt;/li&gt;
  &lt;li&gt;Callee가 종료되면, 컨트롤을 항상 caller에게 되돌려준다.  ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서브프로그램은 정의부와 선언부로 구성된다.&lt;br /&gt;
서브프로그램 정의부는 서브프로그램의 인터페이스와 액션을 서술하고, ​정의부의 맨앞에는 서브프로그램의 헤더가 있다.&lt;br /&gt;
헤더는 void adder(parameter) 처럼 서브프로그램 이름, 유형, 포말 파라미터 등을 포함한다. &lt;br /&gt;
포말 파라미터의 개수, 순서, 타입을 파라미터의 프로파일(시그니처, 요약)이라고 부른다. ​&lt;/p&gt;

&lt;p&gt;서브프로그램 선언부는 파라미터 프로파일과 반환 타입을 선언한다.&lt;br /&gt;
서브프로그램 호출(call)은 서브프로그램으로 점프한다. ​&lt;/p&gt;

&lt;p&gt;서브프로그램에서 데이터에 접근하는 방법은 두가지가 있다.
 ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;난로컬 변수에 직접 접근하는 경우 ​&lt;/li&gt;
  &lt;li&gt;파라미터 패싱을 사용하는 경우 ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파라미터 패싱을 사용하여 데이터를 접근할 때에는 ​로컬 변수명을 사용한다.&lt;br /&gt;
난로컬 변수에 직접 접근하는 것보다 융통성이 높아 파라미터화에 의한 계산이 가능하다.&lt;br /&gt;
난로컬 변수에 대한 광범위한 접근은 부작용으로 인해 신뢰성을 감소시킨다. ​&lt;br /&gt;
순수 함수 언어는 수정 가능한 데이터를 허용하지 않으며, 메모리 내용을 변경할 수 없도록 제한한다. ​&lt;/p&gt;

&lt;p&gt;포말 파라미터는 callee의 헤더에 있는 파라미터를 말한다.&lt;br /&gt;
서브프로그램이 호출될 때만 메모리에 바인딩되고, ​액추얼 파라미터를 통해서 바인딩되기 때문에, ​종종 더미 변수로 취급되기도 한다.&lt;br /&gt;
액추얼 파라미터는 caller에서 사용되는 값이나 주소를 나타낸다.&lt;/p&gt;

&lt;p&gt;액추얼 파라미터를 포말 파라미터에 바인딩하는 방법은 두 가지가 있다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;위치 파라미터: 파라미터의 순서가 중요 ​&lt;/li&gt;
  &lt;li&gt;키워드 파라미터: 파라미터의 이름이 중요, 순서는 중요하지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파이썬에서 sumer(my_length, list=my_array, sum = my_sum),  ​
포말 파라미터는 length, list, sum이고, ​
액추얼 파라미터는 my_length, my_array, my_sum 이라면, ​
첫번째 파라미터는 위치 파라미터이고, ​
두번째 세번째는 키워드 파라미터이다.  ​&lt;/p&gt;

&lt;p&gt;키워드 파라미터의 장점은 순서에 얽매이지 않는다는 것이고, ​
단점은 사용자가 포말 파라미터의 이름을 알고 있어야 한다는 것이다.&lt;/p&gt;

&lt;p&gt;C++, 파이썬 등에서는 액추얼 파라미터가 모두 다 패스되지 않을 경우, ​포말 파라미터는 대응되지 않는 나머지 파라미터에 대해 디폴트 값을 가질 수 있다. ​&lt;/p&gt;

&lt;p&gt;C++에서 파라미터는 위치에 연관되기 때문에 ​
디폴트 파라미터는 마지막에 나타나야 하며, ​
디폴트값은 서브프로그램 헤더에 있다. ​&lt;/p&gt;

&lt;p&gt;서브프로그램 내에 정의된 변수는 모두 로컬이며, ​
그들의 스코프는 항상 서브프로그램 안이다.&lt;br /&gt;
로컬 변수는 정적 또는 스택-동적으로 바인딩된다. ​
로컬 변수가 스택-동적이라면, ​
서브프로그램의 실행이 시작될 때 메모리에 바인딩되고, ​
실행이 끝나면 메모리에서 떨어진다. ​&lt;/p&gt;

&lt;p&gt;스택-동적 변수의 장점은, ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Recursive 서브프로그램이 스택-동적 로컬 변수를 갖는다 -&amp;gt; recursion 처리가 가능​&lt;/li&gt;
  &lt;li&gt;액티브 서브 프로그램의 로컬 변수가 ​
액티브하지 않은 서브프로그램이 해제한 로컬 변수의 메모리를 사용할 수 있다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;프로그램이 시작되고나서 아직 끝나지 않은 상태에서는 ​
자주 호출되는 서브프로그램의 실행이 끝났다고 해도 ​
그 서브 프로그램의 변수는 아직 메모리를 차지하고 있을 수 있다.&lt;br /&gt;
이때 서브프로그램의 상태를 액티브라고 한다. ​&lt;/p&gt;

&lt;p&gt;현대 언어에서, 서브프로그램의 로컬 변수는 디폴트로서 스택-동적으로 바인딩된다. ​&lt;/p&gt;

&lt;p&gt;C, C++ 함수에서, 로컬 변수는 정적이라고 명시되어 있지 않으면 스택-동적이다. ​&lt;/p&gt;

&lt;p&gt;서브프로그램이 다른 서브프로그램안에만 있어야 한다면, ​
이것을 중첩 서브프로그램이라고 한다. ​&lt;/p&gt;

&lt;p&gt;다른 서브프로그램 안에서 숨어서(hide) 다른 프로그램이 호출할 수 없게 만든다. ​&lt;/p&gt;

&lt;p&gt;서브프로그램의 중첩으로 처리 논리와 스코프의 계층구조를 생성할 수 있다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정적 스코핑의 사용 ​&lt;/li&gt;
  &lt;li&gt;알골, 파스칼에서 허용 ​&lt;/li&gt;
  &lt;li&gt;C 계열 언어는 서브프로그램의 중첩을 허용하지 않음​&lt;/li&gt;
  &lt;li&gt;자바스크립트, 파이썬 등은 중첩 허용&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Parameter-Passing Methods&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;파라미터 패싱에 대한 시맨틱 모델은 3가지가 있다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;포말 파라미터가 대응하는 액추얼 파라미터로부터 데이터를 받는 것이다. 이것을 in mode라고 한다. ​&lt;/li&gt;
  &lt;li&gt;포말 파라미터가 액추얼 파라미터에게 데이터를 보내는 것이다. 이것을 out mode라고 한다. ​&lt;/li&gt;
  &lt;li&gt;포말 파라미터가 대응하는 액추얼 파라미터로부터 데이터를 받고, 액추얼 파라미터에게 데이터를 보내는 것이다. 이것을 inout mode라고 한다.  ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파라미터간에 데이터를 주고 받는 방법은 두가지가 있다.&lt;br /&gt;
실제 값을 카피하여 주고 받는 방법과 액세스 패스(접근 경로)를 주고 받는 방법이다.&lt;/p&gt;

&lt;p&gt;파라미터 패싱 구현 모델에는 ​pass by value(in mode), pass by result(out mode), ​pass by value result(inout mode), pass by reference(inout mode)가 있다. ​&lt;/p&gt;

&lt;p&gt;Caller의 액추얼 파라미터를 Pass by value 모델로 callee에게 보낼때, 액추얼 파라미터의 값은 copy를 통해, ​대응되는 포말 파라미터의 초기화에 사용된다. ​&lt;/p&gt;

&lt;p&gt;단점은 다음과 같다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;copy 하면, ​  추가적인 메모리를 필요로하고, 실제 이동 비용이 발생한다. ​&lt;/li&gt;
  &lt;li&gt;만일 접근 경로(access path)에 의한다면, callee에서 쓰기 보호를 해야하는 동시에, ​간접 주소방식에 의한 접근 비용이 추가된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Callee의 파라미터를 pass by result 모델로 caller에게 보낼 때, ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;대응되는 포말 파라미터는 로컬 변수처럼 행동한다. ​&lt;/li&gt;
  &lt;li&gt;Callee가 종료되어 컨트롤을 caller에게 돌려주면, 포말 파라미터의 값을 caller의 액추얼 파라미터로 전달한다. ​&lt;/li&gt;
  &lt;li&gt;추가적인 메모리 위치와 copy 연산이 필요하다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pass by result에 내재하는 문제는 다음과 같다. ​&lt;/p&gt;

&lt;p&gt;Caller와 callee가 ​Caller: sub(p1, p1) actual parameter p1, p1​ Callee: sub(x, y) formal parameter x, y 라고 하자 액추얼 파라미터 두개가 p1으로 같고, ​대응하는 포말 파라미터 두개의 이름이 x, y로 다르다. ​&lt;/p&gt;

&lt;p&gt;Caller가 callee를 호출해서 callee가 실행 후 종료되고, ​
Callee가 calle에게 결과값을 반환할 때, ​
X, y 중 어느 것이 p1에 마지막으로 copy 되느냐에 따라, ​
p1의 값이 달라진다. ​
x거나 y이다. ​&lt;/p&gt;

&lt;p&gt;이것이 pass by result에 내재하는 문제이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Pass by value result는 ​pass by value와 pass by result의 결합으로 ​pass by copy라고도 부른다. ​&lt;br /&gt;
액추얼 파라미터의 값은 대응하는 포말 파라미터의 초기화에 쓰이고, ​포말 파라미터는 로컬 변수처럼 행동한다. ​&lt;br /&gt;
포말 파라미터의 값은 액추얼 파라미터에게 반환된다. ​
단점은 in, out 모두 카피에 의존. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Pass by reference 모델은 접근 통로의 패스를 통해, ​
파라미터를 패스한다. ​&lt;br /&gt;
즉, callee에게 caller의 액추얼 파라미터를 접근하도록 허용한다. &lt;br /&gt;
따라서 pass by sharing이라고도 한다. ​&lt;/p&gt;

&lt;p&gt;장점은 패싱 프로세스가 효율적이다. ​&lt;br /&gt;
Copy 연산, 메모리 모두 필요없다. ​&lt;br /&gt;
단점은 느리고, 예기치 않았던 난로컬 변수를 접근할 수도 있다. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;대부분 언어에서, 파라미터 패싱의 구현은 런타임 스택을 통해 일어난다. ​&lt;br /&gt;
C에서 파라미터 패싱은 pass by value를 지원한다.&lt;br /&gt;
포인터를 사용하면, Pass by reference를 구현할 수 있다.&lt;br /&gt;
자바는 모든 파라미터에 대해 pass by value를 지원하며,&lt;br /&gt;
객체 파라미터에 대해 pass by reference를 지원한다.&lt;/p&gt;

&lt;p&gt;파라미터에 대한 타입 검사는 ​액추얼 파라미터와 포말 파라미터 간에 타입의 일관성을 검사하는 것이다. ​&lt;br /&gt;
파라미터의 타입 검사는 소프트웨어의 신뢰성을 위해 매우 중요하다. ​&lt;br /&gt;
포트란 77, 원시 C에는 파라미터 타입 검사가 없다.&lt;br /&gt;
ANSI C, C++에는 선택적이며, ​파이썬, 루비에서는 변수가 타입을 갖지 않기 때문에 ​파라미터 타입 검사가 없다.&lt;/p&gt;

&lt;p&gt;파라미터의 타입이 다차원 배열일 경우, ​서브프로그램이 따로 컴파일되어 있고, ​다차원 배열이 서브프로그램으로 패스된다고 가정하자. ​&lt;br /&gt;
컴파일러는 메모리 매핑을 위해, ​선언된 배열의 크기를 알 필요가 있다.  ​&lt;/p&gt;

&lt;p&gt;Row-major 매트릭스의 메모리 매핑 함수는 ​&lt;/p&gt;

&lt;p&gt;address(mat[i,j]) = address(mat[0,0]) + i * #_columns + j 이다. ​&lt;/p&gt;

&lt;p&gt;즉, 컬럼의 길이만 알면 전체 크기를 알 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;현대 프로그래밍 언어에서 다차원 배열 파라미터를 어떻게 패스하는지 살펴 보자.​&lt;/p&gt;

&lt;p&gt;C, C++에서,&lt;br /&gt;
1) 프로그래머가 액추얼 파라미터의 첫번째 서브스크립트를 제외하고, ​나머지 서브스크립트의 크기를 선언하는 방법. ​&lt;/p&gt;

&lt;p&gt;슬라이드의 프로그램에서 mat은 2차원 배열이고, ​
함수 fun(mat)은 mat을 파라미터로 하는 함수이다.&lt;br /&gt;
이와 같은 방식은 서브프로그램의 유연성을 불허한다는 것이다. ​&lt;/p&gt;

&lt;p&gt;2) 이에 대한 해결책으로, ​&lt;/p&gt;

&lt;p&gt;배열에 대한 포인터, 차원 크기를 파라미터로 패스하는 방법이 있다.&lt;br /&gt;
다만, 배열 처리를 위해 ​사용자는 메모리 매핑 함수를 포함해야 하는 불편함이 있다.&lt;/p&gt;

&lt;p&gt;자바에서는 배열을 객체로 취급한다.&lt;br /&gt;
이들은 모두 일차원 배열이지만 ​배열의 각 요소가 배열일 수 있어서 ​다차원 배열을 파라미터로 쓸 수 있다.&lt;br /&gt;
자바에서 각 배열은 named constant(length와 같은)를 상속받는다.&lt;/p&gt;

&lt;p&gt;파라미터 패싱 방법의 구현시, 다음 두가지를 고려해야 한다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;효율성, ​&lt;/li&gt;
  &lt;li&gt;일방(in, out) 또는 쌍방(inout) 데이터 이동:caller-callee간에  ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러나 이들 고려사항은 서로 상충된다. ​&lt;/p&gt;

&lt;p&gt;프로그래밍을 잘하려면, 변수에 대한 접근을 가능한한 일방(in, out)으로 제한하는 것이 좋다.&lt;br /&gt;
pass by reference(inout)는 크기가 큰 데이터 스트럭처를 패스하는데 더욱 효율적인 반면, ​변수에 대한 접근을 제한하는데 문제를 일으킬 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Parameters That Are Subprograms&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이번엔 서브프로그램 이름을 파라미터로 패스하는 경우를 살펴보자. &lt;br /&gt;
종종 서브프로그램 이름을 파라미터로 패스하는 것이 편리할 때도 있다.&lt;br /&gt;
​즉, 계산을 서브프로그램으로 패스하는 것이다.&lt;/p&gt;

&lt;p&gt;파라미터 타입 검사? ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;C, C++ 함수 포인터로 패스함. ​-&amp;gt; 함수 포인터의 타입은 파라미터 타입을 포함하므로 파라미터 타입 검사는 가능함 ​&lt;/li&gt;
  &lt;li&gt;자바는 메소드 이름을 파라미터로 패스하는 것을 불허함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서브프로그램 중첩을 허용하는 언어에서, ​어떤 바인딩 방식에 의한 레퍼런싱 환경을 사용하는가? ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;쉘로우 바인딩: 패스된 서브프로그램을 실행시킨 call문(호출문)의 환경 ​&lt;/li&gt;
  &lt;li&gt;딥바인딩: 패스된 서브프로그램에 정의된 환경​&lt;/li&gt;
  &lt;li&gt;즉흥(ad hoc) 바인딩: 서브프로그램을 액추얼 파라미터로 패스한 호출문의 환경&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function sub1() {​
  var x;​
  function sub2() { alert(x); };​
  function sub3() {​
    var x; x = 3;​
    sub4(sub2); }​
  function sub4(subx) {​
    var x; x = 4;​
    subx(); }​
  x = 1;​
  sub3(); }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Sub4의 sub에 대해​&lt;/p&gt;

&lt;p&gt;쉘로우 바인딩을 했을 경우 ​
실행시킨 call문의 환경은 sub4가 되고, ​
sub4에서 x는 4이다. ​&lt;/p&gt;

&lt;p&gt;딥 바인딩을 했을 경우​
Sub2가 정의된 환경은 sub2가 되고,  ​
Sub2에서 x는 난로컬로서 sub1에 따른다. ​
따라서 x는 1이다. ​&lt;/p&gt;

&lt;p&gt;즉흥 바인딩일 경우, ​
Sub2를 파라미터로 넘긴 call문의 환경은 sub3가 되고, ​
Sub3에서 x는 3이다. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Design Issues for Functions&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;언어 설계시 고려사항은&lt;/p&gt;

&lt;p&gt;부작용 허용 여부? 부작용을 줄이려면 파라미터는 항상 in mode가 좋다. ​&lt;/p&gt;

&lt;p&gt;반환 값의 타입은? 대부분의 명령형 언어가 반환값의 타입을 제한함. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;C는 배열과 함수를 제외하고 모든 타입을 허용함. ​&lt;/li&gt;
  &lt;li&gt;C++은 C와 유사하나 사용자 정의 타입을 허용​&lt;/li&gt;
  &lt;li&gt;자바는 모든 타입 허용. ​&lt;/li&gt;
  &lt;li&gt;파이썬, 루비는 반환값 타입으로 객체도 허용&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Coroutines&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;코루틴에서 중요한 것은 재시작(resume) 명령.&lt;br /&gt;
프로그램 단위의 유사 동시 실행 기능을 제공함. 인터리빙.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl38.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위그림은 A가 먼저 시작하고, B를 재시작하고나서 스스로 중지했다가, ​
B가 A를 재시작하고 나서 스스로 중지했다가, ​
번갈아 가며 실행되는 형태를 보여주고 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl39.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 B가 먼저 시작하고, A를 재시작하면서 스스로 중지하고, ​
번갈아가며 실행되는 형태를 보이고 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl40.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위그림은 룹에서 서로 중지하고 상대방을 재시작하는 것을 반복함&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">서브프로그램</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">탐욕 기법</title>
      <link href="https://lee989898.github.io/algorithm-05" rel="alternate" type="text/html" title="탐욕 기법" />
      <published>2021-10-26T01:09:00+09:00</published>
      <updated>2021-10-26T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-05</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-05">&lt;h3 id=&quot;탐욕-기법&quot;&gt;&lt;strong&gt;탐욕 기법&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;탐욕 기법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;매 번 선택할 때 마다 그 순간에 좋은 선택을 함으로써 최종적인 해에 도달한다.&lt;/li&gt;
  &lt;li&gt;최적인 해들을 모아서 최종 해를 만들었다고 해서, 그 해가 궁극 적으로 최적이라는 보장이 없다.&lt;/li&gt;
  &lt;li&gt;따라서 탐욕 기법은 항상 최적의 해를 만들어내는 지를 반드시 검증해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;선택 기준&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;선택이 실현 가능해야 한다.&lt;/li&gt;
  &lt;li&gt;모든 선택들 중에서 최적이라고 여겨지는 선택을 해야 한다.&lt;/li&gt;
  &lt;li&gt;한 번 선택하면 나중에 되돌릴 수 없다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;설계 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;비어 있는 해 모음으로 시작한다.&lt;/li&gt;
  &lt;li&gt;탐욕적인 기준에 따라 해 모음에 추가할 다음 해를 선택한다.&lt;/li&gt;
  &lt;li&gt;새 해 모음이 실형 가능한지를 확인한다.
실현 가능하다면 새 해 모음을 확정하고 아니면 선택한 해를 버린다.&lt;/li&gt;
  &lt;li&gt;새 해 모음이 최종 해라면 종료한다. 아니면 2번으로 간다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;거스름돈 주기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;거스름돈을 동전들의 수가 최소가 되도록 주어야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;액면가가 다른 m(&amp;gt;=1)개의 동전들이 있다.&lt;/li&gt;
  &lt;li&gt;동전 i,1&amp;lt;=i&amp;lt;=m,의 액면가는 $d_i$ 이고 $d_1$ &amp;gt; 
$d_2$ &amp;gt; … &amp;gt; $d_m$ = 1이다.&lt;/li&gt;
  &lt;li&gt;액면가가 같은 동전들의 개수는 무한히 많이 있다.&lt;/li&gt;
  &lt;li&gt;거스름돈 n(&amp;gt;=1)을 최소 개수의 동전들을 사용하여 주어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;탐욕 알고리즘의 아이디어&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;주어야 할 거스름돈이 남아 있는 동안 다음을 반복한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;남은 동전들 중 액면가가 가장 큰 동전을 선택한다.&lt;/li&gt;
  &lt;li&gt;선택한 동전을 거스름돈에 추가하면 거스름돈이 주어야 할 금액을 
초과한다면 그 동전을 버린다. 아니면 그 동전을 거스름돈에 추가하고 주어야 할 거스름돈을 추가한 동전의 액면가만큼 감소시킨다.&lt;br /&gt;
주: 최적의 알고리즘&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;탐욕적인 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;coinChange(d[],m,n)
//거스름돈에 포함되는 동전들의 수를 최소화한다.&lt;br /&gt;
//입력: m - 액면가가 다른 동전들의 수&lt;br /&gt;
//     d[1..m] - 동전들의 액면가를 저장하는 배열&lt;br /&gt;
//     n - 거스름돈&lt;br /&gt;
//출력(반환 값): 거스름돈에 포함된 동전들의 최소 개수&lt;br /&gt;
1  count = 0&lt;br /&gt;
2  i = 1&lt;br /&gt;
3  while(n &amp;gt; 0 &amp;amp;&amp;amp; i &amp;lt;=m){&lt;br /&gt;
4    count = count + $\frac{n}{d[i]}$ 　//가치가 가장 큰 동전들을 최대한 많이 선택&lt;br /&gt;
5    n = n mod d[i] 　　　 //남은 거스름돈을 계산&lt;br /&gt;
6    i = i + 1 　　　　　　 //다음으로 가치가 큰 동전을 선택&lt;br /&gt;
    }&lt;br /&gt;
7  return count&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;시간 복잡도&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;입력의 크기: m(액면가가 다른 동전들의 수)&lt;/li&gt;
  &lt;li&gt;기본 연산: 4번의 배정문&lt;/li&gt;
  &lt;li&gt;기본 연산의 수행 횟수: 최대 m&lt;/li&gt;
  &lt;li&gt;시간 복잡도: m = $\theta$(m)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;최소 비용 신장 트리 찾기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;n(&amp;gt;1)개의 도시들을 최소한의 비용으로 연결하는 철도망을 새로 구축하려고 한다.&lt;/li&gt;
  &lt;li&gt;모든 도시들을 서로 연결하기 위해 도시간 철도를 최소한(n-1)개 깔아야 한다.&lt;/li&gt;
  &lt;li&gt;각 철도는 두 도시를 연결한다.&lt;/li&gt;
  &lt;li&gt;이 철도망들 중에서 철도 노선들의 총 길이가 최소가 되도록 철도망을 구축해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;최소 비용 신장 트리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;신장트리: 연결된, 무방향 그래프 안에 있는 모든 정점을 다 포함하면서 트리가 되는 연결된 부분 그래프&lt;/li&gt;
  &lt;li&gt;산장트리는 순환을 포함하지 않으며 그래프 안에 있는 모든 정점들을 연결시칸다.&lt;/li&gt;
  &lt;li&gt;신장트리의 가중치: 모든 간선들의 가중치들의 합&lt;/li&gt;
  &lt;li&gt;최소 비용 신장 트리: 최소 가중치를 가진 신장트리&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag12.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;억지 기법 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;모든 신장 트리를 찾은 후 그 중에서 최소 비용 신장 트리를 선택한다.&lt;/li&gt;
  &lt;li&gt;시간 복잡도 분석
    &lt;ul&gt;
      &lt;li&gt;최악의 경우, 지수 시간보다도 나쁘다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;탐욕적인 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;신장 트리에 추가할 최선의 간선들을 반복적으로 한 번에 하나씩 선택한다. 선택 시점에서 추가할 최선의 간선을 쉽게 알 수 있다고 가정한다.&lt;/li&gt;
  &lt;li&gt;(n-1)개의 간선들이 신장 트리에 포함된다면 종료한다.&lt;/li&gt;
  &lt;li&gt;한 간선이 선택되면 그 간선의 정점들을 합친다.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;적절한 이유&lt;br /&gt;
정점 a와 b가 연결된다면 정점a에 연결하는 것은 정점 b에 연결하는 것과 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;명제. n(&amp;gt;0)개의 정점들을 가진 그래프 G는 (n-1)개의 간선들을 가지고 순환이 없으면 트리이다. 또한 G가 트리이면 (n-1)개의 간선들이 있고 비순환 그래프이다.&lt;/p&gt;

&lt;p&gt;정리. 간선 e가 정점 v에 접합한 가장 가중치가 작은 간선이라면 e를 포함하는 최소 비용 신장 트리가 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;최소 비용 신장트리 찾기 - 정점지향 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;처음 시작할 때 한 정점 $v_0$를 선택한다.&lt;/li&gt;
  &lt;li&gt;$v_0$ 에서 나가는 가장 가중치가 작은 간선 ($v_0$, x)를 선택한다. 그 간선을 최소 비용 신장 트리 T에 추가하고 $v_0$와 x를 합친다. 모든 정점이 T에 포함될 때까지 이 과정을 반복한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;프림 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;적색 정점: 처음에 선택된 정점 $v_0$와 합쳐진 정점&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;청색 정점: 그 외 다른 정점&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;아이디어&lt;br /&gt;
다음을 (n-1)번 반복한다:
    &lt;ol&gt;
      &lt;li&gt;한 적색 정점과 한 청색 정점을 연결하는 가장 가중치가 작은 간선을 선택한다.&lt;/li&gt;
      &lt;li&gt;선택된 간선의 청색 정점을 적색으로 바꾸고 그 간선을 트리에 추가한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;그래프의 표현: 비용 행렬 W&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;R: 적색 정점들의 집합, B: 청색 정점들의 집합&lt;br /&gt;
V: 그래프내의 모든 정점들의 집합&lt;br /&gt;
T: 트리 내에 포함되는 간선들의 집합&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;  R = {$v_0$}&lt;/li&gt;
  &lt;li&gt;  B = V - {$v_0$}&lt;/li&gt;
  &lt;li&gt; T = $\emptyset${공집합}&lt;/li&gt;
  &lt;li&gt; for(i = 1; i &amp;lt; n; i++) {&lt;/li&gt;
  &lt;li&gt; 　　w[ r,b ]가 최소인 $r \in R$과 $b \in B$를 선택한다.&lt;/li&gt;
  &lt;li&gt; 　　T = T U {(r,b)}　　// 간선 (r,b)를 트리에 추가한다.&lt;/li&gt;
  &lt;li&gt; 　　B = B - {b}&lt;/li&gt;
  &lt;li&gt; 　　R = R U {b}　　　//정점 b를 적색으로 바꾼다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;명확하게 청색 정점의 관점을 취해야 한다. 단순히 어느 적색 정점이 자신에게 가장 가까운지만 기억한다. 이는 한 정점이 적색이 될 때 쉽게 갱신될 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;시간 복잡도&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 알고리즘은 중복 계산을 많이 한다. 매번 반복할 때마다 최소 간선을 거의 같은 집합에서 찾는다.&lt;br /&gt;
$\theta$($n^3$)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;개선된 프림 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;near[0 .. n - 1]: 각 청색 정점에 가장 가까운 적생 정점을 저장하는 배열&lt;br /&gt;
isblue[0 .. n - 1]: 각 정점이 청색이면 true를 아니면 false를 저장하는 배열&lt;br /&gt;
T: 트리 내에 포함되는 간선들의 집합&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt; isblue[0] = false 　　　　//정점 0은 적색이다&lt;/li&gt;
  &lt;li&gt; T = $\emptyset$&lt;/li&gt;
  &lt;li&gt; for(i = 1; i &amp;lt; n; i++){&lt;/li&gt;
  &lt;li&gt; 　　isblue[i] = true 　　　　//다른 정점들은 청색이다&lt;/li&gt;
  &lt;li&gt; 　　near[i] = 0 } 　　　　　 // 가장 가까운 적색 정점은 0이다&lt;/li&gt;
  &lt;li&gt; for(i = 1; i &amp;lt; n; i++){&lt;/li&gt;
  &lt;li&gt; 　　minval = $\infty$&lt;/li&gt;
  &lt;li&gt; 　　for(b = 0; b &amp;lt; n; b++)　//적색 정점들에 가장 가까운 청색 정점을 찾는다&lt;/li&gt;
  &lt;li&gt; 　　　if(isblue[b] &amp;amp;&amp;amp; W[b,near[b]]&amp;lt; minval){&lt;/li&gt;
  &lt;li&gt; 　　　　minval = W[b,near[b]]&lt;/li&gt;
  &lt;li&gt; 　　　　newred = b }&lt;/li&gt;
  &lt;li&gt; 　isblue[newred] = fasle 　　　//정점 newred를 적색으로 바꾼다&lt;/li&gt;
  &lt;li&gt; 　T = T $\cup$ { (newred, near[newred])}　//가장 가중치가 작은 간선을 T에 추가한다&lt;/li&gt;
  &lt;li&gt; 　for(b = 0; b &amp;lt; n; b++)&lt;/li&gt;
  &lt;li&gt; 　　　if(isblue[b] &amp;amp;&amp;amp; W[b,newred] &amp;lt; W[b,near[b]])near[b] = newred&lt;br /&gt;
　　}&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;시간 복잡도&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;입력 크기: n(정점들의 수)&lt;/li&gt;
  &lt;li&gt;기본 연산: isblue의 요소들에 대한 참조 횟수&lt;/li&gt;
  &lt;li&gt;참조 횟수
    &lt;ul&gt;
      &lt;li&gt;각 i, 1&amp;lt;= i &amp;lt; n, 에 대해 항상 n이다.&lt;/li&gt;
      &lt;li&gt;따라서 총 참조 횟수 = (n-1) x n $\in$ $\theta$($n^2$)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;최소 비용 신장 트리 찾기 - 간선 지향 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;그래프에 남아 있는 가장 가중치가 작은 간선을 선택한다.&lt;/li&gt;
  &lt;li&gt;선택된 간선이 합쳐진 두 개의 정덤들 사이에 있다면 그 간선을 버리고 아니면 최소 비용 신장 트리에 추가한다.&lt;/li&gt;
  &lt;li&gt;(n - 1)개의 간선들이 추가될 때까지 과정 1과 2를 반복한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;크루스칼 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;//e: 간선들의 수&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;  간선들을 가중치 순서로 오름차순으로 정렬하여 배열 EDGELIST[1 .. e]에 저장한다&lt;/li&gt;
  &lt;li&gt;  T = $\emptyset$&lt;/li&gt;
  &lt;li&gt;  ecount = 0  　 　 　 　//최소 비용 신장 트리에 추가된 간선들의 수&lt;/li&gt;
  &lt;li&gt;  k = 0  　 　 　 　 　 　 　//처리된 간선들의 수&lt;/li&gt;
  &lt;li&gt;  while (ecount &amp;lt; n - 1){&lt;/li&gt;
  &lt;li&gt;  　k = k + 1&lt;/li&gt;
  &lt;li&gt;  　(v, w) = EDGELIST[k]&lt;/li&gt;
  &lt;li&gt;  　if(! together(v,w)){&lt;/li&gt;
  &lt;li&gt;  　　T = T U {(v,W)}&lt;/li&gt;
  &lt;li&gt;  　　v와 w를 합친다&lt;/li&gt;
  &lt;li&gt;  　  ecount = ecount + 1 }&lt;br /&gt;
} &lt;br /&gt;
주: together(v,w) : v와 w가 이미 합쳐졌으면 true이다.&lt;br /&gt;
분삭: (n-1)번의 통합과 최대 e번의 together를 수행한다.&lt;br /&gt;
정렬시간 = $\theta$( e log e)&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;단일 출발점 최단 경로 찾기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;연결된 가중 그래프에서 한 특정 정점에서 다른 모든 정점으로 가는 최단 경로를 찾아라.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;다익스트라 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;아이디어: 출방 정점 $v_0$로 부터 가까운 순서로 다른 정점들까지의 최단 경로를 찾는다.&lt;/li&gt;
  &lt;li&gt;진행 과정
    &lt;ul&gt;
      &lt;li&gt;i번째 반복이 시작되기 전에 $v_0$에 가장 가까운 (i - 1)개의 정점들까지의 최단 경로들을 찾았다.&lt;/li&gt;
      &lt;li&gt;$v_0$, 이 정점들과 최단 경로들 상의 간선들은 주어진 그래프의 부분 트리 $T_i$를 형성한다.&lt;/li&gt;
      &lt;li&gt;$T_i$내에 있는 정덤들에 인접한 ‘가장자리 정점’들 중에서 찾는다.&lt;/li&gt;
      &lt;li&gt;$T_i$내에 있는 정점들에 인접한 ‘가장자리 정접’들 중에서 찾는다.&lt;/li&gt;
      &lt;li&gt;모든 가장자리 정점 u에 대해서 u에 인접한 트리내의 정점 v까지의 거리, W(u,v)와 출발 정점에서 v까지의 최단 경로의 길이, $d_v$의 합을 계산한다.&lt;/li&gt;
      &lt;li&gt;u에 인접한 트리 내의 정점들이 2개 이상인 경우에는 각 인접 정점에 대해 합을 계산한다. 그러한 합들 중 가장 작은 합을 갖는 가장자리 정점을 트리에 추가할 다음 정점으로 선택한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag13.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 트리 $T_i$이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;n( &amp;gt; 0): 정점들의 수&lt;/li&gt;
  &lt;li&gt;i, 0 &amp;lt;= i &amp;lt; n: 정덤의 번호&lt;/li&gt;
  &lt;li&gt;출발 정점: 0&lt;/li&gt;
  &lt;li&gt;정점 i에 d[i]와 p[i]를 저장한다.
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;d[i]: 출발 정점에서 각 정점까지의 최단 겅로의 거리
  d[0] = 0&lt;br /&gt;
  d[i] = $\infty$ ,i는 최단 경로 트리 내에 포함되지 않은 정점&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;p[i]: 출발 정점에서 각 정점까지의 최단 경로 상의 마지막에서 두 번째 정점(트리에서 부모 노드)의 번호&lt;br /&gt;
  i = 0혹은 트리안에 포함되지 않은 정점이면 p[i] = -1&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;주어진 그래프는 인접 행렬 w로 나타낸다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;트리에 추가할 정점 $u^*$를 선택한 후의 연산&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;$u^*$를 가장자리 정점에서 트리내에 포함되는 정점으로 바꾼다.&lt;/li&gt;
  &lt;li&gt;$u^&lt;em&gt;$에 인접한 트리에 포함되지 않은 각 가장자리 정점 v에 대해 다음 조건을 확인한다.&lt;br /&gt;
d[$u^&lt;/em&gt;$]  + w($u^&lt;em&gt;$ ,v) &amp;lt; d[v]&lt;br /&gt;
위 조건이 만족된다면 다음을 수행한다&lt;br /&gt;
d[v] = d[$u^&lt;/em&gt;$] + w($u^&lt;em&gt;$, v)&lt;br /&gt;
p[v] = $u^&lt;/em&gt;$&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;다익스트라 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;  T = $\emptyset$    //트리에 포함된 정점들의 집합을 공집합으로 초기화한다&lt;/li&gt;
  &lt;li&gt;  for( i = 0; i &amp;lt; n; i++){&lt;/li&gt;
  &lt;li&gt;  d[i] = $\infty$    //정점 i의 최단 거리를 $\infty$ 로 초기화 한다&lt;/li&gt;
  &lt;li&gt;  p[i] = -1 }    //정점 i의 부모 노드를 -1(없음)으로 초기화한다&lt;/li&gt;
  &lt;li&gt;  d[0] = 0    //출발 정점 0의 최단 거리를 0으로 한다&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;  while(&lt;/td&gt;
          &lt;td&gt;T&lt;/td&gt;
          &lt;td&gt;&amp;lt; n){}&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;  T에 포함되지 않은 정점들 중에서 배열 d의 요소값이 가장 작은 정점 u를 선택한다&lt;/li&gt;
  &lt;li&gt;  T = T U { u}    //선택된 정점을 트리에 추가한다&lt;br /&gt;
// 트리에 새로 추가된 정점의 인접 정점들의 출발 정점으로부터 최단 거리를 갱신한다&lt;/li&gt;
  &lt;li&gt;  for( v = 0; v &amp;lt; n; v++)&lt;/li&gt;
  &lt;li&gt;  if(v $\notin$ T and w[u,v]  0 and d[u] &amp;lt; $\infty$ and d[u] + w[u,v] &amp;lt; d[v] ){&lt;/li&gt;
  &lt;li&gt;  d[v] = d[u] + w[u,v]&lt;/li&gt;
  &lt;li&gt;   p[v] = u }&lt;br /&gt;
}&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;시간복잡도&lt;br /&gt;
    +  기본 연산: 10번 조건 확인
    +  9 ~ 12번의 반복문내에서 기본 연산의 수행 횟수 = n
    +  트리에 모든 정점이 포함되어야 하므로 $\theta$($n^2$)&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">탐욕 기법</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Hash</title>
      <link href="https://lee989898.github.io/sc-09" rel="alternate" type="text/html" title="Hash" />
      <published>2021-10-23T01:06:00+09:00</published>
      <updated>2021-10-23T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-09</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-09">&lt;h3 id=&quot;hash&quot;&gt;&lt;strong&gt;Hash&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Hash와 관련된 Key Concepts인 Integrity와 Authentication을 다시 한번 살펴보자&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Integrity&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무결성&lt;/li&gt;
  &lt;li&gt;원본 그대로임을 보장&lt;/li&gt;
  &lt;li&gt;변조가 없다는 것 혹은 변경이 있었음을 알게 됨&lt;/li&gt;
  &lt;li&gt;주요 공격: modification&lt;/li&gt;
  &lt;li&gt;Integrity를 지키기 위한 Solution : hash&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Authentication&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;인증&lt;/li&gt;
  &lt;li&gt;송수신자 서로간의 신원 확인&lt;/li&gt;
  &lt;li&gt;주요 공격 : impersonation&lt;/li&gt;
  &lt;li&gt;Authentication을 지키기 위환 solution : 전자서명, 공인인증서&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hash Functions&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;임의의 긴 입력 값을 적절하게 처리하여 고정된 길이의 짧은 값을 출력하는 함수&lt;/li&gt;
  &lt;li&gt;Message Authentication Code로 무결성 제공&lt;/li&gt;
  &lt;li&gt;전자 서명으로 sender authentication 제공&lt;/li&gt;
  &lt;li&gt;공인인증서, 가상화폐 등에 사용&lt;/li&gt;
  &lt;li&gt;컴퓨터보안에서 대표적인 hash function은 MD2,4,5 SHA1, HAS160&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://www.miraclesalad.com/webtools/md5.php&quot;&gt;http://www.miraclesalad.com/webtools/md5.php&lt;/a&gt;&lt;br /&gt;
위 사이트에서 임의의ㅣ 입력값에 대한 해쉬값을 관찰할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;해쉬의 특징으로는 대표적으로 3가지가 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;입력길이에 상관없이 출력길이가 일정&lt;/li&gt;
  &lt;li&gt;조금이라도 입력값이 다르면 출력값은 완전히 다름&lt;/li&gt;
  &lt;li&gt;revers가 어렵다(일방향성)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위 성질중 integrity는 2번에 의해서 보장된다.&lt;br /&gt;
Encrypt/decrypt와의 차이점은 3번이다. 복호화가 어렵기 때문이다.&lt;/p&gt;

&lt;p&gt;예를 들어보자 h(x): x/23해서 소수점 7~10자리 수를 추출&lt;br /&gt;
h(345689) = xx.95652177391&lt;br /&gt;
출력값은 일정하나, reverse는 불가능하다.&lt;/p&gt;

&lt;p&gt;그러나 h(232.8395049993) = 7391 처럼 다른 값을 넣었음에도 값이 같은 일명 collision이 일어날 수 있다.&lt;br /&gt;
Collison은 서로 다른 입력값이 같은 해시값을 계산하는 것을 의미한다.&lt;br /&gt;
충동저항성은 collision이 일어날 확률이 작음을 의미한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;MAC&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;메시지 무결성: 변경되지 않은 원본이 맞음&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc01.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;메시지와 해쉬값을 붙어서 보낸다.&lt;br /&gt;
받는사람은 비교해서 같으면 원본 다르면 원본이 아닌걸 알 수 있다.&lt;br /&gt;
하지만 여기서 sender authenticationd은 제공되지 않는다.&lt;br /&gt;
Digital Signature에서 이문제를 해결한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Digital Signature&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무결성과 인증을 동시에 제공&lt;/li&gt;
  &lt;li&gt;키를 사용한다(키를 모르는 사용자는 생성불가)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc02.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;비교하여 같으면 변조되지 않고 보낸사람을 인증해준다.&lt;br /&gt;
하지만 mac도 한계가 있는데 제 3자에 대한 sender authentication이 불가능 하다.&lt;br /&gt;
키를 모르면 인증을 못하기 때문이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Replay Attack&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc03.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 MAC 공격방법이다.&lt;br /&gt;
Attacker는 고객이 보낸 똑같은 패킷을 복사하여 고객으로 위장하는 공격 방법이다.&lt;br /&gt;
이러한 공격을 막는 방법은 패킷에 추가정보로 시간을 알려주는 time stamp를 넣어 해결할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;대표적인 해쉬 함수로는 두가지 계열이 있는데 MD와 SHA 계열이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;MD (Message Digest)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;MD2,4,5,6​&lt;/li&gt;
  &lt;li&gt;Ron Rivest (RSA), 1990~92​&lt;/li&gt;
  &lt;li&gt;Merkle structure기반​&lt;/li&gt;
  &lt;li&gt;128bit hash 값​&lt;/li&gt;
  &lt;li&gt;512 bit block size ​&lt;/li&gt;
  &lt;li&gt;MD4는 32bit CPU 전용 (MS)​&lt;/li&gt;
  &lt;li&gt;MD5는 SHA1등 최신 해시들의 기초가됨​&lt;/li&gt;
  &lt;li&gt;2005 강한 충돌 내성 깨짐&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;SHA (Secure Hash Algorithm)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;NIST 1993​&lt;/li&gt;
  &lt;li&gt;Merkle structure기반​&lt;/li&gt;
  &lt;li&gt;SHA0,1은 160bit hash 값, SHA2는 224~512bit​&lt;/li&gt;
  &lt;li&gt;512 bit block size ​&lt;/li&gt;
  &lt;li&gt;최대 2^64-1 bit 메시지처리​&lt;/li&gt;
  &lt;li&gt;가장 많이 사용​&lt;/li&gt;
  &lt;li&gt;2005 강한 충돌 내성 깨짐&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc04.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 Merkle structure의 예시이다.&lt;br /&gt;
MD, SHA 두가지 모두 Merkle structure기반인데 이것은
Message를 block으로 나누어서 고정된 길이의 입력값을 받아들여 고정된 길이로 출력하는 압축함수를 반복 사용하여 긴 길이의 입력을 처리할 수 있는 해쉬 함수로 학대하여 설계하는 방식이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hash attack&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;같은 해시값을 갖는 다른 입력값을 찾아낸다​&lt;/li&gt;
  &lt;li&gt;예를 들면, (ID, PWD)값은 해시값으로 저장되어 있다.​&lt;/li&gt;
  &lt;li&gt;만일 같은 해시값을 갖는 (ID2, PWD2)를 찾는다면, (ID, PWD)로 로그인 가능​하다&lt;/li&gt;
  &lt;li&gt;(ID, PWD), (ID2, PWD2)를 충돌쌍(collision pairs)라 한다​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">Hash</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">컨트롤 스트럭처</title>
      <link href="https://lee989898.github.io/pl-15" rel="alternate" type="text/html" title="컨트롤 스트럭처" />
      <published>2021-10-22T19:18:00+09:00</published>
      <updated>2021-10-22T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-15</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-15">&lt;h3 id=&quot;컨트롤-스트럭처&quot;&gt;&lt;strong&gt;컨트롤 스트럭처&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;프로그램의 컨트롤 스트럭처에는 3가지가 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;sequence(begin-end)&lt;/li&gt;
  &lt;li&gt;selection(if-else, case)&lt;/li&gt;
  &lt;li&gt;iteration(loop)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;각 컨트롤 스트럭처는 여러 개의 문장으로 구성된다. ​&lt;/p&gt;

&lt;p&gt;스트럭처는 여러 문장의 묶음으로, ​
실행 제어 방법에 따라 각각 키워드(begin, if, while,…)를 포함한다&lt;/p&gt;

&lt;p&gt;여기서 컨트롤 스트럭처의 if, while 문을 제어문이라고 하고, ​
제어문의 실행 결과에 따라 실행되는 문장을 실행문이라고 한다. ​&lt;/p&gt;

&lt;p&gt;시퀀스는 순차적으로 실행되는 문장들의 연속을 말하며, ​
실행 제어가 순차적이라서 시작과 끝만 명시하면 된다.&lt;/p&gt;

&lt;p&gt;Selection은 제어문이 참이냐 거짓이냐에 따라 실행문이 다르며,&lt;br /&gt;
하나의 selection 스트럭처에 제어문과 실행문을 여럿 포함하기도 한다. ​&lt;/p&gt;

&lt;p&gt;Iteration도 제어문과 실행문의 반복으로 구성되는데,&lt;br /&gt;
for, while, repeat 등 목적에 따라 그 신택스와 시맨틱스가 다양하다. ​&lt;/p&gt;

&lt;p&gt;프로그래머는 이들 컨트롤 스트럭처를 사용하여 쉽게 프로그램을 구조화한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;프로그램은 나름의 로직을 갖고 있어서, 이에 따른 실행 제어(flow control)가 필요하다. ​&lt;/p&gt;

&lt;p&gt;명령형 프로그램에서 계산은 다음과 같이 진행된다.&lt;br /&gt;
변수를 읽고 연산자를 실행하여 표현식을 계산하여, ​
변수에 결과 값을 부여한다.&lt;br /&gt;
또, 여러 경로 중에서 선택하여 실행을 제어하거나, ​반복 실행한다. ​&lt;/p&gt;

&lt;p&gt;컨트롤 스트럭처는 제어문과 실행문으로 구성된다. ​
이 표현은 문제가 있다. 시퀀스는 제어문이 없다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;selection-statements&quot;&gt;&lt;strong&gt;Selection Statements&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Selection문은 2개 이상의 실행 경로 중에서 선택하는 것이다. ​&lt;/p&gt;

&lt;p&gt;두가지 범주가 있는데, 둘 중에 하나 선택하는 것과 여럿 중에 선택하는 것이 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;If Statements&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If문의 일반적 형식은 if 제어 표현식 then 실행문1 else 실행문2 이다. ​&lt;/p&gt;

&lt;p&gt;제어 표현식은 산술식이거나 부울식이다. ​&lt;/p&gt;

&lt;p&gt;프로그래밍 언어에서 실행문1과 실행문2는 단순문이거나 복합문이다. ​&lt;/p&gt;

&lt;p&gt;C, C++에서 복합문을 { }로 둘러싼다.&lt;br /&gt;
펄에서 모든 실행문을 { }로 구분하고, 파이썬에서는 indentation으로 구분한다.&lt;/p&gt;

&lt;p&gt;자바에서는 중첩 if문을 허용한다.&lt;br /&gt;
dangling else 문제가 발생할 수 있으니 If에 대응되는 else가 어느 것인지 살펴가며 신중하게 써야 한다.&lt;br /&gt;
자바를 비롯한 대부분의 언어에서는 else를 가장 가까운 if에 대응시킨다.  ​&lt;/p&gt;

&lt;p&gt;C, C++에서는 가장 가까운 if에 else를 대응시키는 것의 대안으로서,&lt;br /&gt;
{}로 둘러싼 복합문을 사용할 수도 있다. ​&lt;/p&gt;

&lt;p&gt;​복합문 대신에 end를 사용하기도 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Switch Statements&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;​Switch는 여러 대안 중에 하나 선택하여 실행할 경우이다. ​&lt;/p&gt;

&lt;p&gt;전형적인 형식은 아래와 같다 ​&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Switch 표현식 {​

case 상수 표현식1 : 실행문1   ​

…​

default … }이다. 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;스위치문의 case는 동시에 상수 표현식을 비교하는 것이 아니라 상수 표현식을 순차적으로 비교하여 끝까지 실행한다. 
 ​이것을 피하려면, break 사용해야 한다.&lt;/p&gt;

&lt;p&gt;C에서는 스위치문의 제어 표현식으로 정수 타입만 허용한다.&lt;br /&gt;
 실행문은 시퀀스, 블록, 복합문을 모두 허용한다.&lt;br /&gt;
 조건이 맞으면 여러 case가 실행가능하다.&lt;br /&gt;
 디폴트시에, ​If문에 의한 제어가 가능하다.&lt;/p&gt;

&lt;p&gt;파이썬에서는 스위치 대신에 if elif를 사용할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;iterative-statements&quot;&gt;&lt;strong&gt;Iterative Statements&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Iteration, recursion은 문장이나 복합문의 반복 실행한다.​ &lt;br /&gt;
 카운터로 제어하는 counter-controlled loop은 반복문의 실행 횟수를 세는 변수를 갖는다. ​초기값, 종료값, 증분(반복할 때마다 더해지는 값)&lt;/p&gt;

&lt;p&gt;설계할 때 고려사항은 Loop 변수의 유형과 스코프를 정의해야 하며,&lt;br /&gt;
Loop에서 변화하는 Loop변수의 값이 룹 제어에 영향을 미치는지 확인해야 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;for Statenebts&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;C의 for 반복문을 보면, ​&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for ([expr_1] ; [expr_2] ; [expr_3]) ​

loop body… 와 같습니다. ​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음과 같이 카운터 변수가 여럿일 수 있고, ​
부울식을 포함할 수 있다. ​&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;For (count1 = 0, count2 = 1.0;​
     count1 &amp;lt;= 10 &amp;amp;&amp;amp; count2 &amp;lt;= 100.0;​
    sum = ++count1 + count2, count2 *= 2); ​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자바에서 컨트롤 표현식은 부울식이어야 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;while Loops&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;​While Loop은 부울식에 의해 제어된다.&lt;br /&gt;
Ctrl_expr는 부울식으로, Loop의 맨앞에 또는 맨뒤에 위치한다. ​&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while (ctrl_expr) ​
loop body… ​

do ​
loop body ​
while (ctrl_expr) ​ ​ 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;User-Located Loop Control&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Break 처럼 loop 컨트롤이 loop body의 중간에 위치하기도 한다.&lt;br /&gt;
이것을 user-located loop control이라고 부른다.&lt;br /&gt;
Break 외에도 continue가 있다.&lt;/p&gt;

&lt;p&gt;자료구조를 구성하는 요소에 의해 제어되는 반복 처리가 있다. ​
Iterator를 호출하면, 자료구조에서 다음 요소를 반환해준다. ​
이밖에 for에서도 자료구조에 의한 반복처리를 제어할 수 있다.  ​&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Unconditional Branching&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;앞에서 언급했듯이 goto는 가독성 문제를 일으킨다.&lt;br /&gt;
자바는 goto가 없다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;guarded-commands&quot;&gt;&lt;strong&gt;Guarded Commands&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;각 문장 앞에 부울식이 있는 것을 가디드 코멘드라고 한다. &lt;br /&gt;
즉 가디드 코멘드는 ​selection 문장의 각 라인이 ​부울식과 ‘하나의 문장 또는 문장의 시퀀스＇로 구성된다. ​&lt;/p&gt;

&lt;p&gt;이렇게 하는 목적은 ​프로그램 개발 중에도 프로그램의 correctness(올바름)를 증명하기 위한 것으로, ​Concurrent 프로그래밍의 기초가 된다. ​&lt;/p&gt;

&lt;p&gt;기존의 언어는 개발(코딩)을 마치고 테스트를 통해 프로그램의 올바름을 확인한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Selection Guarded Command&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Selection의 가디드 코멘드는 ​If 안의 각 문장마다 부울식이 있다. ​&lt;/p&gt;

&lt;p&gt;이 가디드 코멘드의 시맨틱은 다음과 같다.&lt;br /&gt;
부울식을 계산해서, ​나 이상이 참이면, 그 중에 아무거나 선택한다.&lt;br /&gt;
아무것도 참이 아니면, 실행 오류로 처리한다.​&lt;br /&gt;
프로그램의 correctness는 선택된 문장에 종속되지 않는다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if x &amp;gt;= y -&amp;gt; max := x​
[] y &amp;gt;= x =&amp;gt; max := y​
fi

if (x &amp;gt;= y)​  
    max = x;​
else​
    max = y;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;X, y가 같을 때, 전자는 아무거나 선택되어 수행되나, ​
후자는 max=x가 수행됨.&lt;br /&gt;
따라서, non-deterministic vs. deterministic&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Loop Guarded Command&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;do &amp;lt;Boolean&amp;gt; -&amp;gt; &amp;lt;statement&amp;gt;​
[] &amp;lt;Boolean&amp;gt; -&amp;gt; &amp;lt;statement&amp;gt;​
...​
[] &amp;lt;Boolean&amp;gt; -&amp;gt; &amp;lt;statement&amp;gt;​
od​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Loop 가디드 코멘드에서, ​Do 다음에 나오는 모든 문장의 앞에 부울식이 있다. ​
​
룹 가디드 코멘드의 시맥틱스는 다음과 같다.&lt;br /&gt;
부울식을 계산하고, ​
하나 이상이 참이면, ​
아무거나 선택하여 룹을 시작한다.&lt;br /&gt;
아무것도 참이 아니면, 룹에서 나온다.&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">컨트롤 스트럭처</summary>
      

      
      
    </entry>
  
</feed>
