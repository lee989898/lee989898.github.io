<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://lee989898.github.io/author/lee989898/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://lee989898.github.io/" rel="alternate" type="text/html" />
  <updated>2021-11-09T21:31:37+09:00</updated>
  <id>https://lee989898.github.io/author/lee989898/feed.xml</id>

  
  
  

  
    <title type="html">LEE | </title>
  

  
    <subtitle>공부 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">NP-완전</title>
      <link href="https://lee989898.github.io/algorithm-06" rel="alternate" type="text/html" title="NP-완전" />
      <published>2021-11-09T01:09:00+09:00</published>
      <updated>2021-11-09T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-06</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-06">&lt;h3 id=&quot;np-완전&quot;&gt;&lt;strong&gt;NP-완전&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;문제의 분류&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;풀 수 있는(solvable) 문제​
    &lt;ul&gt;
      &lt;li&gt;P 문제: 다항 시간 내에 풀 수 있는 문제 ​&lt;/li&gt;
      &lt;li&gt;NP 문제: 다항 시간 내에 풀 수 없는 문제​
        &lt;ul&gt;
          &lt;li&gt;비결정론적 다항 시간 알고리즘으로 해결할 수 있는 문제​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;NP-완전 문제: 지수 시간 내에 풀 수 있는 문제​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;풀 수 없는(unsolvable) 문제​
    &lt;ul&gt;
      &lt;li&gt;예: 정지 문제(Halting Problem)​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag14.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;결정 문제​
    &lt;ul&gt;
      &lt;li&gt;Yes 혹은 No의 해를 요구하는 문제​&lt;/li&gt;
      &lt;li&gt;예: 무방향그래프의 정점 s 에서 정점 f 까지 가는 경로의 거리가 K(상수) 이하인 경로가 있는가?​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최적화 문제​
    &lt;ul&gt;
      &lt;li&gt;최적의 해를 요구하는 문제​&lt;/li&gt;
      &lt;li&gt;예: 무방향그래프의 정점 s 에서 정점 f 까지 가는 최단 경로의 거리는 얼마인가?​&lt;/li&gt;
      &lt;li&gt;최적화 문제는 모두 대응하는 결정 문제로 바꾼 다음 해결한다.​&lt;/li&gt;
      &lt;li&gt;최적화 문제는 대응하는 결정 문제보다 풀기가 쉽지 않다. ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;비결정론적 다항 시간 알고리즘에 의해 해결할 수 있는 결정 문제들의 집합​&lt;/li&gt;
  &lt;li&gt;비결정론적 다항 시간 알고리즘이란?​
    &lt;ul&gt;
      &lt;li&gt;한 결정 문제의 사례 I를 입력으로 받아 다음을 수행하는 2 단계 알고리즘​&lt;/li&gt;
      &lt;li&gt;비결정론적 ‘추측’ 단계: 주어진 사례 I에 대한 해 S를 ‘추측’한다.​&lt;/li&gt;
      &lt;li&gt;결정론적 ‘확인’ 단계: 사례 I와 해 S를 입력으로 받아 S가 I에  대한 해임을 결정론적 다항 시간에 확인하고 그 해가 맞으면 ‘Yes’ 라고 답하고 해가 아니라면 ‘No’ 라고 답하거나 알고리즘이 종료되지 않게 한다. ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;NP 문제는 해가 Yes 라는 근거가 주어졌을 때 그 해가 옳은 근거임을 다항 시간에 확인해 줄 수 있다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-완전 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;NP에 속하는 문제​&lt;/li&gt;
  &lt;li&gt;어떤 NP-완전 문제를 다항 시간 알고리즘에 의해 풀 수 있다면 나머지 모든 NP-완전 문제들도 다항 시간 알고리즘에 의해 풀 수 있다.​&lt;/li&gt;
  &lt;li&gt;NP-완전 문제는 결정 문제만으로 국한한다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-완전 문제의 핵심 원리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;결정 문제의 변환을 이용한 해결 과정​
    &lt;ul&gt;
      &lt;li&gt;결정 문제 A를 다항 시간에 해결할 수 있는지 알고 싶다.​&lt;/li&gt;
      &lt;li&gt;가정​
        &lt;ul&gt;
          &lt;li&gt;다항 시간에 해결 가능한 결정 문제 B를 이미 알고 있다.​&lt;/li&gt;
          &lt;li&gt;문제 A를 다항 시간에 문제 B로 변환할 수 있고 문제 B의 해(Yes 혹은 No)가 문제 A의 해와 항상 일치한다.​
            &lt;ol&gt;
              &lt;li&gt;문제 A의 사례를 문제 B의 사례로 변환한다. ​&lt;/li&gt;
              &lt;li&gt;변환된 문제 B의 사례를 문제 B의 알고리즘을 이용하여 해결한다.&lt;br /&gt;
주: 문제 A도 다항 시간에 해결할 수 있다.​&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다항 시간에 해결할 수 있는 결정 문제가 아직까지 발견되지   않았다. 따라서 문제 A를 다항 시간에 해결할 수 있는지는 알 수 없다. ​&lt;/li&gt;
  &lt;li&gt;NP-완전 문제들은 서로 다항 시간에 변환 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-완전 정의&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;결정 문제 D는 다음 조건들을 만족시켜야 한다. ​
    &lt;ol&gt;
      &lt;li&gt;문제 D는 NP에 속한다.​&lt;/li&gt;
      &lt;li&gt;NP에 속한 모든 문제는 다항 시간에 문제 D로  변환 가능하다.​&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-hard&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;NP-완전보다 넓은 범위의 문제를 포함한다. ​&lt;/li&gt;
  &lt;li&gt;문제 A가 다음 조건을 만족하면 NP-hard이다.​
    &lt;ul&gt;
      &lt;li&gt;NP에 속한 모든 문제는 다항 시간에 문제 A로 변환 가능하다. ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;NP-완전 문제는 NP-hard에 속한다. ​&lt;/li&gt;
  &lt;li&gt;NP-hard 문제는 반드시 NP 문제일 필요는 없다.​&lt;/li&gt;
  &lt;li&gt;NP-hard는 최적화 문제도 포함한다.​&lt;/li&gt;
  &lt;li&gt;문제 A가 다음 조건들을 만족하면 NP-완전이다. ​
    &lt;ol&gt;
      &lt;li&gt;A는 NP에 속한다.​&lt;/li&gt;
      &lt;li&gt;A는 NP-hard이다. ​&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag15.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;한 문제가 NP-hard에 속한다는 것을 증명하는 것은 매우 어렵다. 왜냐하면 NP에 속한 모든 문제를 다항 시간에 그 문제로 변환 가능함을 보여야 하기 때문이다. ​&lt;/li&gt;
  &lt;li&gt;정리: 한 NP-hard 문제를 다항 시간에 주어진 문제로 변환 가능하다면 그 문제는 NP-hard에 속한다. ​&lt;/li&gt;
  &lt;li&gt;한 문제가 NP-hard에 속한다는 증명은 이 정리를 이용한다.​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;문제 A의 NP-완전 증명 방법​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;문제 A가 NP에 속함을 보인다.​&lt;/li&gt;
  &lt;li&gt;한 NP-hard 문제 C의 사례를 다항 시간에 문제 A의 사례로 변환하는 알고리즘을 작성한다.​&lt;/li&gt;
  &lt;li&gt;2의 알고리즘을 수행하여 얻은 결과 사례 C와 사례 A의 Yes/No 해가 일치함을 보인다.​&lt;br /&gt;
주: 어떤 문제가 NP-완전 문제임을 증명하는 것은 쉽지 않다. ​&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-완전 문제​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;논리곱 정규형-만족​&lt;/li&gt;
  &lt;li&gt;완전 부분 그래프​&lt;/li&gt;
  &lt;li&gt;정점 커버​&lt;/li&gt;
  &lt;li&gt;부분 집합의 합​&lt;/li&gt;
  &lt;li&gt;그래프 색칠하기​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;논리곱 정규형-만족 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;부울 연산식은 논리곱 정규형으로 표현될 수 있다.&lt;/li&gt;
  &lt;li&gt;문제: 논리곱 정규형의 주어진 부울 연산식의 값이 true가 되도록 부울 연산식의 변수들에 true나 false 값을 할당할 수 있는가?&lt;/li&gt;
  &lt;li&gt;예: a,b,c -부울 변수,$\bar{a}$, $\bar{b}$ , $\bar{c}$ : a,b,c의 역&lt;br /&gt;
부울 연산삭: ($\bar{a}$ $\lor$ $\bar{b}$ $\lor$ c) $\land$ ($\bar{a}$ $\lor$ b) $\land$ (a $\lor$ $\bar{b}$ $\lor$ $\bar{c}$ )
해: a = true, b = true, c = true&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;완전 부분 그래프​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무방향 그래프 내에 있는 최대 크기의 완전 부분 그래프를 찾아라&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/ag/ag16.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;정점 커버​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무방향 그래프 내에 있는 최소 크기의 정점 커버를 찾아라&lt;/li&gt;
  &lt;li&gt;정점 커버: 무방향 그래프에서 각 간선의 양쪽 끝의 두 정점들 중에서 적어도 1개의 정점을 포함하는 정점들의 집합&lt;/li&gt;
  &lt;li&gt;예: 아래 그래프에서 최소 크기의 정점 커버 C = {a,c,e}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/ag/ag17.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;부분 집합의 합 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;정수들의 집합 S의 요소들의 합이 K가 되는 S의 부분 집합을 찾아라.&lt;/li&gt;
  &lt;li&gt;예: S = {10,20,40,70,80}, K = 160
    &lt;ul&gt;
      &lt;li&gt;부분 집합{10,70,80}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;그래프 색칠하기 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무방향 그래프에서 인접한 정점들을 서로 다른색으로 가장 적은 수의 색을 사용하여 색칠하라&lt;/li&gt;
  &lt;li&gt;예: 아래 그래프에서 a,c: 빨강, b,d: 초록, e: 파랑&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/ag/ag18.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">NP-완전</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">접근 제어</title>
      <link href="https://lee989898.github.io/sc-12" rel="alternate" type="text/html" title="접근 제어" />
      <published>2021-11-04T01:06:00+09:00</published>
      <updated>2021-11-04T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-12</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-12">&lt;h3 id=&quot;접근-제어&quot;&gt;&lt;strong&gt;접근 제어&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Access Control&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;허가되지 않은 사용자의 자원 접근 막고&lt;/li&gt;
  &lt;li&gt;정당한 사용자라도 허가되지 않은 방법으로 자원사용 막고&lt;/li&gt;
  &lt;li&gt;정당한 사용자가 허가된 방식으로만 자원에 접근하도록&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Access control components&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc17.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Authentication function: 사용자가 시스템에 접근할 수 있는지 결정&lt;/li&gt;
  &lt;li&gt;Access control function: 사용자의 요청이 허용되는지 결정&lt;/li&gt;
  &lt;li&gt;Security admin: 사용자의 요청이 자원에 어떻게 접근하는지를 명시한 권한 DB를 관리&lt;/li&gt;
  &lt;li&gt;Audit: 사용자가 시스템 자원에 접근하는 것을 기록, 감시&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Access control architecture&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc18.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Access Control Policy&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;접근 제어 정책&lt;/li&gt;
  &lt;li&gt;어떤 상황에서, 누구에게 어떤 종류의 접근이 허용되는지를 결정&lt;/li&gt;
  &lt;li&gt;권한 DB에 저장되며 보안 admin이 관리&lt;/li&gt;
  &lt;li&gt;종류 (동시에 사용가능)
    &lt;ul&gt;
      &lt;li&gt;Discretinoary access control(DAC)&lt;/li&gt;
      &lt;li&gt;Mandatory access control(MAC)&lt;/li&gt;
      &lt;li&gt;Role-based access control(RBAC)&lt;/li&gt;
      &lt;li&gt;Attribute-based access control(ABAC)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Discretinoary access control(DAC)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;임의 접근 제어&lt;/li&gt;
  &lt;li&gt;요청자의 신분에 따라 무엇을 할 수 있는지 정의&lt;/li&gt;
  &lt;li&gt;Window, unix 등 컴퓨터 시스템 널리 사용&lt;/li&gt;
  &lt;li&gt;Access Matrix 사용
    &lt;ul&gt;
      &lt;li&gt;주체와 객체, 권한을 행렬로 표현&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Access matrix
    &lt;ul&gt;
      &lt;li&gt;행: 자원접근 주체, subject&lt;/li&gt;
      &lt;li&gt;열: subject가 접근하는 대상자원, object&lt;/li&gt;
      &lt;li&gt;Entry: 허용되는 접근&lt;/li&gt;
      &lt;li&gt;-Matrix가 커질 수 있고, 희박해지면 메모리 낭비&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc19.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;방법1. ACL - Access control lists
    &lt;ul&gt;
      &lt;li&gt;Access matrix를 열로 분리&lt;/li&gt;
      &lt;li&gt;객체에 대한 권한을 가진 주체 파악에 유리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc20.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;방법2. Capablility tickets
    &lt;ul&gt;
      &lt;li&gt;Access matrix 행으로 분리&lt;/li&gt;
      &lt;li&gt;특정 주체에 대해 승인된 객체와 권한 명시&lt;/li&gt;
      &lt;li&gt;특정 사용자에 허가된 객체/권한들을 정리하기 쉬움&lt;/li&gt;
      &lt;li&gt;다른 주체에서 티켓을 빌려 주거나 양도 -&amp;gt; 보안문제 발생&lt;/li&gt;
      &lt;li&gt;티켓 무결성, 기밀성, 인증성&lt;/li&gt;
      &lt;li&gt;OS가 관리&lt;/li&gt;
      &lt;li&gt;분산, Cloud 환경에 적합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc21.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;방법 3. authorization table
    &lt;ul&gt;
      &lt;li&gt;한 행에 한 주제의 한 자원에 대한 권한명시&lt;/li&gt;
      &lt;li&gt;RDB로 구현 용이&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc22.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;DAC 장단점 분석
    &lt;ul&gt;
      &lt;li&gt;장점
        &lt;ul&gt;
          &lt;li&gt;객체별 세분화된 접근 제어가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;단점
        &lt;ul&gt;
          &lt;li&gt;Access Matrix 사용에 따른 메모리 낭비&lt;/li&gt;
          &lt;li&gt;주체나 객체별로 제어하기 때문에, 전체 자원의 일관성 있는 제어 어려움&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Role-based access control (RBAC)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;각 사용자 대신에 역할에 접근 권할을 할당&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;상업적으로 회사,기관,조직에서 많이 쓰임&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자 vs 역할 vs 자원의 관계는 다대다&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;관계는 동적이다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;RBAC 장단점 분석
    &lt;ul&gt;
      &lt;li&gt;장점
        &lt;ul&gt;
          &lt;li&gt;전체적으로 일관성있는 제어정책가능&lt;/li&gt;
          &lt;li&gt;직무분석 용이&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;단점
        &lt;ul&gt;
          &lt;li&gt;각 주체, 객체별 유연하게 하기 어려움&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Attribute-based access control(ABAC)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;가장 최근&lt;/li&gt;
  &lt;li&gt;주체와 자원의 속성을 표현&lt;/li&gt;
  &lt;li&gt;DAC, RBAC의 기본개념 실형가능&lt;/li&gt;
  &lt;li&gt;유연성과 표현력이 우수&lt;/li&gt;
  &lt;li&gt;3요소 - 속성, 정책 모델, 아키텍처 모델&lt;/li&gt;
  &lt;li&gt;+유연하고 세분화 보안정책 설계&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-설계자 과다업무, 비용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;속성
    &lt;ul&gt;
      &lt;li&gt;주체, 객체, 환경, 권한에 의해 미리 정의되고 할당된 요구되는 동작의 특정 측면을 정의하는 성질​&lt;/li&gt;
      &lt;li&gt;주체 속성​
        &lt;ul&gt;
          &lt;li&gt;주체는 정보가 객체사이에 이동하거나 시스템 상태를 변경하는 능동적 존재(User, application, process, device)​&lt;/li&gt;
          &lt;li&gt;주체의 이름, 소속, 직책 등​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;객체 속성​
        &lt;ul&gt;
          &lt;li&gt;정보를 포함하거나 받는 수동적 시스템 존재 (file, device, table, record, process, program, network)​&lt;/li&gt;
          &lt;li&gt;MS Word문서는 이름, 저자, 날짜 등을 속성으로 가짐​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;환경 속성​
        &lt;ul&gt;
          &lt;li&gt;운영, 기술, 상황, 환경 기술​&lt;/li&gt;
          &lt;li&gt;현재 날짜, 시간, 네트워크 보안 레벨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">접근 제어</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">ImplementSubprogram</title>
      <link href="https://lee989898.github.io/pl-17" rel="alternate" type="text/html" title="ImplementSubprogram" />
      <published>2021-11-03T19:18:00+09:00</published>
      <updated>2021-11-03T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-17</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-17">&lt;h3 id=&quot;implementsubprogram&quot;&gt;&lt;strong&gt;ImplementSubprogram&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;서브프로그램 호출과 반환의 구현, 이것을 서브프로그램 링키지(linkage)라고 합니다.​&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Semantics of Calls and Returns&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;서브프로그램 링키지는 호출과 반환에 관련된 액션들의 실행으로 구성된다. ​&lt;br /&gt;
이러한 액션들을 호출 및 반환 시맨틱이라고 한다. ​&lt;/p&gt;

&lt;p&gt;일반적인 서브프로그램 호출 시맨틱은 다음을 포함한다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;파라미터 패싱 방법의 구현, ​&lt;/li&gt;
  &lt;li&gt;로컬 변수에 대한 스토리지 할당 및 바인딩 (로컬 변수가 정적 변수가 아닐 경우) ​&lt;/li&gt;
  &lt;li&gt;콜러의 실행 상태 저장: ​
    &lt;ul&gt;
      &lt;li&gt;실행상태는 콜러의 재실행(resume)에 필요한 레지스터 값, CPU 상태 비트, 환경 포인터(EP)를 포함하며,​&lt;/li&gt;
      &lt;li&gt;EP는 콜리의 실행 중에, 로컬 변수 및 파라미터를 접근하는데 사용된다.  ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;콘트롤을 콜리에게 이전​&lt;/li&gt;
  &lt;li&gt;콜리에 나타나는 난로컬 변수의 접근 메커니즘의 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서브프로그램의 반환 시맨틱은 다음을 포함한다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;포말 파라미터의 로컬 값을 액추얼 파라미터에게 인아웃 또는 아웃 모드로 카피​&lt;/li&gt;
  &lt;li&gt;로컬 변수의 스토리지를 해제​&lt;/li&gt;
  &lt;li&gt;콜러 실행 상태의 재저장​&lt;/li&gt;
  &lt;li&gt;콜러에게 콘트롤 이전&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Implementing “Simple” Subprograms&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;단순 서브프로그램의 호출 및 반환을 어떻게 구현하는지 보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;단순 서브프로그램에서는 ​서브프로그램의 중첩을 허용하지 않고, 모든 로컬 변수가 정적이다. ​&lt;/li&gt;
  &lt;li&gt;호출과 반환에 필요한 스토리지는 다음의 데이터를 포함한다. ​
    &lt;ul&gt;
      &lt;li&gt;콜러의 상태 정보, 파라미터, 복귀 주소, 함수의 반환값​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단순 서브프로그램은 서브프로그램 코드와 데이터로 구성되는데, ​
    &lt;ul&gt;
      &lt;li&gt;데이터 파트는 로컬 변수, 호출과 반환에 필요한 데이터(위에 언급된)를 포함한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;단순 서브프로그램의 호출 시맨틱스(액션과 그 순서)은 다음과 같다. ​&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;현재 수행중인 프로그램(콜러)의 실행 상태를 저장 ​&lt;/li&gt;
  &lt;li&gt;파라미터의 계산 및 패스​&lt;/li&gt;
  &lt;li&gt;콜리에게 복귀 주소를 패스​&lt;/li&gt;
  &lt;li&gt;콜리에게 컨트롤을 이전&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;단순 프로그램의 반환 시맨틱스(액션과 그 순서)는 다음과 같다. ​&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;포말 파라미터의 현재 값을 대응하는 액추얼 파라미터에게 카피 (만일 pass-by-value-result나 pass-by-value라면) ​&lt;/li&gt;
  &lt;li&gt;함수 값을 콜러에게 카피(만일 콜리가 함수라면) ​&lt;/li&gt;
  &lt;li&gt;콜러의 실행 상태를 재저장​&lt;/li&gt;
  &lt;li&gt;콜러에게 컨트롤을 재이전(되돌려줌)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;실행중인 서브프로그램의 데이터 파트를 위한 데이터 구조로 액티베이션 레코드를 정의한다.&lt;br /&gt;
액티베이션 레코드는 로컬 변수, 파라미터, 복귀 주소로 구성된다.&lt;br /&gt;
단순 서브프로그램의 액티베이션 레코드(AR)는 크기가 고정되어 있고, ​정적으로 할당된다.&lt;br /&gt;
따라서 스택에 저장되지 않는다. ​이러한 액티베이션 레코드는 recursion을 지원할 수 없다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl41.png&quot; width=&quot;25%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 단순 서브프로그램의 액티베이션 레코드의 예이다.&lt;br /&gt;
예에서 단순 서브프로그램은 A, B, C이고, 이들의 코드와 액티베이션 레코드는 오른쪽 그림과 같이 메모리에 할당된다.&lt;br /&gt;
메모리에 할당되는 A, B, C의 코드와 데이터의 위치는 ​정적으로 할당되기 때문에 호출되는 순서와 무관하다.&lt;br /&gt;
A, B, C 모두 별개로 컴파일될 수 있으며, ​이 경우 링커에 의해 그림과 같이 모아진다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Implementing Subprograms with Stack-Dynamic Local Variables&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;서브프로그램의 로컬 변수가 스택-동적일 경우, ​서브프로그램의 호출 및 반환 구현에 대해 알아보자.&lt;/p&gt;

&lt;p&gt;스택 동적 로컬 변수는 런타임 스택에 할당된다. ​장점은 recursion의 지원이다.  ​&lt;/p&gt;

&lt;p&gt;스택-동적 로컬 변수가 있는 서브프로그램의 호출과 반환을 구현하려면 ​액티베이션 레코드가 더욱 복잡해진다.  ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;컴파일러는 ‘스택에서 로컬 변수의 암묵적인 할당과 해제’를 지원하기 위한 코드를 생성해야 한다.  ​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Recursion은 하나의 서브프로그램에 대해 여러 개의 액티베이션 레코드를 추가할 가능성이 있다. ​즉, 액티베이션 레코드 여러 개가 스택에 생성된다.&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int AddTwo(int x,y)
{
  int sum;
  sum = x + y;
  return sum;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 함수를 실행하려면 어떤 데이터가 필요할까?&lt;br /&gt;
파라미터 x, y, 로컬 변수 sum, AddTwo 종료후 복귀할 return address&lt;br /&gt;
이와 같이, 액티베이션 레코드는 함수를 한번 실행하는데 필요한 데이터로 구성된다. ​&lt;/p&gt;

&lt;p&gt;그러면… 스택에 저장된 이들 변수를 어떻게 접근할까? ​&lt;br /&gt;
Caller의 스택 포인터를 이용하면 가능한가? 아니다.&lt;br /&gt;
SP는 액티베이션 레코드를 스택에 저장하고자 할 때, ​스택 메모리를 할당하고(나중에 해제하는) ‘시스템이 사용하는’ 레지스터이다.&lt;br /&gt;
따라서 서브프로그램이 사용할 수 있는 레지스터가 아니다.&lt;/p&gt;

&lt;p&gt;​액티베이션 레코드에 저장된 파라미터나 로컬 변수에 접근하려면, ​&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;액티베이션 레코드에 접근할 때, ​BP(베이스 포인터)를 사용한다.&lt;br /&gt;
BP는 AR의 맨앞의 주소를 말하며, ​서브프로그램의 실행 중에 변경되지 않는다.&lt;br /&gt;
BP는 지정된 레지스터에 저장되는데, 그림에서 이것을 BP라고 표시하자. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;파라미터나 로컬 변수에 접근하려면, ​BP+옵셋을 계산하여 스택에 저장된 파라미터나 로컬 변수에 접근한다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서브프로그램이 종료되어 반환될 때, ​BP는 ‘caller의 액티베이션 레코드의 BP’로 재저장된다.&lt;br /&gt;
여기서 return addr는 복귀 주소로, ​서브프로그램의 종료후 되돌아갈 caller의 위치를 나타낸다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;BP는 항상 현재 실행 중인 프로그램의 액티베이션 레코드의 시작 주소를 가리킨다.&lt;br /&gt;
서브 프로그램이 호출되면, 현재 BP는 callee의 액티베이션 레코드(dynamic link)에 저장되고 ​BP는 새로 생성된 callee의 액티베이션 레코드의 시작 주소를 가리키도록 새롭게 설정된다.&lt;br /&gt;
즉, callee로부터 반환되자마자, BP는 callee의 액티베이션 레코드(dynamic link)의 값으로 재저장된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl42.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl43.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 코드와 데이터, 서브프로그램 링키지 코드(AddTwo PROC),그리고 액티베이션 레코드가 저장된 스택을 보여준다.&lt;br /&gt;
esp, ebp는 각각 스택포인터, 베이스 포인터이며, eax는 반환값을 저장하는 장소이다&lt;/p&gt;

&lt;p&gt;AddTwo PROC은 스택에 할당된 액티베이션 레코드에 접근하여, ​스택에 저장된 두 수를 더하여 eax에 저장하여 반환하고, 반환후 5와 6이 저장되었던 8 바이트를 청소하고 종료하는 과정을 보여준다.&lt;br /&gt;
이때 EBP, ESP를 caller의 것으로 변경한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl44.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Recursion이 없이, 여러 서브프로그램으로 구성된 프로그램에서, ​메인이 B를 호출하고, ​B가 C를 호출하고, ​A가 C를 호출한다고 하자. &lt;br /&gt;
그렇게 되면, 위와 같이 액티베이션 레코드가 스택 메모리에 할당된다.&lt;br /&gt;
동적 링크는 바로 아래(caller)의 액티베이션 레코드를 가리킨다.&lt;/p&gt;

&lt;p&gt;이와 같이, 스택에 스택-동적 액티베이션 레코드가 연속적으로 쌓여진 것을 동적 체인(dynamic chain)이라고 한다.&lt;br /&gt;
로컬 변수의 접근은 BP와 옵셋을 계산에 의하며, 이러한 옵셋을 로컬 옵셋이라고 한다.&lt;br /&gt;
로컬 변수의 로컬 옵셋은 컴파일러에 의해 컴파일 타임에 결정된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl45.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl46.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl47.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Recursion이 있을 때, ​액티베이션 레코드는  위의 그림과 같다. ​
여기서 파라미터는 n이다.&lt;/p&gt;

&lt;p&gt;첫째, 둘째, 셋째 recursion을 호출했을 때 function value가 모두 ?
셋째 recursion을 종료되었을 때 둘째 호출이 종료되었을 때 function value가 모두 ?이 아니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Nested Subprograms&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;중첩 서브프로그램의 호출과 반환 구현 방법을 살펴 보자.&lt;/p&gt;

&lt;p&gt;서브프로그램이 그 안에 다른 서브프로그램을 포함하는 경우, 이것을 중첩 서브프로그램이라고 부른다.&lt;/p&gt;

&lt;p&gt;중첩 서브프로그램에서, 난로컬 변수에 어떻게 접근할 것인가?&lt;br /&gt;
이들 변수는 스택의 액티베이션 레코드에 있다. ​&lt;/p&gt;

&lt;p&gt;난로컬 변수에 접근하려면, ​먼저 스택에서 올바른 액티베이션 레코드를 찾아야 한다.&lt;br /&gt;
다음, 액티베이션 레코드 내에서 그 변수의 옵셋을 찾아야 한다. ​&lt;/p&gt;

&lt;p&gt;정적 스코프일 경우, ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;정적 조상 스코프에 선언된 변수가 나타나고 접근될 수 있다. ​&lt;/li&gt;
  &lt;li&gt;언급된 모든 난로컬 변수는 스택의 다른 액티베이션 레코드에 할당되어 있다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;올바른 액티베이션 레코드를 찾으려면, ​정적 조상의 액티베이션 레코드를 체인으로 연결하라.&lt;/p&gt;

&lt;p&gt;정적 링크는 정적 부모의 시작 주소를 가리키는 포인터이다.&lt;br /&gt;
정적 체인은 실행 중인 서브프로그램의 정적 부모를 포함해서 모든 정적 조상을 연결한다. ​&lt;/p&gt;

&lt;p&gt;체인을 따라가면, 올바른 액티베이션 레코드를 찾을 수 있다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;스코프의 중첩은 정적이기 때문에 컴파일 타임에 미리 알려진다. ​&lt;/li&gt;
  &lt;li&gt;따라서 쉽게 찾아갈 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정적 체인을 따라가는데 필요한 정보는&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;static_depth: 정적 스크프의 중첩 깊이​&lt;/li&gt;
  &lt;li&gt;Chain_offset(또는 nesting_depth): 난로컬 변수를 언급한 서브프로그램의 staic_depth 와 난로컬 변수를 선언한 서브프로그램의 static_depth 간의 차이 ​변수의 언급은 (chain_offset, local_offset)으로 표현되며, local_offset 은 액티베이션 레코드 내에서 언급된 변수의 옵셋이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;호출할 때, 액티베이션 레코드를 생성한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;동적 링크는 스택의 olld 탑 포인터이다​&lt;/li&gt;
  &lt;li&gt;정적 링크는 ‘가장 최근의 정적 부모’의 액티베이트 레코드를 가리킨다.​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;액티베이션 레코드를 생성한 후, 정적 체인을 생성하는 방법은 두가지가 있다.  ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;동적 체인을 따라가면서 부모 스코프를 찾는다. ​&lt;/li&gt;
  &lt;li&gt;컴파일러가 서브프로그램 호출을 만나면, 호출된 서브프로그램의 정적 부모를 찾아서 그 부모로부터의 nesting_depth를 기록한다. 그 서브프로그램이 호출될 때, 콜러의 정적 링크에 있는 값과 nesting_depth의 수로부터 callee의 정적 링크를 찾을 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정적 체인은 다음과 같은 문제를 내포하고 있다.&lt;br /&gt;
중첩 깊이가 크면, 난로컬 변수에 대한 참조(레퍼런스)가 늦다.&lt;br /&gt;
난로컬 참조의 비용 산출이 어렵다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Implementing Dynamic Scoping&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Deep Access
딥액세스는 동적 체인에서 액티베이션 레코드를 검색하여 난로컬 참조를 찾는다.&lt;/li&gt;
  &lt;li&gt;체인의 길이를 정적으로 결정할 수 없다. ​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 액티베이션 레코드는 검색 과정을 위해 변수명을 가져야 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Shallo Access
쉘로우 액세스는 각 변수명마다 하나의 스택을 유지하고, 중앙 테이블에 각 변수명에 대해 하나의 엔트리를 할당한다.  ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">ImplementSubprogram</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">프로세스통신-pipe</title>
      <link href="https://lee989898.github.io/st-08" rel="alternate" type="text/html" title="프로세스통신-pipe" />
      <published>2021-10-31T01:06:00+09:00</published>
      <updated>2021-10-31T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/st-08</id>
      <content type="html" xml:base="https://lee989898.github.io/st-08">&lt;h3 id=&quot;프로세스통신-pipe&quot;&gt;&lt;strong&gt;프로세스통신-pipe&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="system" />
      

      
        <summary type="html">프로세스통신-pipe</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">이메일 보안</title>
      <link href="https://lee989898.github.io/sc-11" rel="alternate" type="text/html" title="이메일 보안" />
      <published>2021-10-31T01:06:00+09:00</published>
      <updated>2021-10-31T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-11</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-11">&lt;h3 id=&quot;이메일-보안&quot;&gt;&lt;strong&gt;이메일 보안&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;PGP&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;운영체제에 상관없이 확정성이 뛰어나다&lt;/li&gt;
  &lt;li&gt;S/MIME&lt;/li&gt;
  &lt;li&gt;공개키 기반의 프로토콜이다&lt;/li&gt;
  &lt;li&gt;RSA, El Gamel을 사용한다&lt;/li&gt;
  &lt;li&gt;대칭키 방식과도 연동된다(3DES)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Requirements of secure E-mail&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;기밀성&lt;/li&gt;
  &lt;li&gt;송신자 인증&lt;/li&gt;
  &lt;li&gt;메시지 무결성&lt;/li&gt;
  &lt;li&gt;수신자 인증&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Secure e-mail: 기밀성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc10.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;앨리스는 기밀성을 입증한 e-mail, m을 밥에게 보내고 싶다&lt;/li&gt;
  &lt;li&gt;랜덤 대칭키를 생성한다, K&lt;sub&gt;S&lt;/sub&gt;&lt;/li&gt;
  &lt;li&gt;메시지를  K&lt;sub&gt;S&lt;/sub&gt;로 encrypt한다&lt;/li&gt;
  &lt;li&gt;또한 K&lt;sub&gt;S&lt;/sub&gt;를 밥의 공개키로 encrypt한다&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;밥에게 K&lt;sub&gt;S&lt;/sub&gt;(m)과 K&lt;sub&gt;B&lt;/sub&gt;(K&lt;sub&gt;S&lt;/sub&gt;)를 보낸다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;밥은 그의 private키로 decrypt하여 K&lt;sub&gt;S&lt;/sub&gt;를 찾아낸다&lt;/li&gt;
  &lt;li&gt;K&lt;sub&gt;S&lt;/sub&gt;로 K&lt;sub&gt;S&lt;/sub&gt;(m)을 decrypt하여 m을 찾아낸다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Secure e-mail: 송신자 인증, 무결성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc11.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;앨리스는 송신자 인증과 메시지 무결성을 지키고 싶다&lt;/li&gt;
  &lt;li&gt;앨리스는 메세지를 digitally 사인한다&lt;/li&gt;
  &lt;li&gt;메시지와 디지털 시그니처 모두 보낸다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Secure e-mail: all together&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc12.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;앨리스는 보안,송신자 인증,메시지 무결성을 지키고 싶다&lt;/li&gt;
  &lt;li&gt;앨리스는 3가지 키를 사용한다
    &lt;ul&gt;
      &lt;li&gt;그녀의 private key&lt;/li&gt;
      &lt;li&gt;밥의 public key&lt;/li&gt;
      &lt;li&gt;새로 만들어진 대칭키&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Email 보안 표준&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;PGP&lt;/li&gt;
  &lt;li&gt;S/MIME
    &lt;ul&gt;
      &lt;li&gt;이메일을 위해 MIME에 보안서비스 제공 표준&lt;/li&gt;
      &lt;li&gt;인증,무결성,부인방지,기밀성 제공&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc09.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">이메일 보안</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">signature</title>
      <link href="https://lee989898.github.io/sc-10" rel="alternate" type="text/html" title="signature" />
      <published>2021-10-31T01:06:00+09:00</published>
      <updated>2021-10-31T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-10</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-10">&lt;h3 id=&quot;signature&quot;&gt;&lt;strong&gt;signature&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;서명&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;자기의 동일성을 표시하고 책임을 분명하기 하기 위하여 문서 따위에 자기 이름을 써넣음​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;전자서명의 기본 아이디어&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;송신자(alice)는 자신의 비밀키로 암호화​&lt;/li&gt;
  &lt;li&gt;수신자는 송신자의 공개키로 복호화&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;시나리오:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ Bob은 public key를 공개된 장소에 두고, private key는 자신이 가지고 있다
+ Alice는 Bob의 public key를 가져와, 메시지를 암호화해서 전송​
+ 이 메시지는 다른 사람이 보더라도 풀 수 없다. 메시지를 복호화하려면 Bob의 private key가 필요하기 때문-&amp;gt;기밀성보장​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;문제점1. Bob은 Alice가 메시지를 작성했다는것을 확신할 수 있을까? NO​&lt;/li&gt;
  &lt;li&gt;문제점2. Bob은 메시지가 중간에 변경되지않았다는것을 확신할 수 있을까? NO​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;해결법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Alice는 메시지로 MAC을 만들고, 이것을 Alice가 자신의 private key로 암호화 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc05.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;만들어진 것을 본래 메시지에 붙인다 -&amp;gt; 서명&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc06.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이것을 Bob의 public key로 암호화 해서 전송&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;다른 사람은 Bob의 private key가 없으므로 볼수없다 -&amp;gt; 기밀성​&lt;/li&gt;
  &lt;li&gt;Bob은 자신의 private key로 열면 평문과 시그니쳐가 나온다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc07.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Bob은 다음과 같이 무결성,인증을 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc08.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">signature</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">서브프로그램</title>
      <link href="https://lee989898.github.io/pl-16" rel="alternate" type="text/html" title="서브프로그램" />
      <published>2021-10-29T19:18:00+09:00</published>
      <updated>2021-10-29T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-16</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-16">&lt;h3 id=&quot;서브프로그램&quot;&gt;&lt;strong&gt;서브프로그램&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Fundamentals of Subprograms&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서브프로그램이 무엇인지 왜 필요한지 살펴 보자.&lt;br /&gt;
동일한 코드 부분(segment)이 프로그램의 여러 곳에서 나타난다고 하면, 이 코드를 여러 곳에 중복해서 코딩하기보다는,​
한번만 코딩하고, 필요할 때마다 그 코드 부분으로 점프했다가 끝나면 되돌아 오는 방식으로, 프로그램을 짤 수 있다.&lt;br /&gt;
이러한 코드 부분을 서브프로그램이라고 한다.&lt;br /&gt;
동일한 코드 부분이 프로그램의 여러 곳에 나타나고, ​나타나는 곳마다 사용되는 변수가 다르다고 가정해 보자.&lt;br /&gt;
이때 파라미터를 갖는 서브프로그램을 사용할 수 있다.&lt;br /&gt;
서브프로그램의 개념은 쓰레드와 같은 것으로 발전하고 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;서브프로그램은 다음과 같은 특징을 갖는다. ​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;각 서브 프로그램은 단하나의 진입점을 갖는다. ​&lt;/li&gt;
  &lt;li&gt;호출한 서브프로그램(caller)는 호출된 서브프로그램(callee)의 실행 중에는 중지된다. ​&lt;/li&gt;
  &lt;li&gt;Callee가 종료되면, 컨트롤을 항상 caller에게 되돌려준다.  ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서브프로그램은 정의부와 선언부로 구성된다.&lt;br /&gt;
서브프로그램 정의부는 서브프로그램의 인터페이스와 액션을 서술하고, ​정의부의 맨앞에는 서브프로그램의 헤더가 있다.&lt;br /&gt;
헤더는 void adder(parameter) 처럼 서브프로그램 이름, 유형, 포말 파라미터 등을 포함한다. &lt;br /&gt;
포말 파라미터의 개수, 순서, 타입을 파라미터의 프로파일(시그니처, 요약)이라고 부른다. ​&lt;/p&gt;

&lt;p&gt;서브프로그램 선언부는 파라미터 프로파일과 반환 타입을 선언한다.&lt;br /&gt;
서브프로그램 호출(call)은 서브프로그램으로 점프한다. ​&lt;/p&gt;

&lt;p&gt;서브프로그램에서 데이터에 접근하는 방법은 두가지가 있다.
 ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;난로컬 변수에 직접 접근하는 경우 ​&lt;/li&gt;
  &lt;li&gt;파라미터 패싱을 사용하는 경우 ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파라미터 패싱을 사용하여 데이터를 접근할 때에는 ​로컬 변수명을 사용한다.&lt;br /&gt;
난로컬 변수에 직접 접근하는 것보다 융통성이 높아 파라미터화에 의한 계산이 가능하다.&lt;br /&gt;
난로컬 변수에 대한 광범위한 접근은 부작용으로 인해 신뢰성을 감소시킨다. ​&lt;br /&gt;
순수 함수 언어는 수정 가능한 데이터를 허용하지 않으며, 메모리 내용을 변경할 수 없도록 제한한다. ​&lt;/p&gt;

&lt;p&gt;포말 파라미터는 callee의 헤더에 있는 파라미터를 말한다.&lt;br /&gt;
서브프로그램이 호출될 때만 메모리에 바인딩되고, ​액추얼 파라미터를 통해서 바인딩되기 때문에, ​종종 더미 변수로 취급되기도 한다.&lt;br /&gt;
액추얼 파라미터는 caller에서 사용되는 값이나 주소를 나타낸다.&lt;/p&gt;

&lt;p&gt;액추얼 파라미터를 포말 파라미터에 바인딩하는 방법은 두 가지가 있다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;위치 파라미터: 파라미터의 순서가 중요 ​&lt;/li&gt;
  &lt;li&gt;키워드 파라미터: 파라미터의 이름이 중요, 순서는 중요하지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파이썬에서 sumer(my_length, list=my_array, sum = my_sum),  ​
포말 파라미터는 length, list, sum이고, ​
액추얼 파라미터는 my_length, my_array, my_sum 이라면, ​
첫번째 파라미터는 위치 파라미터이고, ​
두번째 세번째는 키워드 파라미터이다.  ​&lt;/p&gt;

&lt;p&gt;키워드 파라미터의 장점은 순서에 얽매이지 않는다는 것이고, ​
단점은 사용자가 포말 파라미터의 이름을 알고 있어야 한다는 것이다.&lt;/p&gt;

&lt;p&gt;C++, 파이썬 등에서는 액추얼 파라미터가 모두 다 패스되지 않을 경우, ​포말 파라미터는 대응되지 않는 나머지 파라미터에 대해 디폴트 값을 가질 수 있다. ​&lt;/p&gt;

&lt;p&gt;C++에서 파라미터는 위치에 연관되기 때문에 ​
디폴트 파라미터는 마지막에 나타나야 하며, ​
디폴트값은 서브프로그램 헤더에 있다. ​&lt;/p&gt;

&lt;p&gt;서브프로그램 내에 정의된 변수는 모두 로컬이며, ​
그들의 스코프는 항상 서브프로그램 안이다.&lt;br /&gt;
로컬 변수는 정적 또는 스택-동적으로 바인딩된다. ​
로컬 변수가 스택-동적이라면, ​
서브프로그램의 실행이 시작될 때 메모리에 바인딩되고, ​
실행이 끝나면 메모리에서 떨어진다. ​&lt;/p&gt;

&lt;p&gt;스택-동적 변수의 장점은, ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Recursive 서브프로그램이 스택-동적 로컬 변수를 갖는다 -&amp;gt; recursion 처리가 가능​&lt;/li&gt;
  &lt;li&gt;액티브 서브 프로그램의 로컬 변수가 ​
액티브하지 않은 서브프로그램이 해제한 로컬 변수의 메모리를 사용할 수 있다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;프로그램이 시작되고나서 아직 끝나지 않은 상태에서는 ​
자주 호출되는 서브프로그램의 실행이 끝났다고 해도 ​
그 서브 프로그램의 변수는 아직 메모리를 차지하고 있을 수 있다.&lt;br /&gt;
이때 서브프로그램의 상태를 액티브라고 한다. ​&lt;/p&gt;

&lt;p&gt;현대 언어에서, 서브프로그램의 로컬 변수는 디폴트로서 스택-동적으로 바인딩된다. ​&lt;/p&gt;

&lt;p&gt;C, C++ 함수에서, 로컬 변수는 정적이라고 명시되어 있지 않으면 스택-동적이다. ​&lt;/p&gt;

&lt;p&gt;서브프로그램이 다른 서브프로그램안에만 있어야 한다면, ​
이것을 중첩 서브프로그램이라고 한다. ​&lt;/p&gt;

&lt;p&gt;다른 서브프로그램 안에서 숨어서(hide) 다른 프로그램이 호출할 수 없게 만든다. ​&lt;/p&gt;

&lt;p&gt;서브프로그램의 중첩으로 처리 논리와 스코프의 계층구조를 생성할 수 있다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정적 스코핑의 사용 ​&lt;/li&gt;
  &lt;li&gt;알골, 파스칼에서 허용 ​&lt;/li&gt;
  &lt;li&gt;C 계열 언어는 서브프로그램의 중첩을 허용하지 않음​&lt;/li&gt;
  &lt;li&gt;자바스크립트, 파이썬 등은 중첩 허용&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Parameter-Passing Methods&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;파라미터 패싱에 대한 시맨틱 모델은 3가지가 있다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;포말 파라미터가 대응하는 액추얼 파라미터로부터 데이터를 받는 것이다. 이것을 in mode라고 한다. ​&lt;/li&gt;
  &lt;li&gt;포말 파라미터가 액추얼 파라미터에게 데이터를 보내는 것이다. 이것을 out mode라고 한다. ​&lt;/li&gt;
  &lt;li&gt;포말 파라미터가 대응하는 액추얼 파라미터로부터 데이터를 받고, 액추얼 파라미터에게 데이터를 보내는 것이다. 이것을 inout mode라고 한다.  ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파라미터간에 데이터를 주고 받는 방법은 두가지가 있다.&lt;br /&gt;
실제 값을 카피하여 주고 받는 방법과 액세스 패스(접근 경로)를 주고 받는 방법이다.&lt;/p&gt;

&lt;p&gt;파라미터 패싱 구현 모델에는 ​pass by value(in mode), pass by result(out mode), ​pass by value result(inout mode), pass by reference(inout mode)가 있다. ​&lt;/p&gt;

&lt;p&gt;Caller의 액추얼 파라미터를 Pass by value 모델로 callee에게 보낼때, 액추얼 파라미터의 값은 copy를 통해, ​대응되는 포말 파라미터의 초기화에 사용된다. ​&lt;/p&gt;

&lt;p&gt;단점은 다음과 같다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;copy 하면, ​  추가적인 메모리를 필요로하고, 실제 이동 비용이 발생한다. ​&lt;/li&gt;
  &lt;li&gt;만일 접근 경로(access path)에 의한다면, callee에서 쓰기 보호를 해야하는 동시에, ​간접 주소방식에 의한 접근 비용이 추가된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Callee의 파라미터를 pass by result 모델로 caller에게 보낼 때, ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;대응되는 포말 파라미터는 로컬 변수처럼 행동한다. ​&lt;/li&gt;
  &lt;li&gt;Callee가 종료되어 컨트롤을 caller에게 돌려주면, 포말 파라미터의 값을 caller의 액추얼 파라미터로 전달한다. ​&lt;/li&gt;
  &lt;li&gt;추가적인 메모리 위치와 copy 연산이 필요하다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pass by result에 내재하는 문제는 다음과 같다. ​&lt;/p&gt;

&lt;p&gt;Caller와 callee가 ​Caller: sub(p1, p1) actual parameter p1, p1​ Callee: sub(x, y) formal parameter x, y 라고 하자 액추얼 파라미터 두개가 p1으로 같고, ​대응하는 포말 파라미터 두개의 이름이 x, y로 다르다. ​&lt;/p&gt;

&lt;p&gt;Caller가 callee를 호출해서 callee가 실행 후 종료되고, ​
Callee가 calle에게 결과값을 반환할 때, ​
X, y 중 어느 것이 p1에 마지막으로 copy 되느냐에 따라, ​
p1의 값이 달라진다. ​
x거나 y이다. ​&lt;/p&gt;

&lt;p&gt;이것이 pass by result에 내재하는 문제이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Pass by value result는 ​pass by value와 pass by result의 결합으로 ​pass by copy라고도 부른다. ​&lt;br /&gt;
액추얼 파라미터의 값은 대응하는 포말 파라미터의 초기화에 쓰이고, ​포말 파라미터는 로컬 변수처럼 행동한다. ​&lt;br /&gt;
포말 파라미터의 값은 액추얼 파라미터에게 반환된다. ​
단점은 in, out 모두 카피에 의존. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Pass by reference 모델은 접근 통로의 패스를 통해, ​
파라미터를 패스한다. ​&lt;br /&gt;
즉, callee에게 caller의 액추얼 파라미터를 접근하도록 허용한다. &lt;br /&gt;
따라서 pass by sharing이라고도 한다. ​&lt;/p&gt;

&lt;p&gt;장점은 패싱 프로세스가 효율적이다. ​&lt;br /&gt;
Copy 연산, 메모리 모두 필요없다. ​&lt;br /&gt;
단점은 느리고, 예기치 않았던 난로컬 변수를 접근할 수도 있다. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;대부분 언어에서, 파라미터 패싱의 구현은 런타임 스택을 통해 일어난다. ​&lt;br /&gt;
C에서 파라미터 패싱은 pass by value를 지원한다.&lt;br /&gt;
포인터를 사용하면, Pass by reference를 구현할 수 있다.&lt;br /&gt;
자바는 모든 파라미터에 대해 pass by value를 지원하며,&lt;br /&gt;
객체 파라미터에 대해 pass by reference를 지원한다.&lt;/p&gt;

&lt;p&gt;파라미터에 대한 타입 검사는 ​액추얼 파라미터와 포말 파라미터 간에 타입의 일관성을 검사하는 것이다. ​&lt;br /&gt;
파라미터의 타입 검사는 소프트웨어의 신뢰성을 위해 매우 중요하다. ​&lt;br /&gt;
포트란 77, 원시 C에는 파라미터 타입 검사가 없다.&lt;br /&gt;
ANSI C, C++에는 선택적이며, ​파이썬, 루비에서는 변수가 타입을 갖지 않기 때문에 ​파라미터 타입 검사가 없다.&lt;/p&gt;

&lt;p&gt;파라미터의 타입이 다차원 배열일 경우, ​서브프로그램이 따로 컴파일되어 있고, ​다차원 배열이 서브프로그램으로 패스된다고 가정하자. ​&lt;br /&gt;
컴파일러는 메모리 매핑을 위해, ​선언된 배열의 크기를 알 필요가 있다.  ​&lt;/p&gt;

&lt;p&gt;Row-major 매트릭스의 메모리 매핑 함수는 ​&lt;/p&gt;

&lt;p&gt;address(mat[i,j]) = address(mat[0,0]) + i * #_columns + j 이다. ​&lt;/p&gt;

&lt;p&gt;즉, 컬럼의 길이만 알면 전체 크기를 알 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;현대 프로그래밍 언어에서 다차원 배열 파라미터를 어떻게 패스하는지 살펴 보자.​&lt;/p&gt;

&lt;p&gt;C, C++에서,&lt;br /&gt;
1) 프로그래머가 액추얼 파라미터의 첫번째 서브스크립트를 제외하고, ​나머지 서브스크립트의 크기를 선언하는 방법. ​&lt;/p&gt;

&lt;p&gt;슬라이드의 프로그램에서 mat은 2차원 배열이고, ​
함수 fun(mat)은 mat을 파라미터로 하는 함수이다.&lt;br /&gt;
이와 같은 방식은 서브프로그램의 유연성을 불허한다는 것이다. ​&lt;/p&gt;

&lt;p&gt;2) 이에 대한 해결책으로, ​&lt;/p&gt;

&lt;p&gt;배열에 대한 포인터, 차원 크기를 파라미터로 패스하는 방법이 있다.&lt;br /&gt;
다만, 배열 처리를 위해 ​사용자는 메모리 매핑 함수를 포함해야 하는 불편함이 있다.&lt;/p&gt;

&lt;p&gt;자바에서는 배열을 객체로 취급한다.&lt;br /&gt;
이들은 모두 일차원 배열이지만 ​배열의 각 요소가 배열일 수 있어서 ​다차원 배열을 파라미터로 쓸 수 있다.&lt;br /&gt;
자바에서 각 배열은 named constant(length와 같은)를 상속받는다.&lt;/p&gt;

&lt;p&gt;파라미터 패싱 방법의 구현시, 다음 두가지를 고려해야 한다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;효율성, ​&lt;/li&gt;
  &lt;li&gt;일방(in, out) 또는 쌍방(inout) 데이터 이동:caller-callee간에  ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러나 이들 고려사항은 서로 상충된다. ​&lt;/p&gt;

&lt;p&gt;프로그래밍을 잘하려면, 변수에 대한 접근을 가능한한 일방(in, out)으로 제한하는 것이 좋다.&lt;br /&gt;
pass by reference(inout)는 크기가 큰 데이터 스트럭처를 패스하는데 더욱 효율적인 반면, ​변수에 대한 접근을 제한하는데 문제를 일으킬 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Parameters That Are Subprograms&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이번엔 서브프로그램 이름을 파라미터로 패스하는 경우를 살펴보자. &lt;br /&gt;
종종 서브프로그램 이름을 파라미터로 패스하는 것이 편리할 때도 있다.&lt;br /&gt;
​즉, 계산을 서브프로그램으로 패스하는 것이다.&lt;/p&gt;

&lt;p&gt;파라미터 타입 검사? ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;C, C++ 함수 포인터로 패스함. ​-&amp;gt; 함수 포인터의 타입은 파라미터 타입을 포함하므로 파라미터 타입 검사는 가능함 ​&lt;/li&gt;
  &lt;li&gt;자바는 메소드 이름을 파라미터로 패스하는 것을 불허함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서브프로그램 중첩을 허용하는 언어에서, ​어떤 바인딩 방식에 의한 레퍼런싱 환경을 사용하는가? ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;쉘로우 바인딩: 패스된 서브프로그램을 실행시킨 call문(호출문)의 환경 ​&lt;/li&gt;
  &lt;li&gt;딥바인딩: 패스된 서브프로그램에 정의된 환경​&lt;/li&gt;
  &lt;li&gt;즉흥(ad hoc) 바인딩: 서브프로그램을 액추얼 파라미터로 패스한 호출문의 환경&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function sub1() {​
  var x;​
  function sub2() { alert(x); };​
  function sub3() {​
    var x; x = 3;​
    sub4(sub2); }​
  function sub4(subx) {​
    var x; x = 4;​
    subx(); }​
  x = 1;​
  sub3(); }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Sub4의 sub에 대해​&lt;/p&gt;

&lt;p&gt;쉘로우 바인딩을 했을 경우 ​
실행시킨 call문의 환경은 sub4가 되고, ​
sub4에서 x는 4이다. ​&lt;/p&gt;

&lt;p&gt;딥 바인딩을 했을 경우​
Sub2가 정의된 환경은 sub2가 되고,  ​
Sub2에서 x는 난로컬로서 sub1에 따른다. ​
따라서 x는 1이다. ​&lt;/p&gt;

&lt;p&gt;즉흥 바인딩일 경우, ​
Sub2를 파라미터로 넘긴 call문의 환경은 sub3가 되고, ​
Sub3에서 x는 3이다. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Design Issues for Functions&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;언어 설계시 고려사항은&lt;/p&gt;

&lt;p&gt;부작용 허용 여부? 부작용을 줄이려면 파라미터는 항상 in mode가 좋다. ​&lt;/p&gt;

&lt;p&gt;반환 값의 타입은? 대부분의 명령형 언어가 반환값의 타입을 제한함. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;C는 배열과 함수를 제외하고 모든 타입을 허용함. ​&lt;/li&gt;
  &lt;li&gt;C++은 C와 유사하나 사용자 정의 타입을 허용​&lt;/li&gt;
  &lt;li&gt;자바는 모든 타입 허용. ​&lt;/li&gt;
  &lt;li&gt;파이썬, 루비는 반환값 타입으로 객체도 허용&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Coroutines&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;코루틴에서 중요한 것은 재시작(resume) 명령.&lt;br /&gt;
프로그램 단위의 유사 동시 실행 기능을 제공함. 인터리빙.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl38.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위그림은 A가 먼저 시작하고, B를 재시작하고나서 스스로 중지했다가, ​
B가 A를 재시작하고 나서 스스로 중지했다가, ​
번갈아 가며 실행되는 형태를 보여주고 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl39.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 B가 먼저 시작하고, A를 재시작하면서 스스로 중지하고, ​
번갈아가며 실행되는 형태를 보이고 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl40.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위그림은 룹에서 서로 중지하고 상대방을 재시작하는 것을 반복함&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">서브프로그램</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Signal</title>
      <link href="https://lee989898.github.io/st-07" rel="alternate" type="text/html" title="Signal" />
      <published>2021-10-27T01:06:00+09:00</published>
      <updated>2021-10-27T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/st-07</id>
      <content type="html" xml:base="https://lee989898.github.io/st-07">&lt;h3 id=&quot;signal&quot;&gt;&lt;strong&gt;Signal&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Signal Concepts​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Signal은 프로세스에 보내는 메시지이다. signal은 시스템에서 어떤 유형의 이벤트가 발생했음을 알려준다
    &lt;ul&gt;
      &lt;li&gt;Signal은 커널에서 프로세스로 보내진다​&lt;/li&gt;
      &lt;li&gt;때로는 다른 프로세스의 요청으로 전송된다​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Signal은 exceptions,interrupts​과 유사하다&lt;/li&gt;
  &lt;li&gt;Signal은 일종의 IPC(Inter-Process Communication)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Sending a Signal&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;커널은 다음과 같은 이유로 신호를 보낸다​
    &lt;ul&gt;
      &lt;li&gt;커널이 0으로 나누기(SIGFPE), 잘못된 메모리 참조(SIGSEGV), child 프로세스 종료(SIGCHLD)와 같은 시스템 이벤트를 감지했다&lt;/li&gt;
      &lt;li&gt;다른 프로세스가 대상 프로세스에 signal를 보내도록 커널을 명시적으로 요청하기 위해 kill 시스템 호출을 호출했다
        &lt;ul&gt;
          &lt;li&gt;보낼 수 있는 신호를 표시하려면 “% kill -l”을 시도하자&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;터미널에서 CTRL-C를 입력하여 실행 중인 프로세스(SIGINT) 중지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Receiving a Signal​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;대상 프로세스는 커널에서 신호를 수신하고 세 가지 가능한 방법 중 하나로 반응한다
    &lt;ul&gt;
      &lt;li&gt;Signal 무시(아무것도 하지 않음)
        &lt;ul&gt;
          &lt;li&gt;SIGKILL 및 SIGSTOP을 제외한 모든 신호는 무시할 수 있다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;프로세스 종료(선택적 코어 덤프 사용) -&amp;gt; default action&lt;/li&gt;
      &lt;li&gt;시그널 핸들러라는 user-level 함수를 실행하여 Catch the signal
        &lt;ul&gt;
          &lt;li&gt;비동기 인터럽트에 대한 응답으로 호출될 때 하드웨어 예외 핸들러와 유사&lt;/li&gt;
          &lt;li&gt;신호 처리기는 signal() 시스템 호출을 호출하여 실행된다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로세스는 커널에게 “이 신호가 발생하면 위의 세 가지 중 하나를 수행하십시오”라고 알려야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Linux Signals / Linux Signal List&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Every signal has a name​
    &lt;ul&gt;
      &lt;li&gt;Begins with ‘SIG’​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Signals are all defined by positive integers (signal numbers) in the header &lt;signal.h&gt; and &lt;siglist.h&gt;​&lt;/siglist.h&gt;&lt;/signal.h&gt;&lt;/li&gt;
  &lt;li&gt;SVR4 and 4.3+BSD both have 31 different signals&lt;/li&gt;
  &lt;li&gt;SIGABRT​
    &lt;ul&gt;
      &lt;li&gt;Generated by calling the abort() system call​&lt;/li&gt;
      &lt;li&gt;Process terminates abnormally​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SIGFPE​
    &lt;ul&gt;
      &lt;li&gt;Floating-Point Exception Signal​&lt;/li&gt;
      &lt;li&gt;Signals an arithmetic exception, such as divide-by-0, floating point overflow, 등등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SIGILL​
    &lt;ul&gt;
      &lt;li&gt;Illegal Instruction Signal: illegal HW instruction executed​&lt;/li&gt;
      &lt;li&gt;Can’t be caught or ignored​&lt;/li&gt;
      &lt;li&gt;A sure way to kill any process​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SIGINT​
    &lt;ul&gt;
      &lt;li&gt;Interrupt Signal​&lt;/li&gt;
      &lt;li&gt;Generated by the terminal driver when we type the interrupt key (Ctrl C)​&lt;/li&gt;
      &lt;li&gt;Sent to all processes in the foreground process group​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SIGKILL​
    &lt;ul&gt;
      &lt;li&gt;Kill Signal​&lt;/li&gt;
      &lt;li&gt;Can’t be caught or ignored​&lt;/li&gt;
      &lt;li&gt;A sure way to kill any process​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;​SIGPIPE​
    &lt;ul&gt;
      &lt;li&gt;Generated when writing on a pipe with no process to read: reader has already terminated​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SIGQUIT​
    &lt;ul&gt;
      &lt;li&gt;Quit Signal​&lt;/li&gt;
      &lt;li&gt;Generated by the terminal driver when we type terminal quit key (Control + Backslash) and sent to all processes in the foreground process group​&lt;/li&gt;
      &lt;li&gt;Usually core file is generated​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SIGSEGV​
    &lt;ul&gt;
      &lt;li&gt;Indicates that the process has made an invalid memory reference​&lt;/li&gt;
      &lt;li&gt;SEGV means “segment violation” ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SIGTRAP​
    &lt;ul&gt;
      &lt;li&gt;Special signal used to transfer control to the debugger (like sdb, adb) ​&lt;/li&gt;
      &lt;li&gt;Usually ptrace system call is used to invoke SIGTRAP​&lt;/li&gt;
      &lt;li&gt;It is not usually used except for debugging​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SIGUSR1 &amp;amp; SIGUSR2​
    &lt;ul&gt;
      &lt;li&gt;User-defined signals, for use in application programs​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Linux Signal List&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st13.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프러그래밍&quot; /&gt; 
&lt;img src=&quot;/assets/built/images/st/st14.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프러그래밍&quot; /&gt; 
&lt;img src=&quot;/assets/built/images/st/st15.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프러그래밍&quot; /&gt; 
&lt;img src=&quot;/assets/built/images/st/st16.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프러그래밍&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;signal()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;signal.h&amp;gt;​

void (*signal(int signo, void(*func)(int))) (int)​
    반환: 정상이면 신호의 이전 처리, 오류 시 SIG_ERR ​ + signal function은 signal &quot;signo&quot; 수신과 관련된 기본 동작을 수정한다
+ signo: signal number를 나타낸다​
+ func:​
    + 신호 수신 시 사용자 정의 함수(signal handler) 호출
    + SIG_IGN: signal를 무시
    + SIG_DFL: default action을 취한다 + signal handler에 단일 정수 인수(signal number)가 전달되고 아무 것도 반환하지 않습니다
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;kill()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;signal.h&amp;gt;​

int kill(pid_t pid, int signo);​
    반환: 정상이면 0, 오류시 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Kill : 프로세스 또는 프로세스 그룹에 신호를 보낸다&lt;/li&gt;
  &lt;li&gt;super user는  모든 프로세스에 신호를 보낼 수 있다​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;발신자의 실제 또는 유효 사용자 ID는 수신자의 실제 또는 유효 사용자 ID와 같아야 한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Pid &amp;gt; 0​
    &lt;ul&gt;
      &lt;li&gt;Signal to the process whose process ID is pid​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pid == 0​
    &lt;ul&gt;
      &lt;li&gt;Signal to the processes whose process group ID equals that of sender​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pid &amp;lt; 0​
    &lt;ul&gt;
      &lt;li&gt;Signal to the processes whose process group ID equals abs. of pid​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pid == -1​
    &lt;ul&gt;
      &lt;li&gt;POSIX.1 leaves this condition unspecified (used as a broadcast signal in SVR4, 4.3+BSD)​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;killpg()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;signal.h&amp;gt;​

int killpg(int pgrp, int sig)​

// int pgrp -&amp;gt; 프로세스 그룹 ID​
// int  sig -&amp;gt; 시그널 번호​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스 그룹으로 시그널을 보냄​&lt;/li&gt;
  &lt;li&gt;반환값 : 정상 종료시에는 0, 에러 발생시 -1​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="system" />
      

      
        <summary type="html">Signal</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">탐욕 기법</title>
      <link href="https://lee989898.github.io/algorithm-05" rel="alternate" type="text/html" title="탐욕 기법" />
      <published>2021-10-26T01:09:00+09:00</published>
      <updated>2021-10-26T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-05</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-05">&lt;h3 id=&quot;탐욕-기법&quot;&gt;&lt;strong&gt;탐욕 기법&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;탐욕 기법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;매 번 선택할 때 마다 그 순간에 좋은 선택을 함으로써 최종적인 해에 도달한다.&lt;/li&gt;
  &lt;li&gt;최적인 해들을 모아서 최종 해를 만들었다고 해서, 그 해가 궁극 적으로 최적이라는 보장이 없다.&lt;/li&gt;
  &lt;li&gt;따라서 탐욕 기법은 항상 최적의 해를 만들어내는 지를 반드시 검증해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;선택 기준&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;선택이 실현 가능해야 한다.&lt;/li&gt;
  &lt;li&gt;모든 선택들 중에서 최적이라고 여겨지는 선택을 해야 한다.&lt;/li&gt;
  &lt;li&gt;한 번 선택하면 나중에 되돌릴 수 없다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;설계 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;비어 있는 해 모음으로 시작한다.&lt;/li&gt;
  &lt;li&gt;탐욕적인 기준에 따라 해 모음에 추가할 다음 해를 선택한다.&lt;/li&gt;
  &lt;li&gt;새 해 모음이 실형 가능한지를 확인한다.
실현 가능하다면 새 해 모음을 확정하고 아니면 선택한 해를 버린다.&lt;/li&gt;
  &lt;li&gt;새 해 모음이 최종 해라면 종료한다. 아니면 2번으로 간다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;거스름돈 주기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;거스름돈을 동전들의 수가 최소가 되도록 주어야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;액면가가 다른 m(&amp;gt;=1)개의 동전들이 있다.&lt;/li&gt;
  &lt;li&gt;동전 i,1&amp;lt;=i&amp;lt;=m,의 액면가는 $d_i$ 이고 $d_1$ &amp;gt; 
$d_2$ &amp;gt; … &amp;gt; $d_m$ = 1이다.&lt;/li&gt;
  &lt;li&gt;액면가가 같은 동전들의 개수는 무한히 많이 있다.&lt;/li&gt;
  &lt;li&gt;거스름돈 n(&amp;gt;=1)을 최소 개수의 동전들을 사용하여 주어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;탐욕 알고리즘의 아이디어&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;주어야 할 거스름돈이 남아 있는 동안 다음을 반복한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;남은 동전들 중 액면가가 가장 큰 동전을 선택한다.&lt;/li&gt;
  &lt;li&gt;선택한 동전을 거스름돈에 추가하면 거스름돈이 주어야 할 금액을 
초과한다면 그 동전을 버린다. 아니면 그 동전을 거스름돈에 추가하고 주어야 할 거스름돈을 추가한 동전의 액면가만큼 감소시킨다.&lt;br /&gt;
주: 최적의 알고리즘&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;탐욕적인 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;coinChange(d[],m,n)
//거스름돈에 포함되는 동전들의 수를 최소화한다.&lt;br /&gt;
//입력: m - 액면가가 다른 동전들의 수&lt;br /&gt;
//     d[1..m] - 동전들의 액면가를 저장하는 배열&lt;br /&gt;
//     n - 거스름돈&lt;br /&gt;
//출력(반환 값): 거스름돈에 포함된 동전들의 최소 개수&lt;br /&gt;
1  count = 0&lt;br /&gt;
2  i = 1&lt;br /&gt;
3  while(n &amp;gt; 0 &amp;amp;&amp;amp; i &amp;lt;=m){&lt;br /&gt;
4    count = count + $\frac{n}{d[i]}$ 　//가치가 가장 큰 동전들을 최대한 많이 선택&lt;br /&gt;
5    n = n mod d[i] 　　　 //남은 거스름돈을 계산&lt;br /&gt;
6    i = i + 1 　　　　　　 //다음으로 가치가 큰 동전을 선택&lt;br /&gt;
    }&lt;br /&gt;
7  return count&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;시간 복잡도&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;입력의 크기: m(액면가가 다른 동전들의 수)&lt;/li&gt;
  &lt;li&gt;기본 연산: 4번의 배정문&lt;/li&gt;
  &lt;li&gt;기본 연산의 수행 횟수: 최대 m&lt;/li&gt;
  &lt;li&gt;시간 복잡도: m = $\theta$(m)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;최소 비용 신장 트리 찾기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;n(&amp;gt;1)개의 도시들을 최소한의 비용으로 연결하는 철도망을 새로 구축하려고 한다.&lt;/li&gt;
  &lt;li&gt;모든 도시들을 서로 연결하기 위해 도시간 철도를 최소한(n-1)개 깔아야 한다.&lt;/li&gt;
  &lt;li&gt;각 철도는 두 도시를 연결한다.&lt;/li&gt;
  &lt;li&gt;이 철도망들 중에서 철도 노선들의 총 길이가 최소가 되도록 철도망을 구축해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;최소 비용 신장 트리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;신장트리: 연결된, 무방향 그래프 안에 있는 모든 정점을 다 포함하면서 트리가 되는 연결된 부분 그래프&lt;/li&gt;
  &lt;li&gt;산장트리는 순환을 포함하지 않으며 그래프 안에 있는 모든 정점들을 연결시칸다.&lt;/li&gt;
  &lt;li&gt;신장트리의 가중치: 모든 간선들의 가중치들의 합&lt;/li&gt;
  &lt;li&gt;최소 비용 신장 트리: 최소 가중치를 가진 신장트리&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag12.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;억지 기법 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;모든 신장 트리를 찾은 후 그 중에서 최소 비용 신장 트리를 선택한다.&lt;/li&gt;
  &lt;li&gt;시간 복잡도 분석
    &lt;ul&gt;
      &lt;li&gt;최악의 경우, 지수 시간보다도 나쁘다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;탐욕적인 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;신장 트리에 추가할 최선의 간선들을 반복적으로 한 번에 하나씩 선택한다. 선택 시점에서 추가할 최선의 간선을 쉽게 알 수 있다고 가정한다.&lt;/li&gt;
  &lt;li&gt;(n-1)개의 간선들이 신장 트리에 포함된다면 종료한다.&lt;/li&gt;
  &lt;li&gt;한 간선이 선택되면 그 간선의 정점들을 합친다.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;적절한 이유&lt;br /&gt;
정점 a와 b가 연결된다면 정점a에 연결하는 것은 정점 b에 연결하는 것과 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;명제. n(&amp;gt;0)개의 정점들을 가진 그래프 G는 (n-1)개의 간선들을 가지고 순환이 없으면 트리이다. 또한 G가 트리이면 (n-1)개의 간선들이 있고 비순환 그래프이다.&lt;/p&gt;

&lt;p&gt;정리. 간선 e가 정점 v에 접합한 가장 가중치가 작은 간선이라면 e를 포함하는 최소 비용 신장 트리가 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;최소 비용 신장트리 찾기 - 정점지향 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;처음 시작할 때 한 정점 $v_0$를 선택한다.&lt;/li&gt;
  &lt;li&gt;$v_0$ 에서 나가는 가장 가중치가 작은 간선 ($v_0$, x)를 선택한다. 그 간선을 최소 비용 신장 트리 T에 추가하고 $v_0$와 x를 합친다. 모든 정점이 T에 포함될 때까지 이 과정을 반복한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;프림 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;적색 정점: 처음에 선택된 정점 $v_0$와 합쳐진 정점&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;청색 정점: 그 외 다른 정점&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;아이디어&lt;br /&gt;
다음을 (n-1)번 반복한다:
    &lt;ol&gt;
      &lt;li&gt;한 적색 정점과 한 청색 정점을 연결하는 가장 가중치가 작은 간선을 선택한다.&lt;/li&gt;
      &lt;li&gt;선택된 간선의 청색 정점을 적색으로 바꾸고 그 간선을 트리에 추가한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;그래프의 표현: 비용 행렬 W&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;R: 적색 정점들의 집합, B: 청색 정점들의 집합&lt;br /&gt;
V: 그래프내의 모든 정점들의 집합&lt;br /&gt;
T: 트리 내에 포함되는 간선들의 집합&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;  R = {$v_0$}&lt;/li&gt;
  &lt;li&gt;  B = V - {$v_0$}&lt;/li&gt;
  &lt;li&gt; T = $\emptyset${공집합}&lt;/li&gt;
  &lt;li&gt; for(i = 1; i &amp;lt; n; i++) {&lt;/li&gt;
  &lt;li&gt; 　　w[ r,b ]가 최소인 $r \in R$과 $b \in B$를 선택한다.&lt;/li&gt;
  &lt;li&gt; 　　T = T U {(r,b)}　　// 간선 (r,b)를 트리에 추가한다.&lt;/li&gt;
  &lt;li&gt; 　　B = B - {b}&lt;/li&gt;
  &lt;li&gt; 　　R = R U {b}　　　//정점 b를 적색으로 바꾼다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;명확하게 청색 정점의 관점을 취해야 한다. 단순히 어느 적색 정점이 자신에게 가장 가까운지만 기억한다. 이는 한 정점이 적색이 될 때 쉽게 갱신될 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;시간 복잡도&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 알고리즘은 중복 계산을 많이 한다. 매번 반복할 때마다 최소 간선을 거의 같은 집합에서 찾는다.&lt;br /&gt;
$\theta$($n^3$)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;개선된 프림 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;near[0 .. n - 1]: 각 청색 정점에 가장 가까운 적생 정점을 저장하는 배열&lt;br /&gt;
isblue[0 .. n - 1]: 각 정점이 청색이면 true를 아니면 false를 저장하는 배열&lt;br /&gt;
T: 트리 내에 포함되는 간선들의 집합&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt; isblue[0] = false 　　　　//정점 0은 적색이다&lt;/li&gt;
  &lt;li&gt; T = $\emptyset$&lt;/li&gt;
  &lt;li&gt; for(i = 1; i &amp;lt; n; i++){&lt;/li&gt;
  &lt;li&gt; 　　isblue[i] = true 　　　　//다른 정점들은 청색이다&lt;/li&gt;
  &lt;li&gt; 　　near[i] = 0 } 　　　　　 // 가장 가까운 적색 정점은 0이다&lt;/li&gt;
  &lt;li&gt; for(i = 1; i &amp;lt; n; i++){&lt;/li&gt;
  &lt;li&gt; 　　minval = $\infty$&lt;/li&gt;
  &lt;li&gt; 　　for(b = 0; b &amp;lt; n; b++)　//적색 정점들에 가장 가까운 청색 정점을 찾는다&lt;/li&gt;
  &lt;li&gt; 　　　if(isblue[b] &amp;amp;&amp;amp; W[b,near[b]]&amp;lt; minval){&lt;/li&gt;
  &lt;li&gt; 　　　　minval = W[b,near[b]]&lt;/li&gt;
  &lt;li&gt; 　　　　newred = b }&lt;/li&gt;
  &lt;li&gt; 　isblue[newred] = fasle 　　　//정점 newred를 적색으로 바꾼다&lt;/li&gt;
  &lt;li&gt; 　T = T $\cup$ { (newred, near[newred])}　//가장 가중치가 작은 간선을 T에 추가한다&lt;/li&gt;
  &lt;li&gt; 　for(b = 0; b &amp;lt; n; b++)&lt;/li&gt;
  &lt;li&gt; 　　　if(isblue[b] &amp;amp;&amp;amp; W[b,newred] &amp;lt; W[b,near[b]])near[b] = newred&lt;br /&gt;
　　}&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;시간 복잡도&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;입력 크기: n(정점들의 수)&lt;/li&gt;
  &lt;li&gt;기본 연산: isblue의 요소들에 대한 참조 횟수&lt;/li&gt;
  &lt;li&gt;참조 횟수
    &lt;ul&gt;
      &lt;li&gt;각 i, 1&amp;lt;= i &amp;lt; n, 에 대해 항상 n이다.&lt;/li&gt;
      &lt;li&gt;따라서 총 참조 횟수 = (n-1) x n $\in$ $\theta$($n^2$)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;최소 비용 신장 트리 찾기 - 간선 지향 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;그래프에 남아 있는 가장 가중치가 작은 간선을 선택한다.&lt;/li&gt;
  &lt;li&gt;선택된 간선이 합쳐진 두 개의 정덤들 사이에 있다면 그 간선을 버리고 아니면 최소 비용 신장 트리에 추가한다.&lt;/li&gt;
  &lt;li&gt;(n - 1)개의 간선들이 추가될 때까지 과정 1과 2를 반복한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;크루스칼 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;//e: 간선들의 수&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;  간선들을 가중치 순서로 오름차순으로 정렬하여 배열 EDGELIST[1 .. e]에 저장한다&lt;/li&gt;
  &lt;li&gt;  T = $\emptyset$&lt;/li&gt;
  &lt;li&gt;  ecount = 0  　 　 　 　//최소 비용 신장 트리에 추가된 간선들의 수&lt;/li&gt;
  &lt;li&gt;  k = 0  　 　 　 　 　 　 　//처리된 간선들의 수&lt;/li&gt;
  &lt;li&gt;  while (ecount &amp;lt; n - 1){&lt;/li&gt;
  &lt;li&gt;  　k = k + 1&lt;/li&gt;
  &lt;li&gt;  　(v, w) = EDGELIST[k]&lt;/li&gt;
  &lt;li&gt;  　if(! together(v,w)){&lt;/li&gt;
  &lt;li&gt;  　　T = T U {(v,W)}&lt;/li&gt;
  &lt;li&gt;  　　v와 w를 합친다&lt;/li&gt;
  &lt;li&gt;  　  ecount = ecount + 1 }&lt;br /&gt;
} &lt;br /&gt;
주: together(v,w) : v와 w가 이미 합쳐졌으면 true이다.&lt;br /&gt;
분삭: (n-1)번의 통합과 최대 e번의 together를 수행한다.&lt;br /&gt;
정렬시간 = $\theta$( e log e)&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;단일 출발점 최단 경로 찾기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;연결된 가중 그래프에서 한 특정 정점에서 다른 모든 정점으로 가는 최단 경로를 찾아라.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;다익스트라 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;아이디어: 출방 정점 $v_0$로 부터 가까운 순서로 다른 정점들까지의 최단 경로를 찾는다.&lt;/li&gt;
  &lt;li&gt;진행 과정
    &lt;ul&gt;
      &lt;li&gt;i번째 반복이 시작되기 전에 $v_0$에 가장 가까운 (i - 1)개의 정점들까지의 최단 경로들을 찾았다.&lt;/li&gt;
      &lt;li&gt;$v_0$, 이 정점들과 최단 경로들 상의 간선들은 주어진 그래프의 부분 트리 $T_i$를 형성한다.&lt;/li&gt;
      &lt;li&gt;$T_i$내에 있는 정덤들에 인접한 ‘가장자리 정점’들 중에서 찾는다.&lt;/li&gt;
      &lt;li&gt;$T_i$내에 있는 정점들에 인접한 ‘가장자리 정접’들 중에서 찾는다.&lt;/li&gt;
      &lt;li&gt;모든 가장자리 정점 u에 대해서 u에 인접한 트리내의 정점 v까지의 거리, W(u,v)와 출발 정점에서 v까지의 최단 경로의 길이, $d_v$의 합을 계산한다.&lt;/li&gt;
      &lt;li&gt;u에 인접한 트리 내의 정점들이 2개 이상인 경우에는 각 인접 정점에 대해 합을 계산한다. 그러한 합들 중 가장 작은 합을 갖는 가장자리 정점을 트리에 추가할 다음 정점으로 선택한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag13.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 트리 $T_i$이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;n( &amp;gt; 0): 정점들의 수&lt;/li&gt;
  &lt;li&gt;i, 0 &amp;lt;= i &amp;lt; n: 정덤의 번호&lt;/li&gt;
  &lt;li&gt;출발 정점: 0&lt;/li&gt;
  &lt;li&gt;정점 i에 d[i]와 p[i]를 저장한다.
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;d[i]: 출발 정점에서 각 정점까지의 최단 겅로의 거리
  d[0] = 0&lt;br /&gt;
  d[i] = $\infty$ ,i는 최단 경로 트리 내에 포함되지 않은 정점&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;p[i]: 출발 정점에서 각 정점까지의 최단 경로 상의 마지막에서 두 번째 정점(트리에서 부모 노드)의 번호&lt;br /&gt;
  i = 0혹은 트리안에 포함되지 않은 정점이면 p[i] = -1&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;주어진 그래프는 인접 행렬 w로 나타낸다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;트리에 추가할 정점 $u^*$를 선택한 후의 연산&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;$u^*$를 가장자리 정점에서 트리내에 포함되는 정점으로 바꾼다.&lt;/li&gt;
  &lt;li&gt;$u^&lt;em&gt;$에 인접한 트리에 포함되지 않은 각 가장자리 정점 v에 대해 다음 조건을 확인한다.&lt;br /&gt;
d[$u^&lt;/em&gt;$]  + w($u^&lt;em&gt;$ ,v) &amp;lt; d[v]&lt;br /&gt;
위 조건이 만족된다면 다음을 수행한다&lt;br /&gt;
d[v] = d[$u^&lt;/em&gt;$] + w($u^&lt;em&gt;$, v)&lt;br /&gt;
p[v] = $u^&lt;/em&gt;$&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;다익스트라 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;  T = $\emptyset$    //트리에 포함된 정점들의 집합을 공집합으로 초기화한다&lt;/li&gt;
  &lt;li&gt;  for( i = 0; i &amp;lt; n; i++){&lt;/li&gt;
  &lt;li&gt;  d[i] = $\infty$    //정점 i의 최단 거리를 $\infty$ 로 초기화 한다&lt;/li&gt;
  &lt;li&gt;  p[i] = -1 }    //정점 i의 부모 노드를 -1(없음)으로 초기화한다&lt;/li&gt;
  &lt;li&gt;  d[0] = 0    //출발 정점 0의 최단 거리를 0으로 한다&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;  while(&lt;/td&gt;
          &lt;td&gt;T&lt;/td&gt;
          &lt;td&gt;&amp;lt; n){}&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;  T에 포함되지 않은 정점들 중에서 배열 d의 요소값이 가장 작은 정점 u를 선택한다&lt;/li&gt;
  &lt;li&gt;  T = T U { u}    //선택된 정점을 트리에 추가한다&lt;br /&gt;
// 트리에 새로 추가된 정점의 인접 정점들의 출발 정점으로부터 최단 거리를 갱신한다&lt;/li&gt;
  &lt;li&gt;  for( v = 0; v &amp;lt; n; v++)&lt;/li&gt;
  &lt;li&gt;  if(v $\notin$ T and w[u,v]  0 and d[u] &amp;lt; $\infty$ and d[u] + w[u,v] &amp;lt; d[v] ){&lt;/li&gt;
  &lt;li&gt;  d[v] = d[u] + w[u,v]&lt;/li&gt;
  &lt;li&gt;   p[v] = u }&lt;br /&gt;
}&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;시간복잡도&lt;br /&gt;
    +  기본 연산: 10번 조건 확인
    +  9 ~ 12번의 반복문내에서 기본 연산의 수행 횟수 = n
    +  트리에 모든 정점이 포함되어야 하므로 $\theta$($n^2$)&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">탐욕 기법</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Hash</title>
      <link href="https://lee989898.github.io/sc-09" rel="alternate" type="text/html" title="Hash" />
      <published>2021-10-23T01:06:00+09:00</published>
      <updated>2021-10-23T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-09</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-09">&lt;h3 id=&quot;hash&quot;&gt;&lt;strong&gt;Hash&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Hash와 관련된 Key Concepts인 Integrity와 Authentication을 다시 한번 살펴보자&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Integrity&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무결성&lt;/li&gt;
  &lt;li&gt;원본 그대로임을 보장&lt;/li&gt;
  &lt;li&gt;변조가 없다는 것 혹은 변경이 있었음을 알게 됨&lt;/li&gt;
  &lt;li&gt;주요 공격: modification&lt;/li&gt;
  &lt;li&gt;Integrity를 지키기 위한 Solution : hash&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Authentication&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;인증&lt;/li&gt;
  &lt;li&gt;송수신자 서로간의 신원 확인&lt;/li&gt;
  &lt;li&gt;주요 공격 : impersonation&lt;/li&gt;
  &lt;li&gt;Authentication을 지키기 위환 solution : 전자서명, 공인인증서&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hash Functions&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;임의의 긴 입력 값을 적절하게 처리하여 고정된 길이의 짧은 값을 출력하는 함수&lt;/li&gt;
  &lt;li&gt;Message Authentication Code로 무결성 제공&lt;/li&gt;
  &lt;li&gt;전자 서명으로 sender authentication 제공&lt;/li&gt;
  &lt;li&gt;공인인증서, 가상화폐 등에 사용&lt;/li&gt;
  &lt;li&gt;컴퓨터보안에서 대표적인 hash function은 MD2,4,5 SHA1, HAS160&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://www.miraclesalad.com/webtools/md5.php&quot;&gt;http://www.miraclesalad.com/webtools/md5.php&lt;/a&gt;&lt;br /&gt;
위 사이트에서 임의의ㅣ 입력값에 대한 해쉬값을 관찰할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;해쉬의 특징으로는 대표적으로 3가지가 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;입력길이에 상관없이 출력길이가 일정&lt;/li&gt;
  &lt;li&gt;조금이라도 입력값이 다르면 출력값은 완전히 다름&lt;/li&gt;
  &lt;li&gt;revers가 어렵다(일방향성)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위 성질중 integrity는 2번에 의해서 보장된다.&lt;br /&gt;
Encrypt/decrypt와의 차이점은 3번이다. 복호화가 어렵기 때문이다.&lt;/p&gt;

&lt;p&gt;예를 들어보자 h(x): x/23해서 소수점 7~10자리 수를 추출&lt;br /&gt;
h(345689) = xx.95652177391&lt;br /&gt;
출력값은 일정하나, reverse는 불가능하다.&lt;/p&gt;

&lt;p&gt;그러나 h(232.8395049993) = 7391 처럼 다른 값을 넣었음에도 값이 같은 일명 collision이 일어날 수 있다.&lt;br /&gt;
Collison은 서로 다른 입력값이 같은 해시값을 계산하는 것을 의미한다.&lt;br /&gt;
충동저항성은 collision이 일어날 확률이 작음을 의미한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;MAC&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;메시지 무결성: 변경되지 않은 원본이 맞음&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc01.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;메시지와 해쉬값을 붙어서 보낸다.&lt;br /&gt;
받는사람은 비교해서 같으면 원본 다르면 원본이 아닌걸 알 수 있다.&lt;br /&gt;
하지만 여기서 sender authenticationd은 제공되지 않는다.&lt;br /&gt;
Digital Signature에서 이문제를 해결한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Digital Signature&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무결성과 인증을 동시에 제공&lt;/li&gt;
  &lt;li&gt;키를 사용한다(키를 모르는 사용자는 생성불가)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc02.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;비교하여 같으면 변조되지 않고 보낸사람을 인증해준다.&lt;br /&gt;
하지만 mac도 한계가 있는데 제 3자에 대한 sender authentication이 불가능 하다.&lt;br /&gt;
키를 모르면 인증을 못하기 때문이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Replay Attack&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc03.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 MAC 공격방법이다.&lt;br /&gt;
Attacker는 고객이 보낸 똑같은 패킷을 복사하여 고객으로 위장하는 공격 방법이다.&lt;br /&gt;
이러한 공격을 막는 방법은 패킷에 추가정보로 시간을 알려주는 time stamp를 넣어 해결할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;대표적인 해쉬 함수로는 두가지 계열이 있는데 MD와 SHA 계열이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;MD (Message Digest)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;MD2,4,5,6​&lt;/li&gt;
  &lt;li&gt;Ron Rivest (RSA), 1990~92​&lt;/li&gt;
  &lt;li&gt;Merkle structure기반​&lt;/li&gt;
  &lt;li&gt;128bit hash 값​&lt;/li&gt;
  &lt;li&gt;512 bit block size ​&lt;/li&gt;
  &lt;li&gt;MD4는 32bit CPU 전용 (MS)​&lt;/li&gt;
  &lt;li&gt;MD5는 SHA1등 최신 해시들의 기초가됨​&lt;/li&gt;
  &lt;li&gt;2005 강한 충돌 내성 깨짐&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;SHA (Secure Hash Algorithm)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;NIST 1993​&lt;/li&gt;
  &lt;li&gt;Merkle structure기반​&lt;/li&gt;
  &lt;li&gt;SHA0,1은 160bit hash 값, SHA2는 224~512bit​&lt;/li&gt;
  &lt;li&gt;512 bit block size ​&lt;/li&gt;
  &lt;li&gt;최대 2^64-1 bit 메시지처리​&lt;/li&gt;
  &lt;li&gt;가장 많이 사용​&lt;/li&gt;
  &lt;li&gt;2005 강한 충돌 내성 깨짐&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc04.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 Merkle structure의 예시이다.&lt;br /&gt;
MD, SHA 두가지 모두 Merkle structure기반인데 이것은
Message를 block으로 나누어서 고정된 길이의 입력값을 받아들여 고정된 길이로 출력하는 압축함수를 반복 사용하여 긴 길이의 입력을 처리할 수 있는 해쉬 함수로 학대하여 설계하는 방식이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hash attack&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;같은 해시값을 갖는 다른 입력값을 찾아낸다​&lt;/li&gt;
  &lt;li&gt;예를 들면, (ID, PWD)값은 해시값으로 저장되어 있다.​&lt;/li&gt;
  &lt;li&gt;만일 같은 해시값을 갖는 (ID2, PWD2)를 찾는다면, (ID, PWD)로 로그인 가능​하다&lt;/li&gt;
  &lt;li&gt;(ID, PWD), (ID2, PWD2)를 충돌쌍(collision pairs)라 한다​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">Hash</summary>
      

      
      
    </entry>
  
</feed>
