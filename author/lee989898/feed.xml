<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://lee989898.github.io/author/lee989898/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://lee989898.github.io/" rel="alternate" type="text/html" />
  <updated>2021-10-15T20:23:54+09:00</updated>
  <id>https://lee989898.github.io/author/lee989898/feed.xml</id>

  
  
  

  
    <title type="html">LEE | </title>
  

  
    <subtitle>공부 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">PL-02</title>
      <link href="https://lee989898.github.io/pl-02" rel="alternate" type="text/html" title="PL-02" />
      <published>2021-10-13T19:18:00+09:00</published>
      <updated>2021-10-13T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-02</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-02">&lt;h1 id=&quot;제-2장--프로그래밍-언어&quot;&gt;&lt;strong&gt;제 2장  프로그래밍 언어&lt;/strong&gt;&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;왜 PL을 공부하는가?&lt;/strong&gt;
&lt;br /&gt;&lt;br /&gt;
프로그래밍 언어는 알고리즘 또는 계산을 표현하는데 적합하도록 설계된 인공
언어이다.&lt;br /&gt;
프로그램은 알고리즘을 프로그래밍 언어로 코딩한 것으로, 데이터 입력,
입력 데이터 처리, 데이터 출력으로 구성된다.
&lt;br /&gt;&lt;br /&gt;
언어의 특징을 이해하면, 효과적인 알고리즘의 개발 능력과 언어 활용 능력을
개선 할 수 있다.&lt;br /&gt;
대표적인 특성을 예를 들면, 객체지향성, recursion, call by value,
call by reference 등이 있다.&lt;/p&gt;

    &lt;p&gt;응용의 특성에 더욱 적합한 PL을 선택할 수 있게 되고 새로운 언어 학습 능력을
올려주고 새로운 언어를 더욱 쉽게 설계 할 수 있다. 또한 구현 시스템의 중요성을 
이해할 수 있다.
구현 이슈 예로는 아래 두가지가 있다. 구현 이슈에 관한 지식을 활용하면
효율성이 더 좋은 것을 선택할 수 있다. 
&lt;br /&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;Recursion과 Loop 중에서 어느 것이 더욱 효율적인가?
&lt;br /&gt;​&lt;/li&gt;
      &lt;li&gt;작은 서브프로그램을 자주 호출하는 것은 좋은 방법인가? ​
        &lt;ul&gt;
          &lt;li&gt;Recursion이나 서브 프로그램 호출 비용에 비해 실행 시간이 너무 짧다면,
성늘을 떨어뜨리기 때문에, Loop을 사용하거나 서브 프로그램을 일정 규모 이상
으로 설계하는 것이 좋다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;응용의 특성에 대한 적절한 PL의 선택의 예&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Fortran
    &lt;ul&gt;
      &lt;li&gt;포트란은 부동점 소수를 4바이트로 표현하고, double precision은 8
바이트로 표한하기 때문에 부동점 소수 계산에 강점이 있다. 또한 데이터 구조로
배열을 지원하며, 2차원 배열로 매트릭스를 표현한다. 이러한 이유들로
숫자 계산을 주로 수행하는 과학 응요에서 사용된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;COBOL
    &lt;ul&gt;
      &lt;li&gt;입출력 데이터는 여러 데이터 필드로 구성된 레코드 구조이며,
 각 필드는 숫자와 문자값을 갖는다. 십진수, 문자를 주로 처리하여 
 비즈니스 응용에 주로 사용된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Lisp
    &lt;ul&gt;
      &lt;li&gt;심볼릭 컴퓨팅을 주로 수행하는 인공 지능 응용에서 주로 사용된다.
 데이터를 링크드 리스트로 표현하며 문자열의 조작에 특화되어 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;PL의 범주에는 세가지가 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;명령/절차적 언어(imperative, procedural)&lt;/li&gt;
  &lt;li&gt;함수적 언어&lt;/li&gt;
  &lt;li&gt;논리적 언어
 etc) 객체지향 언어는 명령/절차적 언어에서 파생된 것으로서, 별도의 범주로 다루지
 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;컴퓨터는 명령어를 받아서 연산을 수행한다. 따라서 프로그래밍은 컴퓨터에게
 절차적 명령어를 보내는 것과 같다.
 아래 코드를 보자.&lt;/p&gt;

&lt;hr /&gt;

&lt;noscript&gt;&lt;pre&gt;int fact(int n) {
  int sofar = 1;
  while (n&amp;gt;0) sofar *= n--;
  return sofar;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/lee989898/7c9d341efe4369acac607d2e56a9f3ce.js&quot;&gt; &lt;/script&gt;

&lt;hr /&gt;
&lt;p&gt;fact(n)은 n!을 계산하는 함수이며, 
 함수안에 정의된 sofar는 현재까지 계산된 n!값을 간직하는 변수이다. ​
 While loop을 끝까지 돌려보면 n에서 시작하여 n=1일 때까지 계속 곱셈(*)을 실행한다. ​
 즉, sofar는 1에서 n까지 곱한 결과이다.  ​
 오늘날 모든 컴퓨터는 본 뉴만 아키텍처로 구성되어 있기 때문에, PL은 이 아키텍처를 모방하고 있다. ​
아래 그림이 본 뉴만 아키텍처이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/pl/pl02.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어02&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;본 뉴만 아키텍처 컴퓨터에서는 다음과 같이 프로그램을 실행한다.
메모리는 프로그램과 메모리를 저장하고, CPU는 연산을 수행한다.   ​
프로그램을 실행하려면, 먼저 프로그램과 데이터를 메모리에 저장해야한다.   ​
PC(program counter)를 프로그램의 첫번째 명령어 위치로 초기화하고, ​
PC가 가리키는 명령어를 Control unit(Decoder 포함)에 적재한다. ​
Control unit(Decoder)는 명령어의 의미(무슨 연산을 해야할지)를 해석하고,​
데이터를 레지스터에 적재하여 ALU에서 연산을 수행한다. ​
연산이 끝나면 그 결과를 메모리에 저장하거나 출력 장치로 내보낸다. ​
연산 뿐만 아니라 control structure(loop, if-then, etc)도 PC와 control unit에 의해 통제된다.&lt;/p&gt;

&lt;p&gt;메모리에서 인스트럭션을 CPU로 가져와서 실행하는 반복적인 절차를 Fetch-execute-cycle이라고 한다. ​
Fetch-execution 사이클이 실행하는 인스트럭션은 어셈블리 코드 또는 머신 코드이다. ​
머신 코드는 컴퓨터가 이해할 수 있는 명령어이고, 어셈블리 코드는 머신코드를 기호로 표현한 것이다.​&lt;/p&gt;

&lt;p&gt;Fetch-execution cycle은 다음과 같다. ​&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;PC를 초기화한다. ​&lt;/li&gt;
  &lt;li&gt;PC가 가리키는 명령어를 fetch하고 ​&lt;/li&gt;
  &lt;li&gt;PC를 증가시킨 다음, ​&lt;/li&gt;
  &lt;li&gt;Fetch한 명령어를 decod하여 ​&lt;/li&gt;
  &lt;li&gt;실행한다. ​&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;더 이상 실행할 명령어가 없을 때까지 1~4를 반복적으로 실행한다. ​&lt;/p&gt;

&lt;p&gt;팩토리얼 함수를 예로 들어보자.
여기서는 메모리와 CPU간의 데이터 이동에 대해 살펴보도록 하자.
컴퓨터가 고급언어를 머신코드로 번역하지 않고 이해할 수는 없지만, ​
설명을 위해 고급 언어를 컴퓨터가 직접 이해한다고 가정한다.
변수 sofar과 n은 메모리에서 공간을 잡고 값을 저장하고 있으며, ​
프로그램 코드는 메모리에 저장되어 있다.
PC가 int sofar를 읽어 오면 Control unit은 =을 assignment로 해석하여 sofar에 1을 할당한다. 
PC가 while loop의 sofar *=n–를 읽어 오면 ALU에서 반복적으로 n!을 계산하고,
PC가 return sofar를 읽어 오면 sofar 값을 메모리에 저장한다. ​&lt;/p&gt;

&lt;p&gt;이와 같이 명령/절차적 언어는 본 뉴만 아키텍처에 적합하게 다음과 같이 실행된다.    ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로그램의 변수는 메모리 셀을 지칭하고, 그 셀에 저장된 값을 대표한다. ​&lt;/li&gt;
  &lt;li&gt;Assignment 문장은 메모리와 CPU 간의 데이터를 이동시킨다. ​&lt;/li&gt;
  &lt;li&gt;연산과 표현식(expression)은 CPU에서 실행된다. ​&lt;/li&gt;
  &lt;li&gt;실행 흐름의 명시적 통제는 프로그램 카운터에 의한다. ​
현재 널리 사용되고 있는 C, C++, Java는 이런 유형의 PL이다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;명령/절차적 언어는 실행 성능의 최적화를 위한 언어와 하드웨어 간의 효율적 매핑을 허용하지만, ​&lt;br /&gt;
본 뉴만 아키텍처에 의해 제한된다.&lt;/p&gt;

&lt;p&gt;고급어 프로그램은 컴파일러에 의해 어셈블리어 프로그램으로 번역되고 ​
어셈블리어 프로그램은 어셈블러에 의해 기계어 프로그램으로 번역된다. ​
기계어 프로그램은 인터프리터에 의해 ALU 연산으로 해석되어 실행된다.     ​&lt;/p&gt;

&lt;p&gt;어셈블리어 프로그램은 RISC 아키텍처의 인스트럭션을 포함하고 있다. ​
RISC 아키텍처는 인스트럭션 집합을 가능한 줄이고 단순화시켜 성능 개선을 이룩한 사례로 남아 있다. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;함수적 프로그래밍은 수학 함수식과 유사하다. ​
각 서브 프로그램은 함수의 구현이다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;fun fact x =
  if x &amp;lt;= 0
  then 1 
  else x * fact(x-1);&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/lee989898/8c70fd99576b6311bb713fd3e2d2cda8.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;p&gt;코드는 ML 언어로 팩토리얼을 구하는 프로그램을 보여주고 있다. ​
Fact 내에서 fact를 호출하는 Recursion을 사용하고 있다.&lt;/p&gt;

&lt;p&gt;또 다른 함수 언어로 리스프를 들 수 있다.
ML과 달리 변수와 assignment가 없다. ​
이 말은 변수로 인해 고정적으로 소비되는 메모리가 없다는 말이다.
즉, 필요시 동적으로 메모리를 할당하고 계산한다.
ML과 마찬가지로 리커전을 컨트롤 구조로 갖고 있다.
이후 리스프는 변화를 겪으면서 사용되고 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​로직 프로그래밍은 술어 논리(predicate logic)에 기반하고 있다.
 로직 프로그램은 사실(fact), 규칙(rule), 목표(goal)로 구성되어 있으며, 
 로직 프로그램의 실행은 목표에 사실과 규칙을 적용하여&lt;br /&gt;
 목표가 논리적으로 추론될 수 있는지, 다시 말하면 참인지 거짓인지 증명하는 절차이다.  ​
 이를 위해 추론 엔진이 필요한데, ​
 로직 프로그램의 추론은 resolution reputation에 의한 추론 엔진을 사용한다.
 이 프로그램에서 grandparent(vern, kake)가 추론될 수 있는 살펴보자.​&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fact:  mother(joanne,jake).​
  father(vern,joanne).​
 
rule:  grandparent(X,Z) :- parent(X,Y),​
           parent(Y,Z).​
goal:  grandparent(vern,jake). ​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;규칙 grandparent(X,Z) :- parent(X,Y), parent(Y,Z)에 X, Z에 각각 vern, jake를 대입하면,  ​
 grandparent(vern,Z) :- parent(X,Y), parent(Y,jake)가 추론된다.
 사실의 mother, father 모두 parent이므로, parent(joanne, jake), parent(vern, joanne)이다. ​&lt;/p&gt;

&lt;p&gt;로직 프로그래밍 언어는 프로그램에 입력 데이터에서 출력 데이터를 생성하는 절차를 서술하는 것이 아니라, ​
 사실과 규칙을 술어 논리로 선언하고, 원하는 것(목표)가 무엇인지 선언한다. ​
 따라서 로직 프로그래밍 언어는 비절차적(선언적)이다.&lt;/p&gt;

&lt;p&gt;로직 프로그래밍은 resolution을 해야 하기 때문에, 매우 비효율적(느리다)이다. ​
 따라서 응용 분야가 대단히 좁다.(DB, AI)  ​ 
 팩토리알 계산하는 프로그램을 봅자.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;fact(X,1) :-  X =:= 1.
fact(X,Fact) :-
  X &amp;gt; 1, NewX is X - 1,
  fact(NewX,NF),
  Fact is X * NF.&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/lee989898/fca92516fff281d9b22e9c38494280bf.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;보기엔 깔끔해 보일 수 있지만, 레졸루션해서 풀려면 오래걸린다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="study" />
      

      
        <summary type="html">제 2장 프로그래밍 언어</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">PL-01</title>
      <link href="https://lee989898.github.io/pl-01" rel="alternate" type="text/html" title="PL-01" />
      <published>2021-10-13T19:18:00+09:00</published>
      <updated>2021-10-13T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-01</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-01">&lt;h1 id=&quot;제-1장--프로그래밍-언어&quot;&gt;&lt;strong&gt;제 1장  프로그래밍 언어&lt;/strong&gt;&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프로그래밍 언어란?&lt;/strong&gt;
&lt;br /&gt;&lt;br /&gt;
프로그래밍 언어는 인공적으로 설계된 언어로 컴퓨터가 실행할 수 있는 계산이나
알고리즘을 표현하는 수단이다.
&lt;br /&gt;&lt;br /&gt;
인간의 언어는 타인에게 자신의 생각을 표현하듯이 프로그래밍 언어는
자신의 생각을 컴퓨터에게 표현하는 수단이다.
&lt;br /&gt;&lt;br /&gt;
현재 프로그래밍 언어는 매우 다양할까?&lt;br /&gt;
문제의 특성에 따라, 프로그램이 각기 요구하는 프로그래밍 언어의 표현력이
다르기 때문이다. 표현력은 언어 선택에 있어 매우 중요하다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;  &lt;br /&gt;
문제해결에 적합한 언어를 선택하려면 아래 내용을 숙지해야 한다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;언어가 다르면, 알고리즘의 표현이 어떻게 다른가? ​&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;어떤 언어가 더 적합한가? 언어의 적합성(goodness)을 어떻게 평가할 것인가? ​&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;왜 이렇게 다른 언어가 많은가? ​&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;도대체 프로그래밍 언어가 뭔가? ​&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;프로그래밍 언어의 특성이 왜 이렇게 많은가? ​&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이들 특성은 어떻게 구현시스템에서 실현되는가?​&lt;/p&gt;
        &lt;ul&gt;
          &lt;li&gt;여기서 구현 시스템이란 컴파일러나 인터프리터 등 PL을 실행할 수 있는 소프트웨어를 말한다. ​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;프로그래밍 언어의 역사, 신택스 및 시맨틱스, 바인딩, 데이터 타입,
컨트롤 구조, 서브 프로그램, 추상데이터 타입, 캡슐화, 예외 처리,
함수 프로그래밍을 공부할 것이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/pl/pl01.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어01&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;PL의 트렌드에 따른 언어를 살펴보면 다음과 같은 특성을 갖고 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;타입의 안정성을 고려한 언어의 사용 증가: C,C++에 비해 Java, C# 타입이 안정적임&lt;/li&gt;
  &lt;li&gt;웹 응용을 위해 클라이언트 측의 기능성을 갖춘 스크립트 언어&lt;/li&gt;
  &lt;li&gt;신택스 보다 알고리즘의 표현력에 중점을 둔 언어&lt;/li&gt;
  &lt;li&gt;컴파일, 분석, 타입 검사 등 실행 환경과 가상화를 갖춘 언어&lt;/li&gt;
  &lt;li&gt;자동 오류 탐지 및 복구 등 프로그램 분석 능력을 갖춘 언어&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PL에 영향을 미치는 요인을 표현력과 구현 시스템의 효율 측면에서 살펴보면 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;표현력: 응용 도메인의 특성과 프로그래밍 방법을 들 수 있다. &lt;br /&gt;
    다중 프로그래밍은 큰 작업(프로그램)이 여러 개의 작은 작업(서브프로그램)으로
    나뉘어져서 서로 연관성을 가지고 동시에 실행되는 것을 말한다.&lt;br /&gt;
    물론 동시라는 말은 특정 시간에는 작은 작업 하나가 실행되지만, 
    타임 피리어드 동안 여러 개의 작은 프로그램이 
    동시에 처리되는 것으로 보이게 된다.&lt;br /&gt;
    이것은 CPU의 시분할과 메모리의 공간 분할에 의해 이루어진다.
    이렇게 하여 큰 프로그램 하나가 다른 프로그램의 방해없이
    여러 개의 작은 서브프로그램으로 나누어져 처리될 수 있는 것이다.  ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;언어 구현 시스템의 효율성: 즉 컴파일러나 인터프리터의 성능을 말한다.&lt;br /&gt;
    컴파일러나 인터프리터의 성능은 주로 컴퓨터 구조, OS, 관련 도구, 라이브러리 등에 달려 있다.    ​
    편의성은 비용을 수반한다. 추상적 관점을 지원하면 편의성은 좋아지지만, 이것을 머신에 
    표현하는데는 나름의 비용이 들어간다.   이러한 사실을 고려하여 편의성과 비용간에 균형을 잡는 것이 
    중요하다.   ​&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="study" />
      

      
        <summary type="html">제 1장 프로그래밍 언어</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">PL-03</title>
      <link href="https://lee989898.github.io/pl-03" rel="alternate" type="text/html" title="PL-03" />
      <published>2021-10-13T19:18:00+09:00</published>
      <updated>2021-10-13T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-03</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-03">&lt;h1 id=&quot;제-3장--프로그래밍-언어&quot;&gt;&lt;strong&gt;제 3장  프로그래밍 언어&lt;/strong&gt;&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;프로그래밍 언어가 프로그램 설계 방법에 준 영향&lt;/strong&gt;
&lt;br /&gt;&lt;br /&gt;
역사적으로 프로그래밍 언어는 응용의 표현에 적합한 개념이 추가되면서 발전되어 왔으며,  ​
그 개념의 활용에 필요한 프로그램 설계 방법이 개발되었다. ​
이에 대해 간략히 간단히 살펴 보자.&lt;br /&gt;
&lt;br /&gt;
    &lt;ul&gt;
      &lt;li&gt;50년대와 60년대 초반에는 숫자 계산을 주로 수행하는 수치 해석 등 비교적 단순한 응용이 컴퓨팅의 주류를 이루었고, 이들 프로그램은 수식 표현이 용이한 Fortran으로 작성되었다.  이러한 이유로 프로그램 설계 방법은 
기계(컴퓨팅 자원)의 효율적 사용 방법을 찾는데 집중되었다.&lt;br /&gt;
 &lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;60년대 후반에는 프로그램의 데이터 처리 절차가 복잡해지고 타인이 작성
한 프로그램을 이해하고 수정하기가 어려워지면서, 기계의 효율적 
사용보다 프로그래머의 효율(생산성)에 관심이 집중되었다. 따라서
 프로그램의 가독성(readability), 다양한 컨트롤 스트럭처에 의한
표현의 편리성이 언어의 중요한 요소로 인식되고, 이를 지원하는 A
LGOL 언어가 등장했다. 이러한 언어를 통해 구조적 프로그래밍, 
하향식 설계, 단계적 정련 기법 등 프로그래밍 기법 또는 설계 방법
이 개발되었다.  여기서 컨트롤 스트럭처란 if-then, loop, {중
괄호} 등과 같이 인풋의 처리 로직을 표현하는 데 사용되는 구조를 
말한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;1970년대 후반에는 데이터의 구조가 복잡해지면서,
 처리 절차 중심의 프로그램 설계에서 데이터 중심의 프
 로그램 설계로 옮겨갔다. 이를 위해 데이터 추상화 기법이 창안되었다
 . 데이터 추상화 기법은 데이터를 구조화하고, 이 데이터에 대한 연산
 을 정의한다. 이와 같은 데이터 추상화 기법은 추상 데이터 타입을 지
 원하는 프로그래밍 언어를 탄생시켰다. 이것이 바로 ALGOL을 발전시
 킨 Pascal의 등장이다. Pascal은 Java가 등장하기 전까지 모든 컴
 퓨터 관련 학과에서 필수 언어로 가르쳤다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;1980년 중반에 데이터 추상화, 상속(속성, 메소드), 
동적 바인딩을 특징으로 하는 객체 지향 언어가 등장하여
 지금까지 이어오고 있다. C++, Java 등이 대표적인 언
 어로, 이들 특징은 이후의 다른 언어에서도 지원할 수 있
 을 정도로 일반적이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/pl/pl03.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어03&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;이 그림은 널리 사용되어 온 프로그래밍 언어의 족보를 보여주고 있다. ​
 많은 언어가 생멸하는 와중에 지속적인 발전이 있었음을 알 수 있다. ​
 눈여겨 볼만한 중요한 언어로는 FORTRAN, COBO
 L, COMMON LISP, Pascal, C, C++, Java 등이다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="study" />
      

      
        <summary type="html">제 3장 프로그래밍 언어</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">클래스의 상속</title>
      <link href="https://lee989898.github.io/kotlin-10" rel="alternate" type="text/html" title="클래스의 상속" />
      <published>2021-09-25T01:07:00+09:00</published>
      <updated>2021-09-25T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-10</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-10">&lt;h1 id=&quot;클래스의-상속&quot;&gt;클래스의 상속&lt;/h1&gt;

&lt;hr /&gt;

&lt;noscript&gt;&lt;pre&gt;fun main() {
    var intValue:Int = 1234
    var LongValue:Long = 1234L
    var intValueByHex:Int = 0x1af
    var intValueByBin:Int = 0b10110110
    
    var doubleValue:Double = 123.5
    var doubleValueWithExp: Double = 123.5e10
    var floatValue:Float = 123.5f
    
    var charValue: Char = &amp;#39;a&amp;#39;
    var koreanCharValue: Char = &amp;#39;가&amp;#39;
    
    var booleanValue: Boolean = true
    
    var stringValue = &amp;quot;one line string test&amp;quot;
    
    val multiLineStringValue = &amp;quot;&amp;quot;&amp;quot;multiline
    string
    test&amp;quot;&amp;quot;&amp;quot;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/lee989898/c6ccc4221fdbd96eae8b91fa55199f92.js&quot;&gt; &lt;/script&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">클래스의 상속</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">클래스의 생성</title>
      <link href="https://lee989898.github.io/kotlin-09" rel="alternate" type="text/html" title="클래스의 생성" />
      <published>2021-09-25T01:07:00+09:00</published>
      <updated>2021-09-25T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-09</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-09">&lt;h1 id=&quot;클래스의-생성&quot;&gt;클래스의 생성&lt;/h1&gt;

&lt;hr /&gt;

&lt;noscript&gt;&lt;pre&gt;fun main() {
    var intValue:Int = 1234
    var LongValue:Long = 1234L
    var intValueByHex:Int = 0x1af
    var intValueByBin:Int = 0b10110110
    
    var doubleValue:Double = 123.5
    var doubleValueWithExp: Double = 123.5e10
    var floatValue:Float = 123.5f
    
    var charValue: Char = &amp;#39;a&amp;#39;
    var koreanCharValue: Char = &amp;#39;가&amp;#39;
    
    var booleanValue: Boolean = true
    
    var stringValue = &amp;quot;one line string test&amp;quot;
    
    val multiLineStringValue = &amp;quot;&amp;quot;&amp;quot;multiline
    string
    test&amp;quot;&amp;quot;&amp;quot;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/lee989898/c6ccc4221fdbd96eae8b91fa55199f92.js&quot;&gt; &lt;/script&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">클래스의 생성</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">클래스의 기본구조</title>
      <link href="https://lee989898.github.io/kotlin-08" rel="alternate" type="text/html" title="클래스의 기본구조" />
      <published>2021-09-25T01:07:00+09:00</published>
      <updated>2021-09-25T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-08</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-08">&lt;h1 id=&quot;클래스의-기본구조&quot;&gt;클래스의 기본구조&lt;/h1&gt;

&lt;hr /&gt;

&lt;noscript&gt;&lt;pre&gt;fun main() {
    var intValue:Int = 1234
    var LongValue:Long = 1234L
    var intValueByHex:Int = 0x1af
    var intValueByBin:Int = 0b10110110
    
    var doubleValue:Double = 123.5
    var doubleValueWithExp: Double = 123.5e10
    var floatValue:Float = 123.5f
    
    var charValue: Char = &amp;#39;a&amp;#39;
    var koreanCharValue: Char = &amp;#39;가&amp;#39;
    
    var booleanValue: Boolean = true
    
    var stringValue = &amp;quot;one line string test&amp;quot;
    
    val multiLineStringValue = &amp;quot;&amp;quot;&amp;quot;multiline
    string
    test&amp;quot;&amp;quot;&amp;quot;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/lee989898/c6ccc4221fdbd96eae8b91fa55199f92.js&quot;&gt; &lt;/script&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">클래스의 기본구조</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">흐름제어와 논리연산자</title>
      <link href="https://lee989898.github.io/kotlin-07" rel="alternate" type="text/html" title="흐름제어와 논리연산자" />
      <published>2021-09-25T01:07:00+09:00</published>
      <updated>2021-09-25T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-07</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-07">&lt;h1 id=&quot;흐름제어와-논리연산자&quot;&gt;흐름제어와 논리연산자&lt;/h1&gt;

&lt;hr /&gt;

&lt;noscript&gt;&lt;pre&gt;fun main() {
    var intValue:Int = 1234
    var LongValue:Long = 1234L
    var intValueByHex:Int = 0x1af
    var intValueByBin:Int = 0b10110110
    
    var doubleValue:Double = 123.5
    var doubleValueWithExp: Double = 123.5e10
    var floatValue:Float = 123.5f
    
    var charValue: Char = &amp;#39;a&amp;#39;
    var koreanCharValue: Char = &amp;#39;가&amp;#39;
    
    var booleanValue: Boolean = true
    
    var stringValue = &amp;quot;one line string test&amp;quot;
    
    val multiLineStringValue = &amp;quot;&amp;quot;&amp;quot;multiline
    string
    test&amp;quot;&amp;quot;&amp;quot;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/lee989898/c6ccc4221fdbd96eae8b91fa55199f92.js&quot;&gt; &lt;/script&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">흐름제어와 논리연산자</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">형변환과 배열</title>
      <link href="https://lee989898.github.io/kotlin-03" rel="alternate" type="text/html" title="형변환과 배열" />
      <published>2021-09-25T01:07:00+09:00</published>
      <updated>2021-09-25T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-03</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-03">&lt;h1 id=&quot;형변환과-배열&quot;&gt;형변환과 배열&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;형변환&quot;&gt;형변환&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;형변환은 하나의 변수에 지정된 자료형을 
호환되는 다른 자료형으로 변경하는 기능입니다&lt;/p&gt;

&lt;p&gt;코틀린은 형변환시 발생할 수 있는 오류를 막기 위해 자동으로 형변환 
해주는 암시적 형변환은 지원하지 않습니다&lt;/p&gt;

&lt;p&gt;명시적 형변환은 변환될 자료형을 개발자가 직접 지정하는 것입니다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;형변환 함수
    &lt;ul&gt;
      &lt;li&gt;toByte()&lt;/li&gt;
      &lt;li&gt;toShort()&lt;/li&gt;
      &lt;li&gt;toInt()&lt;/li&gt;
      &lt;li&gt;toLong()&lt;/li&gt;
      &lt;li&gt;toFloat()&lt;/li&gt;
      &lt;li&gt;toDouble()&lt;/li&gt;
      &lt;li&gt;toChar()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;noscript&gt;&lt;pre&gt;fun main() {
    var a: Int = 54321
    var b: Long = a.toLong()
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/lee989898/c96b8a54be145f7b4b07f03f4e1336e6.js&quot;&gt; &lt;/script&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;배열&quot;&gt;배열&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;배열은 내부적으로 Array&lt;T&gt; 클래스로 제공되는 기능입니다&lt;/T&gt;&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;fun main() {
    
    var intArr = arrayOf(1,2,3,4,5)
    
    val nullArr = arrayOfNulls&amp;lt;Int&amp;gt;(5) //비어있는 배열 만들기
    
    intArr[2] = 8
    
    println(intArr[4])
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/lee989898/6e915687a4c5bcea20ac0c89e590ce74.js&quot;&gt; &lt;/script&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">형변환과 배열</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">타입추론과 함수</title>
      <link href="https://lee989898.github.io/kotlin-04" rel="alternate" type="text/html" title="타입추론과 함수" />
      <published>2021-09-25T01:07:00+09:00</published>
      <updated>2021-09-25T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-04</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-04">&lt;h1 id=&quot;타입추론과-함수&quot;&gt;타입추론과 함수&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;타입추론&quot;&gt;타입추론&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;타입추론은 변수나 함수들을 선언할 때나 연산이 이루어 질 떄
자료형을 코드에 명시하지 않아도 코틀린이 자동으로 자료형을 추론해주는
기능입니다&lt;/p&gt;

&lt;p&gt;변수가 선언될 때 할당된 값의 형태로 해당 변수가 어떤 자료형을 가지는지 
추론이 가능하기 때문입니다&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;fun main() {
    
   var a = 1234
   var b = 1234L
   
   var c = 12.45
   var d = 12.45f
    
   var e = 0xABCD
   var f = 0b01010101
    
   var g = true
   var h = &amp;#39;c&amp;#39;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/lee989898/425656230beda11e903155fee1a0eb07.js&quot;&gt; &lt;/script&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;함수&quot;&gt;함수&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;함수는 특정한 동작을 하거나 원하는 결과값을 연산하는데 사용합니다.&lt;/p&gt;

&lt;p&gt;함수안에서 return은 뒤에 오는 값을 반환하는 키워드로 return이 발생하면
함수의 중간이더라도 값을 반환하고 함수를 종료합니다&lt;/p&gt;

&lt;p&gt;코틀린은 함수를 좀 더 간단하게 기술할 수
 있도록 단일 표현식 함수를 지원합니다&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;fun main() {
    
    println(add(5,6,7))
   
}

fun add(a: Int, b: Int, c: Int): Int{
    return a+b+c    
}

fun add(a: Int, b: Int, c: Int) = a + b + c //위 함수와 동일합니다&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/lee989898/9e247743b379a5df3a1bc54a6c16124f.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;코틀린에서 함수는 내부적으로 기능을 가진 형태이지만 외부에서
볼 때는 파라미터를 넣는다는 점 외에는 자료형이 결정된 변수라는 개념으로
접근합니다&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">타입추론과 함수</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">조건문과 비교연산자</title>
      <link href="https://lee989898.github.io/kotlin-05" rel="alternate" type="text/html" title="조건문과 비교연산자" />
      <published>2021-09-25T01:07:00+09:00</published>
      <updated>2021-09-25T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-05</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-05">&lt;h1 id=&quot;조건문과-비교연산자&quot;&gt;조건문과 비교연산자&lt;/h1&gt;

&lt;hr /&gt;

&lt;noscript&gt;&lt;pre&gt;fun main() {
    var intValue:Int = 1234
    var LongValue:Long = 1234L
    var intValueByHex:Int = 0x1af
    var intValueByBin:Int = 0b10110110
    
    var doubleValue:Double = 123.5
    var doubleValueWithExp: Double = 123.5e10
    var floatValue:Float = 123.5f
    
    var charValue: Char = &amp;#39;a&amp;#39;
    var koreanCharValue: Char = &amp;#39;가&amp;#39;
    
    var booleanValue: Boolean = true
    
    var stringValue = &amp;quot;one line string test&amp;quot;
    
    val multiLineStringValue = &amp;quot;&amp;quot;&amp;quot;multiline
    string
    test&amp;quot;&amp;quot;&amp;quot;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/lee989898/c6ccc4221fdbd96eae8b91fa55199f92.js&quot;&gt; &lt;/script&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">조건문과 비교연산자</summary>
      

      
      
    </entry>
  
</feed>
