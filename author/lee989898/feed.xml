<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://lee989898.github.io/author/lee989898/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://lee989898.github.io/" rel="alternate" type="text/html" />
  <updated>2021-10-22T18:30:36+09:00</updated>
  <id>https://lee989898.github.io/author/lee989898/feed.xml</id>

  
  
  

  
    <title type="html">LEE | </title>
  

  
    <subtitle>공부 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">복잡한 데이터 타입</title>
      <link href="https://lee989898.github.io/pl-13" rel="alternate" type="text/html" title="복잡한 데이터 타입" />
      <published>2021-10-14T19:18:00+09:00</published>
      <updated>2021-10-14T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-13</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-13">&lt;h1 id=&quot;제-13장--프로그래밍-언어&quot;&gt;&lt;strong&gt;제 13장  프로그래밍 언어&lt;/strong&gt;&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;복잡한 데이터 타입&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;배열과 레코드 타입을 살펴보자&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;배열&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;배열은 동일한 유형의 데이터 요소의 모임으로, ​
각 요소의 위치에 의해 지칭된다(식별된다). ​
각 요소의 위치를 나타내는 방식은 ​
‘배열의 맨앞에서 시작하여 각 요소
의 상대적 위치를 지칭하는 인덱스(서브스크립트, subscript)’에 의한다. ​
이와 같이 상대적 위치를 지칭하기 위해서는, ​
인덱스와 요소 간의 매핑이 필요한데, ​
이러한 매핑을 배열 인덱싱 또는 subscripting이라고 한다. ​
1차원 배열 인덱싱은 사소한 문제에 불과하지만, ​
배열의 차원이 증가하고 각 차원의 범위가 다양해지면서 ​
배열의 인덱싱 문제는 복잡해진다.&lt;/p&gt;

&lt;p&gt;배열 인덱스 유형은 주로 정수형을 사용하나 언어에 따라 약간 다르다. ​
포트란, C, 자바는 정수형만을 지원하나, ​
파스칼은 모든 서수 유형(정수, 부울리언, 글자)을 지원한다. ​
C, C++, 펄, 포트란은 인덱스에 대해 범위 검사를 하지 않지만, ​
자바, ML, C#은 인덱스의 범위를 검사한다. ​&lt;/p&gt;

&lt;p&gt;배열의 범주를 서브스크립트의 범위와 메모리 할당 시기를 기준으로 나누면,  ​
정적 배열, 고정 스택-동적 배열, 고정 힙-동적 배열,
 힙-동적 배열로 구분한다. ​&lt;/p&gt;

&lt;p&gt;정적 배열은 서브스크립트의 범위가 정적으로 고정되어 있고, ​
런타임 이전에 메모리가 정적으로 할당된다.  ​
장점은 효율적이지만, ​
단점은 실행중 필요시마다 동적 할당이 불가능하여 융통성이 없다. ​
C, C++에서 static modifier를 포함하는 배열은 정적 배열이다. ​&lt;/p&gt;

&lt;p&gt;고정 스택-동적 배열은 서브스크립트의 범위가 정적으로 고정되어 있지만, ​
메모리는 미리 할당되지 않고, 선언문 실행 중에 할당된다. ​
장점은 실행되지 않는 서브프로그램에서 정의된 배열에 대해 ​
메모리가 미리 할당되지 않아, 메모리 공간 활용이 효율적이다. ​
C, C++에서 static modifier를 포함하지 않는 배열은 고정 스택-동적 배열이다.&lt;/p&gt;

&lt;p&gt;고정 힙-동적 배열은 스토리지 바인딩이 동적이지만, ​
힙에 할당된 후에는 서브스크립트의 범위가 고정된다. ​
C, C++에서 malloc에 의해 할당된 배열은 고정 힙-동적 배열이다. ​&lt;/p&gt;

&lt;p&gt;힙-동적 배열은 서브스크립트 범위와 스토리지의 바인딩이 ​
모두 동적이면서 변경 가능하다. ​
장점은 배열이 실행 중에 늘어나거나 줄어 들 수 있어서 융통성이 있다. ​
C#에서 ArrayList에 의해 정의된 배열은 힙-동적 배열이다. ​
배열의 요소없이 생성되고 나중에 add를 써서 배열을 늘인다.&lt;/p&gt;

&lt;p&gt;C, C++, C#, 자바에서는 ​
스토리지 할당시에 배열이 초기화된다. ​&lt;/p&gt;

&lt;p&gt;포트란은 배열에 대한 연산을 지원한다. ​
두 배열의 합(+)은 위치가 같은 배열의 각 요소들간의 합을 배열로 나타낸 것이다. ​
A = B + C ——- A, B, C 모두 배열…  ​
배열에 대한 연산을 지원하지 않는다면, ​
loop을 써서 반복적으로 ​
각 요소마다 합을 구해야 함 (A[i] = B[i] + C[i]에 의해)&lt;/p&gt;

&lt;p&gt;순서를 무시한 데이터 요소의 모임을 associative array라고 하며, ​
사용자가 정의한 Key를 인덱스로 사용한다. ​
따라서, associative array는 키와 값의 쌍을 나열한 것이다.  ​
펄에서 associative array를 다음과 같이 정의하고, ​
%hi_temps = (“Mon” =&amp;gt; 77, “Tue” =&amp;gt; 79, “Wed” =&amp;gt; 65, …);​
다음과 같이 배열에서 값을 찾는다.  ​
$hi_temps{“Wed”} = 83; 여기서 Wed가 키이다. ​
다음 명령어는 배열에서 값을 삭제한다.  ​
delete $hi_temps{“Tue”};&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;레코드&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;배열은 동일한 유현의 데이터 요소의 모임인 반면, ​
레코드는 다른 유형의 데이터 요소의 모임이다. ​
레코드에서는 그 요소의 이름으로 요소를 식별(지칭, 언급)한다. ​&lt;/p&gt;

&lt;p&gt;레코드 타입에서 각 필드를 지칭(언급)하는 방법은 필드명에 의하며, ​
서브 필드를 명확히 지칭하기 위해,  ​
코볼에서는 of를 키워드로 하고, ​
다른 언어에서는 dot(.)을 쓰기도 한다. ​
레코드 타입의 연산은 assignment(필드명에 값 할당), ​
레코드간의 필드값 카피 등이다.  ​&lt;/p&gt;

&lt;p&gt;튜플 타입은 레코드와 유사하나, 각 요소의 이름이 없다는 것이 다르다. ​
파이썬의 튜플은 튜플의 값을 변경할 수 없다. ​
만일 변경하고자 한다면, ​
List 함수를 써서 튜플을 배열로 변환한 다음에, ​
배열의 값을 변경한다. ​
변경한 후에, tuple 함수를 써서, 튜플로 재변환한다. ​
myTuple = (3, 5.8, ‘apple’)은 튜플을 생성한다. ​
myTuple[1]은 첫째 요소를 가리킨다. ​
+는 튜플 간의 concatenation을 실행하고, ​
del은 튜플을 삭제한다.&lt;/p&gt;

&lt;p&gt;리스트 타입은 튜플과 유사하나, ​
각 요소의 값을 변경 가능하다는 것이 다르다. ​
파이썬은 리스트 타입을 지원하며, 배열처럼 취급된다. ​
배열과 차이점은 각 요소의 값이 어떤 유형이든 상관없다는 것이다.  ​
생성, 지칭, 삭제 연산 등을 보면 튜플과 유사함을 알 수 있다.​
리스트 포함(comprehension)은 컨스트럭트에 리스트를 포함시키는 것을 말한다. ​
이것은 리스트를 필요시 정의할 수 있는 편리한 기능이다. ​
형식은 [expression for iterate_var in array if condition]
을 취한다.  ​
예를 들면, [x*x for x in range(12) if x%3==0]과 같다. ​
range(12)는 0에서 12까지의 배열을 생성하는 함수이고, ​
x%3은 x를 3으로 나눈 나머지를 말한다. ​
이 문장은 0에서 12로 구성된 배열을 생성하고 ​
0,3,6,9,12를 제곱하라는 뜻이다. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;포인터와 레퍼런스 타입에 대해 살펴보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;포인터&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;포인터 타입 변수가 가질 수 있는 값의 범위는 ​
메모리 주소와 영(nil)이다.  ​
포인터는 간접 주소 지정 방식과 동적 메모리 관리 방식을 제공한다. ​
포인터는 힙에 있는 메모리 위치를 접근할 때 사용된다.&lt;/p&gt;

&lt;p&gt;기본적 연산으로 assignment와 dereferencing이 있다. ​
Assignment는 포인터 변수의 값에 주소를 넣어 두는 것이다. ​
디레퍼런싱은 포인터의 값이 가리키는 주소에 저장된 값을 산출하는 것이다. ​
디레퍼런싱은 명시적이거나 암묵적이다. ​
C, C++에서는 명시적인 디레퍼런싱 연산자로 &lt;em&gt;를 사용한다. ​
j=&lt;/em&gt;ptr는 ptr의 값이 가리키는 주소에 저장된 값을 ​
변수 j의 메모리 위치에 넣어 두라는 의미이다. ​
아래 그림은 이것을 그림으로 나타낸 것이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl35.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;포인터 사용할 때 나타나는 문제는 다음의 두가지가 있다. ​
​&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;허상 포인터(dangling pointer)는 ​
힙-동적 변수에 할당된 메모리를 가리키지 않고 있는 포인터를 말한다.  ​
자세히 설명하면, ​
힙에 의해 변수에 메모리가 할당되면, ​
포인터는 이 메모리를 가리키고 있겠지만,  ​
이후 메모리가 해제되었다면, ​
이 포인터는 메모리를 가리키지 못하게 된다. ​
이러한 포인터를 허상 포인터라고 한다. ​
즉, 메모리는 없지만 포인터는 남아 있는 경우이다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;memory leakage(기억 상실)​
힙-동적 변수의 상실은 힙-동적 변수가 이미 메모리에 할당되어 있지만, ​
포인터가 상실되어 ​
사용자 프로그램에서 이 동적 변수에 더 이상 접근 가능하지
 않은 경우를 말한다. ​
즉, 포인터는 없지만 할당된 메모리는 남아 있는 경우이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;포인터는 언제 메모리에 할당되든지 어떤 변수든 가리킬 수 있으며,  ​
동적 스토리지 관리에서 사용된다. ​
포인터 산술 연산이 가능하고, ​
디레퍼런싱과 ‘무엇의 주소’ 연산이 가능하다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    float stuff[100];​
    float *p;​
    p = stuff;​

    *(p+5) is equivalent to stuff[5] and  p[5]​
    *(p+i) is equivalent to stuff[i] and  p[i]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;C, C++에서는 포인터에 대한 산술 연산이 가능하다. ​
5번째값, i번째값&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;레퍼런스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;레퍼런스는 포인터와 유사하나, ​
기본적으로 다른점은 ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;포인터는 메모리의 주소를 가리키지만, ​
  (주소에 대한 연산이 나름의 의미를 갖지만)​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;레퍼런스는 메모리의 값을 가리킨다. ​
  (주소에 대한 연산이 무의미)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;허상 포인터와 허상 객체는 힙 관리 상의 문제이다. ​
포인터는 변수가 가리킬 수 있는 범위를 확장시킨다는 면에서 goto와 비슷하다. ​
레퍼런스는 포인터의 기능과 유연성을 제공하면서, 위험은 제거한다. ​
포인터와 레퍼런스는 동적 데이터 구조를 위해 프로
그래밍 언어의 필수적인 요소이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl36.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;이 그림에서는 허상 포인터의 예를 보여주고 있다. ​&lt;/p&gt;

&lt;p&gt;프로그램 코드가 이와 같을 때, ​
*q=30은 이미 해제된 메모리가 남아 있다고 착각한다.  ​
Q는 결국 아무것도 가리키지 않는 허상 포인터이다.&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">제 13장 프로그래밍 언어</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">표현식과 대입문</title>
      <link href="https://lee989898.github.io/pl-14" rel="alternate" type="text/html" title="표현식과 대입문" />
      <published>2021-10-14T19:18:00+09:00</published>
      <updated>2021-10-14T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-14</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-14">&lt;h1 id=&quot;제-14장--프로그래밍-언어&quot;&gt;&lt;strong&gt;제 14장  프로그래밍 언어&lt;/strong&gt;&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;표현식과 대입문&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;표현식(expression)은 프로그래밍 언어에서 계산을 상술
(상세히 서술)하는 수단이다. ​
대입문은 변수의 값을 변화시키는 문장으로, 모든 명령형 언어의 필수적 요소이다. ​
대입문은 독립적으로 실행 가능한 문장인 반면, ​
표현식은 대입문의 일부분으로서, 독립적으로 실행될 수 있는 문장이 아니다. ​&lt;/p&gt;

&lt;p&gt;대입문과 표현식의 차이를 좀더 살펴 보자.  ​
변수가 메모리의 일정 부분임을 상술하는 수단이라는 것과, ​
대입문의 BNF 형식이 &lt;var&gt;=&lt;expression&gt;임을 알고 있다. ​
BNF의 형식으로부터, ​
표현식(&lt;expression&gt;)은 대입문의 일부분임을 알 수 있고, ​
대입문의 변수(&lt;var&gt;)가 가리키는 메모리에 저장된 값을 ​
표현식의 계산 결과로 변경시킨다는 것을 알 수 있다. ​&lt;/var&gt;&lt;/expression&gt;&lt;/expression&gt;&lt;/var&gt;&lt;/p&gt;

&lt;p&gt;그런데, 표현식의 계산 방식에 따라 계산 결과는 달라질 수 있다.  ​
표현식의 계산 방식을 이해하려면, ​
연산자와 오퍼랜드의 계산 순서에 대한 규칙을 알 필요가 있다.  ​
이들 순서는 결합 법칙과 우선순위 규칙에 의하며, ​
오퍼랜드 계산 순서는 오퍼랜드의 부수효과(부작용)때문에 중요하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;산술식&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;산술식은 연산자, 오퍼랜드, 괄호, 함수 호출로 구성된다. ​
연산자는 단항 연산자, 이진 연산자, 삼항 조건 연산자(?:) 등이 있다. ​&lt;/p&gt;

&lt;p&gt;표현식의 구현은, ​
메모리에서 오퍼랜드를 가지고 와서, ​
그 오퍼랜드에 산술 연산자를 실행한다. ​
산술식 설계시 고려사항 ​
연산자 우선 순위, 결합 법칙 등 ​
오퍼랜드 계산 순서와 부작용(부수효과) ​
연산자 오버로딩 ​
표현식에서 오퍼랜드 타입의 혼합&lt;/p&gt;

&lt;p&gt;연산자 우선순위 규칙은 우선 순위가 다르면서 이웃하는 연산자의
 계산 순서를 정의한다. ​
전형적인 우선순위 규칙은 괄호&amp;gt;단항연산&amp;gt;지수&amp;gt;곱셈과 나눗셈&amp;gt;덧셈과 뺄셈 ​&lt;/p&gt;

&lt;p&gt;연산자 결합 법칙은 우선 순위가 같으면서 이웃하는 연산자의 순서를 정의한다. ​
전형적인 결합법칙은 좌에서 우로(단, 지수는 우에서 좌로) 적용된다.  ​
괄호는 우선순위와 결합 법칙에 앞선다. 
​
C, C++에서 조건 표현식은 삼항 조건 연산자 ?:를 사용한다. ​
average = (count == 0)? 0 : sum / count와 같이 표현한다. ​
이것의 의미는 다음과 같다. ​
if (count == 0), average = 0​
else average = sum / count ​
이 문장을 이해하려면, 대입문의 BNF 형식 &lt;var&gt;=&lt;expr&gt;을 떠올리면 쉽다. ​
그러니까 &lt;var&gt;이 average이고, ​&lt;/var&gt;&lt;/expr&gt;&lt;/var&gt;&lt;/p&gt;
&lt;expr&gt;가 삼항 조건 표현식인 (count==0) ? 0 : sum/count이다. 

표현식에서 오퍼랜드는 어떻게 계산되는지 살펴 보면, ​
변수는 메모리에서 값을 가져온다.  ​
상수는 메모리에서 값을 가져오기도 하지만, 기계 언어에 내재되기도 한다. ​
괄호가 있는 표현식은 괄호속에 있는 모든 오퍼랜드와 연산자를 먼저 
계산하고, 괄호 전체를 계산한다. ​

오퍼랜드가 아무런 부작용(부수효과)가 없을 때, 
오퍼랜드 계산 순서는 결과에 무관하다. ​

그러나 함수가 오퍼랜드일 때, 계산 순서는 다른 결과를 가져온다.  
함수는 다수의 파라미터 또는 글로벌 변수를 변경시킬 수 있고,  ​
이때 함수 부수효과가 발생할 수 있다. ​
이로 인해 표현식의 계산 결과에 영향을 미칠 수 있다. ​


---

 ​&lt;img src=&quot;/assets/built/images/pl/pl37.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;

---

위 그림에서 함수 부수효과 문제의 예를 보자. ​
다음 프로그램에서, ​
Main의 a = a + fun1( )의 값은 ​
먼저 a를 계산하느냐, fun1( )을 먼저 계산하느냐에 따라 달라진다. ​

1. 먼저 a를 계산(메모리에서 가져오는 fetch)하면, ​
a가 5이고, fun1()이 3이므로, 둘을 더하면 a는 8이다. ​

2. 먼저 fun1을 계산하면, ​
fun1은 3이지만 부수효과로서 a가 17이므로, ​
둘을 더하면 a는 20이 된다. 

수학에서 함수는 x에 대응하는 y값을 찾는 것이므로, 부수 효과가 없다.​
함수 언어에서도 마찬가지다. ​
부수효과는 본 뉴만 아키텍처 및
 이에 기반한 명령형 언어의 계산 모형으로 인해 발생한다. ​
본 뉴만 아키텍처 및 이를 그대로 본뜬 명령형 언어의 계산 모형은 ​
계산하여 변화된 값의 상태를 항상 메모리에 
저장하도록 설계되어 있기 때문이다. ​

함수 부수효과의 해결책은 다음 두가지가 있다. ​

+ C, C++ 처럼 함수 부수 효과를 허용하지 않도록 언어를 설계하는 것이다. ​
    함수에서 단일 파라미터만 허용하여, 단일 값을 반환한다. ​
    만일 다수의 파라미터가 필요하면, struct를 사용하여 하나의 파라미터로 만든다. ​
    함수에서 글로벌 변수를 접근 불허한다. ​
    단점은 파라미터 및 글로벌 변수에 융통성이 없다. ​

2. 자바처럼 오퍼랜드 계산 순서를 고정시킨다. ​
    좌에서 우로… ​
    단점은 컴파일러 최적화를 제한한다.  ​

최적화를 위해 표현식을 reordering하기도 하는데 고정 순서는 이를 불허한다. 

---

+ 과적 연산자

기계어에서는 정수의 덧셈 연산자와 부동점 소수의 덧셈 연산자를 구분한다. 
부동점 소수의 덧셈: FADD, ​
정수의 덧셈: ADD ​
프로그래머는 정수의 덧셈과, 부동점 소수의 덧셈에 모두 +를 쓰고 싶어한다.  ​

1. 그러면서, 컴파일러가 알아서 이들을 구분하여 번역하기 바란다. ​
2. 두개의 배열 변수의 덧셈도 +로 간단히 쓰고 싶어 한다.  ​

이와 같이 하나의 연산자를 여러가지 목적으로 사용하는 것을 ​
연산자의 과적(오버로딩)이라고 한다. 

정수와 부동점에 대한 +의 과적은 ​
일상적으로 허용되지만, C와 C++에서는 문제를 일으키기도 한다. 

___

+ 타입 변환

정수와 부동점 소수 간의 덧셈에서, ​
데이터를 어떤 유형으로, 그리고 어떤 포맷으로 변환할 것인가? ​
유형: 정수, 부동점 소수 ​
포맷: 십진수 vs 이진수, 부동점의 (싸인,지수부분,소수부분) 각 몇 비트? 

Narrowing conversion은 ‘원래 유형의 모든 값’을 포함할 수 없
는 유형으로 변환하는 것을 의미한다. ​
예를 들어, 더블 부동점 소수를 싱글 부동점 소수로 변환하는 경우. ​
이때 항상 safe하지는 않다. -&amp;gt; 값의 크기가 바뀐다. 짤린다. ​​

Widening conversion은 원래 유형의 근사값을 포
함하는 유형으로 변환하는 것을 의미한다. ​
예를 들어 정수를 부동점 소수로 변환하는 경우. ​
이때, safe하다. 즉, 근사값으로 바뀌므로 크기가 바뀌지 않는다. ​
다만 포맷(내부 표현 방식)의 차이로 인해 정확하게 같지 않을 경우도 있다.   

오퍼랜드의 타입이 혼합되어 있을 때, ​
명시적이거나 암묵적으로 타입 변환이 필요하다. ​
컴파일러에 의한 암묵적 타입 변환을 코어젼이라고
 한다. -&amp;gt; 대부분의 언어에서…   ​
프로그래머에 의한 명시적 타입 변환을 캐스팅이라고 한다. ​
C에서는 (int) angle과 같이 캐스팅을 괄호로 표시한다.  ​

___

+ 비교 및 부울 표현식

비교 표현식은 두개의 오퍼랜드를 비교하
기 위해 비교 연산자를 사용한다. 

부울 표현식은 부울 연산자 and, or, not를 사용한다. 

표현식의 Short-circuit evaluation에 대해 살펴 본다.
Short-circuit evaluation은 ​
표현식의 결과를 도출하는데 충분한 계산이 완료되면, ​
그 이후의 표현식 계산을 중단한다는 의미이다. ​
따라서, 표현식의 최소 계산이라고 번역하겠다.  

표현식에서 여러 오퍼랜드 중에서 몇 개만 해보고 그 결과를 알 수 있다면 ​
모든 오퍼랜드를 계산할 필요가 없다. ​
이것을 표현식의 최소 계산이라고 한다. ​

간단한 예를 보자. ​
(13 * a) * (b/13–1)에서, a가 0이면, 1
3*a가 0이므로 더 이상 계산할 필요가 없다. ​

만일 최소 계산을 채택하지 않을 경우, ​
다음 프로그램에서 예상치 않은 문제를 발생시킨다. ​

index = 0;​
while ((index &amp;lt; listlen) &amp;amp;&amp;amp; (LIST[index]!= key)) 
index = index + 1; 이고, ​
LIST 배열의 인덱스가 0에서 listlen-1까지 라고 가정하자. ​

index==listlen일 때, (index &amp;lt; listlen)을 만족시키지 못한다. ​
그런데 최소 계산을 채택하지 않기때문에 여기서 중단되지 않고, ​
그 이후의 (LIST[index]!= key))를 계산하게 되며, ​
이때, LIST[index]에서 인덱싱 문제가 발생하게 된다. ​

이와 같이 최소 계산을 채택하지 않을 경우 ​
불필요한 오류를 발생시키기도 한다. 

최소 계산은 표현식의 부작용에 영향을 받을 수도 있다. ​
(a &amp;gt; b) || (b++ / 3)에서 ​
||의 두번째 오퍼랜드를 먼저 계산하면 ​
b가 증가하여 첫째 오퍼랜드의 결과에 영향을 준다.   

---

+ 대입문과 혼합 타입의 대입문

대입문의 일반적 형식은 &lt;var&gt; = &lt;expression&gt;이다. ​
대입 연산자 = 대신에 :=를 쓰기도 한다. ​
= 대신에 :=을 쓰는 이유는 =의 의미가 ‘같다＇의 의미와 혼동되기 때문이다. ​
=를 대입 연산자로 사용하는 경우, ‘같다＇의 연산자로 ==를 사용한다. 

조건 타겟은 조건에 따라 타겟 변수가 결정된다. ​
펄에서 조건 타겟이 포함된 대입문의 예를 보자. ​
대입문 ($flag ? $total : $subtotal) = 0에서 ​
대입 연산자 =의 왼쪽에 조건식이 포함되어 있는데, ​
이 뜻은 만일 ($flag)이 참이면 $total = 0이고, ​
거짓이면 $subtotal = 0이다 ​

복합 대입문 연산자는 대입문의 =과 연산자를 연결한 것이다. 
단항 대입문 연산자는 ++과 같은 것을 의미한다. 

표현식에 대입문을 쓰기도 한다. ​
while ((ch = getchar())!= EOF){…}​
  ch = getchar()
위의 while 문의 조건식에 ch = getchar()라는 대입문이 들어가 있다. ​
이 대입문이 먼저 실행되고 나서, 조건식이 계산된다. ​
그러면 getchar 값이 ch에 할당되고, ​
ch!=eof가 참이면 {…}가 실행된다. ​
a=b+(c=d/b)-1의 경우처럼, ​
표현식에 대입문을 쓰는 것은 대입문의 이해를 어렵게 한다. 
 
​($first, $second, $third) = (20, 30, 4
0)와 같이 다수의 값을 할당할 수도 있고, ​ 
 
Interchange를 ($first, $second) =
($second, $first)와 같이 쓸 수도 있다. 

함수 언어에서 identifier는 값의 이름에 불과하며, ​
변수를 나타내는 것이 아니기때문에 이들의 값은 바뀔 수 없다. ​
val fruit = apples + oranges;에서 ​
이름 fruit는 apples와 oranges의 값을 더해서 나온 결과 값의 이름이다.  ​

대입문에서 혼합 타입이 가능하다. ​
이때 타입 변환이 발생한다. 
​

---
&lt;/expression&gt;&lt;/var&gt;&lt;/expr&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">제 14장 프로그래밍 언어</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">데이터 타입</title>
      <link href="https://lee989898.github.io/pl-12" rel="alternate" type="text/html" title="데이터 타입" />
      <published>2021-10-07T19:18:00+09:00</published>
      <updated>2021-10-07T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-12</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-12">&lt;h1 id=&quot;제-12장--프로그래밍-언어&quot;&gt;&lt;strong&gt;제 12장  프로그래밍 언어&lt;/strong&gt;&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;데이터 타입&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;선언문 int n으로부터 n에 대해 무엇을 알 수 있을까? ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;n이 취할 수 있는 값의 범위는? (모든 정수) ​&lt;/li&gt;
  &lt;li&gt;n에 적용 가능한 연산자는? (닫혀 있는 모든 연산자, +, -, *) ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;데이터 타입의 개념에 대해 살펴 보면, 
특정 타입의 변수를 선언하면,  ​
그 변수가 취할 수 있는 값은 특정 집합이고, ​
그 값들에 적용 가능한 연산자 집합이 존재한다는 의미이다.  ​&lt;/p&gt;

&lt;p&gt;PL 설계자가 마주하는 기본적인 설계 이슈는 ​
목적에 적합한 충분한 데이터 타입으로 구성된 집합을 어떻게 정의할 것인가? ​
무슨 연산자들을 정의하고 이들 연산자를 데이터 타입
에 어떻게 지정(specify)할 것인가?&lt;/p&gt;

&lt;p&gt;데이터 타입은 다음과 같이 진화해 왔다. ​
초기 PL에서는, 많은 데이터 타입으로 다양한 응용을 지원하였다. ​
PL/1이 이러한 예이다. ​&lt;/p&gt;

&lt;p&gt;ALGOL68에서 얻은 지혜: ​
소수의 기본 타입과 이를 위한 소수의 연산자를 정의하고, ​
필요에 따라, 사용자 정의(user-defined) 데이터 타입을 지원하자! ​&lt;/p&gt;

&lt;p&gt;사용자 정의 타입으로부터 추상 데이터 타입으로 발전하였다.​
예를 들어, 스택, 큐, 링크드 리스트 등이 이에 속한다. ​&lt;/p&gt;

&lt;p&gt;타입의 유용성은 다음과 같다.  ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로그램 구조화 및 문서화에 유용​&lt;/li&gt;
  &lt;li&gt;오류 식별 및 방지에 유용​&lt;/li&gt;
  &lt;li&gt;최적화 지원에 유용 ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​먼저 비교적 단순한 형태로서, 원시형, 문자열형, 사용자
 정의 나열형부터 살펴 보자&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;원시 타입&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;원시 타입은 거의 모든 언어가 제공하고 있는 기본적인 데이터 타입으로, ​
다른 데이터 타입을 사용해서 정의되지 않는 데이터 타입이다. ​
Integer, floating-point, Boolean, character ​
원시 타입은 하드웨어 구조를 직접 반영한 것도 있다. ​
부동점 소수는 4바이트의 싱글 프리시전과 8바이트의 더블 프리시전이 있는데, ​
각각의 비트 구성은 ​
싱글 프리시전: 싸인 1비트, 지수부분 8비트, 소수부분 23비트이거나 ​
더블 프리시전: 싸인 1비트, 지수부분 11비트, 소수부분 52비트이다.    ​&lt;/p&gt;

&lt;p&gt;​+ 문자열 형&lt;/p&gt;

&lt;p&gt;문자열 타입의 값은 문자열이다. ​
설계 이슈: ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;원시 타입으로? 아니면 배열의 특수형으로? ​&lt;/li&gt;
  &lt;li&gt;스트링의 길이를 정적으로? 아니면 동적으로?​&lt;/li&gt;
  &lt;li&gt;스트링 연산자는? assignment, copy, comparison, concatenation, substring, pattern matching, etc
문자열을 비교할 때, &amp;gt;의 의미는 사전식 순서의 앞뒤 관계를 의미한다.  ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​C, C++에서 문자열은 원시 타입이 아니라, char 타입을 사용하여 정의한다. 
 이를 위해 라이브러리 함수를 제공한다. ​ 
 C 스트링 라이브러리의 문제는 제공되는 
 함수가 오버플로우를 처리하지 못한다는 것이다. ​
 예를 들어, strcopy (src, dest); 에서 ​
 src가 50바이트이고, dest가 20바이트이면 어떤 일이 일어날까?  ​&lt;/p&gt;

&lt;p&gt;자바의 문자열 타입은 원시 타입으로 String, 
 StringBuffer 클래스를 지원한다.&lt;/p&gt;

&lt;p&gt;문자열 길이 옵션은 3가지(정적, 제한적 동적, 동적) 옵션이 있다.  ​&lt;/p&gt;

&lt;p&gt;먼저 정적 옵션을 보면… ​
COBOL, Java String 클래스는 정적이다. ​
스트링이 생성될 때 길이가 정해진다. ​&lt;/p&gt;

&lt;p&gt;제한적 동적 옵션은… ​
C, C++에서는 동적이나 제한적이다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;길이는 최대 길이까지 가변적이다. ​&lt;/li&gt;
  &lt;li&gt;C에서는 최대 길이로 제한하기 보다, ​
스트링에 특수 문자를 사용하여 스트링의 끝을 나타내기도 한다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;동적 옵션은… Perl, Javascript​&lt;/p&gt;

&lt;p&gt;Ada는 모든 옵션을 지원한다.&lt;/p&gt;

&lt;p&gt;문자열 옵션의 구현 방법은 다음과 같다. ​
정적 옵션의 구현 방법은 컴파일 시에 문자열의 서술을 위해 ​
3개의 필드(타입 이름(static string
), 길이, 첫글자의 주소)를 필요로 한다. ​&lt;/p&gt;

&lt;p&gt;제한적 동적 옵션 구현 방법은 런타임 때 문자열의 서술을 위해 ​
4개의 필드(타입이름(limited dynamic string), 최대 길이, 현재 길이, 첫글자의 주소)를 필요로 한다.  ​&lt;/p&gt;

&lt;p&gt;동적 옵션의 구현 방법은 런타임 때 문자열의 서술을 위해, ​
3개의 필드(타입 이름(dynamic string), 현재길이, 첫글자의 주소)를 필요로 한다. ​
동적 문자열은 문자열의 증가와 감소에 따라 ​
저장 공간을 동적 관리(allocate, deallocate)해야 한다.  &lt;br /&gt;
​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;사용자 정의 서수 타입&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서수 타입은 ‘데이터를 모아 놓은 것인데 순서가 중요
한’ 데이터의 모임이라고 볼 수 있다. ​&lt;/p&gt;

&lt;p&gt;Enumeration(나열형)과 subrange(범위형)가 대표적인 서수 타입이다.&lt;/p&gt;

&lt;p&gt;나열형을 살펴 보면, 속성과 값이 정의되어 있음을 볼 수 있다. ​
Coin은 페니, 니켈, 다임, 쿼터를 각각 1, 5, 10, 25로 정의하고, ​
Escapes는 각 키마다 아스키 코드의 컨트롤 문자가
 대응되어 있음을 볼 수 있다. ​
연산자에 대해, 표현의 특성이 integer면, integer 연산을 수행한다.&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">제 12장 프로그래밍 언어</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">동적 계획</title>
      <link href="https://lee989898.github.io/algorithm-04" rel="alternate" type="text/html" title="동적 계획" />
      <published>2021-10-05T01:09:00+09:00</published>
      <updated>2021-10-05T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-04</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-04">&lt;h3 id=&quot;동적-계획&quot;&gt;동적 계획&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;분할 정복과 같이 주어진 문제를 더 작은 부분 문제들로
나눈 후 부분 문제들의 해들을 합병하여 해결한다.&lt;/li&gt;
  &lt;li&gt;분할 정복과 달리 부분 문제들이 서로 겹친다.&lt;/li&gt;
  &lt;li&gt;많은 해들 중 최적의 해를 찾는 최적화 문제에 적용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag07.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 분할 정복과 동적 계획의 분할 과정의 예이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;동적 계획 전략
    &lt;ol&gt;
      &lt;li&gt;문제를 더 작은 부분 문제들로 분할한다.&lt;/li&gt;
      &lt;li&gt;작은 부분 문제들을 해결하고 해들을 표에 저장한다.&lt;/li&gt;
      &lt;li&gt;나중에 다른 (부분) 문제를 해결할 때 이미 해결한 부분 문제가 나오면
다시 해결하는 대신에 표에서 해를 찾아 사용한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;막대-자르기&quot;&gt;막대 자르기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;막대의 길이는 n(양의 정수)이다.&lt;/li&gt;
  &lt;li&gt;막대의 길이가 i(양의 정수), 1 &amp;lt;= i &amp;lt;= n-1,인 조각막대로 자를 수 있다.&lt;/li&gt;
  &lt;li&gt;길이가 i, 1 &amp;lt;= i &amp;lt;= n, 인 (조각) 막대의 판매 가격은 pi이다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;길이가 n인 막대를 여러 개의 양의 정수 길이의 조각 막대들로
잘라서 판매할 때 얻을 수 있는 최대 판매 금액을 구해야 한다.
물론 막대를 자르지 않고 통째로 팔 수도 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;억기 기법 알고리즘
    &lt;ol&gt;
      &lt;li&gt;막대를 자르는 모든 경우들을 찾아낸다.&lt;/li&gt;
      &lt;li&gt;각 경우에서 얻을 수 있는 판매 금액을 계산한 후 그 중 최대 판매
금액을 구한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag08.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 막대를 자르는 모든 방법들과 판매 금액이다.&lt;/p&gt;

&lt;p&gt;시간 복잡도: 빅오(2의n승)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;분할 정복 알고리즘
    &lt;ol&gt;
      &lt;li&gt;길이가 n인 막대를 처음에 길이 i, 1&amp;lt;=i&amp;lt;=n-1, 인 막대와 
길이 (n-i)인 막대로 자른다.&lt;/li&gt;
      &lt;li&gt;길이 i인 막대는 그대로 팔고 길이 (n-i)인 막대는 최대 판매 금액을
얻을 수 있도록 통째로 팔거나 여러 개의 양의 정수 길이의 조각 막대들로 
잘라서 판다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;R(n): 길이가 n인 막대를 판매할 때 얻을 수 있는 최대 판매금액&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;R(n) = MAX(pi, R(n-i))
          1 &amp;lt;= i &amp;lt;= n
       R(0) = 0&lt;br /&gt;
pi: 길이가 i인 막대의 판매 가격&lt;br /&gt;
R(n-i): 길이 (n - i)의 막대를 판매할 때 얻을 수 있는 최대 판매 금액&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cutRod_DC(p[], i)
//길이 i의 막대를 판매할 때 얻을 수 있는 최대 판매 금액, R[i]를 계산한다.
//입력: p[i..n] - 막대들의 판매 가격
        i - 막대의 길이
//출력(반환값): 최대 판매 금액
if(i = 0) return 0
else{
      maxSell = 0
      for(j = 1; j &amp;lt;= i; j++)
          maxSell = MAX(maxSell, p[j] + cutRod_DC(p,i-j))
      return maxSell
}
최초 호출 maxSellValue = cutRod_DC(p,n)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag09.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 cutRod_DC(p,4) 호출시 실행 트리 이다.&lt;/p&gt;

&lt;p&gt;시간 복잡도: 빅오(2의n제곱)&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;동적 계획 알고리즘 설계 과정&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; cutRod_DP(p[], n)
 // 길이 n의 막대를 판매할 때 얻을 수 있는 최대 판매 금액을 계산
 // 입력: p[1 .. n] - 막대들의 판매 가격, n: 막대의 길이
 // 출력(반환값): 최대 판매 금액
 배열 maxSell[0 .. n]을 선언한다.
 maxSell[0] = 0
 for(j = 1; j&amp;lt;=n; j++){
      maxVal = 0
      for(k = 1; k &amp;lt;= j; k++)
          maxVal = MAX(maxVal, p[k] + maxSell[j - k])
      maxSell[j] = maxVal
  }
  return maxSell[n]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;시간복잡도: 박오(n의2제곱)&lt;/p&gt;

&lt;h3 id=&quot;모든-쌍-최단-경로-찾기&quot;&gt;모든 쌍 최단 경로 찾기&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag10.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 한 그래프 내의 각 정점에서 모든 다른 정점으로 가는 가장 
짧은 경로를 찾는 문제이다.&lt;/p&gt;

&lt;p&gt;가중치를 포함한 방향(혹은 무방향)그래프 G = (V,E)가 주어지면 
각 정점에서 모든 다른 정점으로 가는 최단 경로의 거리를 찾아라.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;경로의 거리 = 경로 상의 모든 간선의 가중치들의 합&lt;/li&gt;
  &lt;li&gt;정점들의 수 = n&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정점들을 각각 1,2,3, …., n으로 나타낸다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;동적 계획 Floyd 알고리즘&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;문제: 행렬 W가 주어지면 최단 거리 행령 D를 구한다.
주 아이디어&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;최단 경로들을 단계적으로 만든다.&lt;/li&gt;
  &lt;li&gt;최단 경로들을 경유 가능한 정점들의 집합 L을 이용하여 만든다.
최단 경로는 L 내에 있는 정점(들)만을 이용한다.&lt;/li&gt;
  &lt;li&gt;L에 정점들을 한 번에 하나씩 정점의 번호 순서대로 추가한다.&lt;/li&gt;
  &lt;li&gt;최단 거리 행렬들을 다음과 같은 순서대로 계산한다.
     D(0),D(1),D(2), …, D(n)&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag11.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 Floyd 알고리즘 예이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Floyd 알고리즘&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AllPairShortestPath(W[])
//입력: 가중치 행렬 W
//출력: D(i)
D(0) = W
for(k = 1; k &amp;lt;= n; k++){
  n x n 행렬 D(k) = (dij(k))를 선언한다
  for(i = 1; i &amp;lt;= n; i++)
      for(j = 1; j &amp;lt;=n; j++)
          dij(k) = MIN(dij(k-1),dik(k-1)+dkj(k-1)
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">동적 계획</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">변수와 시맨틱스</title>
      <link href="https://lee989898.github.io/pl-11" rel="alternate" type="text/html" title="변수와 시맨틱스" />
      <published>2021-09-30T19:18:00+09:00</published>
      <updated>2021-09-30T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-11</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-11">&lt;h1 id=&quot;제-11장--프로그래밍-언어&quot;&gt;&lt;strong&gt;제 11장  프로그래밍 언어&lt;/strong&gt;&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;변수와 시맨틱스&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;변수는 변수명, 데이터 타입, 값, 메모리 주소 등의 속성을 갖는다. ​
이들 속성을 변수에 결합하는 것을 바인딩이라고 한다. ​
바인딩이 되는 때를 바인딩 타임이라고 하는데, ​
주로 컴파일 할 때, 링크할 때, 메모리에 적재할
때, 실행할 때가 바인딩 타임이다.&lt;/p&gt;

&lt;p&gt;값이 assign될 때(assignment statement) 
타입이 바인딩 되는 것을 동적 바인딩이라고 한다. ​&lt;/p&gt;

&lt;p&gt;정적(static) 바인딩은 변수가 정의되거나 맨처음 
나타날 때 타입이 바인딩된다. ​&lt;/p&gt;

&lt;p&gt;바인딩 타임에 따라 변수의 값, 타입 등 ‘변수의 시맨틱’이 달라진다.  ​
스코프는 해당 변수가 정의 및 언급(reference)된 문장의 범위를 말한다.  ​
프로그램에서 선언(정의)문을 기준으로 하는 방법이 있고, ​
값의 할당문 하는(정해지는 순간을 기준으로 하는 방법이 있다. ​&lt;/p&gt;

&lt;p&gt;전자를 static scope(정적 스코프)라고 하고, ​
후자를 dynamic scope(동적 스코프)라고 한다. ​&lt;/p&gt;

&lt;p&gt;이제 상세히 알아보자&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;변수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;우선 변수의 개념을 살펴 보자.
변수는 이름, 값, 타입, 주소(메모리)를 속성으로 갖는다. ​&lt;/p&gt;

&lt;p&gt;이름은 identifier라고 하며, 언어에 따라 정의
 방법에 제한이 있는 경우도 있다. ​
변수의 값은 변수에 연관된 메모리 위치에 저장된 컨텐트(내용)으로, ​
프로그램 실행시 시시각각으로 바뀐다.&lt;/p&gt;

&lt;p&gt;변수의 타입은 데이터 타입을 말하는 것으로, ​
변수가 취할 수 있는 값의 범위와 이에 대한 연산자 집합을 결정한다. ​
변수의 타입은 선언문에 의해 정의되거나, ​
명명법(naming convention)에 따라 유추 가능하다. ​
타입 시스템을 적용하면, 타입 검사 및 프로그램
모듈화를 통한 오류 탐지가 가능하다. ​
같은 이름의 변수가 서브 프로그램의 스
코프에 따라 다른 타입을 가질 수 있으며,  ​
이종 타입 간의 연산이 가능할 수도 있다.&lt;/p&gt;

&lt;p&gt;변수는 메모리의 지정된 주소에 바인딩된다. ​
변수가 메모리 주소에 바인딩되면, ​
끝날 때까지 그 변수는 살아 있으며(active), ​
프로그램이 종료되면 그 메모리는 더 이상 그 변수에 바인딩되지 않는다. ​
이와 같이 바인딩이 시작되서 끝날 때까지의 시간을 lifetime이라고 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl31.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;p&gt;—​&lt;/p&gt;

&lt;p&gt;위 그림에서 변수 i는 맨앞과 foo 함수에서 정의되고 있는데,  ​
이들 i는 변수명과 타입이 같으나, 메모리 위치는 서로 다르다. ​
변수 i는 foo 함수와 bar 함수에서 나타나는 변수 i의 메모리 위치는 ​
Foo의 isms foo에 정의된 i를 언급하지만, ​
Bar의 i는 맨앞의 i를 언급한다.  ​
이들 i가 갖는 값은 변수의 스코프 규칙에 따라
다르다.​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;바인딩​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;바인딩은 변수와 주소/타입 간의 매핑을 말한다. ​
이들 바인딩에는 정적 바인딩과 동적 바인딩이 있다. ​
정적 바인딩은 실행 전(컴파일, 링킹)에 바인딩이 완료되며, ​
프로그램 실행 동안에 그 속성이 변경되지 않는다. ​
동적 바인딩은 실행 중에 바인딩이 일어나며, ​
실행 중에 바뀔 수 있다.&lt;/p&gt;

&lt;p&gt;변수가 언급(referenced)되기 전에 그 변수는 데이터 타입에 바인
딩되어야 한다. ​
정적 바인딩에서, 타입 바인딩은 명시적
 선언에 의하거나 암묵적 선언에 의한다. ​
암묵적 선언이란 선언문 또는 정의문에 의한 것이 아니라 ​
변수의 명명법에 의해 타입을 부여하는 것을 말한다. ​
Perl에서 변수명이 시작되는 특수문자에 따라 타입이 결정된다. ​&lt;/p&gt;

&lt;p&gt;$ is a scalar(numeric, character), @ is an array, % is a hash structure ​
정적 타입 바인딩에서, 타입과 변수명은 동시에 변수에 바인딩된다.&lt;/p&gt;

&lt;p&gt;동적 바인딩은 값이 변수에 부여될 때, 값의 타입을 변수에 부여한다. ​
동적 바인딩은 파이썬, 자바 스크립트 등에서 사용된다.  ​
예를 들어, 프로그램에서 다음과 같이 쓸 수 있다.    ​&lt;/p&gt;

&lt;p&gt;List = [2, 4.33, 6, 8];​
List = 17.3;​
이것의 의미는 ​
List = [2, 4.33, 6, 8]; -&amp;gt; 이때는 벡터이고, ​
List = 17.3; -&amp;gt; 이때는 스칼라이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;타입 검사&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;연산자의 오퍼랜드가 서로 호환적인 타입인지 ​
확인하는 행위를 타입 검사라고 한다. ​
호환적인 타입의 의미는 ​
두 오퍼랜드의 타입이 연산자에 적합하거나 ​
타입 변환이 가능한 경우이다.  ​
Int는 real로 자동 변환되는데, 이를 coercion(자동 변환)이라고 한다. ​
정적인 타입 바인딩을 적용하면, 정적 타입 검사를 실시하고, ​
동적인 타입 바인딩을 적용하면 동적 타입 검사를 실시한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;스토리지(메모리) 바인딩은 ​
메모리 풀에서 메모리 셀을 얻어서 변수에 할당하고(allocation), ​
메모리를 다 쓰고 나면, 메모리 풀로 반납한다(deallocation). ​
변수의 Lifetime은 특정 메모리 셀에 바인딩되어 있는 동안의 시간을 말한다. ​
변수가 특정 셀에 바인딩될 때 시작되서, 바인딩이 해제될 때 끝난다.   ​
스칼라 변수는 lifetim에 따라 4가지 종류가 있다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;정적 변수(Static)
  정적 변수는 실행 전에 메모리 셀이 바인딩 되서, 
  실행이 끝날때까지 그대로 차지한다. ​  &lt;br /&gt;
  포트란77, C의 글로벌 및 정적 변수가 이에 해당 ​
  장점은 인스트럭션의 주소 필드가 (데이터가
  저장된) 메모리 위치를 직접 가리킬 수 있어서 ​
  직접 주소 방식(direct addressing)으로
  데이터를 접근할 수 있을 뿐만 아니라, ​
  실행시 allocation으로 인한 오버헤드가 없어서, 효율적이다. ​
  데이터 구조를 동적으로 생성하거나 객체의 크기를 컴파일 
  할 때 미리 알아야 한다.
  정적 메모리 모델은 recursion을 지원할 수 없다.&lt;/li&gt;
  &lt;li&gt;스택 동적 변수(stack dynamic)
  스택 동적 변수는 다음과 같이 바인딩을 수행한다.  ​
    &lt;ul&gt;
      &lt;li&gt;선언문에 정의된 타입은 정적으로 바인딩되지만, ​&lt;/li&gt;
      &lt;li&gt;스토리지 할당과 초기값 할당 등은 선언문에 정의
  된 대로 실행시에 바인딩된다. ​
  이것을 elaboration이라고 함) ​
예를 들어, 스칼라 변수에 대해 주소를
 제외한 모든 속성은 정적으로 바인딩되지만, ​
서브 프로그램의 로컬 변수나 자바의 메소드 등은 ​
런타임 스택으로부터 메모리가 할당되어 동적으로 바인딩된다. ​
장점은 recursion, 서브프로그램 메모리 보존 등이며, ​
단점은 allocation, deallocation으로 인한 오버헤
드, 간접 주소 방식(indirect addressing)에 의한 비효율 등이다.  ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;간접 주소 방식이란 인스트럭션의 주소 필드가 레지스터를 가리키고, ​
그 레지스터 안에 메모리 위치가 저장되어 있어서, ​
레지스터를 거쳐야 원하는 데이터를 접근하게 되는 방식이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;명시적 힙 동적 변수(explicit heap dynamic) 
힙은 가상 주소 공간의 일부분으로 동적 메모리 할당을 위해 예약되어 있다. ​
명시적 연산자 new, delete에 의해 할당되고 해제된다. ​
타입은 정적으로 바인딩되고, ​
스토리지는 실행시 변수가 생성될 때 바인딩된다. ​
힙에 접근할 때에는 힙 포인터나 레퍼런스를 통해서 접근하게 된다.&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Person *p;​
  p=(Person *) malloc(sizeof Person);​
  p-&amp;gt;name = “Mike”; p-&amp;gt;age = 40;​
  free(p);​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 코드는 C++의 명시적 힙 동적 변수의 예를 보여주고 있다. ​
자바 객체는 명시적 힙 동적 변수이다. ​
명시적 힙동적 변수의 장점은 동적인 구조를 생성할 수 있다. ​
단점은 포인터와 레퍼런스 변수를 올바르게 쓰기가 어려워 
프로그램의 신뢰도가 떨어질 수 있고, ​    &lt;br /&gt;
변수에 대한 레퍼런스 비용과 스트로지 관리의 복잡도가 높다.  ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;암묵적 힙 동적 변수(implicit heap dynamic)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;값이 할당될 때, 힙 스토리지에 바인딩된다. ​
장점은 융통성이 높다.  ​
단점은 동적 속성을 유지하기 위한 런타임 비용이 높고, ​
컴파일러에 의한 오류 탐지가 매우 낮다.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;스코프&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;속성이 바인딩된 변수에 대해, ​
그 바인딩이 유효한 또는 영향을
 미치는 프로그램의 범위, 이것을 스코프라고 한다.&lt;/p&gt;

&lt;p&gt;하나의 프로그램을 구성하는 여러 함수에서 ​
  동일한 이름의 변수들을 다른 타입으로 선언할 수 있다. ​
  이때 이들 변수는 각각 다른 타입으로 바인딩된다. ​
  이러한 이유로, 어떤 변수에 언제 어느 타입을 ​
  바인딩하는 것이 옳은지 결정하려면, ​
  어느 타입의 변수가 프로그램의 어디부터 어디까지 유효한지 ​
  구분이 필요하다. ​
  이와 같이 변수의 타입이 유효한 프로그램의 영역을 스코프라고 한다. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl32.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림의 main에서 foo(x)를 호출할 때, ​
  이때 x는 int인가 float인가? (int이다)&lt;/p&gt;

&lt;p&gt;변수의 스코프에 대한 정의를 살펴 보자&lt;br /&gt;
  스코프는 변수가 visible한(나타나는) 문장의 범위이다. ​
  ‘변수가 어떤 문장에서 visible하다(나타난다)’의 의미는 ​
  바인딩된 변수가 그 속성을 그대로 유지한 채, ​
  그 문장에서 언급(reference)되거나 그 변수에 값이 할당된다는 것이다. ​&lt;/p&gt;

&lt;p&gt;스코프를 변수가 영향을 미치는 범위라고 했는데, ​
  좀더 정확히 말하면, ​
  변수가 자신의 속성을 문장의 계산에 반영한다는 의미이다.&lt;/p&gt;

&lt;p&gt;C++이나 자바에서 포인터, 레퍼런스 타입 등을 설명할 때 ​
  Reference란 말이 사용되는데, ​
  여기서 설명하는 refence의 의미와 다르다.&lt;/p&gt;

&lt;p&gt;여기서, ‘문장에 X가 reference된다’는 말은 ‘x가 문장에
   ‘언급된다(씌여있다)’는 것을 의미하고, ​
    레퍼런스 타입의 레퍼런스를 의미하지 않는다
  ​&lt;br /&gt;
  프로그램에서 nonlocal 변수는 ​
    그 변수가 그 프로그램에서 visible하지만 ​
  그 프로그램에서 선언(declaration)되지는 않았다는 뜻이다. ​
  nonlocal 변수의 선언문은,  ​
  프로그램의 공간적 구조(정적 스코프)나 ​
  프로그램 호출의 역순(동적 스코프)으로 찾아가면, ​
  공간적으로 가깝거나 가까운 호출 함수에서 선언문을 찾을 수 있다. ​&lt;/p&gt;

&lt;p&gt;언어의 스코프 규칙은, 같은 이름의 변수가 여러 개 선언되었을 때, ​
  언급된 이름이 어느 선언문에 의한 변수에 관련되어 있는지 결정한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정적 스코프&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정적 스코프는 변수의 스코프를 ​
  프로그램 텍스트 구조에 따라 공간적 개념에 의해 정적으로 결정한다. ​
    언급된 이름을 변수에 매핑하려면, ​
  프로그래머(또는 컴파일러)는 선언문을 찾아야 한다. ​
  먼저 로컬에서 찾은 후, 없으면 스코프를 넓혀가면서, ​
  같은 이름을 정의한 선언문을 찾거나 선언
  문이 더 이상 없을 때까지 찾는다. 
  C에서 블록 스코프는 텍스트 레이아웃에 의한 ​
  공간적 개념으로 결정된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;동적 스코프&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;동적 스코프는 프로그램의 텍스트 레이아웃이 아니라, ​
  컨스트럭트의 호출 순서에 근거하므로, 런타임 때 결정된다. ​
    동적 스코프는 프로그램 실행 중, ​
    변수가 언급될 때마다 그 변수의 선언문을 찾아서 동적으로 매핑한다. ​
    언급된 변수에 대한 선언문이 어느 함수에 있는지 찾기 위해, ​
    함수 호출 순서의 역순으로 해당 변수의 선언문을 찾는다.&lt;/p&gt;

&lt;p&gt;동적 스코프의 장점은 서브 프로그램을 호출할 때 ​
     파라미터를 패스하지 않아도 되니 편리하다. ​ 
   단점은 자주 실행되는 서브 프로그램의 로컬 변수는 ​
      역시 자주 실행되는 다른 서브 프로그램에서 자주 나타나기 때문에 ​
      계산이 잘못될 가능성이 높다. (신뢰성 문제)​
    정적 타입으로 선언된 난로컬 변수의 타입 검사는 불가하여 오류 탐지가 어렵다.  ​
   게다가 읽고 이해하기 어렵다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;라이프 타임&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;라이프타임(수명)은 ​
변수에 메모리가 할당(allocate)되서
 해제(deallocate)될 때까지의 시간을 말한다. ​
라이프타임은 스코프와 밀접한 관계가 있지만, 개념적으로는 다르다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl33.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림 C 프로그램에서 로컬 정적 변수 count를 살펴 보자. ​
Main에서 fun을 1차 호출하면, count는 1이고, ​
2차 호출하면 count는 2이다. ​
count의 스코프만 따지면, ​
count가 로컬 정적변수이기 때문에 1차, 2차 호출 모두 1, 1이어야 한다.  ​
그러나 count의 lifetime이 전체 프로그램의 실행이 끝날 때까지 ​
연장되기 때문에, 1,2가 된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;변수의 개념을 좀더 상세히 알아보면, ​
x=1, x=x+1의 의미를 따져 보자.
여기서 =은 수학의 equal 사인이 아니라, ​
x에 1을 할당(assign)한다는 말이다. ​&lt;/p&gt;

&lt;p&gt;x는 변수의 이름이거나 변수의 위치를 지칭한다. ​
즉, 변수는 메모리 셀의 추상화이다. ​&lt;/p&gt;

&lt;p&gt;따라서, x는 이름(고유식별자)이고, ​
x는 어떤 값이 저장된 위치를 지칭한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Stack&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;함수가 호출되면, 스택 프레임을 스택의 꼭대기에 push 하고, ​
함수 실행이 끝나면, 스택 프레임을 꼭대기로부터 pop한다. ​&lt;/p&gt;

&lt;p&gt;스택 프레임은 호출되는 함수에 넘겨지는 파라미터 값, ​
호출함수가 호출된 함수로부터 값을 넘겨받는 반환 주소, ​
호출된 함수의 로컬 변수를 위한 저장 공간을 포함한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Heap&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;힙은 동적 메모리 할당이 일어나는 메모리의 일부분이다. ​
할당/해제 함수로는 malloc/free(pointer), new(poi
nter)/delete(pointer)가 있다. ​&lt;/p&gt;

&lt;p&gt;힙에 대한 메모리 할당은,    ​
메모리 일부분이 런타임에 동적으로 할당되고, ​
여러 함수에서 언급한 변수는 스코프에 제한이 없다
할당된 메모리 크기가 크다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;명령형 언어는 본뉴만 아키텍처를 흉내낸 것이다.
본뉴만 아키텍처의 주요 구성요소는 메모리와 프로세서이다
메모리는 데이터와 명령어를 저장하고, ​
프로세서는 메모리 컨텐트를 수정하는 연산을 실행한다&lt;/p&gt;

&lt;p&gt;이에 대응되는 명령형 언어의 추상화는 변수와 산술식이다
변수는 메모리셀에 대응하고, 산술식은 CPU 실행에 대응된다.&lt;/p&gt;

&lt;p&gt;컴퓨터에 실재로 존재하는 메모리(이것을 물리
적 메모리 또는 메모리라고 한다)는 ​
때때로 프로그래머의 프로그램을 한꺼번에 메모리에 모두 올려 놓지 않는다.&lt;/p&gt;

&lt;p&gt;그 이유는 다른 프로그램과 메모리를 나누어 쓰기도 하고, ​
프로그램이 메모리 사이즈를 넘어가기도 하기 때문이다.
프로그래머가 제한된 물리적 메모리 공간을 고려하면서 ​
변수나 배열에 메모리 공간을 할당한다는 것은 매우 복잡하고 어렵다. ​&lt;/p&gt;

&lt;p&gt;따라서 프로그램을 전부 저장할 수 있는 가상 메모리를 프로그램에 할당하고, ​
사용 가능한 메모리에 그만큼의 프로그램을 올렸다 내렸다 하면서 프로그램을 
실행한다. ​&lt;/p&gt;

&lt;p&gt;이와 같이 프로그램을 올렸다 내렸다 하는 작업은 OS가 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl29.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;가상 메모리에서,  ​
변수 i와 배열 a[100]은 메모리에 오렌지 색으로 할당된다. ​
함수 foo에서 적용되는 변수 i, j는 연두색으로 할당된다. ​
이중에서 적재 가능한 만큼의 프로그램을 메모리에 올려서, ​
프로세서에서 실행하고, ​
실행이 끝나면, 프로그램의 다음 부분을 올려서 실행하게 된다.&lt;/p&gt;

&lt;p&gt;이때 가상 메모리를 쓰면, ​
전체적인 상대 주소가 변하지 않기 때문에 ​
물리적 메모리에 적재할 때 ​
프로그램의 주소 변환이 매우 간단해 지는 장점이 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl30.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;변수의 타입에 따라 할당되는 메모리 공간이 다르다. ​
개략적으로 설명하면, ​
스택은 프로시져에 대한 정보를 저장하는 공간으로, ​
이들 프로시져에서 사용되는 파라미터, 변수 등의 속성 정보 등을 저장한다. ​
스택은 중첩 프로시져(함수) 호출, 순환 프로시져(함수) 호출 등을 ​
올바르게 처리하기 위한 목적으로 사용된다. ​&lt;/p&gt;

&lt;p&gt;힙은 malloc, free에 의해 명시적으로 메모
리의 동적 할당 및 해제를 위한 메모리 풀(pool)이다.   ​
Static에는 정적, 글로벌 변수가 저장된다.
Code는 프로그램이 저장된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;래퍼런싱 환경&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;문장의 레퍼런싱 환경은 문장에 visible한(나타난) 모든 변수명의 집합이다. ​
정적 스코프 규칙을 적용하는 언어에서, 레퍼런싱 환경은, ​
로컬 변수와 그 안에 공간 구조적으로 포함된 서브 프로그램
에 언급된(나타난) 변수를 합친 것이다. 
​
동적 스코프 규칙을 적용하는 언어에서, 레퍼런싱 환경은, ​
로컬 변수와 그 안에서 호출되어 실행 중인(active) 서브
 프로그램에 언급된(나타난) 변수를 합친 것이다. ​
실행중인 서브 프로그램의 어떤 변수는 레퍼런싱 환
경에서 hidden(숨겨질)일 수 있다. ​&lt;/p&gt;

&lt;p&gt;Hidden이란 active이지만, 나타나지 않는 것을 의미한다. ​
이와 같은 hidden 변수는, ​
동일한 이름의 변수가 여러 함수에서 선언된 상황에서,  ​
앞에서 선언된 같은 이름의 변수가 여전히 active하지만 ​
나중에 선언된 같은 이름의 변수가 나타날 때 발생한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl34.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;실제로 동적 스코프는 현대 프로그래밍 언어에서 일반적이지 않고, ​
C에서도 지원하지 않는다. ​
따라서, 위 그림은 C이지만, ​
동적 스코프를 지원한다고 가정하고 레퍼런싱 환경을 따져 보자. ​
호출되는 순서는 main -&amp;gt; sub2 -&amp;gt; sub1이다. ​
포인트1에서 나타날 수 있는 변수는 main의 d, sub2의 c, sub1의 a와 b, 이다. ​
여기서 main의 c, sub2의 c는 hidden이다. ​
포인트2에서 나타날 수 있는 변수는 main의 d, sub2의 b와 c이다. ​
여기서 main의 c는 hidden 이다. ​
포인트3에서 나타날 수 있는 변수는 main의 c와 d이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;지정 상수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이름 지정 상수는 상수인데, 변수명처럼 이름을 부여한 것을 말한다. 
이렇게 하는 이유는 읽기 쉽고, 수정하기 쉽도록 하기 위한 것이다. ​
스토리지에 바인딩될 때 값이 결정된다.&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">제 11장 프로그래밍 언어</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">android 시작</title>
      <link href="https://lee989898.github.io/android-01" rel="alternate" type="text/html" title="android 시작" />
      <published>2021-09-24T01:07:00+09:00</published>
      <updated>2021-09-24T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/android-01</id>
      <content type="html" xml:base="https://lee989898.github.io/android-01">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;Android 공부는 여러 절로 구성되어 있습니다. &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./android-01&quot;&gt;Android 시작&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./android-02&quot;&gt;Android 1강 &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;android 시작입니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="android" />
      

      
        <summary type="html">Android 공부는 여러 절로 구성되어 있습니다. Android 시작 Android 1강</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">git 시작</title>
      <link href="https://lee989898.github.io/git-01" rel="alternate" type="text/html" title="git 시작" />
      <published>2021-09-24T01:06:00+09:00</published>
      <updated>2021-09-24T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/git-01</id>
      <content type="html" xml:base="https://lee989898.github.io/git-01">&lt;p&gt;git 시작입니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="git" />
      

      
        <summary type="html">git 시작입니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">정적 시맨틱과 동적 시맨틱</title>
      <link href="https://lee989898.github.io/pl-09" rel="alternate" type="text/html" title="정적 시맨틱과 동적 시맨틱" />
      <published>2021-09-23T19:18:00+09:00</published>
      <updated>2021-09-23T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-09</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-09">&lt;h3 id=&quot;정적-시맨틱과-동적-시맨틱&quot;&gt;&lt;strong&gt;정적 시맨틱과 동적 시맨틱&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;시맨틱에는 정적 시맨틱과 동적 시맨틱이 있다.&lt;br /&gt;
정적인 시맨틱은 컴파일 시에 확인할 수 있는 시맨틱 규칙을 말한다.&lt;br /&gt;
이들 시맨틱 규칙은 ​타입 검사, 프로그램에서 변수가 언급되기 전에 이에 대한 정의가 되어 있는지, ​서브 프로그램에서 어느 선언
 이 어느 변수에 적용되어야 하는지, ​서브 프로그램과 메소드가 호출될 때 호출 순서를 올
바르게 지키는지 등을 포함한다.  ​&lt;/p&gt;

&lt;p&gt;동적 시맨틱스는 프로그램이 실행될 때 ​프로그램 컨스트럭트가 
언제 어떤 행태(계산 결과)를 생성해야 하는지 정의하는 것이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;BNF로 시맨틱을 표현할 수 있을까?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;타입 호환성 규칙은 BNF로 서술할 수 있지만, ​
새로운 난터미널 심볼과 규칙을 추가로 요구하기 때문에, ​
문법이 너무 커지고 신택스 애널라이저(구문 해석기)가 비대해져 유용하지 않다. ​&lt;/p&gt;

&lt;p&gt;프로그래밍 언어에 공통적으로 적용되고 있는 ​
‘모든 변수는 언급되기(reference) 이전에 
선언(정의)되어야 한다’는 규칙은 BNF로 서술이 불가하다. ​&lt;/p&gt;

&lt;p&gt;이러한 종류의 규칙을 정적인(static) 시맨틱스라고 부른다.&lt;br /&gt;
정적인 시맨틱스는 프로그램 실행시 프로그램의 의미에 간접적으로
 관련이 있을 뿐이고, 오히려, 프로그램의 올바른 형태(신택
 스)와 직접 관련이 있다. ​&lt;/p&gt;

&lt;p&gt;따라서, 정적인 시맨틱스의 검사는 컴파일 시에 가능하다.&lt;br /&gt;
이 말은 정적인 시맨틱스는 컴파일러의 구현시 고려되어야 한다는 의미이다. ​&lt;/p&gt;

&lt;p&gt;그러면 정적인 시맨틱스를 어떻게 서술할 수 있을까? ​
바로 속성 문법(attribute grammar)으로 서술한다. ​
속성 문법은, ‘프로그래밍 언어가 만족해야 할’ 정적인 시맨틱 규칙을 
서술하고 검사하기 위해 사용되는 ​BNF와 유사한 형태의 문법이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;속성 문법이 단순한 assignment 문장의 타입 검사에 어떻게 사용 될까?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 assignment 문장의 신택스와 정적 시맨틱스는 다음과 같다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;변수명은 A, B, C 뿐이다.​&lt;/li&gt;
  &lt;li&gt;Assignment의 우변은 변수거나 ‘변수 + 변수’의 표현식이다. ​&lt;/li&gt;
  &lt;li&gt;변수의 타입은 int거나 real이다.​&lt;/li&gt;
  &lt;li&gt;우변에 변수 2개가 있을 때, 이들의 타입은 같을 필요가 없다. ​&lt;/li&gt;
  &lt;li&gt;두 오퍼랜드가 같은 타입이 아닐 때 표현식의 타입은 real이다.&lt;br /&gt;
(여기서 표현식의 타입이란 표현식을 계산한 결과값의 타입을 말한다.) ​&lt;/li&gt;
  &lt;li&gt;이들의 타입이 같을 때, 표현식의 타입은 오퍼랜드의 타입과 같다. ​&lt;/li&gt;
  &lt;li&gt;좌변의 타입은 우변의 타입과 같아야 한다. ​&lt;/li&gt;
  &lt;li&gt;그래서, 우변의 오퍼랜드의 타입이 mix될 수 있으나, 우변의 계산 결과값과 좌변의 타겟이 같을 때만 assignment는 타당하다.  ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;속성 문법은 위와 같은 정적 시맨틱 규칙을 명세한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl21.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;간단한 assignment를 속성문법으로 서술하면 위 그림과 같다. ​&lt;/p&gt;

&lt;p&gt;속성 문법에는 신택스 규칙과 함께 데이터 타입에 관한 시맨틱 
규칙, 그리고 판단식이 서술되어 있다.&lt;br /&gt;
룩업 함수는 심볼 테이블에서 변수명을 찾아서 변수의 타입을 반환한다.&lt;br /&gt;
심볼 테이블은 컴파일러가 구문 분석 단계에서 ​
변수에 대한 이름, 타입 등을 저장하기 위해 생성한 ​
테이블 구조를 말한다. ​&lt;/p&gt;

&lt;p&gt;실제 타입은 var, expr의 실제 타입을 말한다.&lt;br /&gt;
실제 타입은 선언되어 있거나 변수명으로부터 유추 가능하다.&lt;br /&gt;
예를 들어, Perl에서 $, @, %는 ​
각각 스칼라(스티링, 숫자), 벡터(배열), 해쉬 구조를 나타낸다.&lt;br /&gt;
이로부터 변수의 타입을 유추할 수 있다. ​&lt;/p&gt;

&lt;p&gt;예상 타입은 expr와 관련된 속성으로부터 상속된 타입으로 ​
좌변의 변수의 실제 타입에 의해 결정된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl22.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;왼쪽 그림은 속성의 흐름, ​
즉 속성이 파스 트리를 따라
 상속(pass up, pass down)되는 흐름을 나타내고 있고, ​&lt;/p&gt;

&lt;p&gt;오른쪽 그림은 속성 문법에 의한 ​
attributed parse tree(속성이 부여된 파스 트리)를 보여준다.  ​&lt;/p&gt;

&lt;p&gt;이와 같이 부여된 속성에 근거하여, 컴파일러는 타입 검사를 할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;동적 시맨틱스를 서술하는 방법은 여러 가지가 있으나, operational semantics에 대해 살펴 보기로 한다. ​&lt;/p&gt;

&lt;p&gt;Operational semantics는 연산의 의미에 의해 
표현식, 문장, 단위 프로그램의 의미를 서술하는 방식이다. ​&lt;/p&gt;

&lt;p&gt;시맨틱스 서술의 중요성을 각 사용자별로 따져 보면 다음과 같다.  ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로그래머는 원하는 프로그램을 짜기 위해 프로그
래밍 언어의 각 문장이 무엇을 하는지 알 필요가 있다. ​&lt;/li&gt;
  &lt;li&gt;컴파일러 개발자는 프로그래밍 언어
에서 각 컨스트럭트의 의미를 정확히 알아야 한다. ​&lt;/li&gt;
  &lt;li&gt;프로그래밍 언어 설계자는 설계 상의 모호성과 불일치를 발견할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Operational semantics는 문장이나 단위 프로그램
을 컴퓨터에서 실행한 효과를 명세하여, ​
문장이나 프로그램의 의미를 서술한다. ​&lt;/p&gt;

&lt;p&gt;Operational semantics는 머신 상태의 일련의 변화로 볼 수 있다.&lt;br /&gt;
여기서 머신의 상태란 프로그램 수행에 따라 변화하는 각 변수 값의 콜
렉션(집합)이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl23.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위의 그림과 같이, operational semantics는 ​
문장에 대한 의미를 intermediate code처럼 정해진 
방식으로 서술한 것으로 볼 수 있다.&lt;br /&gt;
Intermediate 언어는 가상 머신에서 실
행되는 언어 또는 어셈블리 언어를 말한다.&lt;/p&gt;

&lt;p&gt;Operational semantics 서술을 위해 intermediate 언어와 가상 머신을 사용하기도 한다. ​​&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">정적 시맨틱과 동적 시맨틱</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">신택스 분석방법</title>
      <link href="https://lee989898.github.io/pl-10" rel="alternate" type="text/html" title="신택스 분석방법" />
      <published>2021-09-23T19:18:00+09:00</published>
      <updated>2021-09-23T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-10</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-10">&lt;h3 id=&quot;신택스-분석-방법&quot;&gt;&lt;strong&gt;신택스 분석 방법&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;프로그램이 문법에 적합한지 확인하기 위한 신택스 분석 방법에
대해 알아보자.​&lt;/p&gt;

&lt;p&gt;신택스 분석의 목표는 파스 트리(parse tree)를 생성하는 것이다.&lt;br /&gt;
신택스 분석은 프로그램의 각 문장을 토큰으로 쪼개는 일부터 시작한다.&lt;br /&gt;
이렇게 쪼개는 것을 렉시칼 어낼리시스라고 하고, ​
이것을 수행하는 프로그램을 렉시칼 애널라이저 또는 스캐너라고 한다. ​&lt;/p&gt;

&lt;p&gt;이렇게 쪼갠 후에 문법적으로 타당한지 확인하는데, ​
이것을 신택스 어낼리시스라고 하고, ​
이와 같은 일을 수행하는 프로그램을 신택스 애널라이저 또는 파서라고 한다.&lt;/p&gt;

&lt;p&gt;다시 말하지만 렉시칼 어낼리시스와 신택스 어낼리시스
의 궁극적인 목표는 파스 트리를 생성하는 것이다. ​&lt;/p&gt;

&lt;p&gt;파스 트리로부터 중간 코드가 생성되고, 최적화
되어, 최종적으로 코드 생성이 이루어지기 때문에  ​
파스 트리의 생성이 PL 구현 시스템에서 가장 중요한 부분이다. ​&lt;/p&gt;

&lt;p&gt;파스 트리의 생성은 문법에 의존한다.&lt;br /&gt;
즉, 문법에 적합한 프로그램만 파스 트리로 생성된다. 
​
문법은 신택스와 시맨틱스를 표현한 규칙의 집합으로, 프로그램이 PL의 문법에 적합한지 판단하는 기준이 된다. ​&lt;/p&gt;

&lt;p&gt;문장 A=B&lt;em&gt;(A+C)에 대해, 문법(규칙 집합)에 따라 
Leftmost derivation을 하려면, ​
문장 A=B&lt;/em&gt;(A+C)가 문법의 규칙 중에서 어느 규칙에 해당되고, ​
이 문장을 구성하는 A, =, B, (, A, +, C, )가 어
느 규칙의 어느 심볼에 해당되는지 알 수 있어야 한다.
이것을 신택스 어낼리시스라고 한다.&lt;br /&gt;
이를 위해 A=B*(A+C) 문장을 A, =, B, (, A, +, C, )로 잘라내고, ​
이들이 각각 문법이 허용하는 문장 요소 중의 무엇을 나타내는지(연산자, 
변수명, assignment 기호 등) 구별해야 하는데, ​
이것을 렉시칼 어낼리시스라고 한다.&lt;br /&gt;
잘라낸 A, =, B, (, A, +, ) 각각을 토큰이라고 한다.&lt;/p&gt;

&lt;p&gt;언어의 구현은 컴파일러, 인터프리터, 하이브리드 방식, 세가지 중의 하나이다. ​&lt;/p&gt;

&lt;p&gt;이들 모두 lexical analysis와 syntax analysis를 거친다.&lt;br /&gt;
렉시칼 애널라이저는 스캐너라고도 하는데, 소스 프로그램을 인풋으로 받아 토큰으로 잘라낸다.&lt;/p&gt;

&lt;p&gt;신택스 애널라이저는 파서라고도 하는데, 토큰을 인풋
으로 받아 문법에 따라 파스 트리를 만든다.​&lt;/p&gt;

&lt;p&gt;렉시칼 애널라이저는 신택스 애널라이저의 일부분으로 구현된다. ​&lt;/p&gt;

&lt;p&gt;이러한 이유로 모든 토큰을 한꺼번에 생성하지 않고 필요할 
때마다 토큰을 생성하기도 한다.&lt;br /&gt;
토큰 중에는 변수에 대한 변수명, 타입 등의 속성이 있는데, 이들은 심볼 테이블 안에 저장된다.&lt;br /&gt;
이들 정보는 신택스 어낼리시스 동안에 lookup되기도 하고 새로운 속성이 매핑되기도 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lexical analysis&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;렉시칼 애널라이저는 문장에서 각 단어를 추출하고 이들
이 어느 범주(문장에서 허용되는 개념의 범주)에 해당되는지
구별하는 것이다.&lt;br /&gt;
추출된 단어에 대해 범주를 매핑시킨 것을 토큰이라고 한다. ​&lt;/p&gt;

&lt;p&gt;교과서에서는 일반적인 표현보다는 이들 요소를 구분하여 각각 lexe
me, token이라고 하는데, ​
일반적인 표현을 쓰면, 이들은 각각 word, cate
gory이며, 이들을 합친 것을 토큰이라고 한다. ​&lt;/p&gt;

&lt;p&gt;렉시칼 애널라이저는 이와 같은 토큰을 식별하는 패턴 매처로서, ​
주어진 스트링에서, 주어진 패턴에 매치되는 서브스트링을 찾는다. ​&lt;/p&gt;

&lt;p&gt;이 설명은 매우 정확하지만 매우 까다로와서 렉시칼 애널라이저를
 잘못 이해할 수도 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl24.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;소스 프로그램을 위와 같이 1차원 배열로 표현되어 있다고 치자. ​
주어진 스트링에 해당한다. ​&lt;/p&gt;

&lt;p&gt;‘주어진 패턴’이란 identifier, reserved word 등에 해당되는 스트링을 의미한다. ​&lt;/p&gt;

&lt;p&gt;Identifier, reserved word 등은 오른쪽 
아래의 상태 전이 다이어그램으로 정의된다. ​&lt;/p&gt;

&lt;p&gt;렉시칼 어낼리시스가 어떻게 진행되는지 설명하기 전에 ​
먼저 상태 전이 다이어그램에 대해 알아 보자.&lt;/p&gt;

&lt;p&gt;렉시칼 애널라이저를 구현하려면, 상태 전
이 다이어그램을 그리는 것부터 시작한다. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl25.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위의 그림은 상태전이 다이어그램을 나타내고 있다.&lt;br /&gt;
상태전이 다이어그램은 directed graph로, ​노드는 상태를 나타내며 상태명으로 레이블이 붙어 있다.&lt;br /&gt;
아크는 상태 전이를 나타내며, 인풋 문자로 레이블이 붙어 있다.&lt;br /&gt;
아크의 레이블은 상태 전이를 발생시키는 인풋 문자로서, ​
아크의 이전 상태에서 해당 인풋 글자가 들어오면 아
크의 다음 상태로 전이한다는 의미이다.&lt;br /&gt;
아크는 전이가 일어날 때 수행되어야 할 액션을 포함하기도 한다.&lt;br /&gt;
그림에서 아크의 위에 있는 Letter, Digit 등은 상태 전이
를 일으키는 문자를 나타내고, ​
아래쪽의 addChar, getChar 등은 액션을 나타낸다.  ​&lt;/p&gt;

&lt;p&gt;상태 다이어그램을 단순화하기 위해, reserved wor
d나 identifier을 별도로 인식하기보다 함께 인식할 수 있다.&lt;br /&gt;
그림에서 두겹의 타원은 identifier와 integer를 인식하기 위한 상태이다. ​&lt;/p&gt;

&lt;p&gt;identifie가 변수명으로서의 identifi
er인지 reserved word인지 구별하기 위해 ​
심볼 테이블 lookup을 통해 결정한다.&lt;/p&gt;

&lt;p&gt;상태 전이 다이어그램을 규칙으로 표
현할 수도 있는데 이것을 regular grammar라고 한다.&lt;/p&gt;

&lt;p&gt;그렇다면 ‘주어진 패턴’이란 상태 전이 다이어그램으로 정의되는 것이다.
​
그러니까 렉시칼 애널라이저는 input file을 하나의 긴 스트링
으로 간주하고, ​한글자씩 읽어 들여 상태 전이 다이어그램을 따라 가면서, ​
reserved word, identifier 등의 토큰을 긴 스트링 중의 서
브 스트링으로서 인식하는 것이다.&lt;/p&gt;

&lt;p&gt;위 그리에서 Input file을 읽어 들여 코멘트를 무시하고, 
렉시칼 어낼리시스를 하면, ​오른쪽의 토큰들을 얻게 된다.&lt;/p&gt;

&lt;p&gt;정리하면, 주어진 스트링에서, 주어진 패턴에 매치되
는 서브스트링을 찾는 역할을 하는 것이 ​
바로 상태 전이 다이어그램이고, ​
이것을 프로그래밍하면 렉시칼 애널라이저가 된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl26.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;A=B*(A+C)와 같은 간단한 산술식에서 토큰을 추출하는 렉시칼 
애널라이저를 구현하기 위해, ​
먼저 상태 전이 다이어그램을 그리면 위 그림과 같다. ​
unknown은 identifier와 integer 이외의 것을 인식하는데, ​
이들은 주로 산술식을 구성하는 연산자나 괄호 등에 해당된다.​&lt;/p&gt;

&lt;p&gt;이들은 하나의 문자로 구성되어 있기 때문에 싱글 캐릭터 토큰이라고 하는데, ​
이들이 산술식의 연산자나 괄호인지 아닌지 결정하기 위해 심볼 
테이블을 lookup한다.&lt;/p&gt;

&lt;p&gt;아크 아래의 액션을 나타내는 함수의 역할에 대해 알아 보자.&lt;br /&gt;
getChar는 인풋 스트링에서 다음 글자를 가져와서 변수 nextChar에 넣고 ​
그 유형을 판단해서 변수 charClass에 그 유형을 넣는다. ​&lt;/p&gt;

&lt;p&gt;addChar는 nextChar의 글자를 배열 lexeme에 넣는다. ​&lt;/p&gt;

&lt;p&gt;Lookup은 배열 lexeme에 있는 스트링이 reserved word인지 아닌
지 결정한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Syntax Analysis&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;우선 신택스 어낼리시스 즉, 파싱이 뭔지, 파서가 뭘하는지 알아보자.&lt;/p&gt;

&lt;p&gt;파서는 주어진 프로그램에 대해 파스 트리를 생성한다. ​&lt;/p&gt;

&lt;p&gt;파스 트리는 명시적으로 생성되기도 하지만 ​
트리 순회(traversal) 흔적이 생성되기도 한다.&lt;br /&gt;
(이러한 트리 순회 흔적을 유래(파생, derivation)이라고 합니다.) ​&lt;/p&gt;

&lt;p&gt;파스 트리와 유래 모두 컴파일러나 인터프리터가 필
요로 하는 모든 신택스(구문 구조적) 정보를 포함한다. ​&lt;/p&gt;

&lt;p&gt;신택스 어낼리시스의 목표는 인풋 프로그램이 문법적으로 올바른지 검사하고, ​
문법적으로 올바른 인풋에 대한 파스 트리를 생성한다. ​&lt;/p&gt;

&lt;p&gt;도중에 오류가 발견되면 오류 진단 메시지를 생성하고, ​
인풋 프로그램의 신택스 어낼리시스를 계속한다. ​&lt;/p&gt;

&lt;p&gt;물론 신택스 어낼리시스 도중에 오류가 발생하면, ​
신택스 어낼리시스만 계속하면서 문법적으로 잘못된 부분을 식별할 뿐이지, ​
파스 트리를 생성하지는 않는다.&lt;/p&gt;

&lt;p&gt;파싱 방법은 하향식(탑다운)과 상향식(바텀업) 방식이 있다. ​&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Top -down parsing&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;탑다운 파싱은 start 심볼에서 시작하여, 인풋 스트링을 derivation에 어느 BNF 규칙을 적용하는 게 좋을지 따져 보고 ​
규칙을 선택하여 derivation한다.&lt;/p&gt;

&lt;p&gt;이러한 derivation을 트리로 간주하면, 위에서 아래로 내려오면서 ​
반복적으로 규칙을 선택하고 적용하여 ​궁극적으로 인풋 스트링(프로그램)이 생성될 때까지 계속한다. ​&lt;/p&gt;

&lt;p&gt;그래서 이것을 recursive-descent parser(반복적 하강
식 파서)라고 한다. ​&lt;/p&gt;

&lt;p&gt;이와 같은 방식의 파싱 알고리즘을 LL 알고리즘이라고 하는데, ​
인풋을 왼쪽에서 오른쪽으로 스캔하고, ​
Leftmost derivation을 생성한다. ​&lt;/p&gt;

&lt;p&gt;Leftmost derivation이란 sentential form
(문형식)의 가장 왼쪽에 있는 난터미날에 대해, ​
그 난터미날을 LHS로 갖고 있는 규칙을 선정하여, ​
그 규칙의 RHS로 바꾸는 것을 의미한다. ​&lt;/p&gt;

&lt;p&gt;LL의 앞에 있는 L은 ‘왼쪽에서 오른쪽으로’를 나타내고,  ​
뒤의 L은 ‘leftmost derivation’을 나타낸다.&lt;/p&gt;

&lt;p&gt;탑다운 파서의 파싱 결정 문제 ​
Preorder에 의해 파스 트리를 생성한다.&lt;br /&gt;
Preorder 순회는 root, left, right 순서로 트리를 방문한다.
​
좌선 유도 중인 문형식이 주어졌을 때, 파서는 ​
주어진 문형식에서 가장 왼쪽의 난터미날 심볼에 대해, ​
그 난터미날 심볼을 LHS로 갖고 있는 규칙을 찾아서, ​
그 규칙의 오른쪽 부분으로 문형식의 난 터미날 심볼을 교체한다.(이것을 expand라고 함)&lt;br /&gt;
이렇게 하여, 좌선 유도에 의한 다음 문형식을 생성한다.
​
문형식에서 xAa에서, x는 터미날 심볼로 구성된 스트링을, ​
A는 난터미날 심볼을, a는 터미날과 난터미날 심볼의 혼합 스트링을 나타낸다.&lt;br /&gt;
Expand할 때는 적용할 규칙을 선택하여 ​주어진 스트링의 난터미날 심볼을 규칙의 오른쪽으로 교체하여 확장한다.​&lt;/p&gt;

&lt;p&gt;예를 들어 보자. ​
현재 문형식이 xAa이고, ​
A에 적용 가능한 규칙이 A→bB | cBb | a 라고 하면, ​
탑다운 파서는 어느 규칙을 선택하느냐에 따라, ​
다음 문형식으로 xbBa, xcBba, or xaa 중의 하나를 생성한다.&lt;br /&gt;
이것이 바로 탑다운 파서의 파싱 결정 문제이며, ​백트래킹 비용을 수반한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Bottom-up parsing&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;바텀업 파싱은 인풋 스트링을 스캐닝하면서, ​
규칙의 RHS에 해당되는 스트링이 발견되면, ​
이 스트링을 발견된 규칙의 왼쪽 스트링으로 바꾼다. ​&lt;/p&gt;

&lt;p&gt;이러한 과정을 반복해서 인풋 스트링이 ​
궁극적으로 starting 심볼로 바뀌면 파싱이 끝나는 것이다. ​&lt;/p&gt;

&lt;p&gt;이렇게 하려면 탑다운 방식과 달리 스택이라는 자료 구조를
 필요로 하는데, ​
스택에 넣고 빼고 하는 과정을 포함하기 때문에 이것을 shif
t-reduce 파서라고 한다. ​&lt;/p&gt;

&lt;p&gt;Shift는 스택에 심볼을 넣는 것, reduce는
 스택의 서브 스트링을 규칙의 LHS로 바꾸는 것을 말한다. ​  ​&lt;/p&gt;

&lt;p&gt;이러한 알고리즘을 LR 알고리즘이라고 하는데, ​
L은 왼쪽에서 오른쪽으로 인풋을 스캐닝하고, ​
R은 rightmost derivation을 생성한다는 것을 나타낸다.&lt;/p&gt;

&lt;p&gt;바텀업 파싱의 기본 아이디어는 ​
주어진 스트링을 처리할 때, 규칙의 RHS에 해당되는 서브 스트링을 찾아서, ​
그 서브스트링을 규칙의 LHS로 교체하는 과정을,  ​
주어진 스트링이 start 심볼이 될 때까지 반복하는 것이다. ​&lt;/p&gt;

&lt;p&gt;바텀업 파싱의 기술적인 이슈는 ​
어느 규칙을 적용해서 어느 서브스트링을 교체할 것인지, ​
미리 따져보는 것이다.&lt;/p&gt;

&lt;p&gt;쉬프트-리듀스 파싱은 바텀업 파싱의 일종이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl27.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;예를 보면서, 바텀업 파싱을 알아 보자.&lt;br /&gt;
문법과 인풋 스트링이 이와 같을 때, ​
인풋 스트링의 왼쪽에서부터 시작해서, ​
서브스트링에 적용할 수 있는 규칙을 찾아 본다.&lt;br /&gt;
RHS에 b가 있는 규칙 A → b를 적용할 수 있다. ​
빨간색 b에 A-&amp;gt;b를 적용하면,  ​
빨간색 b가 규칙 A-&amp;gt;b의 LHS인 A로 교체되어 ​
aAbcde가 된다.&lt;/p&gt;

&lt;p&gt;다음, 빨간색 Abc가 A-&amp;gt;Abc에 의해 A로 교체되어 ​
aAde가 되고, ​
빨간색 d가 B-&amp;gt;d에 의해, A로 교체되어 ​
aABe가 된다.&lt;/p&gt;

&lt;p&gt;빨간색 aABe가 S-&amp;gt;aABe에 의해 start 심볼 S로 교체되어 ​
파싱이 종료된다.&lt;/p&gt;

&lt;p&gt;위의 그림을 잘 살펴보면, reduce의 의미와 derivar
ion의 의미가 반대임을 알 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;바텀업 파싱은 규칙이 허용하는 바에 따라 인풋 스트링의 서브스트링을 ​
LHS의 난터미날 심볼로 교체한다. ​
이러한 교체는 인풋 스트링이 S로 교체될 때까지 계속된다. ​
여기서 교체되는 서브스트링은 ​
처음에는 터미날 심볼로 구성되지만, ​
점차 터미날 심볼로 구성된 서브스트링이 난터미날로 교체되면서, ​
터미날 심볼과 난터미날 심볼로 구성된다.  ​
LHS로 교체하는 과정을 보면, ​
인풋 스트링의 길이가 점점 줄어들고 있
음(즉, reduce되고 있음)을 볼 수 있다.  ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;탑다운 파싱과 비교를 해 보면, ​
탑다운 파싱은 S에서 인풋 스트링이 생성될 때까지 규칙을 적용해서 ​
가장 왼쪽의(leftmost) 난터미날 심볼을 RHS로 expand한다. ​
이것을 좌선 유도(leftmost derivation)이라고 하는데… ​
위의 파싱 과정을 거꾸로 살펴 보면, ​
가장 오른쪽의 난터미날이 먼저 RHS로 expand됨을 볼 수 있다. ​
즉, 우선 유도(rightmost derivation)가 되고 있는 것이다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;따라서, 탑다운과 바텀업 파싱의 과정을 보면 서로 반대임을 알 수 있다. ​
즉, 바텀업 파싱은 탑다운 우선 유도의 역순과 같다.   ​&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;바텀업 파싱에서는 어느 서브 스트링에 어떤 규칙을 적용하느냐가 중요하다.&lt;br /&gt;
앞의 예에서 abbcde(b에 A-&amp;gt;b를 적용) =&amp;gt; aAbcde(d에 B-&amp;gt;d를 적용) =&amp;gt; a
AbcBe이 생성되면, ​&lt;/p&gt;

&lt;p&gt;이후 어떠한 규칙을 적용해도 S로 리듀스되지 않는다.&lt;br /&gt;
규칙의 LHS로 교체할 수 있는 ‘인풋 스트링 S의 서브스트링 a’를 핸들이라고 한다. ​&lt;/p&gt;

&lt;p&gt;a가 A → a의 RHS에 매치되면, ​
a를 A(규칙의 LHS)로 교체한다.&lt;br /&gt;
이때 이러한 교체 과정은 탑다운 
방식의 우선 유도(rightmost derivation)의 역순으로 나타난다.   ​&lt;/p&gt;

&lt;p&gt;쉬프트-리듀스 파싱에서 리듀스 연산은 핸들에만 적용 가능하다.&lt;/p&gt;

&lt;p&gt;쉬프트-리듀스 파싱의 구현 방법에 대해 알아 보자.&lt;br /&gt;
바텀업 파싱은 쉬프트와 리듀스라는 두개의 액션으로 설명되기 때문에, ​
쉬프트-리듀스 파싱으로 불리며, ​
이를 위한 자료구조로 스택을 사용한다.  ​​&lt;/p&gt;

&lt;p&gt;쉬프트 액션은 다음 인풋 토큰을 스택의 꼭대기에 옮겨 넣는 것을 의미하며, ​
리듀스 액션은 스택의 꼭대기에 있는 핸들(규칙의 RHS)를 규칙의 LHS로 교체
하는 것을 의미한다. ​&lt;/p&gt;

&lt;p&gt;이 과정을 start 심볼로 리듀스 될 때까지 반복한다.&lt;br /&gt;
쉬프트할 때 스택을 사용하면, ​
현재 처리 중인 스트링에서 리듀스 가능한 서브스트
링(핸들)을 찾기 쉬운 경향이 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl28.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 쉬프트-리듀스의 예이다.&lt;/p&gt;

&lt;p&gt;쉬프트와 리듀스 둘다 가능할 때, 쉬프트-리듀스 컨플릭트가 발생한다. ​
스택에 핸들 if E then S가 있을 때, 문법에 의하면 
쉬프트, 리듀스 모두 가능하다. ​&lt;/p&gt;

&lt;p&gt;그러나, 이것은 그 다음에 나오는 심볼이 무엇이냐에 달려 있다. ​
다음에 else가 나온다면 리듀스하면 안되고 쉬프트해야 한다.  ​
반대로 else가 나오지 않는다면 리듀스해도 된다.  ​&lt;/p&gt;

&lt;p&gt;리듀스에 적용할 규칙이 여럿일 때, 리듀스-리듀스 컨플릭트 발생한다.&lt;br /&gt;
스택에 핸들 id(arg)가 있을 때, Stmt로 리듀스할지, Expr로 리듀스할지?  ​
이것 역시 다음에 나오는 심볼에 달려 있다.&lt;/p&gt;

&lt;p&gt;앞에 언급한 문제를 해결하려면, ​
인풋 스트링에서 현재 심볼의 다음에 오는 k개의 심볼을 먼저 본다면 ​
현재 어느 규칙을 써서 무엇을 할지 쉽게 결정할 수 있을 것이다
이것을 LR(k) 파서라고 하고, 여기서 k는 lookahead라고 한다.​&lt;/p&gt;

&lt;p&gt;장점은 일반적인 방법이면서 많은 유형의 문법을 다룰 수 있고, 효율적이라는 것이다
단점은 구현하기 어렵다는 것이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;컴파일러가 각 단게별로 소모하는 처리 비용을 시간의 비율로 나타내
면 다음과 같다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;~ 35-40% of time spent in I/O​&lt;/li&gt;
  &lt;li&gt;~ 30% in lexical analysis​&lt;/li&gt;
  &lt;li&gt;~ 10% in symbol table management​&lt;/li&gt;
  &lt;li&gt;~ 7-15% in parsing and other control​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;가장 많은 비용을 소모하는 것이 바로 IO이다
렉시칼 애널라이저가 그 만큼의 시간을 소모하고, ​
정착 알고리듬 측면에서 가장 복잡한 파싱이 비용소모가 적다. ​&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">신택스 분석 방법</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">분할 정복</title>
      <link href="https://lee989898.github.io/algorithm-03" rel="alternate" type="text/html" title="분할 정복" />
      <published>2021-09-21T01:09:00+09:00</published>
      <updated>2021-09-21T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-03</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-03">&lt;ul&gt;
  &lt;li&gt;분할 정복 설계 전략&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;분할 단계
    &lt;ul&gt;
      &lt;li&gt;문제를 같은 유형의 여러 개의 더 작은 부분 문제들로 나눈다.&lt;/li&gt;
      &lt;li&gt;부분 문제는 풀기 쉬울 때까지 계속 나눈다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정복 단계
    &lt;ul&gt;
      &lt;li&gt;부분 문제들을 보통 재귀적으로 해결하여 해를 구한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;합병 단계
    &lt;ul&gt;
      &lt;li&gt;문제에 대한 해를 구하기 위해 부분 문제들의 해를 합친다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;최댓값과-최솟값-찾기&quot;&gt;최댓값과 최솟값 찾기&lt;/h3&gt;

&lt;p&gt;문제: 크기가 n인 배열내의 요소들 중 최댓값과 최솟값을 찾는다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;쉬운 전략
    &lt;ol&gt;
      &lt;li&gt;최댓값을 찾는다&lt;/li&gt;
      &lt;li&gt;남은 배열 요소들의 최솟값을 찾는다&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;총 비교 횟수 = 2n - 3&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;분할 정복 전략
    &lt;ol&gt;
      &lt;li&gt;배열을 반으로 나눈다.&lt;/li&gt;
      &lt;li&gt;양쪽 절반들의 최댓값과 최솟값을 찾는다.&lt;/li&gt;
      &lt;li&gt;2에서 찾은 두개의 최댓값들과 두 개의
최솟값들을 비교하여 전체 배열의 최댓값과 최솟값을 구한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;의사코드&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;findMaxMin(A[],i,j,min,max)
// A[i..j]의 최댓값과 최솟값을 찾는다
// 입력: 배열 A[i..j]
// 출력: min(최솟값), max(최댓값)
1. if(i == j) { min = A[i]; max = A[j]}
2. else if(i = j - 1){
3.     if(A[i] &amp;lt; A[j]){
          min = A[i]; max = A[j]}
4.     else{ min = A[j]; max = A[i])}
   }
5. else{
6. mid = (i+j)/2
7. findMaxMin(A,i,mid,min1,max1)
8. findMaxMin(A,mid+1,j,min2,max2)
9. if(min1 &amp;lt; min2) min = min1
10.else min = min2
11.if(max1 &amp;lt; max2) max = max2
12.else max = max1
최초 호출: findMaxMin(A,0,n-1,min,max)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag04.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 실행 트리이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;합병-정렬&quot;&gt;합병 정렬&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;쉬운 전략
    &lt;ol&gt;
      &lt;li&gt;최솟값을 찾는다.&lt;/li&gt;
      &lt;li&gt;남은 요소들을 같은 방법을 사용하여 재귀적으로 정렬한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;총 비교횟수 n의2제곱&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;분할 정복 전략
    &lt;ol&gt;
      &lt;li&gt;배열을 반으로 나눈다.&lt;/li&gt;
      &lt;li&gt;왼쪽 반과 오른쪽 반을 각각 정렬한다.&lt;/li&gt;
      &lt;li&gt;정렬된 왼쪽 반과 오른쪽 반을 합병한다..&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag05.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 합병 정렬의 진행 과정이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;합병 정렬 알고리즘&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;알고리즘 mergeSort(A[], low, high)
// 배열 A[low .. high]를 합병 정렬을 이용하여 정렬한다.
if(low &amp;lt; high){
      mid = (low+high)/2
      mergeSort(A,low,mid)
      mergeSort(A,mid+1,high)
      merge(A,low,mid,high)
}
최초 호출: mergeSort(A,0,n-1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Merge 메소드&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//정렬된 부분 배열 A[low .. mid]와 A[mid+1 .. high]를 합병한다.
MERGE(A[],low,mid,high){
  크기가 (high + 1)인 배열 B를 만든다
  h = low; i = low; j = mid + 1
  while(i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;=high){
      if(A[i] &amp;lt;= A[j] { B[h] = A[i]; i = i + 1}
      else{B[h] = A[j]; j = j + 1}
      h = h + 1
  }
  if( i &amp;gt; mid)
      for(k = j; k &amp;lt;= high; k++) { B[h] = A[k]; h = h + 1}
  else
      for(k = i; k &amp;lt;= mid; k++) {B[h] = A[k]; h = h + 1}
  for(k = low; k &amp;lt;= high; k++) A[k] = B[k];
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;시간 복잡도 nlogn&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;비재귀 합병 정렬 알고리즘&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mergeSort2(A[], n)
//배열 A[0 .. n-1]를 비재귀 합병 정렬을 이용하여 정렬
size = 1
while(size &amp;lt; n){
  for(i = 0; i &amp;lt; n; i = i + 2*size)
      Merge(A,i,i+size-1,i+2*size-1)
  size = size * 2
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;합병 정렬의 단점&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;합병 정렬의 공간 복잡도: 빅오(n)&lt;/li&gt;
  &lt;li&gt;입력을 위한 메모리 공간 외에 추가로 입력과 같은 크기의 공간이 별도로 필요&lt;/li&gt;
  &lt;li&gt;2개의 정렬된 부분을 하나로 합병하기 위해 합병된 결과를 저장할 공간이 필요하기 때문이다&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;빠른-정렬&quot;&gt;빠른 정렬&lt;/h3&gt;

&lt;p&gt;절대적으로 가장 빠른 정렬 알고리즘은 아니지만 평균적으로 매우 효율적이다&lt;/p&gt;

&lt;p&gt;평균 시간복잡도: 빅오(nlogn)&lt;/p&gt;

&lt;p&gt;최악 시간복잡도: 빅오(n의2제곱)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기본 아이디어
    &lt;ol&gt;
      &lt;li&gt;배열을 두 부분으로 분할한다.&lt;/li&gt;
    &lt;/ol&gt;
    &lt;ul&gt;
      &lt;li&gt;배열내의 한 기준 요소보다 작거나 같은 요소들은 앞부분에 놓는다.&lt;/li&gt;
      &lt;li&gt;기준 요소보다 큰 요소들은 모두 뒷부분에 놓는다.
        &lt;ol&gt;
          &lt;li&gt;각 분할된 부분을 재귀적으로 정렬한다.&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag06.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 빠른 정렬의 진행과정이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;빠른 정렬 알고리즘&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;quickSort(A[], low, high)
// 배열: A[low .. high]를 빠른 정렬을 이용하여 정렬한다.
// 입력: 정렬할 수 있는 요소들의 배열 A[low .. high]
// 출력: 오름차순으로 정렬된 요소돌의 배열 A[low .. high]
if(low &amp;lt; high){
      s = partition(A,low,high) // 기준 요소 A[low]를 기준으로 분할
      quickSort(A,low,s-1)
      quickSort(A,s+1,high)
 }
 //최초 호출: quickSort(A,0,n-1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;분할 알고리즘&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;partition(A[], low, high)
//입력: 배열 A[0 .. n-1]의 부분 배열 A[low .. high], low &amp;lt; high
//출력: A[low .. high]의 분할 후 기준 요소의 최종 위치(지수)를 반환
i = low + 1
j = high
while( i &amp;lt;= j){
      if(A[i] &amp;lt;= A[low]) i = i + 1
      else if( A[j] &amp;gt; A[low]) j = j -1
      else { A[i] &amp;lt;-&amp;gt; A[j]
              i = i + 1
              j = j - 1
      }
 }
 A[low] &amp;lt;-&amp;gt; A[j]
 return j
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;분할-정복이-부적절한-경우&quot;&gt;분할 정복이 부적절한 경우&lt;/h3&gt;

&lt;p&gt;문제가 분할될 때만다 분할된 부분 문제들의 입력 크기의 합이 분할되기 전의 입력
크기보다 매우 커지는 겨우&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">분할 정복 설계 전략</summary>
      

      
      
    </entry>
  
</feed>
