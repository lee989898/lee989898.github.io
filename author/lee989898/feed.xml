<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://lee989898.github.io/author/lee989898/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://lee989898.github.io/" rel="alternate" type="text/html" />
  <updated>2021-10-16T01:12:31+09:00</updated>
  <id>https://lee989898.github.io/author/lee989898/feed.xml</id>

  
  
  

  
    <title type="html">LEE | </title>
  

  
    <subtitle>공부 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">PL-09</title>
      <link href="https://lee989898.github.io/pl-09" rel="alternate" type="text/html" title="PL-09" />
      <published>2021-10-13T19:18:00+09:00</published>
      <updated>2021-10-13T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-09</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-09">&lt;h1 id=&quot;제-9장--프로그래밍-언어&quot;&gt;&lt;strong&gt;제 9장  프로그래밍 언어&lt;/strong&gt;&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;정적 시맨틱과 동적 시맨틱&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="study" />
      

      
        <summary type="html">제 9장 프로그래밍 언어</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">PL-08</title>
      <link href="https://lee989898.github.io/pl-08" rel="alternate" type="text/html" title="PL-08" />
      <published>2021-10-13T19:18:00+09:00</published>
      <updated>2021-10-13T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-08</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-08">&lt;h1 id=&quot;제-8장--프로그래밍-언어&quot;&gt;&lt;strong&gt;제 8장  프로그래밍 언어&lt;/strong&gt;&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;프로그래밍 언어의 신택스와 시맨틱스&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;프로그래밍 언어의 신택스는 산술식, 문, 프로그램 단위의 형태를 말한다. ​
문은 statement 또는 sentence를 말한다.   ​&lt;/p&gt;

&lt;p&gt;프로그램 단위는 컨스트럭트(컨트롤 스트럭처)를 말하는데, ​
앞으로 명확한 설명을 위해 프로그램 단위라는 추상적인 말을 쓰지 않고, ​
가급적 컨스트럭스 또는 컨트롤 스트럭처라는 말을 쓰겠다. ​&lt;/p&gt;

&lt;p&gt;시맨틱스는 신택스에 맞게 작성된 표현식, 문, 컨스트럭트의 의미를 말합니다. ​&lt;/p&gt;

&lt;p&gt;자바 while 문에 대해, ​
신택스는 while (Boolean_expr) statement 의 형태를 띄어야 하고, ​
그 시맨틱스는 부울 표현식이 참일 때, statement를 실행하고, ​
컨트롤은 부울 표현식으로 되돌아가서 이 프로세스를 반복하는데, ​
부울 표현식이 거짓이면 ​
while 컨스트럭트의 실행이 끝난다는 의미이다.​&lt;/p&gt;

&lt;p&gt;시맨틱스의 서술 방법은 여러 가지가 있지만, ​
컴퓨터에서 실행되는 ‘연산의 의미’로 시맨틱스를 서술하는 것을 ​
operational semantics라고 하는데, ​
위에 서술된 while문의 시맨틱스는 operational semantics의 예이다.
​
잘 설계된 프로그래밍 언어에서, 시맨틱스는 신택스를 따릅니다. ​
이것은 위에 설명된 자바 while 문의 신택스와 시맨틱스의 예를 
보면 직관적으로 알 수 있을 것이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;그럼 신택스를 어떻게 서술하는지 살펴 보자.&lt;/p&gt;

&lt;p&gt;신택스 서술 방법으로 BNF가 널리 사용되고 있다. ​
BNF를 메타 언어라고 하는데, 메타 언어란 언어를 
서술하는데 사용되는 언어라는 뜻이다.&lt;/p&gt;

&lt;p&gt;즉, BNF는 프로그래밍 언어의 신택스를 서술하는데 사용되는 메타 언어이다. ​
BNF는 신택스 구조를 위한 추상적 개념을 사용하는 규칙 언어이다. ​
규칙은 화살표 왼편(LHS)과 오른편(RHS)으로 나누어지는데, ​
문을 생성하면서, 왼편이 오른편으로 대체된다.
​
BNF가 사용하는 추상적 개념들에는 무엇이 있는지 ​
자바의 예를 보면서 알아 보자&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl12.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;자바의 assign과 if 문은 다음과 같이 서술된다.​&lt;/p&gt;
&lt;assign&gt;, &lt;var&gt;, &lt;expression&gt;, 화살표(-&amp;gt;), =(이퀄 사인)​
&lt;if_stmt&gt;, &lt;logic_expr&gt; &lt;stmt&gt;, if, (괄호), |(세로줄, 
or의 뜻) 등을 볼 수 있다.

화살표를 제외하고, 이들은 각각 BNF를
 구성하는 non-terminal/terminal 심볼입니다. ​
꺽쇠 괄호로 싸여 있는 것이 난터미날이다.

하나의 왼편에 대해 여러 개의 규칙을 가질 수 있는데, ​
이때 여러 개의 규칙에 대해 |를 사용하여 각각의 오른편을 구분합니다. ​

List를 보면, &lt;ident_list&gt;의 오른편에 두개의 규칙이 있음을 알 수 있는데, ​
두번째 규칙은 &lt;ident_list&gt;가 identifier와 &lt;ident_list&gt;로 대체하는 것
입이다. ​

이 규칙의 오른편을 보면, &lt;ident_list&gt;가 또 들어 있는데,  ​
이러한 규칙을 recursive rule(순환 규칙)이라고 한다.

문법은 언어를 정의하기 위한 생성 장치이다.
문은 문법에 있는 일련의 규칙 적용을 통해 생성되며, ​
이러한 일련의 규칙 적용을 유도(derivation)이라고 한다. ​
유도에 의해 생성된 결과를 문형식(sentential form)이라고 한다. ​

문형식(sentential form)에서,  ​
가장 왼쪽의 난터미날을 먼저 대체하는 것을 좌
선유도(leftmost derivation)이라고 하고, ​
그 반대를 우선유도(rightmost derivation)이라고 한다.

---

 ​&lt;img src=&quot;/assets/built/images/pl/pl13.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;

---

위 사례는 덧셈과 뺄셈으로 구성된 산술식을 서술하기 위한 문법과 ​
그 문법에 의한 산술식의 유도(derivation) 과정을 보여주고 있다. ​

오른쪽에 나열된 일련의 문형식(sentential form)들은 ​
&lt;program&gt;이라는 난터미날 심볼에서 시작하여, ​
왼쪽의 문법을 적용하여 좌선유도(Leftmost derivation)된 결과이다.  ​
=&amp;gt;의 오른쪽에 있는 begin &lt;stmt_list&gt; end, ​
begin &lt;stmt&gt; ; &lt;stmt_list&gt; end, 등은 모두 문형식의 예들이다. ​
마지막에 있는 begin A = B + C ; B = C end 은 문(sentence)이다. ​
그러니까 문과 문형식의 차이는 난터미날 심볼의 유무에 달려 있다. ​

---

 ​&lt;img src=&quot;/assets/built/images/pl/pl14.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;

---

위 사례는 Assignment 문을 위한 문법과 ​
그 문법에 의한 assignment 문의 유도를 보여주고 있다. ​

왼쪽 아래는 난터미날 심볼 &lt;assign&gt;에서 시작하여 leftmost
derivation을 보여주고 있고,  ​

이것을 트리로 나타내 보면 오른쪽 그림과 같다. ​
이 트리를 파스(parse) 트리라고 한다. ​

당연한 말이지만 leftmost derivation을 하면, ​
파스 트리의 가장 왼쪽 노드부터 터미날 심볼로 바뀌
는 것을 볼 수 있다. 

---

 ​&lt;img src=&quot;/assets/built/images/pl/pl15.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;

---

이 문법을 가지고 &lt;expr&gt;에서 시작해서 산술식을 유도할 때, ​
+이 포함된 RHS를 먼저 적용하느냐, *이 포함된 RHS를 먼저 적용하느냐에 따라, ​
A=B+C*A를 위한 파스 트리가 두개 생성된다. ​

이와 같이, 문형식에 문법을 적용할 때, ​
동일한 문형식에 대해 파스 트리가 여러 개 생성되면, ​
이 문법을 모호한 문법이라고 한다. ​

문법의 모호성은 중대한 문제를 야기한다. ​
일반적으로 preorder에 따라 산술식을 계산하는데, ​
이들 트리는 실행 결과가 서로 다르다. ​

왜냐하면, 왼쪽의 트리는 덧셈이 먼저, 오른쪽의 트리는 곱셈이 
먼저 계산되기 때문이다. ​
즉, 동일한 문에 대해 어떤 규칙을 먼저 적
용하였느냐에 따라 파스 트리가 다르고, ​
그 트리의 실행 결과가 항상 같지 않다는 것이다. ​
이러한 이유로 문법의 모호성은 제거되어야 한다. 

문의 실행 결과가 항상 같지 않을 수 있기 때문에 모
호성은 제거되어야 함을 알게 되었다. ​

이러한 모호성을 어떻게 제거할 수 있을까?  ​

+ 연산자에 대한 우선순위를 둔다. ​

    즉, 파스 트리의 가장 아래에 있는 연산자부터 먼저 실행한다. ​
    따라서, 아래에 있는 연산자가 위의 연산자보다 우선 순위가 높다. ​

+ 우선순위에 따라 연산자 출현 순서를 지정한다. ​

    이와 같은 출현 순서의 지정은 별도의 난터미널 심볼을 사용
    하여 명세할 수 있다. ​
    난터미널 심볼은 우선순위가 다른 연산자의 오퍼랜
    드를 표현하기 위해 사용한다. ​

모호성 제거 방법을 종합하면, 문법을 서술할 때,  ​
파스 트리에서 낮은 우선순위의 연산자가 ​
높은 우선순위의 연산자보다 위에 나타날 수 있도록, ​
낮은 우선순위의 오른쪽 오퍼랜드를 ​
새로운 난터미널 심볼로 대체한다.  ​

예를 들어 살펴 보자.

---

 ​&lt;img src=&quot;/assets/built/images/pl/pl16.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;

---


+는 *에 비해 트리의 아래에 위치해야 한다
따라서, &lt;expr&gt; -&amp;gt; &lt;expr&gt; + &lt;expr&gt;의 RHS에서 ​
오른쪽 오퍼랜드 &lt;expr&gt;를 &lt;term&gt;으로 대체한다.
그러면 이제 &lt;expr&gt; -&amp;gt; &lt;expr&gt; * &lt;expr&gt;는 ​
&lt;term&gt; -&amp;gt; &lt;term&gt; * &lt;term&gt;으로 잠정적으로 바뀐다.
이 규칙의 RHS에서 오른쪽 오퍼랜드는 ​
곱셈 다음에 &lt;id&gt;나 (괄호속의 식)을 나타날 수 있다.
(괄호속 식)을 서술할 수 있도록 하기 위해 ​
곱셈의 오른쪽 오퍼랜드 &lt;term&gt;을 ​
난터미날 심볼 &lt;factor&gt;를 사용하여 대체한다.
그러면, 잠정적으로 바뀐 &lt;term&gt; -&amp;gt; &lt;term&gt; * &lt;term&gt;은 ​
&lt;term&gt; -&amp;gt; &lt;term&gt; * &lt;factor&gt;가 된다.

원래 &lt;factor&gt;는 없었는데, ​
곱셈의 오른쪽 오퍼랜드로 (괄
호속 식) 또는 &lt;id&gt;를 나타낼 수 있도록 하기 위해 ​
&lt;factor&gt;라는 난터미날을 새로 도입한 것이다. ​

이러한 목적에 의해 &lt;factor&gt;가 (괄호속 식)
 또는 &lt;id&gt;를 생성하는 규칙을 서술해야 한다.
이 규칙은 &lt;factor&gt; -&amp;gt; (&lt;expr&gt;) | &lt;id&gt;로 쓸 수 있다.

연산자 우선순위와 연산자 출현 순서의 지정에 의해 모호성을 제거하여 ​
트리를 생성하면 유일하게 생성된다.


그러나 만일 우선순위가 같은 곱셈과 나눗셈이 포함된 산술식을 위한 문법이라면, ​
모호성을 어떻게 제거해야 할까? ​

이와 긑은 문제는 시맨틱 규칙으로 지정해서 해결해야 한다. ​​

A / B * C와 같이 동일한 우선순위를 가진 곱셈과 나눗셈으
로 이루어진 식에서, ​
이들 연산자간의 계산 순서를 정하기 위해 어떤 시맨틱 규칙을 쓸 수 있을까? ​
바로 결합 법칙을 이용할 수 있다. ​

그런데 결합 법칙에는, ​
왼쪽부터 결합하는 방식과 오른쪽부터 결합하는 방식, ​
두 가지가 있다.
A / B * C 은 어느 방식을 쓰느냐에 따라 계산 결과가 달라진다.  ​
    
또한 if-else 문법의 모호성 문제도 있다.  ​

---

 ​&lt;img src=&quot;/assets/built/images/pl/pl17.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;

---


if (&lt;logic_expr&gt;) if (&lt;logic_expr&gt;) &lt;stmt&gt; else &lt;st mt=&quot;&quot;&gt;에 대해, 위의 문법은 두개의 파스 트리를 생성한다. ​
따라서 이 문법은 모호성이 있다.  

---

 ​&lt;img src=&quot;/assets/built/images/pl/pl18.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;

---

If-else의 모호성 제거는 ‘가장 가까운 t
hen에 else를 매치시킨다’는 규칙으로 해소된다.
If문은 then과 else가 모두 있는 것과 ​
then만 있고 else는 없는 것으로 구분된다. ​

즉 난터미날 &lt;stmt&gt;는 난터미날 &lt;matche d=&quot;&quot;&gt;이거나 &lt;unmatched&gt;로 대체된다.
&lt;matched&gt;는 if… else…를 모두 갖춘 것이고, &lt;unm atched=&quot;&quot;&gt;는 if… 로 구성되어 있다.
&lt;unmatched&gt;는 else 다음에 if… els
e를 허용하기 위해, 규칙에 else &lt;unmatched&gt;를 추가한다. ​

모호성을 제거한 새로운 문법은 오른쪽 아래와 같다.

---

+ Extended BNF

---

 ​&lt;img src=&quot;/assets/built/images/pl/pl19.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;

---

&amp;lt;…&amp;gt;는 난터미날 심볼, x, y, z는 터미날 심볼​
( )는 그룹으로 묶기(일상적인 괄호의 의미), ​
{ }와 [ ]는 일상적인 의미가 아니고, ​
{ }는 0번 이상 반복, ​
[ ]는 생략 가능(이 예제에는 없음), ​
“ ”는 터미날 심볼을 나타내는 규칙의 표현 기호이며, ​
( )는 규칙 표기에 사용되는 기호이기 때문에, ​
산술식의 일부로서 표현되는 소괄호는 “(“  “)”로 표기함  

---

 ​&lt;img src=&quot;/assets/built/images/pl/pl20.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;

---

위 그림에서 왼쪽의 BNF를 EBNF로 나타내면 오른쪽과 같다고 되어 있다.  ​
그러나 이 문법은 산술식에서 우선순위를 나타낼 때 사용하는 소괄호와
EBNF로 표기법의 소괄호의 의미를 구분하지 못하고 있다.  ​

이를 바로 잡으면, 오른쪽 아래의 문법과 같다. ​
EBNF에서 ( )를 산술식의 괄호로 쓰려면, “(“, “)”로 써야 한다.

---
&lt;/unmatched&gt;&lt;/unmatched&gt;&lt;/unm&gt;&lt;/matched&gt;&lt;/unmatched&gt;&lt;/matche&gt;&lt;/stmt&gt;&lt;/st&gt;&lt;/stmt&gt;&lt;/logic_expr&gt;&lt;/logic_expr&gt;&lt;/id&gt;&lt;/expr&gt;&lt;/factor&gt;&lt;/id&gt;&lt;/factor&gt;&lt;/factor&gt;&lt;/id&gt;&lt;/factor&gt;&lt;/factor&gt;&lt;/term&gt;&lt;/term&gt;&lt;/term&gt;&lt;/term&gt;&lt;/term&gt;&lt;/factor&gt;&lt;/term&gt;&lt;/id&gt;&lt;/term&gt;&lt;/term&gt;&lt;/term&gt;&lt;/expr&gt;&lt;/expr&gt;&lt;/expr&gt;&lt;/term&gt;&lt;/expr&gt;&lt;/expr&gt;&lt;/expr&gt;&lt;/expr&gt;&lt;/expr&gt;&lt;/assign&gt;&lt;/stmt_list&gt;&lt;/stmt&gt;&lt;/stmt_list&gt;&lt;/program&gt;&lt;/ident_list&gt;&lt;/ident_list&gt;&lt;/ident_list&gt;&lt;/ident_list&gt;&lt;/stmt&gt;&lt;/logic_expr&gt;&lt;/if_stmt&gt;&lt;/expression&gt;&lt;/var&gt;&lt;/assign&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="study" />
      

      
        <summary type="html">제 8장 프로그래밍 언어</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">PL-07</title>
      <link href="https://lee989898.github.io/pl-07" rel="alternate" type="text/html" title="PL-07" />
      <published>2021-10-13T19:18:00+09:00</published>
      <updated>2021-10-13T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-07</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-07">&lt;h1 id=&quot;제-7장--프로그래밍-언어&quot;&gt;&lt;strong&gt;제 7장  프로그래밍 언어&lt;/strong&gt;&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;프로그래밍 언어의 정교화&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ALGOL&lt;/p&gt;

    &lt;p&gt;초기 포트란은 IBM 704를 타겟으로 개발되었다. ​
 마찬가지로, 많은 언어가 특정 하드웨어에 최적화하도록 개발되었고, ​
 이들 언어 간의 소통은 불가능했다. ​&lt;/p&gt;

    &lt;p&gt;LISP를 포함한 초기의 다른 여러 프로그래밍 언어도 마찬가지였다. ​
 Lisp의 기본 연산자 CAR(content of the address register)
 , CDR(content of decrement register)은 ​
 IBM 704 하드웨어 아키텍처와 매치되지는 않지만, 연산자 이름에서 ​
 당시의 프로그래밍 언어가 하드웨어 아키텍처와 밀접한 관련성이 있었
 다는 흔적임을 알 수 있다. ​&lt;/p&gt;

    &lt;p&gt;이러한 문제를 해결하고자, ALGOL을 개발하였다.
 ALGOL은 과학 알고리듬의 표현을 위한, 하드웨어
  구조에 독립적인 명령식 언어이다.&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  GO TO 27​   27 IF (A-B) 5,6,7​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;알골 이전의 컨트롤 스트럭처는 go to 하나뿐이었다. ​
  go to 27은, 위 코드에서 보듯이, 27이라는 
  레이블이 붙은 문장으로 점프한다.  ​&lt;/p&gt;

    &lt;p&gt;Go to는 레이블 중심의 컨트롤을 하기 때
  문에, 그 레이블이 어디든 점프하게 된다. ​
  이로 인해 프로그램 코드는 스파게티처럼 꼬이게 되어, ​
  디버깅이 매우 어려울 뿐만 아니라, 의도하지 않은 영역
  으로 점프하는 등 ​
  go to는 해로운 컨트롤 스트럭처로 인식되고 있었다. ​&lt;/p&gt;

    &lt;p&gt;이를 해결하기 위해, ​  &lt;br /&gt;
  절(phrase) 수준의 컨트롤 스트럭처로서 if,
   while, switch, for, until 등이 언어에 포함되었다. ​
  뿐만 아니라, 이들 스트럭처를 사용하기 위한 프로그램 설계 
  방법으로 구조적 프로그래밍(structured progra
  mming)이 제안되었다. ​&lt;/p&gt;

    &lt;p&gt;구조적 프로그램 스타일의 핵심은 위에 언급된 컨트롤
   스트럭처를 적재적소에 적용하여, ​
  하나의 프로그램을 여러 개의 블록을
   나누고 이들 블록간의 컨트롤을 구조적으로 유지하자는 것이다.  ​
  이렇게 하면 프로그램의 디버깅이 쉬울 뿐만 아니라, 프로그
  램의 개발, 이해, 수정이 쉬워진다.&lt;/p&gt;

    &lt;p&gt;알골 언어는 프로그래밍할 때 기억해야 특별한 제약이 없다. ​
 따라서 포트란에 비해 프로그램 작성시 다음과 같은 면에서 자유롭다. ​&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;코딩할 때 고정된 포맷이 없다. 초기의 포트란은 레이블의
위치 문장의 시작 위치 등이 지정되어 있다&lt;/li&gt;
      &lt;li&gt;변수명의 길이와 배열의 차원 수에 제한이 없다. 초기의 포트란은 변수명의 길이
가 6자 이내이며, 차원수도 3개로 제한되어 있었다.  ​&lt;/li&gt;
      &lt;li&gt;독립성: 기본 개념의 결합에 제한이 없다. 허용되지
 않는 결합 조건 등 특별한 금지 사항을 기억해야 할 필요가 없다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;알골은 1958년 이후에 개발된 모든 언어에 영향을 주었
 으며, 이들 언어가 사용한 아이디어는 다음과 같다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;특정 포맷이 없는 lexical structure(어휘 구조) ​&lt;/li&gt;
  &lt;li&gt;변수명과 배열 차원의 길이에 제한이 없음 ​&lt;/li&gt;
  &lt;li&gt;BNF에 의한 구문 구조(신택스)​&lt;/li&gt;
  &lt;li&gt;타입 개념​&lt;/li&gt;
  &lt;li&gt;지역 변수의 허용에 의한 블록 구조 ​&lt;/li&gt;
  &lt;li&gt;Begin-end 및 if-then-else의 중첩 허용에 의한 복합 문장 ​&lt;/li&gt;
  &lt;li&gt;실행 시 스택 메모리 기반의 동적 배열 할당 ​&lt;/li&gt;
  &lt;li&gt;Call by value, call by reference, call by name ​&lt;/li&gt;
  &lt;li&gt;Recursion, 조건식(conditional expression) ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Call by value는 함수 호출 시 파라미터의 ‘값’을 넘겨주고, 이
   ‘값’은 ‘새로운 공간’에 저장되어 호출된 함수에서 사용된다. ​&lt;/p&gt;

&lt;p&gt;call by reference는 함수 호출시 파라미터의 ‘주소’를 넘겨주고,
  되돌려 받을 때도 이 ‘주소’를 이용한다. ​&lt;/p&gt;

&lt;p&gt;call by name는 함수 호출시 ‘함수’를 파라미터로 넘겨
 주면, ‘실제 실행할 때’ 그 ‘함수를 호출’한다. ​&lt;/p&gt;

&lt;p&gt;Call by value와 call by reference는 값을 저장하는
  공간을 다루고 있지만,
 Call by name은 ‘넘어간 함수의 호출 시점’을 다루고 있다.
 Call by name은 함수 프로그래밍에서 사용하는 방법이다.&lt;/p&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/pl/pl10.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;p&gt;함수 호출시 파라미터를 call by value로 넘겨준다면, ​
그 아웃풋 순서는 hi 다음에 call이지만, ​&lt;/p&gt;

&lt;p&gt;Call by name으로 한다면, ​
그 순서는 call 다음에 hi가 된다. ​
그 이유는 call(x)의 x에 함수 hou()의 name이 매치되고, ​
call(x) 함수 내에서 x()가 실행되어야 비로소 함수 hou()를 실행하기 때문이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;BASIC&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;베이직은 개발 시기에 비해 늦게 대중화된 언어이다
. MS의 베이직과 같은 언어이다. ​
Basic의 특징은 한대의 컴퓨터에 연결된
 다수의 원격 터미날을 통해 다수의 사용자가 시분
 할 방식으로 동시에 접속하여 컴퓨터를 사용할 수 있는 
 개발 환경을 제공하였다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;COBOL&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;코볼은 유니백이 개발한 플로우매틱을 모
태로 대음과 같은 특성을 갖는 언어로 개발되었다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;변수명은 하이픈(-) 포함해서 30글자까지 ​&lt;/li&gt;
  &lt;li&gt;산술 연산자를 영어명으로 (산술식 표현이 없음) ​&lt;/li&gt;
  &lt;li&gt;모든 문장은 동사로 시작함 ​&lt;/li&gt;
  &lt;li&gt;계층적 데이터 구조(레코드) 제공​&lt;/li&gt;
  &lt;li&gt;If-then-else의 중첩 ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;미국방부가 주도한 설계 고려사항은 다음과 같다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;영어처럼 단순하게 ​&lt;/li&gt;
  &lt;li&gt;사용하기 쉽게​&lt;/li&gt;
  &lt;li&gt;컴퓨터 사용자의 저변 확대 ​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;기존 컴파일러 문제의 회피&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PL/I&lt;/strong&gt;​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;과학 분야의 계산은 포트란으로, 비’
즈니스 응용 분야에서는 코볼로 프로그래밍을 하였으나, ​&lt;/p&gt;

&lt;p&gt;과학분야의 계산과 입출력이 복잡해 지면서 레코드 
형태의 출력 구조를 요구하게 되었고, ​&lt;/p&gt;

&lt;p&gt;비즈니스 분야 응용에서도 부동점 계산이나 배열 등을 요구하게 되었다. ​&lt;/p&gt;

&lt;p&gt;IBM은 이러한 요구를 수용할 수 있는 하드웨어와 프로
그래밍 언어를 동시에 개발하였다. ​
IBM 360은 이들 응용을 모두 커버할 수 있는 하드웨어였고, ​
PL/1은 이들 분야의 문제 해결을 위한 프로그래밍 언어였다. ​&lt;/p&gt;

&lt;p&gt;IBM은 다중 프로그래밍을 지원하는 시스템이었기 때문
에, 컴퓨팅 및 저장 공간 단위의 동시성 제어, 인터럽
트 처리, 예외 처리, 포인터 등에 대한 관리 메커니즘을 개발하였다. ​&lt;/p&gt;

&lt;p&gt;그러나 이들은 너무 복잡해서 시스템 오버헤드에 문제를 노출시켰다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;여기 부터 언급하는 프로그래밍 언어에서는 데이터 추상화가
프로그래밍 언어의 발전 요인이 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;SIMULA&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이번엔 데이터 추상화를 최초로 지원했던 시뮬라를 살펴보자.
시뮬라는 시뮬레이션 프로그램 작성에 편리한 언어로 개발되었다. ​
시뮬라의 가장 중요한 특성으로는 클래스와 코루틴을 들 수 있다. ​&lt;/p&gt;

&lt;p&gt;클래스는 데이터 추상화의 기본이 되는 구조로서, 로컬 데이터와 이
에 대한 함수의 정의를 포함한다. ​&lt;/p&gt;

&lt;p&gt;시뮬라의 이와 같은 데이터 추상화는 객체 지
향 프로그래밍의 객체와 유사하다.  ​&lt;/p&gt;

&lt;p&gt;코루틴은 서브루틴(서브 프로그램)을 일반화한 것으로, 서브프로
그램 실행의 중단과 재시작을 허용한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/pl/pl11.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;​
코루틴이 서브루틴의 일반화한 것이라고 했는데, 왜 그런지 서브루틴
과 코루틴을 비교해 보자.  ​&lt;/p&gt;

&lt;p&gt;위 그림에서 볼 수 있듯이, 서브루틴은 호출(call)될 때마다
 처음부터 실행하여 결과를 (return)돌려준다. ​&lt;/p&gt;

&lt;p&gt;반면, 코루틴은 여러 루틴들이 시작, 중지 및 양보(yi
eld), 재시작을 반복하면서 동시에 실행되는 것을 말한다.  ​&lt;/p&gt;

&lt;p&gt;이때 재시작은 루틴의 처음부터 시작하는 것이 아니
라, 이전에 양보했던 그 지점에서 재시작한다. ​&lt;/p&gt;

&lt;p&gt;루틴1이 실행되다가, 루틴2에게 양보하고, 
루틴2가 실행되다가 루틴1에게 양보하기를 반복한다. ​&lt;/p&gt;

&lt;p&gt;왼쪽 코드를 봅시다. ​
이 프로그램은 두개의 코루틴 producer, consumer과, main(즉, cal
l producer)으로 구성되어 있다.&lt;/p&gt;

&lt;p&gt;프로듀서는 큐가 풀이 아니면, 새로운 아이템을 생산하여 큐에 넣는다. ​
만일 큐가 풀이면, 컨슈머에게 양보한다. ​
​
컨슈머는 큐가 비어있지 않으면, 큐에서 아이템을 뽑아서 처리한다. ​
만일 큐가 비어 있으면, 프로듀서에게 양보한다. ​&lt;/p&gt;

&lt;p&gt;이 프로그램은 프로듀서를 호출함으로써 시작되고, ​
콜루틴의 조건에 따라 서로 양보하면서 반복적으로 실행된다. ​&lt;/p&gt;

&lt;p&gt;논리적으로 보면 이 프로그램은 끝나지 않는 프로그램이다. ​&lt;/p&gt;

&lt;p&gt;이러한 종류의 프로그램은 일반적인 응용 프로그램보다는
 시스템 소프트웨어에서 많이 볼 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Smalltalk&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;스몰톡은 최초의 객체지향언어라고 한다.
앞의 데이터 추상화에서 시뮬라가 최초의 객체지향언어라고 취급하기도 하지만, ​
스몰톡이야말로 객체 지향 언어의 중요한 특성을 구현하였기 때문이다. ​&lt;/p&gt;

&lt;p&gt;그러면 스몰톡 언어의 특성을 살펴보자. ​
변수, 상수, 레코드 실행, 클래스 등 모든 것이 객체로 취급된다.  ​
모든 계산은 객체에 의한 메시지의 전송 및 수신에 의해 수행된다. ​
데이터 추상화, 상속, 동적 타입 바인딩 등   ​
스몰톡 언어는 데스크탑 환경을 가정하였는데, 
이러한 데스크탑은 프로그래머가 아닌 사용자에 의해 사용될 것이며,
 따라서 강력한 휴먼 인터페이스를 필요로 할 거라고 가정하였다.
  이러한 이유로 스몰톡은 GUI 설계를 개척하게 되었던 것이다.
 이러한 아이디어는 개발되어 Dynabook에 탑재되었다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;C++&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;시뮬라 및 스몰톡의 클래스와 함께, 함수 파라미터 타입 검
사 및 컨버전, constructor, 상속된 요소의 접근 통제, 예외 처리 
등을 C에 추가하여 C++를 개발하였다. ​&lt;/p&gt;

&lt;p&gt;절차적(명령형) 프로그래밍과 객체 지향 프로그래밍을 
동시에 지원하면서 C++ 언어는 대단히 복잡해졌다. ​&lt;/p&gt;

&lt;p&gt;C++은 컴파일러의 품질이 좋고 저렴했고 C와 컴패터블했기 때문
에 널리 보급되어 지금도 널리 사용되고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Java&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;자바는 객체지향 언어로, 명령형 프로그래밍 언어이다.
자바는 가전제품의 임베디드 소프트웨어 개발에 적합하도록 ​
다음과 같은 요구사항에 초점을 맞춰 설계되었다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;단순성​&lt;/li&gt;
  &lt;li&gt;객체지향 프로그래밍 지원​&lt;/li&gt;
  &lt;li&gt;포인터 대신에 레퍼런스 지원 -&amp;gt; 클래스 정의, 사용자 정의 타입 ​&lt;/li&gt;
  &lt;li&gt;애플릿 및 동시성(동시처리) 지원 ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;C++는 객체지향 프로그래밍을 지원하지만, ​
임베디드 소프트웨어에 부적합하다고 평가되었다.
그 이유는 절차적 언어를 지원하기 때문에 ​
구현 시스템이 너무 크고 복잡하고, 신뢰도가 낮기 때문이다.   ​&lt;/p&gt;

&lt;p&gt;자바는 순수 객체 지향 언어이다.
모든 처리로직은 객체의 메소드로 정의되기 때문에 ​
서브 프로그램이 존재하지 않았다.  ​
자바는 복잡도를 줄이기 위해 ​
단일 상속만을 허용하고 동시성 형태도 단순화하였다. ​&lt;/p&gt;

&lt;p&gt;자바의 특징은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자바는 C++에 비해 실행 속도보다 안정성에 중점을 두고 있습니다. ​
 안전성은 다양한 면에서 언급될 수 있는데, ​
  우선 자바 가상 머신을 통한 코드 실행과 배열 범위 검사를 들 수 있다.
 자바 가상 머신은 하위 플랫폼을 추상화시키는 결과를 가져 오기 때문에 ​
 하드웨어 플랫폼의 차이점으로 인한 오류 발생을 해소한다.
 그리고 실행시 배열 범위 검사는 배열 처리 상의  오류를 줄인다.    ​&lt;/li&gt;
  &lt;li&gt;동시성 지원(병렬 처리): thread, runnable task ​&lt;/li&gt;
  &lt;li&gt;애플릿, GUI, DB access 라이브러리​&lt;/li&gt;
  &lt;li&gt;컴파일러 및 자바 가상 머신에 의한 이식성​&lt;/li&gt;
  &lt;li&gt;웹 프로그래밍에 적용성 ​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Pascal(1971)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파스칼은 알골의 후속작으로 구조적 프로그래밍을 가르치기 위해 설계되었다. ​
작고 단순하고 전혀 새롭지 않은 언어를 지향하였다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;C&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;C는 시스템 프로그래밍을 위해 개발되었으며, 연산자가 풍부한 반면, 타입
 검사가 없는 언어이다. ​
유닉스와 함께 보급되었으며, 다양한 응용 분야에서 사용되었다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Ada&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;에이다는 이제까지 언급한 프로그래밍 언어의 개념을 하나의 언어로
 설계 및 구현하려는 시도였다. ​&lt;/p&gt;

&lt;p&gt;이 프로젝트를 통해 얻은 것은 다음과 같다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;패키지는 데이터 추상화를 지원​&lt;/li&gt;
  &lt;li&gt;예외 처리를 좀더 정교하게 발전​&lt;/li&gt;
  &lt;li&gt;서브 프로그램이나 패키지를 일반적인 단위 프로그램으로 생성하기때문에, ​
  공통 속성을 갖는 알고리듬에 유용함. ​&lt;/li&gt;
  &lt;li&gt;타스크 간의 소통에 의한 동시성 통제를 통해 병렬 처리를 지원&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이후 새로운 버전으로 에이다95를 설계하였는데, ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;객체지향​&lt;/li&gt;
  &lt;li&gt;공유 변수(shared variable) 컨트롤 메커니즘​&lt;/li&gt;
  &lt;li&gt;사용성을 개선하기 위한 라이브러리 등이 포함되었다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​에이다는 들인 노력에 비해, 대중성에서 실패한 사례로 간주된다. ​
비슷한 시기에 나온 C++에 그 자리를 내준 듯 하다. ​&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="study" />
      

      
        <summary type="html">제 7장 프로그래밍 언어</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">PL-06</title>
      <link href="https://lee989898.github.io/pl-06" rel="alternate" type="text/html" title="PL-06" />
      <published>2021-10-13T19:18:00+09:00</published>
      <updated>2021-10-13T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-06</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-06">&lt;h1 id=&quot;제-6장--프로그래밍-언어&quot;&gt;&lt;strong&gt;제 6장  프로그래밍 언어&lt;/strong&gt;&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;프로그래밍 언어의 진화&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1940 ~ 1950&lt;/p&gt;

    &lt;p&gt;초기 컴퓨터는 기계 코드로 직접 프로그램을 작성했었고 이로
 인해 다음과 같은 제한이 있었다.
하드웨어의 제한으로, 부동점 소수의 계산, 인덱싱 등이 지원되지 않았으며, ​
계산과 직접 관련이 없는 시스템 소프트웨어의 사용도 제한적이었다. ​
그래서 프로그래머 인건비보다 컴퓨터가 훨씬 비쌌다. ​&lt;/p&gt;

    &lt;p&gt;따라서 프로그램의 읽기 및 쓰기의 용이성, 수정 
용이성, 표현력 등은 크게 문제되지 않았으며, ​
프로그래밍은 주로 계산 흐름을 지시하는데 중점을 두었다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 여건 속에서, ​초기 프로그래머는 기계 코드로 프로그램을 작성하였다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;부동점 소수를 계산하기 위해, 프로그래머는 수동으로 지수를 추적해야 했다. ​&lt;/li&gt;
  &lt;li&gt;프로그램이 적재되는 메모리의 위치에 따라 상대 
주소를 절대 주소로 직접 변환해야 했다. ​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;배열에 대한 인덱스가 없기 때문에, 셀의 주소를 계산하려면,첫째 셀을 기준
으로 셀의 길이만큼씩 더해가면서 주소를 계산하였다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;초기 프로그래머를 위해, 어셈블리 언어와 어셈블러가 개발되었다. ​
 어셈블리어는 이진수로 표현된 기계 언어를 일상적인 구절로
일대일 매핑시킨 것이다.  ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;끝으로 복잡한 프로그램이 필요해지고 컴퓨터의
값이 떨어지면서 프로그래머의 시간 절약이 매우 중요해졌다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;FORTRAN&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;초기 프로그래밍은 주로 과학 계산에 집중되었으며, 이
를 위해 가장 많이 사용된 포트란에 대해 알아보자. ​&lt;/p&gt;

&lt;p&gt;포트란은 최초의 대중적인 고급 프로그래밍 언어이다. ​
당시의 컴퓨터는 가격이 매우 비쌌고, 계산 용량이 작고 신뢰성도 낮았다. ​
따라서 기계의 효율이 가장 중요했다. ​&lt;/p&gt;

&lt;p&gt;컴퓨터는 주로 과학 분야의 숫자 계산에 치중되었다.따라서 배열 처리 및
 counting loop 처리를 위한 수단을 필요로 했다.   ​&lt;/p&gt;

&lt;p&gt;포트란은 Formula Translating System에서 For와 Tran을 따온 것으로, ​
과학 분야의 이같은 계산 요구를 만족시키도록 설계 및 구현되었다.&lt;/p&gt;

&lt;p&gt;포트란에서는 변수명이 6글자까지로 제한되고, 사
용자 정의에 의한 서브프로그램은 허용된다. ​
데이터 타입은 구현시스템에서 제공되는 정적 타입만 허용된다.  ​
추후에 다른 언어의 영향으로 다양한 특성을 갖게 된다.&lt;/p&gt;

&lt;p&gt;포트란은 명령식 언어로, 포트란 프로그램은 본 뉴만 아키텍처를 따른다.  ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;변수는 메모리 셀을 가리키고, ​&lt;/li&gt;
  &lt;li&gt;Assignment 문장은 메모리와 CPU간의 데이터 이동을 수행하며, ​&lt;/li&gt;
  &lt;li&gt;연산과 표현식은 CPU에 의한 계산을 실행한다. ​&lt;/li&gt;
  &lt;li&gt;실행 흐름을 명시적으로 통제하며, ​&lt;/li&gt;
  &lt;li&gt;언어와 하드웨어 간 효율적 매핑을 통해, 실행 성능의 효율
 화를 달성할 수 있지만, 본 뉴만 바틀넥에 의해 제한되기도 한다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;포트란 프로그래밍 스타일은 큰 문제를 작은 문제로 쪼개고, ​
작은 문제를 푸는 프로그램을 짜서 이들을 합치는 방식, ​
즉 하향식(탑다운 방식)으로 프로그래밍을 한다. ​&lt;/p&gt;

&lt;p&gt;프로그램은 위에서 시작해서 차근차근 아래로 컨스트럭트를 따라서 실행되며, ​
 go-to를 만나면 점프하기도 한다. ​&lt;/p&gt;

&lt;p&gt;구조적 프로그래밍 방식에서는 프로
그램 디버깅을 어렵게 하는 go-to의 사용을 지극히 제한한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;LISP&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;함수 프로그래밍 언어 LISP는 링크드 리스트로 표현된 
심볼릭(기호) 데이터의 처리를 위한 특성을 제공하기 위
해 발명되었으며, 인공지능 응용(자연어 처리) 프로그램에서 유래되었다. ​&lt;/p&gt;

&lt;p&gt;심볼릭 데이터의 처리는 배열로 처리 불가하며, 배열의 셀을 지칭하기
 위한 인덱스가 없으니 loop을 필요로 하지 않는다. 대신에 심볼
 릭 데이터를 구성하는 심볼(글자) 하나하나를 처리하는 연산이 필요하다. ​&lt;/p&gt;

&lt;p&gt;이에 적합한 자료구조가 링크드 리스트이고, 이들에 대한 연산은 (+a(*b c))
 같은 형태의 함수로 표현된다. ​&lt;/p&gt;

&lt;p&gt;인풋과 함수는 모두 리스트로 표현되며, 데이터 타입은
아톰과 리스트의 두가지 타입이 있다.&lt;/p&gt;

&lt;p&gt;Lisp는 배열과 이에 대한 인덱스가 없어서, 인덱
스를 증감시키며 배열을 처리하는 loop이 필요하지 않다. ​
물론 반복 처리는 필요하다. Lisp는 이를 위해, 순환 함수를 제공한다. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/pl/pl08.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Lisp에서는 X! 팩토리알 계산 프로그램은 위 그림과 같이 순환 함수로 표현한다. ​
defun은 define function(함수 정의)를 의미한다. ​
파란색 점선 상자는 x * fact(x – 1)을 리스트 형태로 나타낸 것입니다. ​&lt;/p&gt;

&lt;p&gt;함수 fact(x)를 정의할 때 x * fact(
x – 1)에서 볼수 있듯이 fact()를 사용하고 있다. 
이와 같이 무엇인가를 정의할 때 그 무엇을 사용하
면, 이것을 recursion 또는 recursive function이라고 한다.  ​&lt;/p&gt;

&lt;p&gt;​
링크드 리스트 처리를 목적으로 최초에 발명된 L
isp는 지금도 사용되고 있는 언어이다. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/pl/pl09.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;리스트는 Lisp 구현 시스템의 내부에서 위와 같이 표현된다.
(A B C D)는 선형적으로 연결된 링크드 리스트로 표현되는 반면, ​
(A (B C) D (E F G))는 트리 구조의 링크드 리스트로 표현된다. ​&lt;/p&gt;

&lt;p&gt;그 이유는  A, (B C), D와 (E F G)가 같은 수준에 있어야 하고, ​
B와 C가 같은 수준에, 그리고 E, F와 G가 같은 수준에 있어야 하기 때문이다. ​&lt;/p&gt;

&lt;p&gt;두 리스트가 같은지 검사하는 프로그램을 Lisp로 작성하면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;​(DEFUN equal_lists (lis1 lis2)​
 
    (COND​
 
        ((ATOM lis1) (EQ lis1 lis2))​
 
        ((ATOM lis2) NIL)​
 
        ((equal_lists (CAR lis1) (CAR lis2))​
 
                         (equal_lists (CDR lis1) (CDR lis2)))​
 
        (T NIL)​
 
      )​
 
   )​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드는 아톰(즉, 리스트의 말단) 수준에서 각 심볼에 
대해 EQ(같은지 아닌지) 검사한다. ​&lt;/p&gt;

&lt;p&gt;현재 EQ 검사해야 할 리스트가 아톰이 아니면, 그 다음 
수준으로 아톰을 만날때까지 내려가서 EQ 검사를 한다. ​&lt;/p&gt;

&lt;p&gt;이렇게 하려면 equal_lists하는 함수를 함수 내에서
 반복적으로 호출해야 한다. 즉, recursion이다. ​&lt;/p&gt;

&lt;p&gt;여기서 CDR, CAR은 Lisp의 기본 연산자로서, ​
CAR은 리스트의 맨 앞의 심볼을 반환하고, CDR은 CAR을 제외
한 나머지(아톰이거나 리스트)를 반환한다.&lt;/p&gt;

&lt;p&gt;최초의 함수 언어 Lisp는 다음과 같은 특징을 가지고 있다.
파라미터에 함수를 적용하는 방식으로 계산을 수행하며, ​
계산에 필요한 중간 변수나 assignment 개념이 없어서,
메모리에 이들을 미리 할당하지 않는다.
Recursion(순환 함수)와 조건식을 통해 흐름을 컨트롤하며, ​
링크드 리스트를 동적으로 필요시마다 메모리에 할당을 한다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;​&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="study" />
      

      
        <summary type="html">제 6장 프로그래밍 언어</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">PL-05</title>
      <link href="https://lee989898.github.io/pl-05" rel="alternate" type="text/html" title="PL-05" />
      <published>2021-10-13T19:18:00+09:00</published>
      <updated>2021-10-13T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-05</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-05">&lt;h1 id=&quot;제-5장--프로그래밍-언어&quot;&gt;&lt;strong&gt;제 5장  프로그래밍 언어&lt;/strong&gt;&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;프로그래밍 언어의 구현 시스템&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;프로그래밍 언어의 각 특징과 컨스트럭트들이 ​
어떻게 구현되는지 이해하는 것은 매우 중요하다. ​
PL 컨스트럭트의 구현은 고급 언어를 어셈블리 언어와 같은 
하위 언어로 번역한다.&lt;br /&gt;
  ​
프로그램의 문장을 번역하는 것을 컴파일이라고 하고, ​
문장을 의미에 적합하게 매핑하는 것을 인터프리테이션이라고 한다. ​&lt;/p&gt;

&lt;p&gt;이와 같은 구현 시스템에 대해 왜 알아야 할까? ​
 컨스트럭트가 효율적으로 구현되고 있는지, ​
 더 좋은 구현 방법이 있는지, ​
  이들간의 절충점이 있는지 등을 알아내기 위함이다.&lt;/p&gt;

&lt;p&gt;컴파일 방법은 컴파일러를 써서 고급 언어로 짠 
 프로그램을 기계 언어로 번역한다.
 컴파일 프로세스는 어휘 분석, 구문 분석, 의
 미 분석, 코드 생성, 링크 및 적재 단계로 구성되어 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/pl/pl04.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 컴파일러의 구성요소와 이들 요소간의 처
리 순서에 의한 컴파일 과정을 ​
플로우 차트로 보여주고 있다. ​&lt;/p&gt;

&lt;p&gt;어휘 분석기(lexical analyzer)는 소스 프로그램의 글
자들을 어휘 단위로 모아 놓는다. ​
프로그램의 어휘 단위는 변수, 키워드, 연산자 등을 의미한다.&lt;/p&gt;

&lt;p&gt;구문 분석기(syntax analyzer)는 어휘 단위를 받아서 파스 트리를 생성한다. ​
파스 트리는 프로그램의 구문 구조를 나타낸다. ​&lt;/p&gt;

&lt;p&gt;중간 코드 생성기는 소스 프로그램과 기계 코드
 사이의 중간 수준의 언어로 작성된 프로그램을 생성한다. ​
중간 언어로 어셈블리 어가 쓰이기도 하고, 이보다 
조금 더 고급 수준의 언어가 사용되기도 한다. ​&lt;/p&gt;

&lt;p&gt;의미 분석기(semantic analyzer)는 중간 코드 생성기(i
ntermediate code generator)의 일부분으로 통합되어 있으며, ​
구문 분석시에 탐지되지 않는 타입 오류 등을 검사한다. ​&lt;/p&gt;

&lt;p&gt;최적화 단계는 중간 코드의 프로그램을 좀더 작고 빠르게 만든다. ​
기계 언어보다 중간 코드를 최적화하는 이유는 기계 코드가 
바이너리 형태이기 때문에​ 중간코드(알파벳으로 표현된)에 비해 최
적화가 더 어렵기 때문이다. ​&lt;/p&gt;

&lt;p&gt;코드 생성기는 중간 코드를
받아서 컴퓨터가 직접 실행할 수 있는 기계 언어로 변환한다. ​&lt;/p&gt;

&lt;p&gt;심볼 테이블은 소스 프로그램내의 변수의 타입과 속성(길이 
등)을 저장하고 있다. 이들 정보는 어휘 분석기와 구문
 분석기에 의해 심볼 테이블에 저장되고, 의미 분석기와 중간 코
 드 생성기 및 코드 생성기에 의해 사용된다. ​&lt;/p&gt;

&lt;p&gt;이렇게 컴파일된 사용자 코드는 실행 시 시스템 코드를 호출하여 ​
시스템 소프트웨어의 도움을 받는다. ​&lt;/p&gt;

&lt;p&gt;이를 위해 실행 직전에 사용자 코드와 시스템 코드를 링크(연결)한다. ​
이 과정을 linking 또는 linking and loading이라고 하고, ​
이러한 역할을 하는 시스템 소프트웨어를 linker라고 한다. ​
링킹에 의해 생성된 것을 executable image(실행 이미지)
 또는 load module(적재 모듈)이라고 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/pl/pl05.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;인터프리터는 프로그램을 기계 언어로 번역하지 않고, ​
문장의 의미에 적합하게 시뮬레이션하여 결과를 낸다. ​&lt;/p&gt;

&lt;p&gt;따라서 인터프러터는 고급 언어 처리를 위한 시뮬레이터 또는 ​
고급언어를 기계어처럼 처리하는 가상 머신의 역할을 한다. ​&lt;/p&gt;

&lt;p&gt;인터프리터의 장점은, 프로그램의 실행 오류 발생시, ​
소스 프로그램의 몇번 라인에서 오류가 발생했는지 오
류 메시지가 알려주기 때문에 ​
프로그램 개발에 매우 편리한다. ​&lt;/p&gt;

&lt;p&gt;단점은 컴파일 코드에 비해 10-100배 느리다는 것이며, ​
프로그램의 인터프리테이션 동안에 심볼 테이블이 메모리에
 적재되어 있어야 하기 때문에 ​
메모리 공간을 많이 차지한다는 것이다. ​&lt;/p&gt;

&lt;p&gt;인터프리터를 이용하는 대표적인 언어
로 자바스크립트, PHP, 파이썬 등이 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/pl/pl06.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;하이브리드 방식은 먼저 컴파일을 해서 중간 코드를 생성한 다음에, ​
중간 코드를 인터프리터에 의해 실행한다. ​&lt;/p&gt;

&lt;p&gt;자바에서는 자바 가상 머신에서 실행되는 바이트 코드를 중간 코드로 생성한다.  ​
바이트 코드는 이진 코드지만 CPU가 아닌 자바 가상 머신이 이해할 수 
있는 언어이다.​&lt;/p&gt;

&lt;p&gt;자바 가상 머신은 바이트 코드 명령어를 하나씩 읽어 들여 실행한다. ​&lt;/p&gt;

&lt;p&gt;이와 같이 중간 코드를 생성하여 자바 가상 머신으로 실행하면, ​
하드웨어의 특이 사항에 제한을 받지 않아서 portability가 높
은 장점이 있다. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/pl/pl07.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어05&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;클래스 및 변수를 선언하고 초기화하는 자바 소스 프로그램을 바
이트 코드로 번역한 예는 위와 같다. ​
빨간색 박스를 눈여겨 보시기 보자. ​
메모리에 위치를 잡고, 초기화 함수를 호출하거나 조작하고 반환한다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;​&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="study" />
      

      
        <summary type="html">제 5장 프로그래밍 언어</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">PL-04</title>
      <link href="https://lee989898.github.io/pl-04" rel="alternate" type="text/html" title="PL-04" />
      <published>2021-10-13T19:18:00+09:00</published>
      <updated>2021-10-13T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-04</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-04">&lt;h1 id=&quot;제-4장--프로그래밍-언어&quot;&gt;&lt;strong&gt;제 4장  프로그래밍 언어&lt;/strong&gt;&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;언어 평가 기준과 언어 설계시 기준 간의 균형&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;좋은 프로그래밍 언어가 갖춰야 할 기준은 무엇인가 살펴 보자. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Readability(읽기 쉬움): 프로그램을 읽고 이해하기 쉬운 정
도를 프로그래밍 언어의 readability라고 한다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Writability(쓰기쉬움): 프로그램을 작성하기 쉬운 정
도를 프로그래밍 언어의 writability라고 한다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Reliability(신뢰성): 프로그램이 다양한 조건 아래
서 ‘원래 하기로 되어 있던’ 일을 수행하는 것을 
reliability라고 한다. 즉, 인풋이 같으면 아웃풋이 같아
야 한다. 만일 인풋이 같은데 조건에 따라 다른 아웃풋을 낸
다면 이 프로그램은 신뢰성이 없는 것이다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;비용: 프로그램은 학습 비용, 개발 비용(인건비 등 포함)
, 실행 비용 등 여러 가지 비용을 수반한다. 이 모든 비용
이 적으면 좋은 프로그래밍 언어인 것이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;프로그래밍 언어의 Readability를 올리려면 다음과 
같은 특성을 갖는 것이 바람직하다.
 ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;첫째, 단순성이다. 만일 프로그래밍 언어가, 언어의 고유 기능과 기본 컨스트럭트(construc
ts; control structure를 의미함)를 비교적 적게 갖고 있으며, ​
고유 기능에 대한 다중성이 적을 수록,   ​
연산의 오버로딩을 최소한으로 허용할 수록 읽기 쉽다.   ​
여기서 다중성이란 동일한 연산을 수행하는 방법이 
여러 가지가 있다는 것을 의미하며,
충돌이 발생할 가능성에 대비하여 프로그래머에 의한 조치가 필요하다. 
이러한 다중성은 객체 지향 언어에서 두드러지는데, ​
C++에서는 허용되지만 Java에서는 허용되지 않는다.   ​
오버로딩은 동일한 이름의 연산을 여러 개 정의하는 것을 의미하고, ​
컴파일할 때 어느 연산을 실행할지 컴파일러가 결정한다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;둘째, 독립성입니다. ​
독립성이란 컨스트럭트 결합 규칙이 문맥에 대해 
종속되지 않고 독립적인 것을 의미합니다. ​
컨스트럭트 간의 결합 규칙에 예외나 불규칙성이 비교적 적고, ​
모든 결합(combination)이 구문적으로 적
합하고 문맥에 독립적이어야 읽기 쉽습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;구조적 프로그래밍에 필요한 loop, if-then-else, begin
-end와 같은 컨트롤 구조를 충분히 제공하면, ​
프로그램을 위에서 아래로 읽어 내려가면서 이해할 수 있
어서 readability에 기여한다. ​&lt;/p&gt;

&lt;p&gt;데이터 타입과 데이터 구조의 정의 기능 또한 프로그램
의 readability에 기여한다. ​
데이터 타입의 정의를 통해 데이터가 가질 수 있는 값의 범위와 ​
이들 데이터에 허용되는 연산을 이해할 수 있다. ​
데이터 구조의 정의 기능은 다양한 여러 복잡한 데이터 유형을 모아서, ​
새로운 단순한 유형의 데이터를 정의할 수 있는 능력을 프로
그래머에게 제공한다. ​
프로그래머는 이와 같이 복잡한 것을 단순화시킬 수 있어서, ​
프로그램을 쉽게 작성할 수 있는 동시에, 다른 프로그
래머를 쉽게 이해시킬 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Writablility: 프로그래밍 언어의 쓰기쉬움의 주요 평가 기준은 ​
단순성과 독립성, 추상화 지원, 표현력을 들 수 있다. ​
단순성이란 컨스트럭트의 수가 적다는 것을 의미하고, ​
독립성이란 컨스트럭트 결합 규칙이 문맥에 대해 독립적이라는 것을 의미한다. ​
그러나 컨스트럭트 결합 규칙이 문맥에 지나치게 독립적이면, ​
실행시 발생하는 오류를 탐지할 수 없게 될 수도 있다. ​
따라서 독립성은 프로그래밍 언어를 설계할 때 신중하게 고려해야 한다.
 &lt;br /&gt;​
복잡한 구조 또는 연산의 추상화도 프로그래밍 언어의 쓰기쉬움을 평가하는 기준이다. ​
추상화에는 처리 절차의 추상화(서브 프로그램)와 데이터 추상화가 있다.
For loop과 같이 편리한 표현 방식과 같은 표현력 또한 쓰기쉬움 평가의 기준입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Reliablitiy:
신뢰성은 타입 검사에 의한 오류 처리, ​
프로그램 실행시에 발생하는 예외 처리, ​
Aliasing(같은 메모리 주소를 다른 이름으로 레퍼런스하는 것), ​
읽기쉬움과 쓰기쉬움 등은 모두 프로그래밍 언어의 신뢰성 평가의 기준이 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cost: 
학습, 개발, 컴파일 및 실행, 컴파일러 및 인터프리터와 
같은 언어 구현 시스템, 신뢰성, 유지 보수 등 ​
프로그래밍 언어 사용에 관련된 모든 비용은 언어 평가 기준에 속한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이밖에 구현 시스템간의 이식성, 다양한 응용에 대한 적용성, 언어
의 표준화에 의한 완결성 및 정확성, 전력 소비 효율 등도 ​
프로그래밍 언어의 평가 기준이다&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;언어 설계시 이들 모든 평가 기준을 최적화하기는 매우 어렵다. ​
문제 해결에 필요한 기준을 먼저 설정하고 이들 간의 
균형점을 찾는 것이 중요하다. ​&lt;/p&gt;

&lt;p&gt;레퍼런스 변수는 메모리 상에 있는 인스턴스를 가리키는 데 사용되는 변수이다. ​
자바에서는 모든 레퍼런스 변수에 대해, ​
이들이 가리키는 메모리에 대한 인덱싱이 적절한지 검사합니다. ​
이것은 신뢰성을 높여 주지만 매우 높은 실행 비용을 유발한다. ​&lt;/p&gt;

&lt;p&gt;강력한 연산자가 많으면 프로그램 짜기는 쉽지만, ​
읽고 이해하기 어려울 수도 있다. ​&lt;/p&gt;

&lt;p&gt;C++의 포인터는 매우 강력하고 유연하여 쓰기 쉬움을 높여주지만, ​
주의를 기울이지 않으면 신뢰성에 문제를 일으킨다.&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="study" />
      

      
        <summary type="html">제 4장 프로그래밍 언어</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">PL-03</title>
      <link href="https://lee989898.github.io/pl-03" rel="alternate" type="text/html" title="PL-03" />
      <published>2021-10-13T19:18:00+09:00</published>
      <updated>2021-10-13T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-03</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-03">&lt;h1 id=&quot;제-3장--프로그래밍-언어&quot;&gt;&lt;strong&gt;제 3장  프로그래밍 언어&lt;/strong&gt;&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;프로그래밍 언어가 프로그램 설계 방법에 준 영향&lt;/strong&gt;
&lt;br /&gt;&lt;br /&gt;
역사적으로 프로그래밍 언어는 응용의 표현에 적합한 개념이 추가되면서 발전되어 왔으며,  ​
그 개념의 활용에 필요한 프로그램 설계 방법이 개발되었다. ​
이에 대해 간략히 간단히 살펴 보자.&lt;br /&gt;
&lt;br /&gt;
    &lt;ul&gt;
      &lt;li&gt;50년대와 60년대 초반에는 숫자 계산을 주로 수행하는 수치 해석 등 비교적 단순한 응용이 컴퓨팅의 주류를 이루었고, 이들 프로그램은 수식 표현이 용이한 Fortran으로 작성되었다.  이러한 이유로 프로그램 설계 방법은 
기계(컴퓨팅 자원)의 효율적 사용 방법을 찾는데 집중되었다.&lt;br /&gt;
 &lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;60년대 후반에는 프로그램의 데이터 처리 절차가 복잡해지고 타인이 작성
한 프로그램을 이해하고 수정하기가 어려워지면서, 기계의 효율적 
사용보다 프로그래머의 효율(생산성)에 관심이 집중되었다. 따라서
 프로그램의 가독성(readability), 다양한 컨트롤 스트럭처에 의한
표현의 편리성이 언어의 중요한 요소로 인식되고, 이를 지원하는 A
LGOL 언어가 등장했다. 이러한 언어를 통해 구조적 프로그래밍, 
하향식 설계, 단계적 정련 기법 등 프로그래밍 기법 또는 설계 방법
이 개발되었다.  여기서 컨트롤 스트럭처란 if-then, loop, {중
괄호} 등과 같이 인풋의 처리 로직을 표현하는 데 사용되는 구조를 
말한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;1970년대 후반에는 데이터의 구조가 복잡해지면서,
 처리 절차 중심의 프로그램 설계에서 데이터 중심의 프
 로그램 설계로 옮겨갔다. 이를 위해 데이터 추상화 기법이 창안되었다
 . 데이터 추상화 기법은 데이터를 구조화하고, 이 데이터에 대한 연산
 을 정의한다. 이와 같은 데이터 추상화 기법은 추상 데이터 타입을 지
 원하는 프로그래밍 언어를 탄생시켰다. 이것이 바로 ALGOL을 발전시
 킨 Pascal의 등장이다. Pascal은 Java가 등장하기 전까지 모든 컴
 퓨터 관련 학과에서 필수 언어로 가르쳤다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;1980년 중반에 데이터 추상화, 상속(속성, 메소드), 
동적 바인딩을 특징으로 하는 객체 지향 언어가 등장하여
 지금까지 이어오고 있다. C++, Java 등이 대표적인 언
 어로, 이들 특징은 이후의 다른 언어에서도 지원할 수 있
 을 정도로 일반적이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/pl/pl03.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어03&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;이 그림은 널리 사용되어 온 프로그래밍 언어의 족보를 보여주고 있다. ​
 많은 언어가 생멸하는 와중에 지속적인 발전이 있었음을 알 수 있다. ​
 눈여겨 볼만한 중요한 언어로는 FORTRAN, COBO
 L, COMMON LISP, Pascal, C, C++, Java 등이다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="study" />
      

      
        <summary type="html">제 3장 프로그래밍 언어</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">PL-01</title>
      <link href="https://lee989898.github.io/pl-01" rel="alternate" type="text/html" title="PL-01" />
      <published>2021-10-13T19:18:00+09:00</published>
      <updated>2021-10-13T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-01</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-01">&lt;h1 id=&quot;제-1장--프로그래밍-언어&quot;&gt;&lt;strong&gt;제 1장  프로그래밍 언어&lt;/strong&gt;&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프로그래밍 언어란?&lt;/strong&gt;
&lt;br /&gt;&lt;br /&gt;
프로그래밍 언어는 인공적으로 설계된 언어로 컴퓨터가 실행할 수 있는 계산이나
알고리즘을 표현하는 수단이다.
&lt;br /&gt;&lt;br /&gt;
인간의 언어는 타인에게 자신의 생각을 표현하듯이 프로그래밍 언어는
자신의 생각을 컴퓨터에게 표현하는 수단이다.
&lt;br /&gt;&lt;br /&gt;
현재 프로그래밍 언어는 매우 다양할까?&lt;br /&gt;
문제의 특성에 따라, 프로그램이 각기 요구하는 프로그래밍 언어의 표현력이
다르기 때문이다. 표현력은 언어 선택에 있어 매우 중요하다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;  &lt;br /&gt;
문제해결에 적합한 언어를 선택하려면 아래 내용을 숙지해야 한다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;언어가 다르면, 알고리즘의 표현이 어떻게 다른가? ​&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;어떤 언어가 더 적합한가? 언어의 적합성(goodness)을 어떻게 평가할 것인가? ​&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;왜 이렇게 다른 언어가 많은가? ​&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;도대체 프로그래밍 언어가 뭔가? ​&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;프로그래밍 언어의 특성이 왜 이렇게 많은가? ​&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;이들 특성은 어떻게 구현시스템에서 실현되는가?​&lt;/p&gt;
        &lt;ul&gt;
          &lt;li&gt;여기서 구현 시스템이란 컴파일러나 인터프리터 등 PL을 실행할 수 있는 소프트웨어를 말한다. ​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;프로그래밍 언어의 역사, 신택스 및 시맨틱스, 바인딩, 데이터 타입,
컨트롤 구조, 서브 프로그램, 추상데이터 타입, 캡슐화, 예외 처리,
함수 프로그래밍을 공부할 것이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/pl/pl01.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어01&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;PL의 트렌드에 따른 언어를 살펴보면 다음과 같은 특성을 갖고 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;타입의 안정성을 고려한 언어의 사용 증가: C,C++에 비해 Java, C# 타입이 안정적임&lt;/li&gt;
  &lt;li&gt;웹 응용을 위해 클라이언트 측의 기능성을 갖춘 스크립트 언어&lt;/li&gt;
  &lt;li&gt;신택스 보다 알고리즘의 표현력에 중점을 둔 언어&lt;/li&gt;
  &lt;li&gt;컴파일, 분석, 타입 검사 등 실행 환경과 가상화를 갖춘 언어&lt;/li&gt;
  &lt;li&gt;자동 오류 탐지 및 복구 등 프로그램 분석 능력을 갖춘 언어&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PL에 영향을 미치는 요인을 표현력과 구현 시스템의 효율 측면에서 살펴보면 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;표현력: 응용 도메인의 특성과 프로그래밍 방법을 들 수 있다. &lt;br /&gt;
    다중 프로그래밍은 큰 작업(프로그램)이 여러 개의 작은 작업(서브프로그램)으로
    나뉘어져서 서로 연관성을 가지고 동시에 실행되는 것을 말한다.&lt;br /&gt;
    물론 동시라는 말은 특정 시간에는 작은 작업 하나가 실행되지만, 
    타임 피리어드 동안 여러 개의 작은 프로그램이 
    동시에 처리되는 것으로 보이게 된다.&lt;br /&gt;
    이것은 CPU의 시분할과 메모리의 공간 분할에 의해 이루어진다.
    이렇게 하여 큰 프로그램 하나가 다른 프로그램의 방해없이
    여러 개의 작은 서브프로그램으로 나누어져 처리될 수 있는 것이다.  ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;언어 구현 시스템의 효율성: 즉 컴파일러나 인터프리터의 성능을 말한다.&lt;br /&gt;
    컴파일러나 인터프리터의 성능은 주로 컴퓨터 구조, OS, 관련 도구, 라이브러리 등에 달려 있다.    ​
    편의성은 비용을 수반한다. 추상적 관점을 지원하면 편의성은 좋아지지만, 이것을 머신에 
    표현하는데는 나름의 비용이 들어간다.   이러한 사실을 고려하여 편의성과 비용간에 균형을 잡는 것이 
    중요하다.   ​&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="study" />
      

      
        <summary type="html">제 1장 프로그래밍 언어</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">PL-02</title>
      <link href="https://lee989898.github.io/pl-02" rel="alternate" type="text/html" title="PL-02" />
      <published>2021-10-13T19:18:00+09:00</published>
      <updated>2021-10-13T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-02</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-02">&lt;h1 id=&quot;제-2장--프로그래밍-언어&quot;&gt;&lt;strong&gt;제 2장  프로그래밍 언어&lt;/strong&gt;&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;왜 PL을 공부하는가?&lt;/strong&gt;
&lt;br /&gt;&lt;br /&gt;
프로그래밍 언어는 알고리즘 또는 계산을 표현하는데 적합하도록 설계된 인공
언어이다.&lt;br /&gt;
프로그램은 알고리즘을 프로그래밍 언어로 코딩한 것으로, 데이터 입력,
입력 데이터 처리, 데이터 출력으로 구성된다.
&lt;br /&gt;&lt;br /&gt;
언어의 특징을 이해하면, 효과적인 알고리즘의 개발 능력과 언어 활용 능력을
개선 할 수 있다.&lt;br /&gt;
대표적인 특성을 예를 들면, 객체지향성, recursion, call by value,
call by reference 등이 있다.&lt;/p&gt;

    &lt;p&gt;응용의 특성에 더욱 적합한 PL을 선택할 수 있게 되고 새로운 언어 학습 능력을
올려주고 새로운 언어를 더욱 쉽게 설계 할 수 있다. 또한 구현 시스템의 중요성을 
이해할 수 있다.
구현 이슈 예로는 아래 두가지가 있다. 구현 이슈에 관한 지식을 활용하면
효율성이 더 좋은 것을 선택할 수 있다. 
&lt;br /&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;Recursion과 Loop 중에서 어느 것이 더욱 효율적인가?
&lt;br /&gt;​&lt;/li&gt;
      &lt;li&gt;작은 서브프로그램을 자주 호출하는 것은 좋은 방법인가? ​
        &lt;ul&gt;
          &lt;li&gt;Recursion이나 서브 프로그램 호출 비용에 비해 실행 시간이 너무 짧다면,
성늘을 떨어뜨리기 때문에, Loop을 사용하거나 서브 프로그램을 일정 규모 이상
으로 설계하는 것이 좋다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;응용의 특성에 대한 적절한 PL의 선택의 예&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Fortran
    &lt;ul&gt;
      &lt;li&gt;포트란은 부동점 소수를 4바이트로 표현하고, double precision은 8
바이트로 표한하기 때문에 부동점 소수 계산에 강점이 있다. 또한 데이터 구조로
배열을 지원하며, 2차원 배열로 매트릭스를 표현한다. 이러한 이유들로
숫자 계산을 주로 수행하는 과학 응요에서 사용된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;COBOL
    &lt;ul&gt;
      &lt;li&gt;입출력 데이터는 여러 데이터 필드로 구성된 레코드 구조이며,
 각 필드는 숫자와 문자값을 갖는다. 십진수, 문자를 주로 처리하여 
 비즈니스 응용에 주로 사용된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Lisp
    &lt;ul&gt;
      &lt;li&gt;심볼릭 컴퓨팅을 주로 수행하는 인공 지능 응용에서 주로 사용된다.
 데이터를 링크드 리스트로 표현하며 문자열의 조작에 특화되어 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;PL의 범주에는 세가지가 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;명령/절차적 언어(imperative, procedural)&lt;/li&gt;
  &lt;li&gt;함수적 언어&lt;/li&gt;
  &lt;li&gt;논리적 언어
 etc) 객체지향 언어는 명령/절차적 언어에서 파생된 것으로서, 별도의 범주로 다루지
 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;컴퓨터는 명령어를 받아서 연산을 수행한다. 따라서 프로그래밍은 컴퓨터에게
 절차적 명령어를 보내는 것과 같다.
 아래 코드를 보자.&lt;/p&gt;

&lt;hr /&gt;

&lt;noscript&gt;&lt;pre&gt;int fact(int n) {
  int sofar = 1;
  while (n&amp;gt;0) sofar *= n--;
  return sofar;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/lee989898/7c9d341efe4369acac607d2e56a9f3ce.js&quot;&gt; &lt;/script&gt;

&lt;hr /&gt;
&lt;p&gt;fact(n)은 n!을 계산하는 함수이며, 
 함수안에 정의된 sofar는 현재까지 계산된 n!값을 간직하는 변수이다. ​
 While loop을 끝까지 돌려보면 n에서 시작하여 n=1일 때까지 계속 곱셈(*)을 실행한다. ​
 즉, sofar는 1에서 n까지 곱한 결과이다.  ​
 오늘날 모든 컴퓨터는 본 뉴만 아키텍처로 구성되어 있기 때문에, PL은 이 아키텍처를 모방하고 있다. ​
아래 그림이 본 뉴만 아키텍처이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/pl/pl02.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어02&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;본 뉴만 아키텍처 컴퓨터에서는 다음과 같이 프로그램을 실행한다.
메모리는 프로그램과 메모리를 저장하고, CPU는 연산을 수행한다.   ​
프로그램을 실행하려면, 먼저 프로그램과 데이터를 메모리에 저장해야한다.   ​
PC(program counter)를 프로그램의 첫번째 명령어 위치로 초기화하고, ​
PC가 가리키는 명령어를 Control unit(Decoder 포함)에 적재한다. ​
Control unit(Decoder)는 명령어의 의미(무슨 연산을 해야할지)를 해석하고,​
데이터를 레지스터에 적재하여 ALU에서 연산을 수행한다. ​
연산이 끝나면 그 결과를 메모리에 저장하거나 출력 장치로 내보낸다. ​
연산 뿐만 아니라 control structure(loop, if-then, etc)도 PC와 control unit에 의해 통제된다.&lt;/p&gt;

&lt;p&gt;메모리에서 인스트럭션을 CPU로 가져와서 실행하는 반복적인 절차를 Fetch-execute-cycle이라고 한다. ​
Fetch-execution 사이클이 실행하는 인스트럭션은 어셈블리 코드 또는 머신 코드이다. ​
머신 코드는 컴퓨터가 이해할 수 있는 명령어이고, 어셈블리 코드는 머신코드를 기호로 표현한 것이다.​&lt;/p&gt;

&lt;p&gt;Fetch-execution cycle은 다음과 같다. ​&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;PC를 초기화한다. ​&lt;/li&gt;
  &lt;li&gt;PC가 가리키는 명령어를 fetch하고 ​&lt;/li&gt;
  &lt;li&gt;PC를 증가시킨 다음, ​&lt;/li&gt;
  &lt;li&gt;Fetch한 명령어를 decod하여 ​&lt;/li&gt;
  &lt;li&gt;실행한다. ​&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;더 이상 실행할 명령어가 없을 때까지 1~4를 반복적으로 실행한다. ​&lt;/p&gt;

&lt;p&gt;팩토리얼 함수를 예로 들어보자.
여기서는 메모리와 CPU간의 데이터 이동에 대해 살펴보도록 하자.
컴퓨터가 고급언어를 머신코드로 번역하지 않고 이해할 수는 없지만, ​
설명을 위해 고급 언어를 컴퓨터가 직접 이해한다고 가정한다.
변수 sofar과 n은 메모리에서 공간을 잡고 값을 저장하고 있으며, ​
프로그램 코드는 메모리에 저장되어 있다.
PC가 int sofar를 읽어 오면 Control unit은 =을 assignment로 해석하여 sofar에 1을 할당한다. 
PC가 while loop의 sofar *=n–를 읽어 오면 ALU에서 반복적으로 n!을 계산하고,
PC가 return sofar를 읽어 오면 sofar 값을 메모리에 저장한다. ​&lt;/p&gt;

&lt;p&gt;이와 같이 명령/절차적 언어는 본 뉴만 아키텍처에 적합하게 다음과 같이 실행된다.    ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로그램의 변수는 메모리 셀을 지칭하고, 그 셀에 저장된 값을 대표한다. ​&lt;/li&gt;
  &lt;li&gt;Assignment 문장은 메모리와 CPU 간의 데이터를 이동시킨다. ​&lt;/li&gt;
  &lt;li&gt;연산과 표현식(expression)은 CPU에서 실행된다. ​&lt;/li&gt;
  &lt;li&gt;실행 흐름의 명시적 통제는 프로그램 카운터에 의한다. ​
현재 널리 사용되고 있는 C, C++, Java는 이런 유형의 PL이다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;명령/절차적 언어는 실행 성능의 최적화를 위한 언어와 하드웨어 간의 효율적 매핑을 허용하지만, ​&lt;br /&gt;
본 뉴만 아키텍처에 의해 제한된다.&lt;/p&gt;

&lt;p&gt;고급어 프로그램은 컴파일러에 의해 어셈블리어 프로그램으로 번역되고 ​
어셈블리어 프로그램은 어셈블러에 의해 기계어 프로그램으로 번역된다. ​
기계어 프로그램은 인터프리터에 의해 ALU 연산으로 해석되어 실행된다.     ​&lt;/p&gt;

&lt;p&gt;어셈블리어 프로그램은 RISC 아키텍처의 인스트럭션을 포함하고 있다. ​
RISC 아키텍처는 인스트럭션 집합을 가능한 줄이고 단순화시켜 성능 개선을 이룩한 사례로 남아 있다. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;함수적 프로그래밍은 수학 함수식과 유사하다. ​
각 서브 프로그램은 함수의 구현이다.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;fun fact x =
  if x &amp;lt;= 0
  then 1 
  else x * fact(x-1);&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/lee989898/8c70fd99576b6311bb713fd3e2d2cda8.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;p&gt;코드는 ML 언어로 팩토리얼을 구하는 프로그램을 보여주고 있다. ​
Fact 내에서 fact를 호출하는 Recursion을 사용하고 있다.&lt;/p&gt;

&lt;p&gt;또 다른 함수 언어로 리스프를 들 수 있다.
ML과 달리 변수와 assignment가 없다. ​
이 말은 변수로 인해 고정적으로 소비되는 메모리가 없다는 말이다.
즉, 필요시 동적으로 메모리를 할당하고 계산한다.
ML과 마찬가지로 리커전을 컨트롤 구조로 갖고 있다.
이후 리스프는 변화를 겪으면서 사용되고 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​로직 프로그래밍은 술어 논리(predicate logic)에 기반하고 있다.
 로직 프로그램은 사실(fact), 규칙(rule), 목표(goal)로 구성되어 있으며, 
 로직 프로그램의 실행은 목표에 사실과 규칙을 적용하여&lt;br /&gt;
 목표가 논리적으로 추론될 수 있는지, 다시 말하면 참인지 거짓인지 증명하는 절차이다.  ​
 이를 위해 추론 엔진이 필요한데, ​
 로직 프로그램의 추론은 resolution reputation에 의한 추론 엔진을 사용한다.
 이 프로그램에서 grandparent(vern, kake)가 추론될 수 있는 살펴보자.​&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fact:  mother(joanne,jake).​
  father(vern,joanne).​
 
rule:  grandparent(X,Z) :- parent(X,Y),​
           parent(Y,Z).​
goal:  grandparent(vern,jake). ​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;규칙 grandparent(X,Z) :- parent(X,Y), parent(Y,Z)에 X, Z에 각각 vern, jake를 대입하면,  ​
 grandparent(vern,Z) :- parent(X,Y), parent(Y,jake)가 추론된다.
 사실의 mother, father 모두 parent이므로, parent(joanne, jake), parent(vern, joanne)이다. ​&lt;/p&gt;

&lt;p&gt;로직 프로그래밍 언어는 프로그램에 입력 데이터에서 출력 데이터를 생성하는 절차를 서술하는 것이 아니라, ​
 사실과 규칙을 술어 논리로 선언하고, 원하는 것(목표)가 무엇인지 선언한다. ​
 따라서 로직 프로그래밍 언어는 비절차적(선언적)이다.&lt;/p&gt;

&lt;p&gt;로직 프로그래밍은 resolution을 해야 하기 때문에, 매우 비효율적(느리다)이다. ​
 따라서 응용 분야가 대단히 좁다.(DB, AI)  ​ 
 팩토리알 계산하는 프로그램을 봅자.&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;fact(X,1) :-  X =:= 1.
fact(X,Fact) :-
  X &amp;gt; 1, NewX is X - 1,
  fact(NewX,NF),
  Fact is X * NF.&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/lee989898/fca92516fff281d9b22e9c38494280bf.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;보기엔 깔끔해 보일 수 있지만, 레졸루션해서 풀려면 오래걸린다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="study" />
      

      
        <summary type="html">제 2장 프로그래밍 언어</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">반복문과 증감연산자</title>
      <link href="https://lee989898.github.io/kotlin-06" rel="alternate" type="text/html" title="반복문과 증감연산자" />
      <published>2021-09-25T01:07:00+09:00</published>
      <updated>2021-09-25T01:07:00+09:00</updated>
      <id>https://lee989898.github.io/kotlin-06</id>
      <content type="html" xml:base="https://lee989898.github.io/kotlin-06">&lt;h1 id=&quot;반복문과-증감연산자&quot;&gt;반복문과 증감연산자&lt;/h1&gt;

&lt;hr /&gt;

&lt;noscript&gt;&lt;pre&gt;fun main() {
    var intValue:Int = 1234
    var LongValue:Long = 1234L
    var intValueByHex:Int = 0x1af
    var intValueByBin:Int = 0b10110110
    
    var doubleValue:Double = 123.5
    var doubleValueWithExp: Double = 123.5e10
    var floatValue:Float = 123.5f
    
    var charValue: Char = &amp;#39;a&amp;#39;
    var koreanCharValue: Char = &amp;#39;가&amp;#39;
    
    var booleanValue: Boolean = true
    
    var stringValue = &amp;quot;one line string test&amp;quot;
    
    val multiLineStringValue = &amp;quot;&amp;quot;&amp;quot;multiline
    string
    test&amp;quot;&amp;quot;&amp;quot;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/lee989898/c6ccc4221fdbd96eae8b91fa55199f92.js&quot;&gt; &lt;/script&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="kotlin" />
      

      
        <summary type="html">반복문과 증감연산자</summary>
      

      
      
    </entry>
  
</feed>
