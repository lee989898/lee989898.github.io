<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://lee989898.github.io/author/lee989898/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://lee989898.github.io/" rel="alternate" type="text/html" />
  <updated>2022-03-15T23:53:04+09:00</updated>
  <id>https://lee989898.github.io/author/lee989898/feed.xml</id>

  
  
  

  
    <title type="html">LEE | </title>
  

  
    <subtitle>공부 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">FPinPython</title>
      <link href="https://lee989898.github.io/pl-21" rel="alternate" type="text/html" title="FPinPython" />
      <published>2021-12-05T19:18:00+09:00</published>
      <updated>2021-12-05T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-21</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-21">&lt;h3 id=&quot;fpinpython&quot;&gt;&lt;strong&gt;FPinPython&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;python-is-not-a-fpl&quot;&gt;&lt;strong&gt;Python is not a FPL&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;What is FP?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;수학적 의미의 순수 함수는 부작용이 없이, 아웃풋 값이 순전히 인풋값에 따르는 함수이다&lt;br /&gt;
함수 프로그래밍에서, 프로그램은 전적으로 순수 함수의 평가(계산의 실행)로 구성된다&lt;br /&gt;
계산은 상태 변화나 데이터의 변경없이, 중첩 함수나 합성 함수의 호출에 의해 진행된다&lt;/p&gt;

&lt;p&gt;명령형 프로그래밍에 대한 함수 프로그래밍의 장점은 다음과 같다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;첫째, 함수 코드는 고수준이다. ​함수는 결과를 얻는데 필요한 절차를 명시적으로 상술하는 것이 아니라, ​얻고자 하는 결과가 무엇인지 서술한다.  즉, how가 아니라 what을 서술한다 ​&lt;/li&gt;
  &lt;li&gt;둘째, 함수 코드는 투명하다. ​함수의 행태는 계산 중에 생성되는 잠정적인 값에 무관하고, 인풋과 아웃풋에만 의존한다. 이것은 부작용의 가능성을 제거하며, 디버깅을 쉽게 한다&lt;/li&gt;
  &lt;li&gt;끝으로, 함수 코드는 병렬성이 있다. ​부작용이 없어서, 프로그램의 루틴들은 더욱 쉽게 병렬 처리할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;함수 프로그래밍은 다음과 같은 특징을 갖는다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;함수는 first class이다. ​파이썬을 비롯한 현대 프로그래밍 언어에서는 ​기본적으로 객체, 클래스 개념을 갖기 때문에, ​함수를 기본적인 객체로 간주한다. ​따라서 ‘Functions are first class’라는 말은 ​’함수는 기본적인 객체이다’라는 의미로 받아 들여도 무방하다. 실제로 파이썬에서는 function을 객체로 간주하여, ​파라미터로 주고 받는다. ​이것은 함수 프로그래밍 언어에서 원하는 바이다&lt;/li&gt;
  &lt;li&gt;함수 프로그래밍에서 리커젼은 기본적인 컨트롤 스트럭처로 사용된다. ​몇몇 언어에서는 리커젼 이외에 순환 처리를 위한 다른 방법(loop)을 지원하지 않는다. 반면, 순수 함수 언어가 아닌 명령형 프로그래밍을 지원하는 언어에서는 loop도 함께 지원한다&lt;/li&gt;
  &lt;li&gt;함수 프로그래밍 언어는 리스트 처리에 초점을 둔다. ​Loop는 ‘리스트에 대한 리커젼 처리’로 대체될 수 있다. ​이와 같이 리스트는 loop의 대체에 필요한 데이터 구조로서 사용된다&lt;/li&gt;
  &lt;li&gt;순수 함수 프로그래밍 언어는 부작용을 피하기 위해, ​변수에 초기값을 할당하거나, 계산 중에 이 변수의 값을 변경하는 것을 모두 금지한다&lt;/li&gt;
  &lt;li&gt;함수 프로그래밍은 문장 단위로 프로그램을 작성하는 것이 아니라, ​함수와 파라미터 단위로 프로그램을 작성한다. ​순수 함수 프로그램에서,프로그램은 하나의 표현식과 이를 지원하는 함수 정의로 구성된다&lt;/li&gt;
  &lt;li&gt;함수 프로그래밍은 어떻게 계산할 것인가가 아니라, ​무엇을 계산할 것인가에 관심을 갖는다​&lt;/li&gt;
  &lt;li&gt;함수 프로그래밍은 고차 함수를 이용한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기서 언급하는 FP의 특징은 지극히 일부분이고 상이한 측면도 보이는데, 이렇게 된 이유는 ​순수 함수 언어가 아닌 현대 프로그래밍 언어를 가지고 ​함수 프로그래밍을 하는 실용적인 개발자(practitioner)의 관점이 반영되어 있기 때문이다&lt;/p&gt;

&lt;p&gt;파이썬은 ‘순수’ 함수 언어가 확실히 아니다. 대부분의 파이썬 프로그램에서 부작용을 흔히 볼 수 있다&lt;br /&gt;
즉, 변수는 자주 재바인딩되고, ​수정 가능한 데이터 컬렉션은 그 내용을 종종 변경하며, ​I/O는 자유롭게 계산과 인터리빙된다 (메모리에 바인딩된다는 의미이다)&lt;/p&gt;

&lt;p&gt;파이썬은 함수 언어 근처에도 못간다. ​파이썬은 멀티 패러다임 언어이다&lt;br /&gt;
파이썬은 필요할 때, 함수 프로그래밍을 쉽게 할 수 있고, ​다른 프로그래밍 스타일과 혼합하기 쉽다&lt;br /&gt;
즉, 명령형 프로그래밍 스타일과 함수 프로그래밍 스타일을 섞어서 쓸 수 있다&lt;br /&gt;
따라서, 멀티 패러다임 언어라는 말은 ​다양한 프로그래밍 스타일을 지원하는 언어라는 의미로 이해하면 될 것이다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;how-well-python-supports-fp&quot;&gt;&lt;strong&gt;How well Python supports FP?​&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;함수 프로그래밍을 지원하려면, ​함수는 다른 함수를 파라미터로 받을 수 있고, ​또 다른 함수를 반환할 수 있어야 한다&lt;br /&gt;
파이썬은 프로그램 내의 모든 것을 객체로 취급하기 때문에, ​두가지를 모두 지원한다&lt;/p&gt;

&lt;p&gt;파이썬에서, 함수는 일등 시민이다. 함수는 값과 동일한 특징을 갖기 때문에, ​함수를 변수에 할당할 수 있고(명령형 언어의 변수와 의미적으로 다름)​
print()를 써서 함수를 콘솔에 디스플레이할 수 있으며, ​함수를 다른 함수에게 파라미터로 패스할 수 있다
​&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def func():
        printf(&quot;I am function func()!&quot;)

&amp;gt;&amp;gt;&amp;gt; func()
I am function func()!

&amp;gt;&amp;gt;&amp;gt; another_name = func
&amp;gt;&amp;gt;&amp;gt; another_name()
I am function func()!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드는 func을 another_name에 할당하는 것을 보여주고 있다&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def func():
        printf(&quot;I am funtion func()!&quot;)

&amp;gt;&amp;gt;&amp;gt; print(&quot;cat&quot;, func, 42)
cat &amp;lt;function func at 0x2123123123&amp;gt; 42

&amp;gt;&amp;gt;&amp;gt; objects = [&quot;cat&quot;, func, 42]
&amp;gt;&amp;gt;&amp;gt; objects[1]
&amp;lt;function func at 0x2123123123&amp;gt;
&amp;gt;&amp;gt;&amp;gt; objects[1]()
I am function func()!

&amp;gt;&amp;gt;&amp;gt; d = {&quot;cat&quot;: 1, func: 2, 42: 3}
&amp;gt;&amp;gt;&amp;gt; d[func]
2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드는 print(“cat”, func, 42)를 통해, ​&amp;lt;function func at …&amp;gt;을 디스플레이하는 것을 보여주고 있다&lt;br /&gt;
또 print()를 내포하는 함수 func()을 통해, ​함수를 디스플레이하고 있다&lt;br /&gt;
끝으로 d는 키: 값 쌍을 갖는 dictionary인데, ​d[func]은 func의 값 2를 반환한다
​&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def inner():
        printf(&quot;I am function inner()!&quot;)

&amp;gt;&amp;gt;&amp;gt; def outer(function):
        function()

&amp;gt;&amp;gt;&amp;gt; outer(inner)
I an function inner()!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드는 inner()가 outer()의 파라미터로 패스되는 것을 보여준다. 이것은 합성 함수의 정의 사례이다&lt;/p&gt;

&lt;p&gt;파이썬에서, 합성 함수는 다음과 같이 실행된다. ​outer(inner) 호출은 inner()를 outer()에게 파라미터로 패스한다&lt;br /&gt;
outer() 내에서 파이썬은 inner()를 파라미터 ‘function’에 바인딩한다. ​그러면, outer()는 ‘function’을 통해 직접 inner()를 호출한다&lt;br /&gt;
함수가 다른 함수에 패스될 때, 패스-인 함수를 콜백이라고 부른다. ​그 이유는 패스-인 함수(앞의 예에서는 inner())의 호출이 ​역으로 outer에 
영향을 줄 수 있기 때문이다&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; animals = [&quot;ferret&quot;, &quot;vole&quot;, &quot;dog&quot;, &quot;gecko&quot;]
&amp;gt;&amp;gt;&amp;gt; sorted(animals, key=len)
['dog', 'vole', 'gecko', 'ferret']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드는 sorted()의 파라미터로 len()을 사용하여 ​길이 순으로 정렬하고 있다&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; animals = [&quot;ferret&quot;, &quot;vole&quot;, &quot;dog&quot;, &quot;gecko&quot;]
&amp;gt;&amp;gt;&amp;gt; sorted(animals, key=len, reverse=True)
['ferret', 'gecko', 'vole', 'dog']

&amp;gt;&amp;gt;&amp;gt; def reverse_len(s):
        return -len(s)

&amp;gt;&amp;gt;&amp;gt; sorted(animals, key=reverse_len)
['ferret', 'gecko', 'vole', 'dog']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드는 길이의 역순으로 정렬한다. 이때 메소드 reverse=True와 함수 -len()에 의한 reverse_len()의 정의를 사용한다&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def outer():
        def inner():
                print(&quot;I am function inner()!&quot;)

        return inner

&amp;gt;&amp;gt;&amp;gt; function = outer()
&amp;gt;&amp;gt;&amp;gt; function
&amp;lt;function outer.&amp;lt;locals&amp;gt;.inner at 0x231312312&amp;gt;
&amp;gt;&amp;gt;&amp;gt; function()
I am function inner()!

&amp;gt;&amp;gt;&amp;gt; outer()()
I am function inner()!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;파이썬에서는, 함수를 반환값으로 반환한다. ​파이썬에서는 함수를 다른 함수에게 파라미터로 패스할 수 있고, ​함수를 다른 함수의 반환값으로 반환한다&lt;br /&gt;
예를 들어, 위 코드에서 함수 outer()의 정의를 보자. outer() 내에서 inner()를 정의하고, ​inner를 반환한다&lt;br /&gt;
outer()의 반환값을 변수 function에 할당한다. ​function()는 간접적으로 inner()를 호출한다. ​outer()의 반환값을 이용하여 간접적으로 inner()를 호출한다&lt;br /&gt;
이와 같이, 파이썬은 함수를 파라미터로, 그리고 반환값으로 사용할 수 있다. 이러한 측면에서 파이썬은 함수 프로그래밍을 잘 지원한다&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; lambda s: s[::-1]
&amp;lt;function &amp;lt;lambda&amp;gt; at 0x123312512&amp;gt;

&amp;gt;&amp;gt;&amp;gt; callable(lambda s: s[:: 1])
True

&amp;gt;&amp;gt;&amp;gt; reverse = lambda s: s[:: -1]
&amp;gt;&amp;gt;&amp;gt; reverse(&quot;I am a string&quot;)

&amp;gt;&amp;gt;&amp;gt; (lambda s: s[::-1])(&quot;I am a string&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;파이썬은 람다를 사용하여 익명의 함수를 정의한다. ​람다 표현식은 lambda &lt;param_list&gt;: &lt;expression&gt;의 형식을 갖는다&lt;/expression&gt;&lt;/param_list&gt;&lt;/p&gt;
&lt;expression&gt;은 파라미터 리스트의 이름을 포함한다  
위 코드는 문자열의 역순을 반환하는 함수 정의를 ​람다 표현식으로 나타낸 것이다  
Callable은 함수 호출이나 메소드인지를 확인하는 함수이다. ​가운데 코드와 같이, 람다 함수의 적용을 통해, ​그리고 람다 함수를 변수에 할당 및 호출을 통해, ​함수를 평가할 수 있다  

---

## __Applying function to iterable with map()​__

---

```
&amp;gt;&amp;gt;&amp;gt; def reverse(s): 
            return s[::-1]

&amp;gt;&amp;gt;&amp;gt; reverse(&quot;I am a string&quot;)

&amp;gt;&amp;gt;&amp;gt; animals = [&quot;cat&quot;, &quot;dog&quot;, &quot;hedgehog&quot;, &quot;gecko&quot;]
&amp;gt;&amp;gt;&amp;gt; iterator = map(reverse, animals)
&amp;gt;&amp;gt;&amp;gt; for i in iterator:
        print(i)
tac
god
gohefdeh
okceg

&amp;gt;&amp;gt;&amp;gt; list(iterator)
['tac', 'god', 'gohegdeh', 'okceg']

&amp;gt;&amp;gt;&amp;gt; list(map(lambda s: s[::-1], [&quot;cat&quot;, &quot;dog&quot;, &quot;hedgehog&quot;, &quot;gecko&quot;]))
['tac', 'god', 'gohegdeh', 'okceg']
```

이터러블에 대한 함수에 map()을 적용하면, ​리스트 각 요소마다 원하는 함수 f를 적용할 수 있다  
리스트 각 요소마다 reverse를 적용하려면, ​map(reverse, animal)와 같이 하면 된다  
이것은 이터러블 animal의 각 요소에 reverse 함수를 적용한다. ​이것을 for loop을 써서 프린트한다  
이터레이터를 써서 프린트할 수 있다 

```
&amp;gt;&amp;gt;&amp;gt; def f(a,b,c):
        return a + b + c

&amp;gt;&amp;gt;&amp;gt; list(map(f,[1,2,3], [10,20,30], [100, 200, 300]))
[111, 222, 333]
```

다수의 이터러블에 map()을 적용하려면, ​그 형식은 map(f, iter1, iter2,… itern)과 같다  

---

## __Selecting elements from iterable with filter()__

---

```
&amp;gt;&amp;gt;&amp;gt; def greater_than_100(x):
        return x &amp;gt; 100

&amp;gt;&amp;gt;&amp;gt; list(filter(greater_than_100, [1, 111, 2, 222, 3, 333]))
[111, 222, 333]

&amp;gt;&amp;gt;&amp;gt; list(filter(lambda x: x &amp;gt; 100, [1, 111, 2, 222, 3, 333]))
[111, 222, 333]
```

함수 filter()를 써서 이터러블로부터 원하는 요소를 선택하려면, ​그 형식은 filter(f, iter)이다  
함수 f가 greater_than_100()이라면, ​표현식 filter(greater_than_100, [1,111,2,222,3,333]))의 결과는​ 111,222,333이다  

---​

## __Avoiding control flow​__

명령형 파이썬 프로그램에서 코드 블록은 다음과 같이 구성된다
+ 외부 loop(for 또는 while)​
+ 외부 loop 내의 상태 변수의 할당​
+ 데이터 구조(dicts, lists, sets 등)의 수정​
+ 분기문(if/elif/else 또는 try/except/finally)​  

이렇게 하는 것은 자연스럽고 문제를 인식하기 쉬운 듯 보인다. ​그러나 상태 변수와 수정가능한 데이터 구조로 인해 부작용이 발생할 수 있을 뿐만 아니라, ​프로그램의 특정 지점에서 데이터의 상태를 알아내기가 어렵다  
이에 대한 해결책으로 'how'가 아니라 'what'에 초점을 맞추는 것이 중요하다  
즉, '여기 어떤 데이터가 있는데,' '원하는 결과를 생성하기 위해 이 데이터를 어떻게 처리할 것인가?'가 아니라 ​'이 데이터를 가지고(또는 이 데이터에 대해) 내가 처리해야 하는 것이 무엇인가?'를 고민하는 것이다  

플로우 컨트롤을 피하고 함수 프로그래밍을 위해, ​'how'에서 'what'으로 어떻게 전환할 것인가?  
캡슐화, 컴프리헨션, 리커젼 등을 잘 활용하는 것이 그 방법이다  
컴프리헨션은 주어진 구조적 데이터에서 새로운 구조적 데이터를 생성하는 간략한 방법으로, ​파이썬 프로그래머는 반복 처리나 조건을 만족하는 리스트, 딕셔너리, 집합을 쉽게 생성할 수 있다

&amp;gt; Encapsulation

```
# imperative style​
collection = get_initial_state()​
state_var = None​
for datum in data_set:​
     if condition(state_var):​
          state_var = calculate_from(datum)​
          new = modify(datum, state_var)​
          collection.add_to(new)​
     else:​
          new = modify_differently(datum)​
          collection.add_to(new)​

# work with the data collection​
for thing in collection:​
    process(thing)

# functional style ​
def make_collection(data_set):​
     collection = get_initial_state()​
     state_var = None​
     for datum in data_set:​
          if condition(state_var):​
                state_var = calculate_from(datum, state_var)​
                new = modify(datum, state_var)​
                collection.add_to(new)​
          else:​
                new = modify_differently(datum)​
                collection.add_to(new)​
     return collection​

# work with the data collection​
for thing in make_collection(data_set):​
     process(thing)
```

캡슐화는 코드를 refactor(재분해)하고, ​데이터 생성을 함수나 메소드 안으로 집어 넣는 것이다  
예를 들어 위 코드는 캡슐화를 써서, ​명령형 스타일의 'collection 생성 절차'라는 'how'를 함수 프로그래밍 스타일의 'make_collection(즉 collection 생성)'이라는 what으로 전환한다  
위 코드는 명령형 절차를 나타내며, ​아래 코드는 함수 프로그램 코드를 나타낸다

&amp;gt; List Comprehension

```
collection = list()​
for datum in data_set:​
     if condition(datum):​
          collection.append(datum)​
     else:​
          new = modify(datum)​
          collection.append(new)

collection = [d if condition(d) else modify(d)​
                 for d in data_set]

```

컴프리핸션은 주어진 이터러블에서 새로운 이터러블을 생성하는 간략한 방법이다  
파이썬의 컴프리헨션에는 리스트, 제너레이터, 딕셔너리, 집합이 있으며, ​이를 위한 문법을 제공한다
리스트 컴프리헨션은 표현식을 […]로 감싼다  

컴프리헨션은 같은 키워드를 사용하면서, ​그 키워드들의 순서를 바꾼 표현식의 형태를 갖는다  
순서를 바꾼 이유는 절차가 아닌 데이터에 초점을 두기 위함이다. 이 말은 컴프리헨션을 이용하여 함수 프로그래밍에 도움이 된다는 뜻이다  

주어진 리스트 data_set으로부터 새로운 리스트 collection을 생성하는 ​프로그램을 코딩하면 위 코드와 같다  
위는 명령형 스타일이고, 아래는 함수형 스타일이다  
위 코드에서, 삼진 연산자 if를, ​같은 키워드를 사용하면서 순서만 바꿔, ​명령형 코드를 함수형 코드로 재구조화한 것을 볼 수 있다  
절차에 초점을 둔 코드는 조건을 만족시키면, append​ 만족시키지 못하면, modify &amp;amp; append​  

반면에 데이터에 초점을 둔 함수 스타일로 표현하면, ​리스트 컴프리헨션이 적절한 형식이고, ​주어진 리스트 data_set에서 조건에 맞는 것만 collection로 생성하면 된다  
리스트 요소를 d로 지칭하여 표현식을 작성하면, ​아래쪽 코드와 같다. Data_set의 각 요소 d에 대해 ​먼저 조건을 만족시키는지 확인하고, 맞으면 bypass 안맞으면 modify  

마치 순서를 바꾼 것처럼 보이지만, 시맨틱을 고려하면 조건을 만족하면 리스트에 남기고(하나씩 append 하지 않고), ​조건을 만족하지 않으면 modify(d)해서 수정된 d를 리스트에 남긴다. 그리고 이와 같이 생성된 새로운 리스트를 collection으로 명명(naming)한다는 의미이다  

&amp;gt; Generator Comprehension  

제너레이터 컴프리헨션은 리스트 컴프리헨션과 유사하게 데이터를 생성하나 문법적으로 [ ] 대신에 ( )를 사용한다  
제너레이터 컴프리헨션은 데이터 생성을 위해, ​함수 정의에 '데이터 생성 방법'을 서술한다  
이 서술은 그에 대한 반복 처리를 하거나 .next()를 호출할 때까지 실행되지 않는다  
따라서 대규모 시퀀스를 위한 메모리를 절약하고​ 실제로 필요할 때까지 계산을 지연시킨다  

```
# imperative​
def get_log_lines(log_file):​
     line = read_line(log_file)​
     while True:​
          try:​
             if complex_condition(line):​
                  yield line​
             line = read_line(log_file)​
          except StopIteration:​
                  raise​

log_lines = get_log_lines(huge_log_file)​

# functional ​
class GetLogLines(object):​
     def __init__(self, log_file):​
          self.log_file = log_file​
          self.line = None​
     def __iter__(self):​
          return self​
     def __next__(self):​
          if self.line is None:​
               self.line = read_line(log_file)​
          while not complex_condition(self.line):​
               self.line = read_line(self.log_file)​
          return self.line​

log_lines = GetLogLines(huge_log_file)​
```

간단한 예를 들면, 로그 파일에서 로그 라인을 읽어서 ​라인 리스트를 만드는 함수 코드는 위와 같다  
위의 코드는 실제 상황을 고려한 코드로서, ​위쪽 코드는 명령형 프로그래밍 스타일, ​아래쪽 코드는 함수 프로그래밍 스타일을 나타낸다  

&amp;gt; Dictionary and Set Comprehension  

```
&amp;gt;&amp;gt;&amp;gt; {i:chr(65+i) for i in range(6)}​
{0: 'A', 1: 'B', 2: 'C', 3: 'D', 4: 'E', 5: 'F'}​
&amp;gt;&amp;gt;&amp;gt; {chr(65+i) for i in range(6)}​
{'A', 'B', 'C', 'D', 'E', 'F'}​
```

딕셔너리와 집합 컴프리헨션은 모두 { }을 사용하나, ​그 안의 형식이 {key : value}, {value}로 각기 다르다  
이들의 요소는 loop안에서 .update(), add() 호출을 통해 하나씩 생성되는 것이 아니라, ​모두 '한꺼번에' 생성된다​  
각각의 예는 위와 같다. 

&amp;gt; Recursion

```
# recursive​
def factorialR(N):​
     assert isinstance(N, int) and N &amp;gt;= 1​
     return 1 if N &amp;lt;= 1 else N * factorialR(N-1)

# iterative ​
def factorialI(N):​
     assert isinstance(N, int) and N &amp;gt;= 1​
     product = 1​
     while N &amp;gt;= 1:​
          product *= N​
          N -= 1​
     return product
```

파이썬은 리커션과 룹에 의한 함수 프로그래밍을 지원한다  
리커션과 while 룹을 이용한 팩토리알 계산 함수는 각각 위와 아래에 있다  
While 룹을 이용한 것은 거의 명령형 코드로 보이지만, ​함수로 정의하는 점과 while 안에서 함수형 코드가 있는 점 등​ 함수 프로그래밍 스타일과 명령형 프로그래밍 스타일이 혼합되어 있다  

```
# Quicksort over a list-like sequence​
def quicksort(lst):​
     if len(lst) == 0:​
         return lst​
     pivot = lst[0]​
     pivots = [x for x in lst if x == pivot]​
     small = quicksort([x for x in lst if x &amp;lt; pivot])​
     large = quicksort([x for x in lst if x &amp;gt; pivot])​
     return small + pivots + large
```

이러한 혼합 형식은 퀵소트 함수에서도 볼 수 있다. 삼진 연산자 if, [표현식…]은 함수형이지만, ​나열된 문장은 명령형으로 보인다. 즉, 혼합형이다  

```
# statement-based loop​
for e in it: ​
     func(e)​

# map()-based &quot;loop“​
map(func, it) ​
```

고차 함수를 써서 룹을 제거할 수 있다. ​이것은 가독성과 성능 저하를 가져오지만, ​함수 프로그래밍을 위한 좋은 아이디어를 얻을 수 있는 배경 지식으로 중요하다  

우선 for loop을 제거하기 위해 map()을 쓴 경우를 보자. ​위쪽 코드는 for loop에 의한 코드이다. ​반면 아래쪽 코드는 map에 의해 loop이 제거된 코드이다  

함수 map()을 적용할 때, ​다수의 함수를 같은 수의 리스트에 적용하고 싶다면, ​다수의 함수와 같은 수의 리스트를 파라미터로 하여, ​map(do_it, [f1, f2, f3], [l1, l2, l3])와 같이 표현한다  
이때 적용해야 할 함수는 ​do_it = lambda f, *args: f(*args)와 같이, ​람다에 의해 정의되어 있어야 한다

```
&amp;gt;&amp;gt;&amp;gt; hello = lambda first, last: print(&quot;Hello&quot;, first, last)​
&amp;gt;&amp;gt;&amp;gt; bye = lambda first, last: print(&quot;Bye&quot;, first, last)​
&amp;gt;&amp;gt;&amp;gt; _ = list(map(do_it, [hello, bye],​
&amp;gt;&amp;gt;&amp;gt;                         ['David','Jane'], ['Mertz','Doe']))​
Hello David Mertz​
Bye Jane Doe​

&amp;gt;&amp;gt;&amp;gt; do_all_funcs = lambda fns, *args: [​
                                     list(map(fn, *args)) for fn in fns]​
&amp;gt;&amp;gt;&amp;gt; _ = do_all_funcs([hello, bye],​
                             ['David','Jane'], ['Mertz','Doe'])​
Hello David Mertz​
Hello Jane Doe​
Bye David Mertz​
Bye Jane Doe
```

위쪽 코드는 함수 hello를 [Dav, Jan]에, ​함수 bye를 [Mer, Do]에 적용하는데, ​이들 함수 hello, bye는 각각 ​lambda first, last: print(&quot;Hello&quot;, first, last)와 ​lambda first, last: print(&quot;Bye&quot;, first, last)이다  

만일 모든 함수를 각각의 리스트에 적용하려면, ​함수 map()을 lambda fns, *args: [list(map(fn, *args)) for fn in fns]와 같이 정의한다  

---
&lt;/expression&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">FPinPython</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">__SSL/TLS__</title>
      <link href="https://lee989898.github.io/sc-20" rel="alternate" type="text/html" title="__SSL/TLS__" />
      <published>2021-12-03T01:06:00+09:00</published>
      <updated>2021-12-03T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-20</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-20">&lt;h3 id=&quot;ssltls&quot;&gt;&lt;strong&gt;SSL/TLS&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Secure sockets layer (SSL)​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;1996, Netscape​&lt;/li&gt;
  &lt;li&gt;1999, TLS로​&lt;/li&gt;
  &lt;li&gt;웹기반 전자상거래를 위해 TCP layer에서 메시지와 무결성과 비밀성 제공​&lt;/li&gt;
  &lt;li&gt;Web-server와 web-browser간 보안​&lt;/li&gt;
  &lt;li&gt;HTTPS – 현재 대부분 서버에서 사용​&lt;/li&gt;
  &lt;li&gt;Handshake (암호spec, session관리), record (암호,무결성등 보안서비스) protocols로 나뉜다​&lt;/li&gt;
  &lt;li&gt;인증수행-&amp;gt;세션키분배-&amp;gt;암호화 메시지 송수신 순서​&lt;/li&gt;
  &lt;li&gt;지원하는 보안서비스 ​
    &lt;ul&gt;
      &lt;li&gt;Server/client authentication, confidentiality, integrity&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;부인방지기능은 제공안됨 – 전자서명 사용해야​&lt;/li&gt;
  &lt;li&gt;단순히 web-server와 web-browser간의 모든 data를 암호화하면 안전? No, replay attack (관찰된 통신내용을 동일하게 재생하면 같은 결과를 얻을 수 있다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Secure sockets layer (SSL) 표준​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;User authentication​&lt;/li&gt;
  &lt;li&gt;Confidentiality​&lt;/li&gt;
  &lt;li&gt;Integrity​
​
&lt;img src=&quot;/assets/built/images/sc/sc31.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;TLS/SSL Protocol 구성​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Handshake protocol​
    &lt;ul&gt;
      &lt;li&gt;Client, server 간 인증, 암호 알고리즘 합의, 키교환 등 수행​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Record protocol​
    &lt;ul&gt;
      &lt;li&gt;데이터를 인증, 암호화처리하고 메시지 송수신​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Change cipher spec​
    &lt;ul&gt;
      &lt;li&gt;암호 spec을 변경담당​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Alter protocol​
    &lt;ul&gt;
      &lt;li&gt;에러처리​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Handshake Protocol&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;핸드셰이크는 서버를 확인하고 데이터가 전송되기 전에 클라이언트와 서버가 암호화 세트에 동의하도록 한다&lt;/li&gt;
  &lt;li&gt;Record protocol의 의한 data송수신보다 먼저 수행되어 다음의 session정보를 생성, 관리​
    &lt;ul&gt;
      &lt;li&gt;Session ID​&lt;/li&gt;
      &lt;li&gt;Certification​&lt;/li&gt;
      &lt;li&gt;Cipher spec: 압축, MAC algorithm​&lt;/li&gt;
      &lt;li&gt;Compression method: 암호화 이전 압축 algorithm​&lt;/li&gt;
      &lt;li&gt;Master secret key: 48bit&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Handshake Protocol&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;3개의 필드로 이루어진 메시지 교환
    &lt;ul&gt;
      &lt;li&gt;type: 메시지 종류 명시&lt;/li&gt;
      &lt;li&gt;length: 메시지 길이&lt;/li&gt;
      &lt;li&gt;content: 메시지 종류에 따른 값들&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;4단계 진행
    &lt;ul&gt;
      &lt;li&gt;1단계: Security capability establish​&lt;/li&gt;
      &lt;li&gt;2단계: Server authentication &amp;amp; key exchange​&lt;/li&gt;
      &lt;li&gt;3단계: Client authentication &amp;amp; key exchange​&lt;/li&gt;
      &lt;li&gt;4단계: Change cipher specs​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc32.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1단계: Security capability establish​
    &lt;ul&gt;
      &lt;li&gt;1~3​&lt;/li&gt;
      &lt;li&gt;Hello 메시지 교환으로 session ID, 키교환알고리즘, 인증 알고리즘, 암호알고리즘, 압축 알고리즘 결정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Server authentication &amp;amp; key exchange​
    &lt;ul&gt;
      &lt;li&gt;4~6​&lt;/li&gt;
      &lt;li&gt;4: 서버의 인증서와 검증위한 인증서체인, 공개키전송​&lt;/li&gt;
      &lt;li&gt;5: client 인증서 요구(opt)​&lt;/li&gt;
      &lt;li&gt;6: 2단계 종료메시지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;3단계: Client authentication &amp;amp; key exchange​
    &lt;ul&gt;
      &lt;li&gt;7~9​&lt;/li&gt;
      &lt;li&gt;7: client 인증서전송​&lt;/li&gt;
      &lt;li&gt;8: 48byte premaster secrete 전송​&lt;/li&gt;
      &lt;li&gt;9: client 인증서 검증&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;4단계: Change cipher specs​
    &lt;ul&gt;
      &lt;li&gt;10~11​&lt;/li&gt;
      &lt;li&gt;암호사양변경 메시지 교환을 통해 다음 세션에 적용될 암호 spec 결정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Record Protocol&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;메시지를 최대 16KB 단위로 fragment​&lt;/li&gt;
  &lt;li&gt;MAC 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc33.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1: 메시지를 최대 16KB 단위로 fragment​&lt;/li&gt;
  &lt;li&gt;2: 압축 (opt)​&lt;/li&gt;
  &lt;li&gt;3: MAC 추가​&lt;/li&gt;
  &lt;li&gt;4: Encryption​&lt;/li&gt;
  &lt;li&gt;5: SSL reacord header 추가&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Changes from SSL 3.0 to TLS&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Transport Layer Security [RFC2246]​&lt;/li&gt;
  &lt;li&gt;Additional Alerts added​&lt;/li&gt;
  &lt;li&gt;Modification to hash calculations​&lt;/li&gt;
  &lt;li&gt;Protocol version 3.1 in ClientHello, ServerHello&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">SSL/TLS</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">__IPSEC__</title>
      <link href="https://lee989898.github.io/sc-21" rel="alternate" type="text/html" title="__IPSEC__" />
      <published>2021-12-03T01:06:00+09:00</published>
      <updated>2021-12-03T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-21</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-21">&lt;h3 id=&quot;ipsec&quot;&gt;&lt;strong&gt;IPSEC&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;IPSEC&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;IP 주소 위장 방지(출발지 인증)​&lt;/li&gt;
  &lt;li&gt;IP 데이터그램의 변경 및 재전송 방지​&lt;/li&gt;
  &lt;li&gt;IP 데이터 그램을 위한 기밀성, 무결성 제공​&lt;/li&gt;
  &lt;li&gt;보안  프로토콜 선택(시스템들이 필요로 하는)​&lt;/li&gt;
  &lt;li&gt;암호 알고리즘 선택(선택된 프로토콜에서 사용되도록)​&lt;/li&gt;
  &lt;li&gt;암호키 생성,분배(요청된 서비스의 제공에 필요) ​&lt;/li&gt;
  &lt;li&gt;Application​
    &lt;ul&gt;
      &lt;li&gt;VPN (virtual Private Network): 가상 전용회선​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;IPSEC 구성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;IPsec AH(인증 헤더) 프로토콜​
    &lt;ul&gt;
      &lt;li&gt;데이터 근원 인증,비연결형 무결성 제공 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;캡슐화 보안페이로드 (ESP ) – 데이터기밀성, 제한된 트래칙 흐름 기밀성, 비연결형 무결성, 데이터 근원인증, 재전송공격 방지 제공​&lt;/li&gt;
  &lt;li&gt;IKE 프로토콜 ​
    &lt;ul&gt;
      &lt;li&gt;통신당사자간 키관리 프로토콜​&lt;/li&gt;
      &lt;li&gt;암호알고리즘 선택협상, 키분배 위해 사용​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Transport and Tunnel Modes&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc34.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Transport mode​
    &lt;ul&gt;
      &lt;li&gt;End to end between hosts​&lt;/li&gt;
      &lt;li&gt;관련 hosts들이 IPSec을 지원해야​&lt;/li&gt;
      &lt;li&gt;IP 상위 프로토콜 (TCP, Application) 안전하게 전송​&lt;/li&gt;
      &lt;li&gt;IP header에 IPSec header정보 추가​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc35.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Tunnel mode​
    &lt;ul&gt;
      &lt;li&gt;터널내의 모든 IP 트래픽 보호​&lt;/li&gt;
      &lt;li&gt;터널의 시작,종류 지점에 IPSec gateway​&lt;/li&gt;
      &lt;li&gt;터널 시작 gateway에서 새 IP header와 Ipsec header 추가하고, 종료 gateway에서 제거​&lt;/li&gt;
      &lt;li&gt;라우터가 내부 패킷을 검사하지 않음&lt;/li&gt;
      &lt;li&gt;소스 및 목적지 주소가 다를 수 있음&lt;/li&gt;
      &lt;li&gt;방화벽에서 구현 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">IPSEC</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">__Kerberos​__</title>
      <link href="https://lee989898.github.io/sc-18" rel="alternate" type="text/html" title="__Kerberos​__" />
      <published>2021-12-01T01:06:00+09:00</published>
      <updated>2021-12-01T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-18</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-18">&lt;h3 id=&quot;kerberos&quot;&gt;&lt;strong&gt;Kerberos​&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Kerberos?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Symmetric key 기반 분산 인증 시스템​&lt;/li&gt;
  &lt;li&gt;사용자가 서버의 서비스에 액세스하려는 경우 (예, 프린터서버, 네트워크 디스크 등)​&lt;/li&gt;
  &lt;li&gt;세 가지 위협 존재:​
    &lt;ul&gt;
      &lt;li&gt;사용자가 다른 사용자로 가장​&lt;/li&gt;
      &lt;li&gt;사용자가 워크스테이션의 네트워크 주소를 변경&lt;/li&gt;
      &lt;li&gt;사용자는 교환을 도청하고 재생 공격을 사용​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Client들이 원격으로 서버에 자원, 서비스 요청시마다 인증반복​&lt;/li&gt;
  &lt;li&gt;매번 passwd 입력 안해도 되며, 각 서버가 사용자들의 비번을 저장할 필요없다​&lt;/li&gt;
  &lt;li&gt;경쟁자: SSL&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;​Kerberos Design 요구사항​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;사용자는 워크스테이션 세션(로그인 세션)이 시작될 때 한 번 자신을 식별해야 한다&lt;/li&gt;
  &lt;li&gt;암호는 네트워크를 통해 일반 텍스트로 전송되지 않습니다(또는 메모리에 저장)&lt;/li&gt;
  &lt;li&gt;각 서버가 사용자들의 비번을 저장할 필요없어야 ​함&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;System Components​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Server, User​&lt;/li&gt;
  &lt;li&gt;AS(Authentication Server)​
    &lt;ul&gt;
      &lt;li&gt;모든 user/server 들의 password 안다​&lt;/li&gt;
      &lt;li&gt;TGS 에 제시할 ticket 발급​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TGS(Ticket Granting Server)​
    &lt;ul&gt;
      &lt;li&gt;서버는 ticket만 받는다​&lt;/li&gt;
      &lt;li&gt;서비스 요청시, 한 user는 한 server에 한 ticket제시​&lt;/li&gt;
      &lt;li&gt;Server에 제시할 ticket 발급역할​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;시스템 구성도&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc28.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Protocol​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;User/TGS는 AS에, server는 TGS에 등록(passwd)되어 있다  (or PKI사용)​&lt;/li&gt;
  &lt;li&gt;User가 서비스 필요​&lt;/li&gt;
  &lt;li&gt;서비스 제공할 server 찾는다​&lt;/li&gt;
  &lt;li&gt;해당 server 관리하는 TGS 찾는다​&lt;/li&gt;
  &lt;li&gt;AS에 TGS에 보낼 ticket요청&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;User는 AS에게  UserID, TGS이름을 $K_{user-AS}$로 암호화하여 보낸다&lt;/li&gt;
  &lt;li&gt;AS는 User와 TGS간의 통신을 위한 세션키1 $K_{user-TGS}$ 를 생성​ 세션키1, UserID 를 $K_{AS-TGS}$로 암호화하여 User에게 발급할 Ticket을 생성​ 세션키1과 Ticket을 $K_{user-AS}$로 암호화하여 보낸다​&lt;/li&gt;
  &lt;li&gt;받은 2를 $K_{user-AS}$복호화해서 세션키1 $K_{user-TGS}$ 와 Ticket을 얻는다. ​UserID를 세션키1로 암호화해서 Ticket과 함께 TGS로 보낸다​&lt;/li&gt;
  &lt;li&gt;받은 3을 $K_{user-TGS}$와 $K_{AS-TGS}$ 로 복호화해서 User정보와 요구내용 확인, ​TGS는 User와 Server간의 통신을 위한 세션키2 $K_{user-server}$ 생성 ​세션키2, UserID 를 $K_{TGS-server}$로 암호화하여 User에게 발급할 Ticket을 생성​ 세션키2와 Ticket을 $K_{user-TGS}$로 암호화하여 보낸다​&lt;/li&gt;
  &lt;li&gt;받은 4를 $K_{user-TGS}$로 복호화해서 세션키2 $K_{user-server}$와 Ticket(user, Server)를 얻는다. Server에게 $K_{user-server}$로 암호화한 UserID와 Ticket을 전송한다​&lt;/li&gt;
  &lt;li&gt;Server는 받는 5의 Ticket을 $K_{TGS-server}$로 복호화 하여 세션키2 $K_{user-server}$을 얻는다. 이걸로 UserID를 복호화해서  사용자확인을 한다.​&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Drawbacks of Kerberos&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;단일 실패 지점: 중앙 서버의 지속적인 가용성이 필요. Kerberos 서버가 다운되면 아무도 로그인할 수 없다&lt;/li&gt;
  &lt;li&gt;Kerberos에는 엄격한 시간 요구 사항이 있으므로 관련된 호스트의 시계가 구성된 제한 내에서 동기화되어야 함&lt;/li&gt;
  &lt;li&gt;관리 프로토콜은 표준화되지 않았으며 서버 구현에 따라 다르다&lt;/li&gt;
  &lt;li&gt;모든 인증은 중앙 집중식 KDC에 의해 제어되므로 이 인증 인프라가 손상되면 공격자가 모든 사용자를 가장할 수 있음&lt;/li&gt;
  &lt;li&gt;다른 호스트 이름이 필요한 각 네트워크 서비스에는 고유한 Kerberos 키 세트가 필요합니다. 이는 가상 호스팅 및 클러스터를 복잡하게 만든다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">Kerberos​</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">__Dos​__</title>
      <link href="https://lee989898.github.io/sc-19" rel="alternate" type="text/html" title="__Dos​__" />
      <published>2021-12-01T01:06:00+09:00</published>
      <updated>2021-12-01T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-19</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-19">&lt;h3 id=&quot;dos&quot;&gt;&lt;strong&gt;Dos​&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Dos (Denial of Service)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;서비스 거부​&lt;/li&gt;
  &lt;li&gt;시스템 자원(cpu, memory, network, storage 등)을 고갈시켜 정상적인 접근에 대한 서비스를 제공할 수 없도록 만드는 행위​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Dos attack type​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Error trigger Dos attack​&lt;/li&gt;
  &lt;li&gt;OS,application의 약점에 attack packet 전송해서 system error 유발 (slammer worm)​&lt;/li&gt;
  &lt;li&gt;Ping of death, Land, Teardrop​&lt;/li&gt;
  &lt;li&gt;Flooding Dos attack​&lt;/li&gt;
  &lt;li&gt;packet, traffic을 과중하게 발생하여 server, network resource 고갈​&lt;/li&gt;
  &lt;li&gt;TCP syn flooding​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;TCP syn flooding​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;TCP 3-way handshaking의 취약점 이용​&lt;/li&gt;
  &lt;li&gt;공격자가 src IP 주소를 위조해서 TCP SYN를  동시에 대량전송​&lt;/li&gt;
  &lt;li&gt;서버는 TCP ACK를 보내고, 자원할당 후 응답 기다림​&lt;/li&gt;
  &lt;li&gt;정상적인 접근방해+엉뚱한 피해자​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc29.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;DDoS Attack​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Distributed Denial of Service​&lt;/li&gt;
  &lt;li&gt;다수의 pc가 동시에 Dos 공격​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;BotNet?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Bot(=zombie): 악성sw에 감염되어 자신도 모르게 해커의 조종을 받는 컴퓨터​&lt;/li&gt;
  &lt;li&gt;BotNet: 명령제어서버(C&amp;amp;C,command and control)를 통해 원격제어되는 악성코드에 감염된 컴퓨터(bot)들의 네트워크 ​&lt;/li&gt;
  &lt;li&gt;대부분 사어버테러의 주요 원인&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc30.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;DDos 종류&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Standard DoS: 알려진 취약점 집중공격​&lt;/li&gt;
  &lt;li&gt;Tool을 이용한 DoS: TFN, TFN2K, Trinoo, Loki, Stacheldraht, Jolt, Land, teardrop…​&lt;/li&gt;
  &lt;li&gt;Traffic anomalie 공격: bandwidth점유, ICMP, TCP, UDP flooding​&lt;/li&gt;
  &lt;li&gt;Spoofed SYN flooding: spoof된 source IP로 TCP syn보냄​&lt;/li&gt;
  &lt;li&gt;Connection Per Second(CPS) flood: zombie로 부터 connection flooding​&lt;/li&gt;
  &lt;li&gt;Established Connection flood: zombie로 부터 established connection flood​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Why DDos?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Simple​&lt;/li&gt;
  &lt;li&gt;Easy: just use tools​&lt;/li&gt;
  &lt;li&gt;Effective​&lt;/li&gt;
  &lt;li&gt;공격자추적이 어렵다​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">Dos​</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">근사 알고리즘</title>
      <link href="https://lee989898.github.io/algorithm-09" rel="alternate" type="text/html" title="근사 알고리즘" />
      <published>2021-11-29T01:09:00+09:00</published>
      <updated>2021-11-29T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-09</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-09">&lt;h3 id=&quot;근사-알고리즘&quot;&gt;&lt;strong&gt;근사 알고리즘&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;근사-알고리즘-1&quot;&gt;근사 알고리즘&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-완전 문제 해결 방법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;문제의 크기가 작다면 완전 탐색 알고리즘 사용&lt;/li&gt;
  &lt;li&gt;문제의 특별한 경우(들)에는 다항 시간 알고리즘을 찾으려고 노력&lt;/li&gt;
  &lt;li&gt;문제의 최적해에 매우 근사한 해를 구하는 것이 허용된다면 비교적 빠른 근사 알고리즘을 찾으려고 노력&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;근사 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;NP-완전 문제와 같이 지금까지 알려진 실용적인 다항 시간 알고리즘이 없거나 최적의 해를 반드시 찾을 필요가 없을 때 사용&lt;/li&gt;
  &lt;li&gt;대부분의 근사 알고리즘은 특정 문제에만 적용되는 휴리스틱에 기초&lt;/li&gt;
  &lt;li&gt;휴리스틱은 경험을 통해 얻는 상식적인 접근법&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;근사 비율&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;근사해의 값과 최적해의 값의 비율&lt;/li&gt;
  &lt;li&gt;정의: 근사 비율 p
    &lt;ul&gt;
      &lt;li&gt;f: 목적 함수&lt;/li&gt;
      &lt;li&gt;$S_a$: 근사해&lt;/li&gt;
      &lt;li&gt;$S^*$: 최적해&lt;/li&gt;
      &lt;li&gt;$S_a$는 다음 부등식을 만족시켜야 한다
        &lt;ul&gt;
          &lt;li&gt;최소화 문제: $\frac{f(S_a)} {f(S^*)}$&amp;lt;= p&lt;/li&gt;
          &lt;li&gt;최대화 문제: $\frac{f(S^*)} {f(S_a)}$&amp;lt;= p&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;p-근사 알고리즘: 근사비율이 p인 알고리즘&lt;/li&gt;
  &lt;li&gt;1에 가까울수록 정확도가 높은 알고리즘&lt;/li&gt;
  &lt;li&gt;근사 비율은 보통 2를 사용&lt;/li&gt;
  &lt;li&gt;대부분의 경우에 목적 함수의 최적 값인 $f(S^*)$를 알 수 없기 때문에 근사 비율 계산 불가&lt;/li&gt;
  &lt;li&gt;$f(S^*)$를 대신할 수 있는 $f(S_a)$의 상한을 구하여 근사 비율을 계산&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;정점 커버 찾기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무방향 그래프에서 각 간선의 양쪽 끝의 두 정점들 중에서 적어도 1개의 정점을 포함하는 정점들의 집합&lt;/li&gt;
  &lt;li&gt;크기 = 정점 커버내에 있는 정점들의 수&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그래프는 여러 개의 정점 커버들을 가질 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;무방향 그래프내에 있는 최소 크기의 정점 커버를 찾아라
    &lt;ul&gt;
      &lt;li&gt;정점 지향 전략&lt;/li&gt;
      &lt;li&gt;간선 지향 전략&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;정점 지향 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;그래프의 모든 정점들을 차수(한 정점에 인접한 정점들의 수) 기준으로 내림차순으로 정렬한다&lt;/li&gt;
  &lt;li&gt;차수가 가장 큰 정점을 선택한다&lt;/li&gt;
  &lt;li&gt;선택된 정점에 인접한 모든 간선을 제거한다&lt;/li&gt;
  &lt;li&gt;남은 그래프에서 과정 2와 3을 반복한다&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;간선 지향 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;그래프의 한 간선 (u, v)를 임의로 선택한다&lt;/li&gt;
  &lt;li&gt;u와 v를 정점 커버에 포함시키고 u와 v에 인접한 간선들은 모두 그래프에서 제거한다&lt;/li&gt;
  &lt;li&gt;남은 간선들 중 임의로 한 간선을 선택하고 같은 과정을 반복한다. 선택할 간선들이 더 이상 남아 있지 않으면 종료한다&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;근사 정점 커버 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Approx_Vertex_Cover(G)&lt;br /&gt;
// 입력: 그래프 G = (V, E)&lt;br /&gt;
// 출력: C - 정점 커버&lt;br /&gt;
1 C = $\emptyset$&lt;br /&gt;
2 $E^&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$ = E  
3 while ( $E^&lt;/code&gt;$ $\neq$  $\emptyset$){&lt;br /&gt;
4   $E^&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$에서 임의로 간선 (u,v)를 선택한다  
5   C = C {u} {v}  
6   $E^&lt;/code&gt;$에서 정점 u나 v에 인접한 모든 간선들을 제거한다&lt;br /&gt;
    }&lt;br /&gt;
7 return C&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;시간 복잡도: O(&lt;/td&gt;
          &lt;td&gt;E&lt;/td&gt;
          &lt;td&gt;)&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;해밀토니안 회로&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;해밀토니안 회로: 그래프의 한 정점에서 출발하여 다른 모든 정점을 1번씩만 방문하고 출발 정점으로 돌아오는 경로&lt;/li&gt;
  &lt;li&gt;완전 그래프에는 반드시 해밀토니안 회로가 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;외판원 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;가중 완전 그래프의 최단 거리 해밀토니안 회로를 찾아라&lt;/li&gt;
  &lt;li&gt;NP-완전 문제&lt;/li&gt;
  &lt;li&gt;다음 조건들을 만족시켜야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;가중치가 있는 완전 무방향 그래프 G = (V, E)의 각 간선 (u, v) $\in$ E는 음이 아닌 가중치 c(u, v)를 가진다&lt;/li&gt;
  &lt;li&gt;모든 정점 u,v,w $\in$ V에 대해서 거리 함수 c가 다음과 같은 삼각 부등식을 만족한다
    &lt;ul&gt;
      &lt;li&gt;c(u,v) &amp;lt;= c(u, w) + c(w, v)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;근사 외판원 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;아이디어&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;프림의 최소 비용 신장 트리 알고리즘을 이용하여 주어진 그래프에서 최소 비용 신장 트리를 찾는다&lt;/li&gt;
  &lt;li&gt;이 트리에 깊이 우선 탐색을 하여 정점들의 방문 순서를 구한다&lt;/li&gt;
  &lt;li&gt;이 순서를 따라 정점들을 방문하면서 다시 방문하는 정점을 순서에서 제거하여 외판원 문제의 근사해를 구한다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Approx_MST_TSP(G, c)&lt;br /&gt;
// 입력: G = (V, E) - 가중 완전 그래프, c - G의 간선들의 가중치(삼각 부등식을 만족)&lt;br /&gt;
// 출력: 해밀토니안 회로 H&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;임의의 정점 r $\in$ V를 출발 정점으로 선택한다&lt;/li&gt;
  &lt;li&gt;Prim의 최소 비용 신장 트리 알고리즘을 이용하여 r이 루트 노드인 그래프 G의 최소 비용 신장 트리 T를 구한다&lt;/li&gt;
  &lt;li&gt;트리 T의 루트 노드에서 시작하여 깊이 우선 탐색을 하면서 노드들을 방문한 순서대로 나열한 목록 H를 구한다&lt;/li&gt;
  &lt;li&gt;목록 H에 있는 정점들을 출발 정점을 제외하고 처음부터 순서대로 스캔하면서 중복하여 나타나는 정점들을 H에서 제거한다&lt;/li&gt;
  &lt;li&gt;return H&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;시간복잡도: O($n^2$)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">근사 알고리즘</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">FPLs</title>
      <link href="https://lee989898.github.io/pl-20" rel="alternate" type="text/html" title="FPLs" />
      <published>2021-11-24T19:18:00+09:00</published>
      <updated>2021-11-24T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-20</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-20">&lt;h3 id=&quot;fpls&quot;&gt;&lt;strong&gt;FPLs&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;lisp&quot;&gt;Lisp​&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Lisp은 심볼(문자열) 처리를 위한 언어로 개발되었다&lt;br /&gt;
심볼들을 표현하기 위한 데이터 구조로 리스트, 즉 링크드 리스트를 기본으로 한다&lt;br /&gt;
이러한 이유로 데이터 연산은 자연스레 링크(포인터) 조작을 포함한다&lt;br /&gt;
Lisp이라는 이름은 리스트 프로세싱의 합성어로서, 말 그대로 리스트 처리에 적합하도록 설계되었다&lt;/p&gt;

&lt;p&gt;Lisp의 데이터 타입은 아톰과 리스트, 두 가지이다&lt;br /&gt;
아톰은 식별자처럼 생긴 심볼들이거나 숫자 형태의 상수를 말한다&lt;br /&gt;
아톰에 값이 없을 수 있어서 nil도 가능하다&lt;br /&gt;
리스트는 리스트 요소가 연결되어 있고, 리스트 요소는 두개의 링크(포인터), 데이터 포인터와 넥스트 포인터로 구성된다&lt;br /&gt;
데이터 포인터는 아톰을 가리키거나 중첩리스트를 가리킨다&lt;br /&gt;
넥스트 포인터는 다른 리스트 요소를 가리키거나 nil(리스트의 끝을 나타냄)이다&lt;/p&gt;

&lt;p&gt;Lisp 프로그램에서 리스트는 괄호를 써서 나타내는데, 중첩 리스트는 괄호 안에 괄호를 써서 나타낸다&lt;/p&gt;

&lt;p&gt;ex) (A, B, C, D)&lt;br /&gt;
A,B,C,D는 각각이 아톰이며, (A,B,C,D)는 리스트이다&lt;/p&gt;

&lt;p&gt;산술 연산자로 +, - , incf, decf가 있고, 비교 연산자로 =, /= , &amp;lt;, max, min이 있다&lt;br /&gt;
부울 값에 대한 논리 연산자로 loand,logor 등이 있다&lt;br /&gt;
컨트롤 스트럭처로 selection, recursiong, iteration이 있는데, iteration은 명령형 언어의 특성으로, Lisp이 순수 함수 언어가 아니라는 것을 보여준다&lt;br /&gt;
함수 정의는 (defun 함수명 (파라미터1… 파라미터n)표현식)형식을 따르고, 함수 적용(호출)은 (함수명 파라미터1 … 파라미터n)의 형식을 따른다&lt;/p&gt;

&lt;p&gt;Lisp으로 작성된 팩토리알 함수는&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(DEFUN factorial (X))
    (IF &amp;lt;= n 1)
            1
            (* n factorial (-n 1)))
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;과 같다&lt;/p&gt;

&lt;p&gt;미리 정의된 함수 중의 몇몇은 실제로는 함수가 아니라 매크로이다&lt;br /&gt;
예를 들어, 두개의 파라미터, 죽 변수와 리스트를 받아들이는 DOLIST는 매크로이다&lt;br /&gt;
DOLIST(x ‘(1 2 3)) (print x))는 리스트 요소 1,2,3,nil로 구성된 리스트를 생성한다&lt;/p&gt;

&lt;p&gt;매크로의 실행은 다음 두 단계로 이루어진다&lt;br /&gt;
우선, 매크로를 미리 정의딘 Lisp 코드로 펼치고, 다음에, 펼친 Lisp 코드를 평가(실행)한다&lt;/p&gt;

&lt;p&gt;사용자는 DEFMACRO를 써서 자신이 원하는 매크로를 정의할 수 있다&lt;/p&gt;

&lt;p&gt;Lisp에서 괄호 앞의 ‘(QUOTE)는 괄호 속의 표현식을 평가(실행)하지 말고, 그 객체(표현식)를 결과로서 반환하라는 뜻이다&lt;br /&gt;
예를 들어 ‘(a(* 3 4)c)는 (a 12 c)를 결과로 반환한다&lt;br /&gt;
중첩된 괄호 속의 (* 3 4)는 평가한다는 것에 주의하자&lt;/p&gt;

&lt;p&gt;Lisp은 컴파일러가 아닌 인터프리터에 의해 실행된다&lt;br /&gt;
Lisp 프로그램에서는 함수 정의 및 함수 적용(호출)을 “괄호에 의한 리스트 표시 방식”으로 표현된다&lt;br /&gt;
함수 정의는 (함수명(람다 (파라미터1 … 파라미터n) 표현식)) 으로 정의하며, 함수 적용은 (함수명 파라미터1 … 파라미터n)으로 호출한다&lt;br /&gt;
예를 들어, (+ 5 7)은 12이고, (+ 3 4 7 6)은 20이다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;scheme&quot;&gt;Scheme​&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Scheme은 Lisp으로부터 유래되었으나 함수를 일등 시민으로 취급한다&lt;br /&gt;
Scheme에서는 함수가 표현식의 결과 값일 수 있고, 함수가 리스트의 요소로 사용될 수 있으며, 함수가 파라미터로 패스될 수 있고, 함수가 함수의 결과로서 반환될 수 있다&lt;/p&gt;

&lt;p&gt;Scheme은 단순한 신택스와 시맨틱스를 갖는, 타입이 없는 작은 언어이다&lt;/p&gt;

&lt;p&gt;Scheme 인터프리터는 상호작용 모드로 동작하면서, read-evaluate-print 순환(REPL)을 무한으로 반복한다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;사용자가 입력한 표현식을 읽어서&lt;/li&gt;
  &lt;li&gt;EVAL 함수에 의해 표현식을 해석하고&lt;/li&gt;
  &lt;li&gt;결과값을 화면에 display한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;EVAL 함수는 다음과 같이 표현식을 평가한다&lt;br /&gt;
리터럴의 평가는 그 자체를 결과로 displaat한다&lt;br /&gt;
원시 함수를 포함하는 표현식의 평가는 다음과 같이 실행한다&lt;br /&gt;
첫째, 특별한 순서 없이, 파라미터 표현식의 각각 평가한다&lt;br /&gt;
둘째, 파라미터 값에 원시 함수의 적용을 평가한다&lt;br /&gt;
끝으로, 결과값을 display한다&lt;/p&gt;

&lt;p&gt;원시 산술 함수는 +,-,*,/,modulo,round,max,min,log,sin,sqrt 등이다&lt;br /&gt;
음수에 대한 sqrt는 허수이다&lt;/p&gt;

&lt;p&gt;함수 정의는 (LAMBDA (x) (* x x))의 형식을 가지며, 함수 적용은 ((LAMBDA(x) (* x x)) 7)의 형식을 갖는다&lt;/p&gt;

&lt;p&gt;DEFINE 함수는 이름을 값이나 람다 함수에 바인딩하는 특수한 함수이다&lt;br /&gt;
(DEFINE symbol expression)의 형식을 가지며, 그 예로 (DFINE pi 3.141592), (DEFINE two_pi (* 2 pi))을 들 수 있다&lt;/p&gt;

&lt;p&gt;DEFINE 함수가 이름을 람다 표현식에 바인딩하는 형식은 (DEFINE (function_name parameters) (expression))이다&lt;br /&gt;
예를 들면, 제곱수를 (DEFINE (square number) (* number number))와 같이 정의하고, 직각삼각형의 빗변의 길이를 (DEFINE (hypotenuse side1 side2)(SQRT(+(square side1)(square side2))))와 같이 정의한다&lt;/p&gt;

&lt;p&gt;출력 함수는 EVAL 함수의 적용을 통해 그 결과를 display한다&lt;/p&gt;

&lt;p&gt;논리적 술어(predicate)함수는 부울 값을 반환한다&lt;br /&gt;
Scheme의 논리적 술어 함수는 =, &amp;lt;&amp;gt;, &amp;gt;,&amp;lt;,&amp;gt;=, &amp;lt;=, EVEN?, ODD?, ZERO?가 있다&lt;br /&gt;
리스트가 부울식으로서 해석될 때에는 비어있지 않은 리스트는 참이고, 비어있는 리스트는 거짓이다&lt;/p&gt;

&lt;p&gt;컨트롤 플로우는 택인 컨스트럭트(IF)와 평가 컨트롤(COND)이 있다&lt;br /&gt;
if는 3개의 파라미터(논리적 술어 표현식, then 표현식, else 표현식)를 갖는다&lt;br /&gt;
그 형식은 (IF 논리적 술어 then 표현식 else 표현식)이고, 사용 예를 들면 DEFINE(factorial n)(IF (&amp;lt;+ n 1)1(*n(factorial(-n 1))))이다&lt;/p&gt;

&lt;p&gt;평가 컨트롤은 여럿 중에서 하나 이상이 선택 및 실행되는 COND와 recursion이 있다&lt;br /&gt;
COND의 형식은&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(DEFINE (leap? year))
    (COND
        ((ZERO? (MODULO year 400)) #T)
        ((ZERO? (MODULO year 100)) #F)
        (ELSE (ZERO? (MODULO year 4)))))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;와 같다&lt;/p&gt;

&lt;p&gt;리스트 함수에는 QUOTE,CAR,CDR,CONS 함수가 있다&lt;br /&gt;
QUOTE는 그 자체를 결과로 반환하며, ‘로 표시한다&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(QUOTE A) returns A ​
(QUOTE (A B C)) returns (A B C)​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CAR 함수는&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(CAR '((A B) C D)) returns (A B) ​
(CAR 'A) is an error because A is not a list ​
(CAR '(A)) returns A ​
(CAR '()) is an error ​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CDR 함수는 ​&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(CDR '((A B) C D)) returns (C D) ​
(CDR 'A) is an error ​
(CDR '(A)) returns () ​
(CDR '()) is an error​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CONS 함수는 ​&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(CONS 'A '()) returns (A) ​
(CONS 'A '(B C)) returns (A B C)​
(CONS '() '(A B)) returns (() A B)​
(CONS '(A B) '(C D)) returns ((A B) C D)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CAR, CDR을 가지고 a_list의 두번째 리스트 요소를 결과값으로 반환하는 함수를 정의하면, (DEFINE (second a_list)(CAR(CDR a_list)))가 된다&lt;br /&gt;
이것은 a_list에서 첫째 요소를 제외한 나머지를 반환하고, 이중에서 첫째 요소를 반환한다는 뜻이다&lt;br /&gt;
리스트를 생성하기 위해 CAR CDR의 연속으로 적용해 보면, (CADDAR ‘((A B (C)D)E)) == (C) 임을 알 수 있다&lt;/p&gt;

&lt;p&gt;리스트 함수는 다수의 파라미터로부터 하나의 리스트를 생성한다&lt;br /&gt;
CONS는 생성할 수도 있으나, List함수가 편리하다&lt;/p&gt;

&lt;p&gt;논리적 술어 함수 중에서 EQ? NULL? LIST?는 심볼 아톰과 리스트에도 적용할 수 있다&lt;br /&gt;
EQV?은 숫자 아톰과 심볼 아톰에 모두 적용할 수 있다&lt;/p&gt;

&lt;p&gt;Scheme에서 함수 정의의 예를 들어 보자&lt;br /&gt;
멤버 함수는 파라미터 간의 소속관계를 평가한다&lt;br /&gt;
리스트의 맨앞 리스트 요소에서부터 차례로 비교하기 위해, COND와 EQ, CAR, CDR을 사용한다&lt;br /&gt;
append 함수는 앞의 파라미터에 뒤의 파라미터를 잇는다&lt;br /&gt;
list1의 리스트 요소를 앞에서부터 하나씩 새로운 리스트에 넣기를 반복한다&lt;br /&gt;
list1의 리스트의 요소를 모두 새로운 리스트에 넣고 나면, 이때 lsit1은 NULL이 되므로, list2의 요소를 새로운 리스트에 넣으면 된다&lt;br /&gt;
이를 위해 COND와 NULL?, CONS, CAR, CDR을 이용한다&lt;/p&gt;

&lt;p&gt;두개의 리스트가 같은지 판단하려면, 각 리스트의 맨앞 요소에서부터 하나씩 같은지 비교하기를 반복한다&lt;br /&gt;
이를 위해 COND, EQ?, CAR, CDR 등을 이용한다&lt;/p&gt;

&lt;p&gt;반복 처리는 모두 recursion을 이용한다&lt;br /&gt;
즉, 이들 모두 recursion으로 프로그래밍 된다&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root1 = (-b + sqrt(b2 - 4 ac))/2a, root 2 = (-b - sqrt(b2 - 4 ac))/2 a​

(DEFINE (quadratic_roots a b c) ​

  (LET ( ​

     (root_part_over_2a ​

                    (/ (SQRT (− (* b b) (* 4 a c))) (* 2 a))) ​

     (minus_b_over_2a (/ (− 0 b) (* 2 a))) ​

         ) ​

  (LIST (+ minus_b_over_2a root_part_over_2a) ​

                  (− minus_b_over_2a root_part_over_2a)) ​

))​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;LET 함수는 로컬 변수를 생성한다&lt;br /&gt;
표현을 쉽게 하기 위해 루트 부분과 루트가 없는 부분(이것을 마이너스 부분)으로 나누어, 이들을 각각 로컬 변수 root_part_over_2a, minus_b_over_2a로 언급한다&lt;br /&gt;
LIST 함수에서 이들을 언급하며 근의 공식 함수를 정의한다&lt;/p&gt;

&lt;p&gt;함수의 합성은 두개의 함수를 파리미터로 받아들여 합성 함수를 결과로 반환한다&lt;br /&gt;
합성 함수는 DEFINE (compose f g)(LAMBDA(x) (f(g(x))))로 정의한다&lt;br /&gt;
CADDR을 (DEFINE (third a_list) ((compose CAR (compose CDR CDR)) a_list))와 같이 정의한다&lt;/p&gt;

&lt;p&gt;리스트의 모든 요소에 적용하는 함수로 map 함수를 정의해 보자&lt;br /&gt;
함수 정의의 형식은 (DEFINE (mao fun a_list) 표현식)이며, a-list의 모든 요소에 함수 fun을 적용하라는 의미이다&lt;br /&gt;
즉, 함수 map을 정의하는데 파라미터로서 fun이라는 함수를 쓴다&lt;br /&gt;
따라서 이것은 고차 함수이다&lt;/p&gt;

&lt;p&gt;처리 목적에 맞게 처리하려면, 리스트 요소를 하나씩 반환하는 함수가 필요하며, 이렇게 반환된 리스트 요소에 fun을 적용하기를 반복하면 된다&lt;br /&gt;
위의 map 함수 정의에서 (COND … NULL? … ELSE …) 부분은 리스트 요소를 하나씩 꺼내는 처리 로직을 수행한다&lt;br /&gt;
맵함수 사용 예: (map (LAMBDA(num)(*num num num))’(3 4 2 6))은 (27 64 8 216)를 반환한다&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; (DEFINE (adder a_list) ​

      (COND ​

          ((NULL? a_list) 0) ​

          (ELSE (+ (CAR a_list) (adder (CDR a_list)))) ))​

(adder '(3 4 5)) ​

   (+ 3 (adder (4 5))) ​

   (+ 3 (+ 4 (adder (5)))) ​

   (+ 3 (+ 4 (+ 5 (adder ())))) ​

   (+ 3 (+ 4 (+ 5 0))) ​

   (+ 3 (+ 4 5)) ​

   (+ 3 9) ​

   (12)​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;리스트에 있는 아톰의 합을 구하는 프로그램을 작성해보면, 코드는 위에서 보듯이 매우 간결하다&lt;br /&gt;
실제 평가 과정을 보면, recursion이 있어 매우 복잡해 보이지만 이것은 인터프리터의 역할이다&lt;/p&gt;

&lt;p&gt;만일 EVAL 함수를 써서 코딩하면, 아래 프로그램이 된다&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Alternative code with EVAL function:​

(DEFINE (adder a_list) ​

    (COND ​

        ((NULL? a_list) 0) ​

        (ELSE (EVAL (CONS '+ a_list))) ​

))​

(adder '(3 4 5)) ​

(EVAL (+ 3 4 5) ​

(12)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;ml&quot;&gt;ML​&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;ML은 타입 검사를 엄격하게 수행하는 언어이다&lt;br /&gt;
평가 환경은 프로그램에서 명시적 또는 암묵적으로 선언된 모든 변수명을 그 유형(타입)과 함께 테이블을 포함한다&lt;br /&gt;
이 테이블은 컴파일러의 심볼 테이블과 유사하다&lt;br /&gt;
ML 신택스는 Lisp이나 Scheme에 비해 IPL과 더욱 유사하다&lt;br /&gt;
산술 표현식은 인픽스 방식으로 표현된다&lt;/p&gt;

&lt;p&gt;함수 정의는 함수명(파라미터) = 표현식;의 신택스를 갖는다&lt;br /&gt;
예를 들어, fun circumf( r ) = 3.14159&lt;em&gt;r&lt;/em&gt;r;로 정의 되었다면, 함수 circumf는 부동점 파라미터를 받아서 부동점 결과를 생산한다&lt;br /&gt;
이 값의 타입은 표현식의 값으로부터 추론된다&lt;br /&gt;
함수 적용은 circumf(1.3)과 같이 호출된다&lt;/p&gt;

&lt;p&gt;ML의 컨트롤 플로우는 if 표현식 then 표현식1 else 표현식2에 의한다&lt;br /&gt;
ML에서는 주어진 파라미터에 대한 패턴 매칭을 통해 함수의 반환값을 정의하는 특정 표현식을 선택하기도 한다&lt;br /&gt;
예를 들어, 팩토리알을 구할 떄&lt;br /&gt;
fun fact(n : int): int = if n &amp;lt;= 1 then 1 else n * fact(n − 1);로 표현할 수도 있지만, ​fun fact(0) = 1 | fact(1) = 1 | fact(n : int): int = n * fact(n − 1);로 표현할 수도 있다.&lt;br /&gt;
후자에서는 Fact(0), Fact(1)의 값을 구할 때, 두개의 식 fun fact(0) = 1, fact(1) = 1에 대한 패턴 매칭을 통해 그 결과값을 선택할 수 있다&lt;/p&gt;

&lt;p&gt;ML에서는 h, t는 각각 헤드와 테일을 나타내며, CAR, CDR과 같다&lt;br /&gt;
그리고 ::는 CONS와 같다&lt;br /&gt;
두개의 리스트를 append하는 함수는&lt;br /&gt;
fun append([], lis2) = lis2 | append(h :: t, lis2) = h :: append(t, lis2);로 정의된다.&lt;/p&gt;

&lt;p&gt;주어진 리스트에서 리스트 요소의 개수를 구하는 함수는&lt;br /&gt;
fun length([]) = 0 | length(h :: t) = 1 + length(t);이다&lt;/p&gt;

&lt;p&gt;ML에서 값을 선언하는 방법은 변수명에 값을 바인딩하는 것이다&lt;br /&gt;
그 형식은 val new_name = expression이다&lt;br /&gt;
만일 새로운 값을 바인딩하려면 새로운 변수명에 새로운 값을 바인딩하여 테이블에 새로운 엔트리로 생성해야 한다&lt;br /&gt;
val의 정상적인 사용은 표현식에서 사용하는 변수에 대해, Let안에서 바인딩하는 것이다&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Let val radius = 2.7 ​

      val pi = 3.14159 ​

   in pi * radius * radius ​

   end;​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;예에서 radius와 pi는 표현식에 제한된 변수임을 명확히 선언하고 있다&lt;/p&gt;

&lt;p&gt;많이 쓰이는 고차 함수로 리스트를 필터링하는 filter함수가 있다&lt;br /&gt;
필터는 다음과 같이 동작한다&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;필터는 술어 함수를 파라미터로 받아들여서, 술어 만족 여부에 따라 필터링하는 함수를 반환한다(술어 함수는 종종 fn으로 정의된 람다 표현식으로 주어진다)&lt;/li&gt;
  &lt;li&gt;반환된 필터링 함수는 리스트를 파라미터로 받아들여서 다음과 같이 처리한다
    &lt;ul&gt;
      &lt;li&gt;각 리스트 요소에 대해 술어함수를 적용하여 술어 조건을 만족시키는지 검사&lt;/li&gt;
      &lt;li&gt;그 결과가 참이면, 리스트 요소를 새로운 리스트(결과 리스트)에 추가한나다&lt;/li&gt;
      &lt;li&gt;참이 아니면, 스킵한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이렇게 생성된 새로운 리스트를 결과로 반환한다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;필터의 사용을 보면 Filter(fn(x)) =&amp;gt; x &amp;lt;100, [25, 1, 50, 711, 100, 150, 27, 161, 3]);는 결과로서 100보다 작은 요소만으로 구성된 새로운 리스트 [25, 1, 50, 27, 3]를 반환한다&lt;/p&gt;

&lt;p&gt;많이 쓰이는 다른 함수로 map함수가 있다&lt;br /&gt;
map함수는 파라미터로 함수 (fa)를 받아 들여서 새로운 함수를 만든다&lt;br /&gt;
새로운 함수는 파라미터로 리스트를 받아 들인다&lt;br /&gt;
각 리스트 요소에 파라미터로 받은 함수(fa)를 적용한다&lt;/p&gt;

&lt;p&gt;합성 함수는 val h = g o f로 정의하며, 이것은 h(x) = g(f(x))와 같다&lt;/p&gt;

&lt;p&gt;커링은 하나 이상의 파라미터를 가진 함수를 하나의 파라미터를 가진 함수로 교체하는 것이다&lt;br /&gt;
하나의 파라미터를 가진 함수는 함수를 반환하며, 반환된 이 함수는 초기 함수의 다른 파라미터를 받아 들여 결과를 반환한다&lt;br /&gt;
예를 들어, (DEFINE (add x y)(+ x y))의 커리 함수는 DEFINE (add y) (LAMBDA (x) (+ y x))이며, 이것이 호출되면, 그 결과는 (+ y x)으로 리덕션된다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;haskell&quot;&gt;Haskell​&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Haskell은 순수 함수 언어로 알려져 있다&lt;br /&gt;
연산자는 표시 방식만 다를 뿐 다른 FPL과 거의 같다&lt;/p&gt;

&lt;p&gt;Haskell 역시 앞에서 Scheme에서 본 것과 유사한 let 컨스트럭트를 지원한다&lt;/p&gt;

&lt;p&gt;다른 언어와 다르게 지연 평가를 수행하며, 표현식은 값이 필요할 때에만 평가된다&lt;/p&gt;

&lt;p&gt;이에 비해 이른(eager) 평가에서는 함수가 호출되기 전에 미리 함수에 대한 파라미터를 평가한다&lt;br /&gt;
따라서 엄격한 시맨틱스를 갖는다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;support-fp-in-ipl&quot;&gt;Support FP in IPL&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;자바 스크립트에서는 이름을 가진 함수를 정의할 수 있다&lt;br /&gt;
ex) 함수명 (파라미터 여러개) { 표현식 (블록)}&lt;/p&gt;

&lt;p&gt;여기서 함수명을 빼면 익명의 함수를 정의하게 된다&lt;/p&gt;

&lt;p&gt;파이썬에는 람다 표현식이 가능하다&lt;br /&gt;
즉, lambda a,b: 2*a-b라고 하면, 파라미터 a,b로 이름이 없는 익명의 함수를 정의하는 것이다&lt;br /&gt;
파라미터와 함수 바디를 콜론으로 구분한다&lt;/p&gt;

&lt;p&gt;파이썬에서는 고차 함수 filter와 map를 정의할 수 있다&lt;br /&gt;
이들은 첫째 파라미터로 모두 람다 표현식을 사용하며, 두번째 파라미터로 시퀀스 타입을 사용한다&lt;br /&gt;
두 함수 모두 두번째 파라미터와 동일한 타입의 시퀀스를 결과로 반환한다.&lt;br /&gt;
예를 들어 map(lambda x : x**3, [2, 4, 6, 8]이라고 하면, 반환 결과는 [8, 64, 216, 512]이다.&lt;br /&gt;
이 예에서 첫번째 파라미터는 함수(표현식)임을 기억하라.&lt;/p&gt;

&lt;p&gt;이 map은 2004년 구글의 MapReduce의 map과 같은 의미이며, ​병렬 처리의 한 방법으로 유명해졌다. ​&lt;/p&gt;

&lt;p&gt;파이썬은 파라미터의 개수를 제한하고, ​명시적으로 새로운 함수를 정의하고 적용할 수 있도록 partial 함수를 지원한다.&lt;br /&gt;
먼저 제한적으로 적용하려는 함수를 임포트하고,​ (여기서 add5는 add a b : a + b에서 파라미터를 ​한 개로 줄여서 add + 5로 정의한 것이다.)​ 명령문 add5=partial (add, 5)은 함수 add+5를 add5로 정의하고, ​함수 add5(15)를 적용(호출)하면 결과는 20이다. ​&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">FPLs</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">POSIX Thread Programming</title>
      <link href="https://lee989898.github.io/st-10" rel="alternate" type="text/html" title="POSIX Thread Programming" />
      <published>2021-11-24T01:06:00+09:00</published>
      <updated>2021-11-24T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/st-10</id>
      <content type="html" xml:base="https://lee989898.github.io/st-10">&lt;h3 id=&quot;posix-thread-programming&quot;&gt;&lt;strong&gt;POSIX Thread Programming&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;thread-overview-&quot;&gt;Thread Overview ​&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스처럼 독립적으로 수행되는 프로그램 코드​
    &lt;ul&gt;
      &lt;li&gt;“경량 프로세스(light-weight process)”라고도 함​&lt;/li&gt;
      &lt;li&gt;“프로세스 내에서 독립적으로, 순차적으로 수행되는 instruction stream 또는 제어의 흐름”이라고도 함​&lt;/li&gt;
      &lt;li&gt;여러 스레드는 동시에 실행이 가능​&lt;/li&gt;
      &lt;li&gt;스레드들의 실행에 관한 스케쥴링은 OS가 담당​&lt;/li&gt;
      &lt;li&gt;싱글 코어에서도 여러 스레드의 실행이 가능 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;한 프로세스내의 스레드들은 같은 주소 공간을 사용 ​
    &lt;ul&gt;
      &lt;li&gt;공유 매모리를 이용하여 스레드간의 통신을 이용함으로써 복잡한 프로세스간 통신(IPC) 기능을 사용하지 않아도 됨​&lt;/li&gt;
      &lt;li&gt;스레드간의 통신 비용이 IPC 비용보다 낮음​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st25.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Process는 실행을 위하여 resource들이 필요하며 실행 상태를 메모리에 저장 ​
    &lt;ul&gt;
      &lt;li&gt;Process ID, group ID, … ​&lt;/li&gt;
      &lt;li&gt;Program instructions​&lt;/li&gt;
      &lt;li&gt;Registers, Stack​&lt;/li&gt;
      &lt;li&gt;Heap ​&lt;/li&gt;
      &lt;li&gt;File descriptor, …​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Thread는 Process 내부에 존재하면서 resource들을 같이 사용 ​
    &lt;ul&gt;
      &lt;li&gt;Registers, stack, 등은 thread 별로 따로 존재  ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st26.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;공통 스레드 구현​
    &lt;ul&gt;
      &lt;li&gt;병렬 소스 코드 내에서 호출되는 서브루틴 라이브러리&lt;/li&gt;
      &lt;li&gt;직렬 또는 병렬 소스 코드에 포함된 컴파일러 지시문 세트&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스레드 구현은 컴퓨팅에서 새로운 것이 아니다
    &lt;ul&gt;
      &lt;li&gt;역사적으로 하드웨어 공급업체는 고유한 스레드 버전을 구현했다&lt;/li&gt;
      &lt;li&gt;이러한 구현은 서로 상당히 다르다&lt;/li&gt;
      &lt;li&gt;프로그래머가 휴대용 스레드 응용 프로그램을 개발하기 어려움​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;관련 없는 표준화 노력으로 인해 두 개의 매우 다른 스레드 구현이 발생했다
    &lt;ul&gt;
      &lt;li&gt;POSIX Threads (Pthread)​&lt;/li&gt;
      &lt;li&gt;OpenMP​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;pthread-introduction-&quot;&gt;Pthread Introduction ​&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;IEEE POSIX (Portable Operating System Interface for UNIX) 1003.1c Standard​
    &lt;ul&gt;
      &lt;li&gt;과거에 하드웨어 업체별로 각각 제작되어 사용되었던 스레드에 관한 구현을 표준화 ​&lt;/li&gt;
      &lt;li&gt;이 표준에 따라 구현된 스레드를 POSIX Thread 또는 Pthread로 부름​
        &lt;ul&gt;
          &lt;li&gt;스레드를 생성하고 동기화하는 system call 들로 구성​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;표준화는 계속 진행 중​
        &lt;ul&gt;
          &lt;li&gt;가장 최근의  표준은 IEEE Std 1003.1, 2004 Edition​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;C-프로그래밍 언어의 type과 procedure call의 집합으로 정의 ​
    &lt;ul&gt;
      &lt;li&gt;
        &lt;pthread.h&gt; header 파일 및 thread library로 구현​
&lt;/pthread.h&gt;
        &lt;ul&gt;
          &lt;li&gt;libc library의 일부로 구현되기도 함​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;우수한 성능 : 프로세스와 비교​
    &lt;ul&gt;
      &lt;li&gt;스레드 생성에 드는 OS overhead가 프로세스 생성에 비해 현격히 낮음​
        &lt;ul&gt;
          &lt;li&gt;50,000번의 프로세스 생성(fork() 사용) vs. 스레드 생성(pthread_create() 사용) ​&lt;/li&gt;
          &lt;li&gt;실행 시간의 단위는 second, time 커맨드에 의해 측정​&lt;/li&gt;
          &lt;li&gt;스레드 관리에 드는 resource도 프로세스에 비해 현격히 적음​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pthread에서는 ​
    &lt;ul&gt;
      &lt;li&gt;Parallelism 생성​&lt;/li&gt;
      &lt;li&gt;동기화(synchronization)​을 지원함​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Communication에 대한 explicit한 지원은 없음​
    &lt;ul&gt;
      &lt;li&gt;Shared-memory 모델이므로 communication은 implicit하게 일어남​
​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스레드의 상태​
    &lt;ul&gt;
      &lt;li&gt;준비(ready) : 스레드가 실행될 수 있는 상태​&lt;/li&gt;
      &lt;li&gt;실행(running) : CPU의 서비스를 받고 있는 상태​&lt;/li&gt;
      &lt;li&gt;블록(block) : sleep(), read(), 세마포어 연산 등으로 기다리는 상태​&lt;/li&gt;
      &lt;li&gt;종료(terminated) : 스레드가 종료 또는 취소된 상태​
​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;준비 상태​
    &lt;ul&gt;
      &lt;li&gt;스레드가 처음 생성되면 준비 상태로 감​&lt;/li&gt;
      &lt;li&gt;CPU의 서비스를 받을 수 있는 상태​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실행 상태​
    &lt;ul&gt;
      &lt;li&gt;OS의 스케줄러에 의해 CPU의 서비스를 받고 있는 상태​&lt;/li&gt;
      &lt;li&gt;스케줄링에 의해 준비상태로 갈 수 있음​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;블록 상태​
    &lt;ul&gt;
      &lt;li&gt;실행 상태에서 즉시 처리할 수 없는 작업을 만나는 경우​
        &lt;ul&gt;
          &lt;li&gt;read(), wait(), sleep(), 세마포어/뮤텍스/조건변수를 기다리는 경우​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;원하는 조건이 만족되면 준비 상태가 됨​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;종료 상태​
    &lt;ul&gt;
      &lt;li&gt;스레드 시작함수에서 return 또는 pthread_exit()가 호출된 경우​&lt;/li&gt;
      &lt;li&gt;사용하던 자원의 대부분을 시스템에 반납​&lt;/li&gt;
      &lt;li&gt;종료 상태 값을 부모 스레드에게 넘겨주기 위한 자원은 부모 스레드에서 pthread_join()을 통해 읽어가면 완전히 삭제​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Application 프로그램은 하나의 스레드로 시작​
    &lt;ul&gt;
      &lt;li&gt;Main 스레드 또는 master 스레드로 불림 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;pthread_create() 호출에 의해 새로운 child 스레드를 생성​
    &lt;ul&gt;
      &lt;li&gt;새로운 child 스레드의 생성은 procedure 호출의 형태를 띔​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;pthread_exit() 또는 pthread_join() 호출에 의해 새로 생성되었던 스레드 종료​
    &lt;ul&gt;
      &lt;li&gt;Master 스레드만 남게 됨​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st27.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;스레드 생성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int pthread_create (​
  pthread_t   *thread, // 생성된 스레드의 핸들 ​
  pthread_attr_t   *attr, // 스레드 속성을 지정하는 인자​
  void   *(*start_routine) (void *), // 스레드 시작함수(start routine) 주소​
  void   *arg ) // 스레드 시작 함수의 인자(들)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;thread : 새로운 child 스레드가 성공적으로 생성될 경우 생성된 스레드의 핸들​&lt;/li&gt;
  &lt;li&gt;attr : 생성되는 child 스레드의 속성을 지정(디폴트 값은 NULL)​&lt;/li&gt;
  &lt;li&gt;start_routine : 새로 생성되는 child 스레드를 지정하는 함수의 시작 주소​&lt;/li&gt;
  &lt;li&gt;arg : 시작 함수들의 인자(들)​&lt;/li&gt;
  &lt;li&gt;리턴 값 ​
    &lt;ul&gt;
      &lt;li&gt;성공시 0을 리턴​&lt;/li&gt;
      &lt;li&gt;에러 발생시 에러코드의 정수 값(errno)을 리턴​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Pthread 프로그램 컴파일&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;일반적으로 –lpthread 옵션이 필요​
    &lt;ul&gt;
      &lt;li&gt;스레드 라이브러리가 다른 라이브러리(예 : libc)에 통합된 경우는 불필요 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;-D_REENTRANT 옵션​
    &lt;ul&gt;
      &lt;li&gt;멀티 스레드 환경에서 싱글 스레드의 경우와 구별된 errno를 사용하도록 함​&lt;/li&gt;
      &lt;li&gt;일반 함수들이 멀티 스레드 환경에 적합하게 동작하도록 함​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컴파일 예제​
    &lt;ul&gt;
      &lt;li&gt;Linux/GCC의 경우​
        &lt;ul&gt;
          &lt;li&gt;% gcc test.c –lpthread (-lpthread 옵션에 –D_REENTRANT 포함)​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Solaris/Studio 컴파일러의 경우​
        &lt;ul&gt;
          &lt;li&gt;% cc –mt test.c (-mt 옵션에 –D_REENTRANT 포함, 스레드 라이브러리는 libc 라이브러리에 포함됨) ​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;스레드 종료&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void  pthread_exit(void   *retval);​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;생성된 child 스레드의 종료​
    &lt;ul&gt;
      &lt;li&gt;프로세스와 마찬가지로 return을 만나면 종료​&lt;/li&gt;
      &lt;li&gt;또는 pthread_exit() 호출시 종료​&lt;/li&gt;
      &lt;li&gt;pthread_exit() 호출에 의해 child 스레드가 종료할 경우 할당되었던 자원들은 반납되지 않음​&lt;/li&gt;
      &lt;li&gt;나중에 pthread_join() 호출에 의해 반납됨 ​&lt;/li&gt;
      &lt;li&gt;Detach 된 스레드는 예외  ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int  pthread_join(pthread_t   thrd,   void   **thread_return);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Parent 스레드에서 호출​
    &lt;ul&gt;
      &lt;li&gt;자신이 생성한 child 스레드가 종료할 때까지 기다림​
        &lt;ul&gt;
          &lt;li&gt;thrd​
            &lt;ul&gt;
              &lt;li&gt;종료를 기다릴 스레드의 핸들​&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;thread_return​
            &lt;ul&gt;
              &lt;li&gt;child 스레드의 종료 상태가 저장됨​&lt;/li&gt;
              &lt;li&gt;NULL로 하면 종료 상태를 받지 않음​&lt;/li&gt;
              &lt;li&gt;child 스레드의 종료값은 return, pthread_exit()로 남길 수 있음​&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Child 스레드가 종료되기 전에 parent 스레드가 먼저 종료되지 않게 할 때 사용​
    &lt;ul&gt;
      &lt;li&gt;Parent 스레드가 종료하면 child 스레드가 함께 종료되며​&lt;/li&gt;
      &lt;li&gt;Child 스레드의 작업이 모두 이루어 지지 않은 상태일 수 있음​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Child 스레드의 종료 시점을 정확히 파악하여 어떤 작업을 하고 싶거나 종료 상태 값을 얻기 위해 사용​&lt;/li&gt;
  &lt;li&gt;종료된 child 스레드에 할당되었던 resource 들은 반납됨 ​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;스레드 Detach&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int   pthread_detach(pthread_t   thrd);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Detached 스레드​
    &lt;ul&gt;
      &lt;li&gt;Join이 가능한 스레드(pthread_join()을 사용)와 대비​&lt;/li&gt;
      &lt;li&gt;Parent 스레드가 생성한 child 스레드에 대해 pthread_detach()를 호출하면 parent 스레드가 나중에 wait하지 않음​
        &lt;ul&gt;
          &lt;li&gt;빠른 스레드의 실행에 도움이 됨​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Detach 된 스레드에 pthread_join()를 호출하면 error 발생​&lt;/li&gt;
      &lt;li&gt;Detach 된 스레드는 pthread_join() 호출 없이 할당되었던 resources 들이 반납됨 
​
        &lt;blockquote&gt;
          &lt;p&gt;스레드 Attribute&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스레드의 attribute는 스레드가 생성될 때 설정됨
    &lt;ul&gt;
      &lt;li&gt;이미 생성된 스레드의 attribute 값을 바꾸는 것은 제한적인 경우에만 가능 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;따라서 pthread_create를 호출하기 전에 원하는 attribute 값들을 설정해야 ​&lt;/li&gt;
  &lt;li&gt;Attribute 설정과 관련된 pthread API
    &lt;ul&gt;
      &lt;li&gt;pthread_attr_init()​&lt;/li&gt;
      &lt;li&gt;pthread_attr_destroy()​&lt;/li&gt;
      &lt;li&gt;pthread_attr_setdetachstate()​&lt;/li&gt;
      &lt;li&gt;pthread_attr_getstacksize()​&lt;/li&gt;
      &lt;li&gt;pthread_attr_setstacksize()​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스레드는 joinable 또는 detached 스레드로 생성 가능​&lt;/li&gt;
  &lt;li&gt;Default stack size는 OS 마다 다른 값을 지정​&lt;/li&gt;
  &lt;li&gt;최소 스택 크기는 변수 PTHREAD_STACK_MIN에 저장된다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;기타 스레드 Attribute들&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Guard size: 스택 오버플로로부터 보호하기 위해 사용&lt;/li&gt;
  &lt;li&gt;스케줄링 속성 상속(스레드 생성에서) or not&lt;/li&gt;
  &lt;li&gt;Scheduling parameter(s): 특히 스레드 우선순위&lt;/li&gt;
  &lt;li&gt;Scheduling policy: FIFO or Round Robin​&lt;/li&gt;
  &lt;li&gt;Contention scope: 이 스레드는 어떤 스레드와 CPU를 놓고 경쟁하는가&lt;/li&gt;
  &lt;li&gt;Stack address: 스택의 위치를 ​​명시적으로 지정&lt;/li&gt;
  &lt;li&gt;Lazy stack allocation: 요청 시 할당(lazy) 또는 한 번에 모두 선행&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;synchronization&quot;&gt;Synchronization​&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;스레드의 동기화 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;여러 스레드가 공유 데이터에 접근하여 값들을 읽거나 저장
    &lt;ul&gt;
      &lt;li&gt;Run time 에 공유 데이터가 어떤 값을 가질지 예측하기 어려움​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Data race 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;두 개 이상의 스레드가 같은 변수를 access, 그 중 적어도 하나의 access는 write 연산을 실행​&lt;/li&gt;
  &lt;li&gt;Access들이 동시에 발생, 그러나 동기화되지 않은 상태로&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;기본적인 동기화 Mechanism: Mutex&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;스레드들이 서로 배타적으로 공유데이터에 접근하도록 하기위해 Mutex (mutual exclusion)를 사용​
    &lt;ul&gt;
      &lt;li&gt;스레드들은 거의 독립적으로 실행​&lt;/li&gt;
      &lt;li&gt;Common한 data structure를 사용함​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Mutex외에도 세마포어를 많이 사용​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Mutex 사용방법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Critical 영역에 들어가기 전에 mutex 를 잠금​&lt;/li&gt;
  &lt;li&gt;Critical 영역에서 나오면서 mutex 잠금을 해제​&lt;/li&gt;
  &lt;li&gt;다른 스레드들은 이 mutex 잠금이 해제될 때까지 대기​&lt;/li&gt;
  &lt;li&gt;Mutex 사용 절차&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pthread_mutex_t mutex; // 뮤텍스 선언​
Pthread_mutex_init(&amp;amp;mutex); // 뮤텍스 초기화 작업​
pthread_mutex_lock(mutex); // 뮤텍스 잠금​
... // 공유데이터(크리티컬 영역) 액세스​
pthread_mutex_unlock(mutex); // 뮤텍스 잠금 해제​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Mutex 선언 및 초기화&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Mutex의 변수 타입 : pthread_mutex_t​&lt;/li&gt;
  &lt;li&gt;여러 스레드들이 사용하므로 전역 변수로 선언​&lt;/li&gt;
  &lt;li&gt;반드시 초기화를 해야 사용 가능​&lt;/li&gt;
  &lt;li&gt;초기화 방법​
    &lt;ul&gt;
      &lt;li&gt;함수를 통한 초기화​&lt;/li&gt;
      &lt;li&gt;매크로를 통한 초기화​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Mutex 초기화에 특별한 타입을 지정하지 않음 ​&lt;/li&gt;
  &lt;li&gt;단 한 번의 잠금만 허용​
    &lt;ul&gt;
      &lt;li&gt;스레드 A가 잠금을 하고 있는 상황에서 스레드 B가 잠금을 시도하면 B는 A의 잠금이 해제될 때까지 기다림​&lt;/li&gt;
      &lt;li&gt;A에 의해 잠긴 뮤텍스에 대해 A가 다시 잠금을 시도하면 deadlock이 발생하여 A는 영원히 블록 상태가 됨​&lt;/li&gt;
      &lt;li&gt;이러한 현상을 피하기 위해 pthread_mutex_trylock()을 사용​&lt;/li&gt;
      &lt;li&gt;Mutex를 얻지 못하는 경우 블록되지 않고 바로 리턴되고 EBUSY 에러 발생​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;잠금되어 있는 않은 mutex에 잠금해제를 시도하면 아무 동작을 하지 않음​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Mutex의 삭제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;더 이상 mutex를 사용하지 않을 때 삭제​&lt;/li&gt;
  &lt;li&gt;잠금 상태의 mutex를 삭제하려 시도하면 에러 발생​
    &lt;ul&gt;
      &lt;li&gt;EBUSY 에러 발생​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Mutex의 현재 상태(잠금, 잠금해제) 확인 함수는 없음​&lt;/li&gt;
  &lt;li&gt;안전하게 mutex를 삭제하기 위해서는 삭제 전에 무조건 mutex를 해제해야 함​&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pthread_mutex_unlock(&amp;amp;mutex);​
pthread_mutex_destory(&amp;amp;mutex);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Mutex와 deadlock&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Deadlock​
    &lt;ul&gt;
      &lt;li&gt;두 개의 스레드가 두 개의 mutex를 사용​&lt;/li&gt;
      &lt;li&gt;각 스레드가 mutex를 하나씩 잠그고 있는 상태에서 상대방의 mutex 해제를 기다리는 현상​&lt;/li&gt;
      &lt;li&gt;deadlock이 발생하면 프로그램은 영원히 블록​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Deadlock을 피하는 방법​
    &lt;ul&gt;
      &lt;li&gt;Mutex를 잠그는데 일정한 순서를 정하여 사용​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;성능​
    &lt;ul&gt;
      &lt;li&gt;Mutex를 많이 사용하면 프로그램의 성능이 저하됨​&lt;/li&gt;
      &lt;li&gt;Mutex를 얻은 상태에서 처리하는 작업의 양(Critical Section)을 최소화 해야 함​
        &lt;ul&gt;
          &lt;li&gt;Mutex가 잠긴 동안 다른 스레드가 블록될 가능성이 높으며 Critical Section이 길수록 전체 프로그램 성능이 저하될 수 있음​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;다른 data structure에 대해서는 다른 lock을 적용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Spin Lock​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Mutex lock 과 달리, lock을 얻을때까지 CPU cycle을 소비하면서 계속 spinning 함​
    &lt;ul&gt;
      &lt;li&gt;Mutex lock : lock을 얻지 못하면 바로 sleep 모드로 들어감 ​&lt;/li&gt;
      &lt;li&gt;Adaptive mutex lock : 잠깐 동안 spinning 하다가 sleep 모드로 들어감 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Spin lock APIs​
    &lt;ul&gt;
      &lt;li&gt;pthread_spin_init() ​
        &lt;ul&gt;
          &lt;li&gt;PTHREAD_PROCESS_PRIVATE : 생성되는 spin lock이 프로세스에 private 하게 사용될 경우 ​&lt;/li&gt;
          &lt;li&gt;PTHREAD_PROCESS_SHARED : 다른 프로세스와 공유할 경우​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;pthread_spin_lock()​&lt;/li&gt;
      &lt;li&gt;pthread_spin_unlock()​&lt;/li&gt;
      &lt;li&gt;pthread_spin_destroy()​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;pthread_spin_trylock() ​
    &lt;ul&gt;
      &lt;li&gt;Lock을 얻으려 시도​&lt;/li&gt;
      &lt;li&gt;Lock을 얻는 경우나 얻지 못하는 경우 모두 바로 리턴&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Barrier&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Barrier: 글로벌 동기화
    &lt;ul&gt;
      &lt;li&gt;특히 SPMD(동일한 기능의 여러 복사본을 병렬로 실행할 때)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Simple use of barriers: all threads hit the same one​
    &lt;ul&gt;
      &lt;li&gt;work_on_my_subgrid();​&lt;/li&gt;
      &lt;li&gt;barrier;​&lt;/li&gt;
      &lt;li&gt;read_neighboring_values();​&lt;/li&gt;
      &lt;li&gt;barrier;​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;more complicated: barriers on branches (or loops)​
    &lt;ul&gt;
      &lt;li&gt;if (thread_id % 2 == 0) {​&lt;/li&gt;
      &lt;li&gt;work1();​&lt;/li&gt;
      &lt;li&gt;barrier; } ​&lt;/li&gt;
      &lt;li&gt;else ​&lt;/li&gt;
      &lt;li&gt;barrier;​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 스레드 라이브러리에 Barrier가 제공되지 않는다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Barrier APIs​
    &lt;ul&gt;
      &lt;li&gt;pthread_barrier_init(&amp;amp;barrier, attr, no_of_threads)
        &lt;ul&gt;
          &lt;li&gt;pthread_barrier_t  barrier;&lt;/li&gt;
          &lt;li&gt;Default value of attr is “NULL”&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;pthread_barrier_destroy(&amp;amp;barrier)&lt;/li&gt;
      &lt;li&gt;pthread_barrier_wait(&amp;amp;barrier)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;semaphore&quot;&gt;&lt;strong&gt;Semaphore&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Semaphore : counting and signaling mechanism
    &lt;ul&gt;
      &lt;li&gt;지정된 개수의 아이템들을 위한 접근 제어에 활용
        &lt;ul&gt;
          &lt;li&gt;아이템 개수가 하나이면 mutex와 동일​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;스레드간에 신호를 보내는 역할​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;두 종류의 semaphore​
    &lt;ul&gt;
      &lt;li&gt;Named semaphore​&lt;/li&gt;
      &lt;li&gt;Unnamed semaphore&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Unnamed semaphore의 초기화​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;sem_t *sem;​&lt;br /&gt;
int sem_init(sem_t *sem, int pshared, unsigned int value);&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;sem : 세마포어 객체​&lt;/li&gt;
  &lt;li&gt;pshared : 다른 스레드와 공유할 것인지의 여부​&lt;/li&gt;
  &lt;li&gt;value : 세마포어의 초기값​&lt;/li&gt;
  &lt;li&gt;예 : sem_init(&amp;amp;sem, 0, 10)​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Unnamed semaphore의 종료​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;sem_destroy(&amp;amp;sem)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Named semaphore의 초기화​
    &lt;ul&gt;
      &lt;li&gt;sem_open(sem_name, FLAGS, permission, value)​&lt;/li&gt;
      &lt;li&gt;예 : sem_open(“/my_sem”, O_CREAT, 0777, 10)​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Named semaphore의 종료​
    &lt;ul&gt;
      &lt;li&gt;sem_close(sem) : semaphore와의 연결을 끊지만, 시스템 상에 semaphore를 남겨둠​&lt;/li&gt;
      &lt;li&gt;sem_unlink(sem_name) : semaphore에 사용된 resource를 free 시킴&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;세마포어의 값을 감소시키는 함수 ​
    &lt;ul&gt;
      &lt;li&gt;크리티컬 영역에 진입하면서 자동으로 세마포어의 값을 감소(-1)시킴&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;int sem_wait(sem_t *sem);​&lt;br /&gt;
int sem_trywait(sem_t *sem);&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;세마포어의 값을 1 증가시키는 함수&lt;br /&gt;
int sem_post(sem_t *sem);&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;현재 세마포어의 값을 읽는 함수&lt;br /&gt;
int sem_getvalue(sem_t *sem, int *sval);&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;conditional-variable&quot;&gt;&lt;strong&gt;Conditional Variable&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;조건변수​
    &lt;ul&gt;
      &lt;li&gt;스레드 간에 특정 조건이 발생했음을 알리는 통신을 위해 사용​&lt;/li&gt;
      &lt;li&gt;조건변수는 반드시 mutex와 함께 사용되어야 한다​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;조건변수의 생성​
    &lt;ul&gt;
      &lt;li&gt;함수를 이용한 초기화와 매크로를 이용한 초기화 방법이 있음​&lt;br /&gt;
pthread_cond_t cond;​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;pthread_cond_init(&amp;amp;cond, NULL); // 함수를 이용한 초기화​&lt;/p&gt;

&lt;p&gt;pthread_cond_t cond = PTHREAD_COND_INITIALIZER; // 매크로를 이용​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;조건변수의 삭제​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;pthread_cond_destory(&amp;amp;cond);&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;조건변수를 기다리는 함수​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;cond : 조건 알림이 발생할 때까지 대기​&lt;/li&gt;
  &lt;li&gt;mutex : mutex가 cond를 제어​&lt;/li&gt;
  &lt;li&gt;동작​
    &lt;ul&gt;
      &lt;li&gt;Mutex 해제 -&amp;gt; 블록 상태 -&amp;gt; 조건 알림을 받음 -&amp;gt; 깨어나면서 mutex를 얻음​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;조건 알림을 보내는 함수​
int pthread_cond_signal(pthread_cond_t *cond);&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;조건 변수 cond에 의해 기다리던 조건이 발생했음을 대기하고 있는 스레드에게 통보​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;하나의 생산자 스레드와 여러개의 소비자 스레드가 있는 경우​
    &lt;ul&gt;
      &lt;li&gt;pthread_cond_signal() 함수를 사용하면 단 하나의 스레드만 깨우고 나머지 스레드는 영원히 기다릴 가능성이 있음​&lt;/li&gt;
      &lt;li&gt;pthread_cond_broadcast()를 사용​
        &lt;ul&gt;
          &lt;li&gt;여러 스레드를 동시에 깨움​&lt;/li&gt;
          &lt;li&gt;깨어난 스레드들 중 공유 데이터를 위한 mutex를 얻은 스레드만이 공유 데이터에 접근​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Producer-Consumer 예제 ​
    &lt;ul&gt;
      &lt;li&gt;Queue를 사용​
        &lt;ul&gt;
          &lt;li&gt;생산자 스레드는 queue에 메시지 쓰기 작업을 수행​&lt;/li&gt;
          &lt;li&gt;소비자 스레드는 queue에서 메시지 읽기 작업을 수행​&lt;/li&gt;
          &lt;li&gt;운영체제의 scheduler는 생산자와 소비자 스레드가 교대로 실행되는 것을 보장하지 않음​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;조건변수를 사용하여 queue의 길이가 0보다 클 경우 소비자 스레드를 깨움​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="system" />
      

      
        <summary type="html">POSIX Thread Programming</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">__방화벽__</title>
      <link href="https://lee989898.github.io/sc-17" rel="alternate" type="text/html" title="__방화벽__" />
      <published>2021-11-24T01:06:00+09:00</published>
      <updated>2021-11-24T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-17</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-17">&lt;h3 id=&quot;방화벽&quot;&gt;&lt;strong&gt;방화벽&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Firewalls?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;조직의 내부망을 외부 인터넷과 격리시켜 일부 패킷은 통과시키고 나머지는 차단하는 HW와 SW의 조합&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc24.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Firewall 서비스&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Traffic monitoring​&lt;/li&gt;
  &lt;li&gt;Traffic control​&lt;/li&gt;
  &lt;li&gt;NAT – 내부 network 보호​&lt;/li&gt;
  &lt;li&gt;VPN – 내부 traffic 노출차단&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Firewalls을 쓰는 이유&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;서비스 거부 공격 방지:
    &lt;ul&gt;
      &lt;li&gt;SYN 플러딩: 공격자가 많은 가짜 TCP 연결을 설정하고 “실제” 연결을 위한 리소스가 남지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;내부 데이터의 불법적인 수정/접근을 방지한다
    &lt;ul&gt;
      &lt;li&gt;예: 공격자가 CIA의 홈페이지를 다른 것으로 교체&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;내부 네트워크(인증된 사용자/호스트 집합)에 대한 승인된 액세스만 허용&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Firewall types&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;Stateless packet filter​&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;지나는 packet에 대해 미리 정의된 규칙에 따라 pass/block 결정​&lt;/li&gt;
  &lt;li&gt;Packet의 다음 정보를 기반으로 결정​
    &lt;ul&gt;
      &lt;li&gt;source IP address, destination IP address​&lt;/li&gt;
      &lt;li&gt;TCP/UDP source and destination port numbers​&lt;/li&gt;
      &lt;li&gt;ICMP message type​&lt;/li&gt;
      &lt;li&gt;TCP SYN and ACK bits​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;example 1: block incoming and outgoing BitTorrent traffic source or dest port = 6881-6889​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;example 2: Block outbound Web access, port=80.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ACL: 규칙이 있는 테이블, 들어오는 패킷에 위에서 아래로 적용: (액션, 조건) pair&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;장점​
    &lt;ul&gt;
      &lt;li&gt;Simple : 동작방식이 직관적이며 간단, 구현용이​&lt;/li&gt;
      &lt;li&gt;Fast​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;application layer protocol의 취약점공격에 차단 불가능​&lt;/li&gt;
      &lt;li&gt;사용자/application 별 서비스 제공불가능 ​&lt;/li&gt;
      &lt;li&gt;필터링시 사용 정보가 제한되어서 정교한 필터링 불가능​&lt;/li&gt;
      &lt;li&gt;IP주소 위변조 여부 판단 불가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Statefull packet filter​&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;동일한 상태정보를 가지는 패킷들을(packet flow) 그룹으로 필터링​
    &lt;ul&gt;
      &lt;li&gt;상태정보: src IP/port, dst IP/port ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점​
    &lt;ul&gt;
      &lt;li&gt;정교한 필터링​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;상태정보 테이블 검사수행에 따른 성능저하​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Application gateway&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;애플리케이션 데이터 및 IP/TCP/UDP 필드에서 패킷을 필터링한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;장점​
    &lt;ul&gt;
      &lt;li&gt;Application layer protocol 공격 차단​&lt;/li&gt;
      &lt;li&gt;사용자 인증가능​&lt;/li&gt;
      &lt;li&gt;정교한 Log, audit 가능​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;응용 프로그램마다 다른 응용 프로그램 게이트웨이가 필요하다(텔넷, http, ftp, 이메일 …)&lt;/li&gt;
      &lt;li&gt;모든 데이터가 게이트웨이를 통과하기 때문에 성능이 저하됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;방화벽 및 게이트웨이의 한계&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;IP spoofing: 라우터는 데이터가 “실제로” 청구된 소스에서 오는지 알 수 없다&lt;/li&gt;
  &lt;li&gt;여러 앱의 경우. 특별한 대우가 필요하며 각각의 앱이 있다&lt;/li&gt;
  &lt;li&gt;클라이언트 소프트웨어는 게이트웨이에 접속하는 방법을 알아야 한다.
    &lt;ul&gt;
      &lt;li&gt;예를 들어, 웹 브라우저에서 프록시의 IP 주소를 설정해야 한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;내부 공격자 방어에 취약​&lt;/li&gt;
  &lt;li&gt;데이터 내용은 미확인 – 문서 등 내부에 심겨진 악성코드 방어 취약&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">방화벽</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">__침입탐지__</title>
      <link href="https://lee989898.github.io/sc-16" rel="alternate" type="text/html" title="__침입탐지__" />
      <published>2021-11-24T01:06:00+09:00</published>
      <updated>2021-11-24T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-16</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-16">&lt;h3 id=&quot;침입탐지&quot;&gt;&lt;strong&gt;침입탐지&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;IDS(침입탐지 시스템)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;침입탐지시스템​&lt;/li&gt;
  &lt;li&gt;침입행위에 대한 탐지를 수행하고 탐지시 대응할 수 있도록 지원하는 일련의 시스템​&lt;/li&gt;
  &lt;li&gt;Intrusion?​
    &lt;ul&gt;
      &lt;li&gt;시스템에 허가되지 않은 방법으로 내부 자원에 접근​&lt;/li&gt;
      &lt;li&gt;Login 시도 (ID, PWD 추측)​&lt;/li&gt;
      &lt;li&gt;불법적으로 데이터 도용시도 (rootkit)​&lt;/li&gt;
      &lt;li&gt;Root/관리자 권한 획득시도​&lt;/li&gt;
      &lt;li&gt;메일발송 실행파일을 숨겨놓고 메일전송시도​&lt;/li&gt;
      &lt;li&gt;Backdoor 접근시도&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;패킷 필터링
    &lt;ul&gt;
      &lt;li&gt;오직 TCP/IP 헤더만 본다&lt;/li&gt;
      &lt;li&gt;패킷 간의 연관성을 알아 내기 어렵다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;IDS
    &lt;ul&gt;
      &lt;li&gt;depp packet inspection: 패킷 콘테츠 까지 검사한다&lt;/li&gt;
      &lt;li&gt;다수의 패킷을 검사한다
        &lt;ul&gt;
          &lt;li&gt;port scanning&lt;/li&gt;
          &lt;li&gt;network mapping&lt;/li&gt;
          &lt;li&gt;Dos attack&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Dectection 방법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;Signature-based dectection​
    &lt;ul&gt;
      &lt;li&gt;침입사건들을 패턴화(signature)​
    + Signature example​&lt;/li&gt;
      &lt;li&gt;실행 파일 첨부 메일 유형​&lt;/li&gt;
      &lt;li&gt;파일 읽기 시도 유형​&lt;/li&gt;
      &lt;li&gt;로그인 시도 유형​
    + 장점​&lt;/li&gt;
      &lt;li&gt;known attack에 대해 효율적​
    + 단점​&lt;/li&gt;
      &lt;li&gt;Unknown attack에 취약​&lt;/li&gt;
      &lt;li&gt;새로운 공격유형 발견때마다 signature 생성해야​&lt;/li&gt;
      &lt;li&gt;일반적으로 False negative rate 높음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Anomaly-based dectection​
    &lt;ul&gt;
      &lt;li&gt;정상범위를 벗어나는 사건을 탐지​
    + Anomaly example​&lt;/li&gt;
      &lt;li&gt;휴일에 traffic 량이 평소보다 20%증가​&lt;/li&gt;
      &lt;li&gt;일반사용자가 갑자기 1000통 메일발송​&lt;/li&gt;
      &lt;li&gt;특정 호스트에 단시간 주문요청 100%증가​&lt;/li&gt;
      &lt;li&gt;국내 사용자 카드가 해외에서 결재​
    + 장점​&lt;/li&gt;
      &lt;li&gt;Machine learning 처리​&lt;/li&gt;
      &lt;li&gt;Unknown attac에 대해 효율적​
    + 단점​&lt;/li&gt;
      &lt;li&gt;정상범위 정의 어려움​&lt;/li&gt;
      &lt;li&gt;비정상탐지까지 기다려야​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;IDS types&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;Network-based IDS​&lt;/li&gt;
  &lt;li&gt;Wireless IDS (wireless IDS)​&lt;/li&gt;
  &lt;li&gt;Host-based IDS​&lt;/li&gt;
  &lt;li&gt;Distributed Host-based IDS&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Network-based IDS​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Example​
    &lt;ul&gt;
      &lt;li&gt;Network 망에 곳곳에 traffic을 모니터, 분석하여 침입탐지​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Example​
    &lt;ul&gt;
      &lt;li&gt;Ddos, worm  ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점 ​
    &lt;ul&gt;
      &lt;li&gt;Host는 부하적음 (하나의  NIDS로 여러 host보호)​&lt;/li&gt;
      &lt;li&gt;조기 탐지가능​&lt;/li&gt;
      &lt;li&gt;취약한 부분의 packet 을 정밀분석하여 다양한 침입탐지 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;각 host 내부는 탐지제한​&lt;/li&gt;
      &lt;li&gt;전체 network 망에 부하&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Wireless IDS (wireless IDS)​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무선통신 WLAN network망의 traffic 분석​&lt;/li&gt;
  &lt;li&gt;장점​
    &lt;ul&gt;
      &lt;li&gt;무선통신의 취약성위협 탐지​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;Network 부하, 비용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Host-based IDS​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;특정 host 컴퓨터내부를 모니터링, 분석하여 탐지​&lt;/li&gt;
  &lt;li&gt;Example​
    &lt;ul&gt;
      &lt;li&gt;로그분석, 파일시스템 기록분석, 실행코드분석 ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점​
    &lt;ul&gt;
      &lt;li&gt;악성sw 탐지용이​&lt;/li&gt;
      &lt;li&gt;내부공격자 탐지​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;각 host마다 다름​&lt;/li&gt;
      &lt;li&gt;Host 부하&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Distributed Host-based IDS&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;여러 HIDS들이 연계하여 전체적으로 host들을 분석하여 탐지 ​&lt;/li&gt;
  &lt;li&gt;장점​
    &lt;ul&gt;
      &lt;li&gt;효율적이고 정확성​&lt;/li&gt;
      &lt;li&gt;공격들의 연관관계 파악용이​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점​
    &lt;ul&gt;
      &lt;li&gt;HIDS보다 복잡, 부담&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Honey Pot&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;꿀단지​&lt;/li&gt;
  &lt;li&gt;의도적으로 해커의 침입을 유도하는 시스템​&lt;/li&gt;
  &lt;li&gt;해커 정보수집, 공격유형파악, 대응전략수립, 법적증거 ​&lt;/li&gt;
  &lt;li&gt;침입자 활동감시, 로그기록&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;IDS 평가 기준&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;False Positive rate​
    &lt;ul&gt;
      &lt;li&gt;정상을 침입으로 판단하는 확률​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;False Negative​
    &lt;ul&gt;
      &lt;li&gt;침입을 정상으로 판단하는 확률​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;True Positive rate​&lt;/li&gt;
  &lt;li&gt;True Negative rate​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;IPS (Intrusion Prevention System)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;침입방지시스템​&lt;/li&gt;
  &lt;li&gt;IDS+침입방지기능​&lt;/li&gt;
  &lt;li&gt;Example​
    &lt;ul&gt;
      &lt;li&gt;IDS로 침입탐지하고 계정, 연결 등 차단​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">침입탐지</summary>
      

      
      
    </entry>
  
</feed>
