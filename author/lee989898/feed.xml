<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://lee989898.github.io/author/lee989898/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://lee989898.github.io/" rel="alternate" type="text/html" />
  <updated>2021-11-02T00:24:33+09:00</updated>
  <id>https://lee989898.github.io/author/lee989898/feed.xml</id>

  
  
  

  
    <title type="html">LEE | </title>
  

  
    <subtitle>공부 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">Process_Control</title>
      <link href="https://lee989898.github.io/st-01" rel="alternate" type="text/html" title="Process_Control" />
      <published>2021-10-31T01:06:00+09:00</published>
      <updated>2021-10-31T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/st-01</id>
      <content type="html" xml:base="https://lee989898.github.io/st-01">&lt;h3 id=&quot;process-control&quot;&gt;&lt;strong&gt;Process Control&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;exec&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;프로세스가 exec 함수 중 하나를 호출할 때&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로세스는 새 프로그램으로 완전히 대체된다. 텍스트, 데이터, 힙 및 스택 세그먼트를 부모의 주소 공간에 로드한다.&lt;/li&gt;
  &lt;li&gt;새 program은 main function에서 시작한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;새 program은 caller와 동일한 PID를 사용한다.&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;
main()
{ printf(&quot;execiton ls\n&quot;)};
execl(&quot;/bin/ls&quot;,&quot;ls&quot;,&quot;-l&quot;, (char *)0);
perror(&quot;execl failed to run ls\n&quot;);
exit(1);}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;exec: Program Execution&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스 실행을 맡고 있는 시스템 콜은 execve()이다&lt;/li&gt;
  &lt;li&gt;같은 기능을 하면서 라이브러리 함수로 분류되어 있는것으로 execv(), execvp(), execle(), execl(), execlp()가 있다 ​&lt;/li&gt;
  &lt;li&gt;이 6가지를 합쳐서 exec()시스템 콜이라 부른다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;exec() 이후에 오는 문자에 의해 구별되는 표시는 다음의 의미가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;l -&amp;gt; argv 정보를 개개의 문자열 데이터를 가르키는 포인터 arg0,arg1……. argn으로 전달한다&lt;/li&gt;
  &lt;li&gt;v -&amp;gt; argv 정보를 개개의 문자열 데이터를 가리키는 포인터 배열의 ​
선두주소 argv로 전달한다​&lt;/li&gt;
  &lt;li&gt;e -&amp;gt; envp 정보를 전달한다​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;p -&amp;gt; p를 사용하는 경우, 실행할 파일이름을 환경 변수 PATH로 지정한 디렉토리 안에서 찾아내어 실행한다​&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int execl(const char *path, const char *arg0, ... *argn,
(char *)0);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;path: 실행 가능한 파일 경로&lt;/li&gt;
  &lt;li&gt;arg0~argn: 파일에 전달한 argv 정보(명령 인수)&lt;/li&gt;
  &lt;li&gt;(char*)0: 마지막임을 알리는 표시로 NULL 포인터&lt;/li&gt;
  &lt;li&gt;리턴값: 에러시 -1&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;execl.c&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include&amp;lt;unistd.h&amp;gt;

main(int argc, char *argv[]){
    execl(&quot;/bin/ls&quot;,&quot;ls&quot;,argv[1],(char *)0);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;execv.c&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include&amp;lt;unistd.h&amp;gt;
main(){
    char *av[3];

    av[0]=&quot;ls&quot;;
    av[1]=&quot;-1&quot;;
    av[2]=(char *)0;

    execv(&quot;/bin/ls&quot;,av);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;execle()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; #include &amp;lt;unistd.h&amp;gt;

 int execle(const char *path, const char *arg0...*argn,
                    (char *)0, char *const envp[]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;path: 파일의 경로명&lt;/li&gt;
  &lt;li&gt;arg0 ~ argn: 파일에 전달한 argv 정보(명령 인수)&lt;/li&gt;
  &lt;li&gt;envp[]: envp 정보(환경변수)&lt;/li&gt;
  &lt;li&gt;리턴 값: 에러시 -1&lt;/li&gt;
  &lt;li&gt;execl()에 환경 변수 정보를 전달하는 기능을 추가한 것&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;execve()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int execve(const char* path, char *const argv[],
                char *const envp[]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;path: 파일의 경로명&lt;/li&gt;
  &lt;li&gt;argv: 파일에 전달한 argv 정보(명령 인수)&lt;/li&gt;
  &lt;li&gt;envp[]: envp 정보(환경변수)&lt;/li&gt;
  &lt;li&gt;리턴 값: 에러시 -1&lt;/li&gt;
  &lt;li&gt;execv()에 환경 변수 정보를 전달하는 기능을 추가한 것&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;execlp()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int execlp(const char *file, const char *arg0, .... *argn);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;file: 실행하는 파일의 파일 이름&lt;/li&gt;
  &lt;li&gt;arg0 ~ argn: 파일에 전달한 argv 정보(명령 인수)&lt;/li&gt;
  &lt;li&gt;리턴 값: 에러시 -1&lt;/li&gt;
  &lt;li&gt;execlp()는 첫 번째 인자 file에서 지정한 파일 이름을 환경 변수 PATH에서 지정하고 있는 디렉토리 안에서 찾아 실행한다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;execvp()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;

int execvp(const char *file, char *const argv[]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;file: 실행하는 파일의 파일 이름&lt;/li&gt;
  &lt;li&gt;argv: 파일에 전달한 argv 정보(명령 인수)&lt;/li&gt;
  &lt;li&gt;리턴 값: 에러시 -1&lt;/li&gt;
  &lt;li&gt;execlp()는 첫 번째 인자 file에서 지정한 파일 이름을 환경 변수 PATH에서 지정하고 있는 디렉토리 안에서 찾아 실행한다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Race Conditions&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;여러 프로세스가 일부 데이터를 공유&lt;/li&gt;
  &lt;li&gt;결과는 실행 순서(예: RACE)에 따라 다르다&lt;/li&gt;
  &lt;li&gt;fork() 후에는 부모 또는 자식이 먼저 실행되는지 예측할 수 없다&lt;/li&gt;
  &lt;li&gt;실행 순서는 다음에 따라 다르다
    &lt;ul&gt;
      &lt;li&gt;시스템 부하&lt;/li&gt;
      &lt;li&gt;커널의 스케줄링 알고리즘&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Race condition 문제는 대부분의 시간 작동하기 때문에 감지하기 어렵다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;after fork
    &lt;ul&gt;
      &lt;li&gt;parent,child 모두 스스로 무언가를 한다&lt;/li&gt;
      &lt;li&gt;예를 들어 parent: 로그 파일에 기록 쓰기&lt;/li&gt;
      &lt;li&gt;예를 들어 child: 로그 파일 생성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;parent,child는 다음을 수행해야 한다
    &lt;ul&gt;
      &lt;li&gt;초기 작업 세트가 완료되면 서로 알리고&lt;/li&gt;
      &lt;li&gt;서로 완료될 때까지 기다린다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;system()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;

int system(const char *cmdstring);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;문자열이 터미널에서 명령으로 입력된 것처럼 문자열이 sh(1)에 입력으로 제공한다. ex) system(“date &amp;gt; file”);&lt;/li&gt;
  &lt;li&gt;fork, exec 및 waitpid를 호출하여 시스템을 구현한다.&lt;/li&gt;
  &lt;li&gt;반환 값:
    &lt;ul&gt;
      &lt;li&gt;-1 with errno: fork 또는 waitpid 실패&lt;/li&gt;
      &lt;li&gt;127 : 실행 실패&lt;/li&gt;
      &lt;li&gt;쉘 종료 상태: 3개 모두 성공&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Process Times&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/times.h&amp;gt;

clock_t times(struct tms *buf);

struct tms(
    clock_t tms_utime;
    clock_t tms_stime;
    clock_t tms_cutime;
    clock_t tms_cstime;
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;wall clock time: 프로세스가 실행되는 데 걸리는 시간이며 시스템 부하에 따라 다르다.
    &lt;ul&gt;
      &lt;li&gt;반환된 wall clock time의 시간은 과거의 임의의 지점에서 측정된다. 상대 값을 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자 CPU 시간: 사용자 지침에 기인&lt;/li&gt;
  &lt;li&gt;시스템 CPU 시간: 프로세스를 대신하여 실행될 때 커널에 귀속됨&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="system" />
      

      
        <summary type="html">Process Control</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">이메일 보안</title>
      <link href="https://lee989898.github.io/sc-03" rel="alternate" type="text/html" title="이메일 보안" />
      <published>2021-10-31T01:06:00+09:00</published>
      <updated>2021-10-31T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-03</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-03">&lt;h3 id=&quot;이메일-보안&quot;&gt;&lt;strong&gt;이메일 보안&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;PGP&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;운영체제에 상관없이 확정성이 뛰어나다&lt;/li&gt;
  &lt;li&gt;S/MIME&lt;/li&gt;
  &lt;li&gt;공개키 기반의 프로토콜이다&lt;/li&gt;
  &lt;li&gt;RSA, El Gamel을 사용한다&lt;/li&gt;
  &lt;li&gt;대칭키 방식과도 연동된다(3DES)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Requirements of secure E-mail&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;기밀성&lt;/li&gt;
  &lt;li&gt;송신자 인증&lt;/li&gt;
  &lt;li&gt;메시지 무결성&lt;/li&gt;
  &lt;li&gt;수신자 인증&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Secure e-mail: 기밀성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc10.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;앨리스는 기밀성을 입증한 e-mail, m을 밥에게 보내고 싶다&lt;/li&gt;
  &lt;li&gt;랜덤 대칭키를 생성한다, K&lt;sub&gt;S&lt;/sub&gt;&lt;/li&gt;
  &lt;li&gt;메시지를  K&lt;sub&gt;S&lt;/sub&gt;로 encrypt한다&lt;/li&gt;
  &lt;li&gt;또한 K&lt;sub&gt;S&lt;/sub&gt;를 밥의 공개키로 encrypt한다&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;밥에게 K&lt;sub&gt;S&lt;/sub&gt;(m)과 K&lt;sub&gt;B&lt;/sub&gt;(K&lt;sub&gt;S&lt;/sub&gt;)를 보낸다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;밥은 그의 private키로 decrypt하여 K&lt;sub&gt;S&lt;/sub&gt;를 찾아낸다&lt;/li&gt;
  &lt;li&gt;K&lt;sub&gt;S&lt;/sub&gt;로 K&lt;sub&gt;S&lt;/sub&gt;(m)을 decrypt하여 m을 찾아낸다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Secure e-mail: 송신자 인증, 무결성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc11.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;앨리스는 송신자 인증과 메시지 무결성을 지키고 싶다&lt;/li&gt;
  &lt;li&gt;앨리스는 메세지를 digitally 사인한다&lt;/li&gt;
  &lt;li&gt;메시지와 디지털 시그니처 모두 보낸다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Secure e-mail: all together&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc12.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;앨리스는 보안,송신자 인증,메시지 무결성을 지키고 싶다&lt;/li&gt;
  &lt;li&gt;앨리스는 3가지 키를 사용한다
    &lt;ul&gt;
      &lt;li&gt;그녀의 private key&lt;/li&gt;
      &lt;li&gt;밥의 public key&lt;/li&gt;
      &lt;li&gt;새로 만들어진 대칭키&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Email 보안 표준&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;PGP&lt;/li&gt;
  &lt;li&gt;S/MIME
    &lt;ul&gt;
      &lt;li&gt;이메일을 위해 MIME에 보안서비스 제공 표준&lt;/li&gt;
      &lt;li&gt;인증,무결성,부인방지,기밀성 제공&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc09.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">이메일 보안</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">signature</title>
      <link href="https://lee989898.github.io/sc-02" rel="alternate" type="text/html" title="signature" />
      <published>2021-10-31T01:06:00+09:00</published>
      <updated>2021-10-31T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-02</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-02">&lt;h3 id=&quot;signature&quot;&gt;&lt;strong&gt;signature&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;서명&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;자기의 동일성을 표시하고 책임을 분명하기 하기 위하여 문서 따위에 자기 이름을 써넣음​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;전자서명의 기본 아이디어&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;송신자(alice)는 자신의 비밀키로 암호화​&lt;/li&gt;
  &lt;li&gt;수신자는 송신자의 공개키로 복호화&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;시나리오:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ Bob은 public key를 공개된 장소에 두고, private key는 자신이 가지고 있다
+ Alice는 Bob의 public key를 가져와, 메시지를 암호화해서 전송​
+ 이 메시지는 다른 사람이 보더라도 풀 수 없다. 메시지를 복호화하려면 Bob의 private key가 필요하기 때문-&amp;gt;기밀성보장​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;문제점1. Bob은 Alice가 메시지를 작성했다는것을 확신할 수 있을까? NO​&lt;/li&gt;
  &lt;li&gt;문제점2. Bob은 메시지가 중간에 변경되지않았다는것을 확신할 수 있을까? NO​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;해결법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Alice는 메시지로 MAC을 만들고, 이것을 Alice가 자신의 private key로 암호화 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc05.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;만들어진 것을 본래 메시지에 붙인다 -&amp;gt; 서명&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc06.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이것을 Bob의 public key로 암호화 해서 전송&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;다른 사람은 Bob의 private key가 없으므로 볼수없다 -&amp;gt; 기밀성​&lt;/li&gt;
  &lt;li&gt;Bob은 자신의 private key로 열면 평문과 시그니쳐가 나온다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc07.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Bob은 다음과 같이 무결성,인증을 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc08.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">signature</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Signal</title>
      <link href="https://lee989898.github.io/st-02" rel="alternate" type="text/html" title="Signal" />
      <published>2021-10-31T01:06:00+09:00</published>
      <updated>2021-10-31T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/st-02</id>
      <content type="html" xml:base="https://lee989898.github.io/st-02">&lt;h3 id=&quot;signal&quot;&gt;&lt;strong&gt;Signal&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="system" />
      

      
        <summary type="html">Signal</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">서브프로그램</title>
      <link href="https://lee989898.github.io/pl-16" rel="alternate" type="text/html" title="서브프로그램" />
      <published>2021-10-29T19:18:00+09:00</published>
      <updated>2021-10-29T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-16</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-16">&lt;h3 id=&quot;서브프로그램&quot;&gt;&lt;strong&gt;서브프로그램&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Fundamentals of Subprograms&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서브프로그램이 무엇인지 왜 필요한지 살펴 보자.&lt;br /&gt;
동일한 코드 부분(segment)이 프로그램의 여러 곳에서 나타난다고 하면, 이 코드를 여러 곳에 중복해서 코딩하기보다는,​
한번만 코딩하고, 필요할 때마다 그 코드 부분으로 점프했다가 끝나면 되돌아 오는 방식으로, 프로그램을 짤 수 있다.&lt;br /&gt;
이러한 코드 부분을 서브프로그램이라고 한다.&lt;br /&gt;
동일한 코드 부분이 프로그램의 여러 곳에 나타나고, ​나타나는 곳마다 사용되는 변수가 다르다고 가정해 보자.&lt;br /&gt;
이때 파라미터를 갖는 서브프로그램을 사용할 수 있다.&lt;br /&gt;
서브프로그램의 개념은 쓰레드와 같은 것으로 발전하고 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;서브프로그램은 다음과 같은 특징을 갖는다. ​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;각 서브 프로그램은 단하나의 진입점을 갖는다. ​&lt;/li&gt;
  &lt;li&gt;호출한 서브프로그램(caller)는 호출된 서브프로그램(callee)의 실행 중에는 중지된다. ​&lt;/li&gt;
  &lt;li&gt;Callee가 종료되면, 컨트롤을 항상 caller에게 되돌려준다.  ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서브프로그램은 정의부와 선언부로 구성된다.&lt;br /&gt;
서브프로그램 정의부는 서브프로그램의 인터페이스와 액션을 서술하고, ​정의부의 맨앞에는 서브프로그램의 헤더가 있다.&lt;br /&gt;
헤더는 void adder(parameter) 처럼 서브프로그램 이름, 유형, 포말 파라미터 등을 포함한다. &lt;br /&gt;
포말 파라미터의 개수, 순서, 타입을 파라미터의 프로파일(시그니처, 요약)이라고 부른다. ​&lt;/p&gt;

&lt;p&gt;서브프로그램 선언부는 파라미터 프로파일과 반환 타입을 선언한다.&lt;br /&gt;
서브프로그램 호출(call)은 서브프로그램으로 점프한다. ​&lt;/p&gt;

&lt;p&gt;서브프로그램에서 데이터에 접근하는 방법은 두가지가 있다.
 ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;난로컬 변수에 직접 접근하는 경우 ​&lt;/li&gt;
  &lt;li&gt;파라미터 패싱을 사용하는 경우 ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파라미터 패싱을 사용하여 데이터를 접근할 때에는 ​로컬 변수명을 사용한다.&lt;br /&gt;
난로컬 변수에 직접 접근하는 것보다 융통성이 높아 파라미터화에 의한 계산이 가능하다.&lt;br /&gt;
난로컬 변수에 대한 광범위한 접근은 부작용으로 인해 신뢰성을 감소시킨다. ​&lt;br /&gt;
순수 함수 언어는 수정 가능한 데이터를 허용하지 않으며, 메모리 내용을 변경할 수 없도록 제한한다. ​&lt;/p&gt;

&lt;p&gt;포말 파라미터는 callee의 헤더에 있는 파라미터를 말한다.&lt;br /&gt;
서브프로그램이 호출될 때만 메모리에 바인딩되고, ​액추얼 파라미터를 통해서 바인딩되기 때문에, ​종종 더미 변수로 취급되기도 한다.&lt;br /&gt;
액추얼 파라미터는 caller에서 사용되는 값이나 주소를 나타낸다.&lt;/p&gt;

&lt;p&gt;액추얼 파라미터를 포말 파라미터에 바인딩하는 방법은 두 가지가 있다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;위치 파라미터: 파라미터의 순서가 중요 ​&lt;/li&gt;
  &lt;li&gt;키워드 파라미터: 파라미터의 이름이 중요, 순서는 중요하지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파이썬에서 sumer(my_length, list=my_array, sum = my_sum),  ​
포말 파라미터는 length, list, sum이고, ​
액추얼 파라미터는 my_length, my_array, my_sum 이라면, ​
첫번째 파라미터는 위치 파라미터이고, ​
두번째 세번째는 키워드 파라미터이다.  ​&lt;/p&gt;

&lt;p&gt;키워드 파라미터의 장점은 순서에 얽매이지 않는다는 것이고, ​
단점은 사용자가 포말 파라미터의 이름을 알고 있어야 한다는 것이다.&lt;/p&gt;

&lt;p&gt;C++, 파이썬 등에서는 액추얼 파라미터가 모두 다 패스되지 않을 경우, ​포말 파라미터는 대응되지 않는 나머지 파라미터에 대해 디폴트 값을 가질 수 있다. ​&lt;/p&gt;

&lt;p&gt;C++에서 파라미터는 위치에 연관되기 때문에 ​
디폴트 파라미터는 마지막에 나타나야 하며, ​
디폴트값은 서브프로그램 헤더에 있다. ​&lt;/p&gt;

&lt;p&gt;서브프로그램 내에 정의된 변수는 모두 로컬이며, ​
그들의 스코프는 항상 서브프로그램 안이다.&lt;br /&gt;
로컬 변수는 정적 또는 스택-동적으로 바인딩된다. ​
로컬 변수가 스택-동적이라면, ​
서브프로그램의 실행이 시작될 때 메모리에 바인딩되고, ​
실행이 끝나면 메모리에서 떨어진다. ​&lt;/p&gt;

&lt;p&gt;스택-동적 변수의 장점은, ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Recursive 서브프로그램이 스택-동적 로컬 변수를 갖는다 -&amp;gt; recursion 처리가 가능​&lt;/li&gt;
  &lt;li&gt;액티브 서브 프로그램의 로컬 변수가 ​
액티브하지 않은 서브프로그램이 해제한 로컬 변수의 메모리를 사용할 수 있다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;프로그램이 시작되고나서 아직 끝나지 않은 상태에서는 ​
자주 호출되는 서브프로그램의 실행이 끝났다고 해도 ​
그 서브 프로그램의 변수는 아직 메모리를 차지하고 있을 수 있다.&lt;br /&gt;
이때 서브프로그램의 상태를 액티브라고 한다. ​&lt;/p&gt;

&lt;p&gt;현대 언어에서, 서브프로그램의 로컬 변수는 디폴트로서 스택-동적으로 바인딩된다. ​&lt;/p&gt;

&lt;p&gt;C, C++ 함수에서, 로컬 변수는 정적이라고 명시되어 있지 않으면 스택-동적이다. ​&lt;/p&gt;

&lt;p&gt;서브프로그램이 다른 서브프로그램안에만 있어야 한다면, ​
이것을 중첩 서브프로그램이라고 한다. ​&lt;/p&gt;

&lt;p&gt;다른 서브프로그램 안에서 숨어서(hide) 다른 프로그램이 호출할 수 없게 만든다. ​&lt;/p&gt;

&lt;p&gt;서브프로그램의 중첩으로 처리 논리와 스코프의 계층구조를 생성할 수 있다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정적 스코핑의 사용 ​&lt;/li&gt;
  &lt;li&gt;알골, 파스칼에서 허용 ​&lt;/li&gt;
  &lt;li&gt;C 계열 언어는 서브프로그램의 중첩을 허용하지 않음​&lt;/li&gt;
  &lt;li&gt;자바스크립트, 파이썬 등은 중첩 허용&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Parameter-Passing Methods&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;파라미터 패싱에 대한 시맨틱 모델은 3가지가 있다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;포말 파라미터가 대응하는 액추얼 파라미터로부터 데이터를 받는 것이다. 이것을 in mode라고 한다. ​&lt;/li&gt;
  &lt;li&gt;포말 파라미터가 액추얼 파라미터에게 데이터를 보내는 것이다. 이것을 out mode라고 한다. ​&lt;/li&gt;
  &lt;li&gt;포말 파라미터가 대응하는 액추얼 파라미터로부터 데이터를 받고, 액추얼 파라미터에게 데이터를 보내는 것이다. 이것을 inout mode라고 한다.  ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파라미터간에 데이터를 주고 받는 방법은 두가지가 있다.&lt;br /&gt;
실제 값을 카피하여 주고 받는 방법과 액세스 패스(접근 경로)를 주고 받는 방법이다.&lt;/p&gt;

&lt;p&gt;파라미터 패싱 구현 모델에는 ​pass by value(in mode), pass by result(out mode), ​pass by value result(inout mode), pass by reference(inout mode)가 있다. ​&lt;/p&gt;

&lt;p&gt;Caller의 액추얼 파라미터를 Pass by value 모델로 callee에게 보낼때, 액추얼 파라미터의 값은 copy를 통해, ​대응되는 포말 파라미터의 초기화에 사용된다. ​&lt;/p&gt;

&lt;p&gt;단점은 다음과 같다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;copy 하면, ​  추가적인 메모리를 필요로하고, 실제 이동 비용이 발생한다. ​&lt;/li&gt;
  &lt;li&gt;만일 접근 경로(access path)에 의한다면, callee에서 쓰기 보호를 해야하는 동시에, ​간접 주소방식에 의한 접근 비용이 추가된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Callee의 파라미터를 pass by result 모델로 caller에게 보낼 때, ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;대응되는 포말 파라미터는 로컬 변수처럼 행동한다. ​&lt;/li&gt;
  &lt;li&gt;Callee가 종료되어 컨트롤을 caller에게 돌려주면, 포말 파라미터의 값을 caller의 액추얼 파라미터로 전달한다. ​&lt;/li&gt;
  &lt;li&gt;추가적인 메모리 위치와 copy 연산이 필요하다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pass by result에 내재하는 문제는 다음과 같다. ​&lt;/p&gt;

&lt;p&gt;Caller와 callee가 ​Caller: sub(p1, p1) actual parameter p1, p1​ Callee: sub(x, y) formal parameter x, y 라고 하자 액추얼 파라미터 두개가 p1으로 같고, ​대응하는 포말 파라미터 두개의 이름이 x, y로 다르다. ​&lt;/p&gt;

&lt;p&gt;Caller가 callee를 호출해서 callee가 실행 후 종료되고, ​
Callee가 calle에게 결과값을 반환할 때, ​
X, y 중 어느 것이 p1에 마지막으로 copy 되느냐에 따라, ​
p1의 값이 달라진다. ​
x거나 y이다. ​&lt;/p&gt;

&lt;p&gt;이것이 pass by result에 내재하는 문제이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Pass by value result는 ​pass by value와 pass by result의 결합으로 ​pass by copy라고도 부른다. ​&lt;br /&gt;
액추얼 파라미터의 값은 대응하는 포말 파라미터의 초기화에 쓰이고, ​포말 파라미터는 로컬 변수처럼 행동한다. ​&lt;br /&gt;
포말 파라미터의 값은 액추얼 파라미터에게 반환된다. ​
단점은 in, out 모두 카피에 의존. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Pass by reference 모델은 접근 통로의 패스를 통해, ​
파라미터를 패스한다. ​&lt;br /&gt;
즉, callee에게 caller의 액추얼 파라미터를 접근하도록 허용한다. &lt;br /&gt;
따라서 pass by sharing이라고도 한다. ​&lt;/p&gt;

&lt;p&gt;장점은 패싱 프로세스가 효율적이다. ​&lt;br /&gt;
Copy 연산, 메모리 모두 필요없다. ​&lt;br /&gt;
단점은 느리고, 예기치 않았던 난로컬 변수를 접근할 수도 있다. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;대부분 언어에서, 파라미터 패싱의 구현은 런타임 스택을 통해 일어난다. ​&lt;br /&gt;
C에서 파라미터 패싱은 pass by value를 지원한다.&lt;br /&gt;
포인터를 사용하면, Pass by reference를 구현할 수 있다.&lt;br /&gt;
자바는 모든 파라미터에 대해 pass by value를 지원하며,&lt;br /&gt;
객체 파라미터에 대해 pass by reference를 지원한다.&lt;/p&gt;

&lt;p&gt;파라미터에 대한 타입 검사는 ​액추얼 파라미터와 포말 파라미터 간에 타입의 일관성을 검사하는 것이다. ​&lt;br /&gt;
파라미터의 타입 검사는 소프트웨어의 신뢰성을 위해 매우 중요하다. ​&lt;br /&gt;
포트란 77, 원시 C에는 파라미터 타입 검사가 없다.&lt;br /&gt;
ANSI C, C++에는 선택적이며, ​파이썬, 루비에서는 변수가 타입을 갖지 않기 때문에 ​파라미터 타입 검사가 없다.&lt;/p&gt;

&lt;p&gt;파라미터의 타입이 다차원 배열일 경우, ​서브프로그램이 따로 컴파일되어 있고, ​다차원 배열이 서브프로그램으로 패스된다고 가정하자. ​&lt;br /&gt;
컴파일러는 메모리 매핑을 위해, ​선언된 배열의 크기를 알 필요가 있다.  ​&lt;/p&gt;

&lt;p&gt;Row-major 매트릭스의 메모리 매핑 함수는 ​&lt;/p&gt;

&lt;p&gt;address(mat[i,j]) = address(mat[0,0]) + i * #_columns + j 이다. ​&lt;/p&gt;

&lt;p&gt;즉, 컬럼의 길이만 알면 전체 크기를 알 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;현대 프로그래밍 언어에서 다차원 배열 파라미터를 어떻게 패스하는지 살펴 보자.​&lt;/p&gt;

&lt;p&gt;C, C++에서,&lt;br /&gt;
1) 프로그래머가 액추얼 파라미터의 첫번째 서브스크립트를 제외하고, ​나머지 서브스크립트의 크기를 선언하는 방법. ​&lt;/p&gt;

&lt;p&gt;슬라이드의 프로그램에서 mat은 2차원 배열이고, ​
함수 fun(mat)은 mat을 파라미터로 하는 함수이다.&lt;br /&gt;
이와 같은 방식은 서브프로그램의 유연성을 불허한다는 것이다. ​&lt;/p&gt;

&lt;p&gt;2) 이에 대한 해결책으로, ​&lt;/p&gt;

&lt;p&gt;배열에 대한 포인터, 차원 크기를 파라미터로 패스하는 방법이 있다.&lt;br /&gt;
다만, 배열 처리를 위해 ​사용자는 메모리 매핑 함수를 포함해야 하는 불편함이 있다.&lt;/p&gt;

&lt;p&gt;자바에서는 배열을 객체로 취급한다.&lt;br /&gt;
이들은 모두 일차원 배열이지만 ​배열의 각 요소가 배열일 수 있어서 ​다차원 배열을 파라미터로 쓸 수 있다.&lt;br /&gt;
자바에서 각 배열은 named constant(length와 같은)를 상속받는다.&lt;/p&gt;

&lt;p&gt;파라미터 패싱 방법의 구현시, 다음 두가지를 고려해야 한다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;효율성, ​&lt;/li&gt;
  &lt;li&gt;일방(in, out) 또는 쌍방(inout) 데이터 이동:caller-callee간에  ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러나 이들 고려사항은 서로 상충된다. ​&lt;/p&gt;

&lt;p&gt;프로그래밍을 잘하려면, 변수에 대한 접근을 가능한한 일방(in, out)으로 제한하는 것이 좋다.&lt;br /&gt;
pass by reference(inout)는 크기가 큰 데이터 스트럭처를 패스하는데 더욱 효율적인 반면, ​변수에 대한 접근을 제한하는데 문제를 일으킬 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Parameters That Are Subprograms&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이번엔 서브프로그램 이름을 파라미터로 패스하는 경우를 살펴보자. &lt;br /&gt;
종종 서브프로그램 이름을 파라미터로 패스하는 것이 편리할 때도 있다.&lt;br /&gt;
​즉, 계산을 서브프로그램으로 패스하는 것이다.&lt;/p&gt;

&lt;p&gt;파라미터 타입 검사? ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;C, C++ 함수 포인터로 패스함. ​-&amp;gt; 함수 포인터의 타입은 파라미터 타입을 포함하므로 파라미터 타입 검사는 가능함 ​&lt;/li&gt;
  &lt;li&gt;자바는 메소드 이름을 파라미터로 패스하는 것을 불허함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서브프로그램 중첩을 허용하는 언어에서, ​어떤 바인딩 방식에 의한 레퍼런싱 환경을 사용하는가? ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;쉘로우 바인딩: 패스된 서브프로그램을 실행시킨 call문(호출문)의 환경 ​&lt;/li&gt;
  &lt;li&gt;딥바인딩: 패스된 서브프로그램에 정의된 환경​&lt;/li&gt;
  &lt;li&gt;즉흥(ad hoc) 바인딩: 서브프로그램을 액추얼 파라미터로 패스한 호출문의 환경&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function sub1() {​
  var x;​
  function sub2() { alert(x); };​
  function sub3() {​
    var x; x = 3;​
    sub4(sub2); }​
  function sub4(subx) {​
    var x; x = 4;​
    subx(); }​
  x = 1;​
  sub3(); }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Sub4의 sub에 대해​&lt;/p&gt;

&lt;p&gt;쉘로우 바인딩을 했을 경우 ​
실행시킨 call문의 환경은 sub4가 되고, ​
sub4에서 x는 4이다. ​&lt;/p&gt;

&lt;p&gt;딥 바인딩을 했을 경우​
Sub2가 정의된 환경은 sub2가 되고,  ​
Sub2에서 x는 난로컬로서 sub1에 따른다. ​
따라서 x는 1이다. ​&lt;/p&gt;

&lt;p&gt;즉흥 바인딩일 경우, ​
Sub2를 파라미터로 넘긴 call문의 환경은 sub3가 되고, ​
Sub3에서 x는 3이다. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Design Issues for Functions&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;언어 설계시 고려사항은&lt;/p&gt;

&lt;p&gt;부작용 허용 여부? 부작용을 줄이려면 파라미터는 항상 in mode가 좋다. ​&lt;/p&gt;

&lt;p&gt;반환 값의 타입은? 대부분의 명령형 언어가 반환값의 타입을 제한함. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;C는 배열과 함수를 제외하고 모든 타입을 허용함. ​&lt;/li&gt;
  &lt;li&gt;C++은 C와 유사하나 사용자 정의 타입을 허용​&lt;/li&gt;
  &lt;li&gt;자바는 모든 타입 허용. ​&lt;/li&gt;
  &lt;li&gt;파이썬, 루비는 반환값 타입으로 객체도 허용&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Coroutines&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;코루틴에서 중요한 것은 재시작(resume) 명령.&lt;br /&gt;
프로그램 단위의 유사 동시 실행 기능을 제공함. 인터리빙.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl38.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위그림은 A가 먼저 시작하고, B를 재시작하고나서 스스로 중지했다가, ​
B가 A를 재시작하고 나서 스스로 중지했다가, ​
번갈아 가며 실행되는 형태를 보여주고 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl39.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 B가 먼저 시작하고, A를 재시작하면서 스스로 중지하고, ​
번갈아가며 실행되는 형태를 보이고 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl40.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위그림은 룹에서 서로 중지하고 상대방을 재시작하는 것을 반복함&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">서브프로그램</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">탐욕 기법</title>
      <link href="https://lee989898.github.io/algorithm-05" rel="alternate" type="text/html" title="탐욕 기법" />
      <published>2021-10-26T01:09:00+09:00</published>
      <updated>2021-10-26T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-05</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-05">&lt;h3 id=&quot;탐욕-기법&quot;&gt;&lt;strong&gt;탐욕 기법&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;탐욕 기법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;매 번 선택할 때 마다 그 순간에 좋은 선택을 함으로써 최종적인 해에 도달한다.&lt;/li&gt;
  &lt;li&gt;최적인 해들을 모아서 최종 해를 만들었다고 해서, 그 해가 궁극 적으로 최적이라는 보장이 없다.&lt;/li&gt;
  &lt;li&gt;따라서 탐욕 기법은 항상 최적의 해를 만들어내는 지를 반드시 검증해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;선택 기준&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;선택이 실현 가능해야 한다.&lt;/li&gt;
  &lt;li&gt;모든 선택들 중에서 최적이라고 여겨지는 선택을 해야 한다.&lt;/li&gt;
  &lt;li&gt;한 번 선택하면 나중에 되돌릴 수 없다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;설계 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;비어 있는 해 모음으로 시작한다.&lt;/li&gt;
  &lt;li&gt;탐욕적인 기준에 따라 해 모음에 추가할 다음 해를 선택한다.&lt;/li&gt;
  &lt;li&gt;새 해 모음이 실형 가능한지를 확인한다.
실현 가능하다면 새 해 모음을 확정하고 아니면 선택한 해를 버린다.&lt;/li&gt;
  &lt;li&gt;새 해 모음이 최종 해라면 종료한다. 아니면 2번으로 간다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;거스름돈 주기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;거스름돈을 동전들의 수가 최소가 되도록 주어야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;액면가가 다른 m(&amp;gt;=1)개의 동전들이 있다.&lt;/li&gt;
  &lt;li&gt;동전 i,1&amp;lt;=i&amp;lt;=m,의 액면가는 d&lt;sub&gt;i&lt;/sub&gt; 이고 d&lt;sub&gt;1&lt;/sub&gt; &amp;gt; 
d&lt;sub&gt;2&lt;/sub&gt; &amp;gt; … &amp;gt; d&lt;sub&gt;m&lt;/sub&gt; = 1이다.&lt;/li&gt;
  &lt;li&gt;액면가가 같은 동전들의 개수는 무한히 많이 있다.&lt;/li&gt;
  &lt;li&gt;거스름돈 n(&amp;gt;=1)을 최소 개수의 동전들을 사용하여 주어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;탐욕 알고리즘의 아이디어&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;주어야 할 거스름돈이 남아 있는 동안 다음을 반복한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;남은 동전들 중 액면가가 가장 큰 동전을 선택한다.&lt;/li&gt;
  &lt;li&gt;선택한 동전을 거스름돈에 추가하면 거스름돈이 주어야 할 금액을 
초과한다면 그 동전을 버린다. 아니면 그 동전을 거스름돈에 추가하고 주어야 할 거스름돈을 추가한 동전의 액면가만큼 감소시킨다.&lt;br /&gt;
주: 최적의 알고리즘&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;탐욕적인 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;coinChange(d[],m,n)
//거스름돈에 포함되는 동전들의 수를 최소화한다.&lt;br /&gt;
//입력: m - 액면가가 다른 동전들의 수&lt;br /&gt;
//     d[1..m] - 동전들의 액면가를 저장하는 배열&lt;br /&gt;
//     n - 거스름돈&lt;br /&gt;
//출력(반환 값): 거스름돈에 포함된 동전들의 최소 개수&lt;br /&gt;
1  count = 0&lt;br /&gt;
2  i = 1&lt;br /&gt;
3  while(n &amp;gt; 0 &amp;amp;&amp;amp; i &amp;lt;=m){&lt;br /&gt;
4    count = count + $\frac{n}{d[i]}$ 　//가치가 가장 큰 동전들을 최대한 많이 선택&lt;br /&gt;
5    n = n mod d[i] 　　　 //남은 거스름돈을 계산&lt;br /&gt;
6    i = i + 1 　　　　　　 //다음으로 가치가 큰 동전을 선택&lt;br /&gt;
    }&lt;br /&gt;
7  return count&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;시간 복잡도&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;입력의 크기: m(액면가가 다른 동전들의 수)&lt;/li&gt;
  &lt;li&gt;기본 연산: 4번의 배정문&lt;/li&gt;
  &lt;li&gt;기본 연산의 수행 횟수: 최대 m&lt;/li&gt;
  &lt;li&gt;시간 복잡도: m = $\theta$(m)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;최소 비용 신장 트리 찾기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;n(&amp;gt;1)개의 도시들을 최소한의 비용으로 연결하는 철도망을 새로 구축하려고 한다.&lt;/li&gt;
  &lt;li&gt;모든 도시들을 서로 연결하기 위해 도시간 철도를 최소한(n-1)개 깔아야 한다.&lt;/li&gt;
  &lt;li&gt;각 철도는 두 도시를 연결한다.&lt;/li&gt;
  &lt;li&gt;이 철도망들 중에서 철도 노선들의 총 길이가 최소가 되도록 철도망을 구축해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;최소 비용 신장 트리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;신장트리: 연결된, 무방향 그래프 안에 있는 모든 정점을 다 포함하면서 트리가 되는 연결된 부분 그래프&lt;/li&gt;
  &lt;li&gt;산장트리는 순환을 포함하지 않으며 그래프 안에 있는 모든 정점들을 연결시칸다.&lt;/li&gt;
  &lt;li&gt;신장트리의 가중치: 모든 간선들의 가중치들의 합&lt;/li&gt;
  &lt;li&gt;최소 비용 신장 트리: 최소 가중치를 가진 신장트리&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag12.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;억지 기법 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;모든 신장 트리를 찾은 후 그 중에서 최소 비용 신장 트리를 선택한다.&lt;/li&gt;
  &lt;li&gt;시간 복잡도 분석
    &lt;ul&gt;
      &lt;li&gt;최악의 경우, 지수 시간보다도 나쁘다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;탐욕적인 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;신장 트리에 추가할 최선의 간선들을 반복적으로 한 번에 하나씩 선택한다. 선택 시점에서 추가할 최선의 간선을 쉽게 알 수 있다고 가정한다.&lt;/li&gt;
  &lt;li&gt;(n-1)개의 간선들이 신장 트리에 포함된다면 종료한다.&lt;/li&gt;
  &lt;li&gt;한 간선이 선택되면 그 간선의 정점들을 합친다.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;적절한 이유&lt;br /&gt;
정점 a와 b가 연결된다면 정점a에 연결하는 것은 정점 b에 연결하는 것과 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;명제. n(&amp;gt;0)개의 정점들을 가진 그래프 G는 (n-1)개의 간선들을 가지고 순환이 없으면 트리이다. 또한 G가 트리이면 (n-1)개의 간선들이 있고 비순환 그래프이다.&lt;/p&gt;

&lt;p&gt;정리. 간선 e가 정점 v에 접합한 가장 가중치가 작은 간선이라면 e를 포함하는 최소 비용 신장 트리가 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;최소 비용 신장트리 찾기 - 정점지향 전략&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;처음 시작할 때 한 정점 v&lt;sub&gt;0&lt;/sub&gt;를 선택한다.&lt;/li&gt;
  &lt;li&gt;v&lt;sub&gt;0&lt;/sub&gt; 에서 나가는 가장 가중치가 작은 간선 (v&lt;sub&gt;0&lt;/sub&gt;, x)를 선택한다. 그 간선을 최소 비용 신장 트리 T에 추가하고 v&lt;sub&gt;0&lt;/sub&gt;와 x를 합친다. 모든 정점이 T에 포함될 때까지 이 과정을 반복한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;프림 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;적색 정점: 처음에 선택된 정점 v&lt;sub&gt;0&lt;/sub&gt;와 합쳐진 정점&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;청색 정점: 그 외 다른 정점&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;아이디어&lt;br /&gt;
다음을 (n-1)번 반복한다:
    &lt;ol&gt;
      &lt;li&gt;한 적색 정점과 한 청색 정점을 연결하는 가장 가중치가 작은 간선을 선택한다.&lt;/li&gt;
      &lt;li&gt;선택된 간선의 청색 정점을 적색으로 바꾸고 그 간선을 트리에 추가한다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;그래프의 표현: 비용 행렬 W&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;R: 적색 정점들의 집합, B: 청색 정점들의 집합&lt;br /&gt;
V: 그래프내의 모든 정점들의 집합&lt;br /&gt;
T: 트리 내에 포함되는 간선들의 집합&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;  R = {v&lt;sub&gt;0&lt;/sub&gt;}&lt;/li&gt;
  &lt;li&gt;  B = V - {v&lt;sub&gt;0&lt;/sub&gt;}&lt;/li&gt;
  &lt;li&gt; T = $\emptyset${공집합}&lt;/li&gt;
  &lt;li&gt; for(i = 1; i &amp;lt; n; i++) {&lt;/li&gt;
  &lt;li&gt; 　　w[ r,b ]가 최소인 $r \in R$과 $b \in B$를 선택한다.&lt;/li&gt;
  &lt;li&gt; 　　T = T U {(r,b)}　　// 간선 (r,b)를 트리에 추가한다.&lt;/li&gt;
  &lt;li&gt; 　　B = B - {b}&lt;/li&gt;
  &lt;li&gt; 　　R = R U {b}　　　//정점 b를 적색으로 바꾼다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;명확하게 청색 정점의 관점을 취해야 한다. 단순히 어느 적색 정점이 자신에게 가장 가까운지만 기억한다. 이는 한 정점이 적색이 될 때 쉽게 갱신될 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;시간 복잡도&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 알고리즘은 중복 계산을 많이 한다. 매번 반복할 때마다 최소 간선을 거의 같은 집합에서 찾는다.&lt;br /&gt;
$\theta$(n&lt;sup&gt;3&lt;/sup&gt;)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;개선된 프림 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;near[0 .. n - 1]: 각 청색 정점에 가장 가까운 적생 정점을 저장하는 배열&lt;br /&gt;
isblue[0 .. n - 1]: 각 정점이 청색이면 true를 아니면 false를 저장하는 배열&lt;br /&gt;
T: 트리 내에 포함되는 간선들의 집합&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt; isblue[0] = false 　　　　//정점 0은 적색이다&lt;/li&gt;
  &lt;li&gt; T = $\emptyset$&lt;/li&gt;
  &lt;li&gt; for(i = 1; i &amp;lt; n; i++){&lt;/li&gt;
  &lt;li&gt; 　　isblue[i] = true 　　　　//다른 정점들은 청색이다&lt;/li&gt;
  &lt;li&gt; 　　near[i] = 0 } 　　　　　 // 가장 가까운 적색 정점은 0이다&lt;/li&gt;
  &lt;li&gt; for(i = 1; i &amp;lt; n; i++){&lt;/li&gt;
  &lt;li&gt; 　　minval = $\infty$&lt;/li&gt;
  &lt;li&gt; 　　for(b = 0; b &amp;lt; n; b++)　//적색 정점들에 가장 가까운 청색 정점을 찾는다&lt;/li&gt;
  &lt;li&gt; 　　　if(isblue[b] &amp;amp;&amp;amp; W[b,near[b]]&amp;lt; minval){&lt;/li&gt;
  &lt;li&gt; 　　　　minval = W[b,near[b]]&lt;/li&gt;
  &lt;li&gt; 　　　　newred = b }&lt;/li&gt;
  &lt;li&gt; 　isblue[newred] = fasle 　　　//정점 newred를 적색으로 바꾼다&lt;/li&gt;
  &lt;li&gt; 　T = T $\cup$ { (newred, near[newred])}　//가장 가중치가 작은 간선을 T에 추가한다&lt;/li&gt;
  &lt;li&gt; 　for(b = 0; b &amp;lt; n; b++)&lt;/li&gt;
  &lt;li&gt; 　　　if(isblue[b] &amp;amp;&amp;amp; W[b,newred] &amp;lt; W[b,near[b]])near[b] = newred&lt;br /&gt;
　　}&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;시간 복잡도&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;입력 크기: n(정점들의 수)&lt;/li&gt;
  &lt;li&gt;기본 연산: isblue의 요소들에 대한 참조 횟수&lt;/li&gt;
  &lt;li&gt;참조 횟수
    &lt;ul&gt;
      &lt;li&gt;각 i, 1&amp;lt;= i &amp;lt; n, 에 대해 항상 n이다.&lt;/li&gt;
      &lt;li&gt;따라서 총 참조 횟수 = (n-1) x n $\in$ $\theta$(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">탐욕 기법</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Hash</title>
      <link href="https://lee989898.github.io/sc-01" rel="alternate" type="text/html" title="Hash" />
      <published>2021-10-23T01:06:00+09:00</published>
      <updated>2021-10-23T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-01</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-01">&lt;h3 id=&quot;hash&quot;&gt;&lt;strong&gt;Hash&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Hash와 관련된 Key Concepts인 Integrity와 Authentication을 살펴보자&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Integrity&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무결성&lt;/li&gt;
  &lt;li&gt;원본 그대로임을 보장&lt;/li&gt;
  &lt;li&gt;변조가 없다는 것 혹은 변경이 있었음을 알게 됨&lt;/li&gt;
  &lt;li&gt;주요 공격: modification&lt;/li&gt;
  &lt;li&gt;Integrity를 지키기 위한 Solution : hash&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Authentication&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;인증&lt;/li&gt;
  &lt;li&gt;송수신자 서로간의 신원 확인&lt;/li&gt;
  &lt;li&gt;주요 공격 : impersonation&lt;/li&gt;
  &lt;li&gt;Authentication을 지키기 위환 solution : 전자서명, 공인인증서&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hash Functions&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;임의의 긴 입력 값을 적절하게 처리하여 고정된 길이의 짧은 값을 출력하는 함수&lt;/li&gt;
  &lt;li&gt;Message Authentication Code로 무결성 제공&lt;/li&gt;
  &lt;li&gt;전자 서명으로 sender authentication 제공&lt;/li&gt;
  &lt;li&gt;공인인증서, 가상화폐 등에 사용&lt;/li&gt;
  &lt;li&gt;컴퓨터보안에서 대표적인 hash function은 MD2,4,5 SHA1, HAS160&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://www.miraclesalad.com/webtools/md5.php&quot;&gt;http://www.miraclesalad.com/webtools/md5.php&lt;/a&gt;&lt;br /&gt;
위 사이트에서 임의의ㅣ 입력값에 대한 해쉬값을 관찰할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;해쉬의 특징으로는 대표적으로 3가지가 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;입력길이에 상관없이 출력길이가 일정&lt;/li&gt;
  &lt;li&gt;조금이라도 입력값이 다르면 출력값은 완전히 다름&lt;/li&gt;
  &lt;li&gt;revers가 어렵다(일방향성)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위 성질중 integrity는 2번에 의해서 보장된다.&lt;br /&gt;
Encrypt/decrypt와의 차이점은 3번이다. 복호화가 어렵기 때문이다.&lt;/p&gt;

&lt;p&gt;예를 들어보자 h(x): x/23해서 소수점 7~10자리 수를 추출&lt;br /&gt;
h(345689) = xx.95652177391&lt;br /&gt;
출력값은 일정하나, reverse는 불가능하다.&lt;/p&gt;

&lt;p&gt;그러나 h(232.8395049993) = 7391 처럼 다른 값을 넣었음에도 값이 같은 일명 collision이 일어날 수 있다.&lt;br /&gt;
Collison은 서로 다른 입력값이 같은 해시값을 계산하는 것을 의미한다.&lt;br /&gt;
충동저항성은 collision이 일어날 확률이 작음을 의미한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;MAC&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;메시지 무결성: 변경되지 않은 원본이 맞음&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc01.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;메시지와 해쉬값을 붙어서 보낸다.&lt;br /&gt;
받는사람은 비교해서 같으면 원본 다르면 원본이 아닌걸 알 수 있다.&lt;br /&gt;
하지만 여기서 sender authenticationd은 제공되지 않는다.&lt;br /&gt;
Digital Signature에서 이문제를 해결한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Digital Signature&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무결성과 인증을 동시에 제공&lt;/li&gt;
  &lt;li&gt;키를 사용한다(키를 모르는 사용자는 생성불가)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc02.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;비교하여 같으면 변조되지 않고 보낸사람을 인증해준다.&lt;br /&gt;
하지만 mac도 한계가 있는데 제 3자에 대한 sender authentication이 불가능 하다.&lt;br /&gt;
키를 모르면 인증을 못하기 때문이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Replay Attack&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc03.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 MAC 공격방법이다.&lt;br /&gt;
Attacker는 고객이 보낸 똑같은 패킷을 복사하여 고객으로 위장하는 공격 방법이다.&lt;br /&gt;
이러한 공격을 막는 방법은 패킷에 추가정보로 시간을 알려주는 time stamp를 넣어 해결할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;대표적인 해쉬 함수로는 두가지 계열이 있는데 MD와 SHA 계열이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;MD (Message Digest)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;MD2,4,5,6​&lt;/li&gt;
  &lt;li&gt;Ron Rivest (RSA), 1990~92​&lt;/li&gt;
  &lt;li&gt;Merkle structure기반​&lt;/li&gt;
  &lt;li&gt;128bit hash 값​&lt;/li&gt;
  &lt;li&gt;512 bit block size ​&lt;/li&gt;
  &lt;li&gt;MD4는 32bit CPU 전용 (MS)​&lt;/li&gt;
  &lt;li&gt;MD5는 SHA1등 최신 해시들의 기초가됨​&lt;/li&gt;
  &lt;li&gt;2005 강한 충돌 내성 깨짐&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;SHA (Secure Hash Algorithm)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;NIST 1993​&lt;/li&gt;
  &lt;li&gt;Merkle structure기반​&lt;/li&gt;
  &lt;li&gt;SHA0,1은 160bit hash 값, SHA2는 224~512bit​&lt;/li&gt;
  &lt;li&gt;512 bit block size ​&lt;/li&gt;
  &lt;li&gt;최대 2^64-1 bit 메시지처리​&lt;/li&gt;
  &lt;li&gt;가장 많이 사용​&lt;/li&gt;
  &lt;li&gt;2005 강한 충돌 내성 깨짐&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc04.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 Merkle structure의 예시이다.&lt;br /&gt;
MD, SHA 두가지 모두 Merkle structure기반인데 이것은
Message를 block으로 나누어서 고정된 길이의 입력값을 받아들여 고정된 길이로 출력하는 압축함수를 반복 사용하여 긴 길이의 입력을 처리할 수 있는 해쉬 함수로 학대하여 설계하는 방식이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hash attack&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;같은 해시값을 갖는 다른 입력값을 찾아낸다​&lt;/li&gt;
  &lt;li&gt;예를 들면, (ID, PWD)값은 해시값으로 저장되어 있다.​&lt;/li&gt;
  &lt;li&gt;만일 같은 해시값을 갖는 (ID2, PWD2)를 찾는다면, (ID, PWD)로 로그인 가능​하다&lt;/li&gt;
  &lt;li&gt;(ID, PWD), (ID2, PWD2)를 충돌쌍(collision pairs)라 한다​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">Hash</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">컨트롤 스트럭처</title>
      <link href="https://lee989898.github.io/pl-15" rel="alternate" type="text/html" title="컨트롤 스트럭처" />
      <published>2021-10-22T19:18:00+09:00</published>
      <updated>2021-10-22T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-15</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-15">&lt;h3 id=&quot;컨트롤-스트럭처&quot;&gt;&lt;strong&gt;컨트롤 스트럭처&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;프로그램의 컨트롤 스트럭처에는 3가지가 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;sequence(begin-end)&lt;/li&gt;
  &lt;li&gt;selection(if-else, case)&lt;/li&gt;
  &lt;li&gt;iteration(loop)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;각 컨트롤 스트럭처는 여러 개의 문장으로 구성된다. ​&lt;/p&gt;

&lt;p&gt;스트럭처는 여러 문장의 묶음으로, ​
실행 제어 방법에 따라 각각 키워드(begin, if, while,…)를 포함한다&lt;/p&gt;

&lt;p&gt;여기서 컨트롤 스트럭처의 if, while 문을 제어문이라고 하고, ​
제어문의 실행 결과에 따라 실행되는 문장을 실행문이라고 한다. ​&lt;/p&gt;

&lt;p&gt;시퀀스는 순차적으로 실행되는 문장들의 연속을 말하며, ​
실행 제어가 순차적이라서 시작과 끝만 명시하면 된다.&lt;/p&gt;

&lt;p&gt;Selection은 제어문이 참이냐 거짓이냐에 따라 실행문이 다르며,&lt;br /&gt;
하나의 selection 스트럭처에 제어문과 실행문을 여럿 포함하기도 한다. ​&lt;/p&gt;

&lt;p&gt;Iteration도 제어문과 실행문의 반복으로 구성되는데,&lt;br /&gt;
for, while, repeat 등 목적에 따라 그 신택스와 시맨틱스가 다양하다. ​&lt;/p&gt;

&lt;p&gt;프로그래머는 이들 컨트롤 스트럭처를 사용하여 쉽게 프로그램을 구조화한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;프로그램은 나름의 로직을 갖고 있어서, 이에 따른 실행 제어(flow control)가 필요하다. ​&lt;/p&gt;

&lt;p&gt;명령형 프로그램에서 계산은 다음과 같이 진행된다.&lt;br /&gt;
변수를 읽고 연산자를 실행하여 표현식을 계산하여, ​
변수에 결과 값을 부여한다.&lt;br /&gt;
또, 여러 경로 중에서 선택하여 실행을 제어하거나, ​반복 실행한다. ​&lt;/p&gt;

&lt;p&gt;컨트롤 스트럭처는 제어문과 실행문으로 구성된다. ​
이 표현은 문제가 있다. 시퀀스는 제어문이 없다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;selection-statements&quot;&gt;&lt;strong&gt;Selection Statements&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Selection문은 2개 이상의 실행 경로 중에서 선택하는 것이다. ​&lt;/p&gt;

&lt;p&gt;두가지 범주가 있는데, 둘 중에 하나 선택하는 것과 여럿 중에 선택하는 것이 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;If Statements&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If문의 일반적 형식은 if 제어 표현식 then 실행문1 else 실행문2 이다. ​&lt;/p&gt;

&lt;p&gt;제어 표현식은 산술식이거나 부울식이다. ​&lt;/p&gt;

&lt;p&gt;프로그래밍 언어에서 실행문1과 실행문2는 단순문이거나 복합문이다. ​&lt;/p&gt;

&lt;p&gt;C, C++에서 복합문을 { }로 둘러싼다.&lt;br /&gt;
펄에서 모든 실행문을 { }로 구분하고, 파이썬에서는 indentation으로 구분한다.&lt;/p&gt;

&lt;p&gt;자바에서는 중첩 if문을 허용한다.&lt;br /&gt;
dangling else 문제가 발생할 수 있으니 If에 대응되는 else가 어느 것인지 살펴가며 신중하게 써야 한다.&lt;br /&gt;
자바를 비롯한 대부분의 언어에서는 else를 가장 가까운 if에 대응시킨다.  ​&lt;/p&gt;

&lt;p&gt;C, C++에서는 가장 가까운 if에 else를 대응시키는 것의 대안으로서,&lt;br /&gt;
{}로 둘러싼 복합문을 사용할 수도 있다. ​&lt;/p&gt;

&lt;p&gt;​복합문 대신에 end를 사용하기도 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Switch Statements&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;​Switch는 여러 대안 중에 하나 선택하여 실행할 경우이다. ​&lt;/p&gt;

&lt;p&gt;전형적인 형식은 아래와 같다 ​&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Switch 표현식 {​

case 상수 표현식1 : 실행문1   ​

…​

default … }이다. 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;스위치문의 case는 동시에 상수 표현식을 비교하는 것이 아니라 상수 표현식을 순차적으로 비교하여 끝까지 실행한다. 
 ​이것을 피하려면, break 사용해야 한다.&lt;/p&gt;

&lt;p&gt;C에서는 스위치문의 제어 표현식으로 정수 타입만 허용한다.&lt;br /&gt;
 실행문은 시퀀스, 블록, 복합문을 모두 허용한다.&lt;br /&gt;
 조건이 맞으면 여러 case가 실행가능하다.&lt;br /&gt;
 디폴트시에, ​If문에 의한 제어가 가능하다.&lt;/p&gt;

&lt;p&gt;파이썬에서는 스위치 대신에 if elif를 사용할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;iterative-statements&quot;&gt;&lt;strong&gt;Iterative Statements&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;Iteration, recursion은 문장이나 복합문의 반복 실행한다.​ &lt;br /&gt;
 카운터로 제어하는 counter-controlled loop은 반복문의 실행 횟수를 세는 변수를 갖는다. ​초기값, 종료값, 증분(반복할 때마다 더해지는 값)&lt;/p&gt;

&lt;p&gt;설계할 때 고려사항은 Loop 변수의 유형과 스코프를 정의해야 하며,&lt;br /&gt;
Loop에서 변화하는 Loop변수의 값이 룹 제어에 영향을 미치는지 확인해야 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;for Statenebts&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;C의 for 반복문을 보면, ​&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for ([expr_1] ; [expr_2] ; [expr_3]) ​

loop body… 와 같습니다. ​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다음과 같이 카운터 변수가 여럿일 수 있고, ​
부울식을 포함할 수 있다. ​&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;For (count1 = 0, count2 = 1.0;​
     count1 &amp;lt;= 10 &amp;amp;&amp;amp; count2 &amp;lt;= 100.0;​
    sum = ++count1 + count2, count2 *= 2); ​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자바에서 컨트롤 표현식은 부울식이어야 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;while Loops&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;​While Loop은 부울식에 의해 제어된다.&lt;br /&gt;
Ctrl_expr는 부울식으로, Loop의 맨앞에 또는 맨뒤에 위치한다. ​&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while (ctrl_expr) ​
loop body… ​

do ​
loop body ​
while (ctrl_expr) ​ ​ 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;User-Located Loop Control&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Break 처럼 loop 컨트롤이 loop body의 중간에 위치하기도 한다.&lt;br /&gt;
이것을 user-located loop control이라고 부른다.&lt;br /&gt;
Break 외에도 continue가 있다.&lt;/p&gt;

&lt;p&gt;자료구조를 구성하는 요소에 의해 제어되는 반복 처리가 있다. ​
Iterator를 호출하면, 자료구조에서 다음 요소를 반환해준다. ​
이밖에 for에서도 자료구조에 의한 반복처리를 제어할 수 있다.  ​&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Unconditional Branching&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;앞에서 언급했듯이 goto는 가독성 문제를 일으킨다.&lt;br /&gt;
자바는 goto가 없다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;guarded-commands&quot;&gt;&lt;strong&gt;Guarded Commands&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;각 문장 앞에 부울식이 있는 것을 가디드 코멘드라고 한다. &lt;br /&gt;
즉 가디드 코멘드는 ​selection 문장의 각 라인이 ​부울식과 ‘하나의 문장 또는 문장의 시퀀스＇로 구성된다. ​&lt;/p&gt;

&lt;p&gt;이렇게 하는 목적은 ​프로그램 개발 중에도 프로그램의 correctness(올바름)를 증명하기 위한 것으로, ​Concurrent 프로그래밍의 기초가 된다. ​&lt;/p&gt;

&lt;p&gt;기존의 언어는 개발(코딩)을 마치고 테스트를 통해 프로그램의 올바름을 확인한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Selection Guarded Command&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Selection의 가디드 코멘드는 ​If 안의 각 문장마다 부울식이 있다. ​&lt;/p&gt;

&lt;p&gt;이 가디드 코멘드의 시맨틱은 다음과 같다.&lt;br /&gt;
부울식을 계산해서, ​나 이상이 참이면, 그 중에 아무거나 선택한다.&lt;br /&gt;
아무것도 참이 아니면, 실행 오류로 처리한다.​&lt;br /&gt;
프로그램의 correctness는 선택된 문장에 종속되지 않는다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if x &amp;gt;= y -&amp;gt; max := x​
[] y &amp;gt;= x =&amp;gt; max := y​
fi

if (x &amp;gt;= y)​  
    max = x;​
else​
    max = y;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;X, y가 같을 때, 전자는 아무거나 선택되어 수행되나, ​
후자는 max=x가 수행됨.&lt;br /&gt;
따라서, non-deterministic vs. deterministic&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Loop Guarded Command&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;do &amp;lt;Boolean&amp;gt; -&amp;gt; &amp;lt;statement&amp;gt;​
[] &amp;lt;Boolean&amp;gt; -&amp;gt; &amp;lt;statement&amp;gt;​
...​
[] &amp;lt;Boolean&amp;gt; -&amp;gt; &amp;lt;statement&amp;gt;​
od​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Loop 가디드 코멘드에서, ​Do 다음에 나오는 모든 문장의 앞에 부울식이 있다. ​
​
룹 가디드 코멘드의 시맥틱스는 다음과 같다.&lt;br /&gt;
부울식을 계산하고, ​
하나 이상이 참이면, ​
아무거나 선택하여 룹을 시작한다.&lt;br /&gt;
아무것도 참이 아니면, 룹에서 나온다.&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">컨트롤 스트럭처</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">복잡한 데이터 타입</title>
      <link href="https://lee989898.github.io/pl-13" rel="alternate" type="text/html" title="복잡한 데이터 타입" />
      <published>2021-10-14T19:18:00+09:00</published>
      <updated>2021-10-14T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-13</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-13">&lt;h3 id=&quot;복잡한-데이터-타입&quot;&gt;&lt;strong&gt;복잡한 데이터 타입&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;배열과 레코드 타입을 살펴보자&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;배열&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;배열은 동일한 유형의 데이터 요소의 모임으로, ​
각 요소의 위치에 의해 지칭된다(식별된다). ​
각 요소의 위치를 나타내는 방식은 ​
‘배열의 맨앞에서 시작하여 각 요소
의 상대적 위치를 지칭하는 인덱스(서브스크립트, subscript)’에 의한다. ​
이와 같이 상대적 위치를 지칭하기 위해서는, ​
인덱스와 요소 간의 매핑이 필요한데, ​
이러한 매핑을 배열 인덱싱 또는 subscripting이라고 한다. ​
1차원 배열 인덱싱은 사소한 문제에 불과하지만, ​
배열의 차원이 증가하고 각 차원의 범위가 다양해지면서 ​
배열의 인덱싱 문제는 복잡해진다.&lt;/p&gt;

&lt;p&gt;배열 인덱스 유형은 주로 정수형을 사용하나 언어에 따라 약간 다르다. ​
포트란, C, 자바는 정수형만을 지원하나, ​
파스칼은 모든 서수 유형(정수, 부울리언, 글자)을 지원한다. ​
C, C++, 펄, 포트란은 인덱스에 대해 범위 검사를 하지 않지만, ​
자바, ML, C#은 인덱스의 범위를 검사한다. ​&lt;/p&gt;

&lt;p&gt;배열의 범주를 서브스크립트의 범위와 메모리 할당 시기를 기준으로 나누면,  ​
정적 배열, 고정 스택-동적 배열, 고정 힙-동적 배열,
 힙-동적 배열로 구분한다. ​&lt;/p&gt;

&lt;p&gt;정적 배열은 서브스크립트의 범위가 정적으로 고정되어 있고, ​
런타임 이전에 메모리가 정적으로 할당된다.  ​
장점은 효율적이지만, ​
단점은 실행중 필요시마다 동적 할당이 불가능하여 융통성이 없다. ​
C, C++에서 static modifier를 포함하는 배열은 정적 배열이다. ​&lt;/p&gt;

&lt;p&gt;고정 스택-동적 배열은 서브스크립트의 범위가 정적으로 고정되어 있지만, ​
메모리는 미리 할당되지 않고, 선언문 실행 중에 할당된다. ​
장점은 실행되지 않는 서브프로그램에서 정의된 배열에 대해 ​
메모리가 미리 할당되지 않아, 메모리 공간 활용이 효율적이다. ​
C, C++에서 static modifier를 포함하지 않는 배열은 고정 스택-동적 배열이다.&lt;/p&gt;

&lt;p&gt;고정 힙-동적 배열은 스토리지 바인딩이 동적이지만, ​
힙에 할당된 후에는 서브스크립트의 범위가 고정된다. ​
C, C++에서 malloc에 의해 할당된 배열은 고정 힙-동적 배열이다. ​&lt;/p&gt;

&lt;p&gt;힙-동적 배열은 서브스크립트 범위와 스토리지의 바인딩이 ​
모두 동적이면서 변경 가능하다. ​
장점은 배열이 실행 중에 늘어나거나 줄어 들 수 있어서 융통성이 있다. ​
C#에서 ArrayList에 의해 정의된 배열은 힙-동적 배열이다. ​
배열의 요소없이 생성되고 나중에 add를 써서 배열을 늘인다.&lt;/p&gt;

&lt;p&gt;C, C++, C#, 자바에서는 ​
스토리지 할당시에 배열이 초기화된다. ​&lt;/p&gt;

&lt;p&gt;포트란은 배열에 대한 연산을 지원한다. ​
두 배열의 합(+)은 위치가 같은 배열의 각 요소들간의 합을 배열로 나타낸 것이다. ​
A = B + C ——- A, B, C 모두 배열…  ​
배열에 대한 연산을 지원하지 않는다면, ​
loop을 써서 반복적으로 ​
각 요소마다 합을 구해야 함 (A[i] = B[i] + C[i]에 의해)&lt;/p&gt;

&lt;p&gt;순서를 무시한 데이터 요소의 모임을 associative array라고 하며, ​
사용자가 정의한 Key를 인덱스로 사용한다. ​
따라서, associative array는 키와 값의 쌍을 나열한 것이다.  ​
펄에서 associative array를 다음과 같이 정의하고, ​
%hi_temps = (“Mon” =&amp;gt; 77, “Tue” =&amp;gt; 79, “Wed” =&amp;gt; 65, …);​
다음과 같이 배열에서 값을 찾는다.  ​
$hi_temps{“Wed”} = 83; 여기서 Wed가 키이다. ​
다음 명령어는 배열에서 값을 삭제한다.  ​
delete $hi_temps{“Tue”};&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;레코드&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;배열은 동일한 유현의 데이터 요소의 모임인 반면, ​
레코드는 다른 유형의 데이터 요소의 모임이다. ​
레코드에서는 그 요소의 이름으로 요소를 식별(지칭, 언급)한다. ​&lt;/p&gt;

&lt;p&gt;레코드 타입에서 각 필드를 지칭(언급)하는 방법은 필드명에 의하며, ​
서브 필드를 명확히 지칭하기 위해,  ​
코볼에서는 of를 키워드로 하고, ​
다른 언어에서는 dot(.)을 쓰기도 한다. ​
레코드 타입의 연산은 assignment(필드명에 값 할당), ​
레코드간의 필드값 카피 등이다.  ​&lt;/p&gt;

&lt;p&gt;튜플 타입은 레코드와 유사하나, 각 요소의 이름이 없다는 것이 다르다. ​
파이썬의 튜플은 튜플의 값을 변경할 수 없다. ​
만일 변경하고자 한다면, ​
List 함수를 써서 튜플을 배열로 변환한 다음에, ​
배열의 값을 변경한다. ​
변경한 후에, tuple 함수를 써서, 튜플로 재변환한다. ​
myTuple = (3, 5.8, ‘apple’)은 튜플을 생성한다. ​
myTuple[1]은 첫째 요소를 가리킨다. ​
+는 튜플 간의 concatenation을 실행하고, ​
del은 튜플을 삭제한다.&lt;/p&gt;

&lt;p&gt;리스트 타입은 튜플과 유사하나, ​
각 요소의 값을 변경 가능하다는 것이 다르다. ​
파이썬은 리스트 타입을 지원하며, 배열처럼 취급된다. ​
배열과 차이점은 각 요소의 값이 어떤 유형이든 상관없다는 것이다.  ​
생성, 지칭, 삭제 연산 등을 보면 튜플과 유사함을 알 수 있다.​
리스트 포함(comprehension)은 컨스트럭트에 리스트를 포함시키는 것을 말한다. ​
이것은 리스트를 필요시 정의할 수 있는 편리한 기능이다. ​
형식은 [expression for iterate_var in array if condition]
을 취한다.  ​
예를 들면, [x*x for x in range(12) if x%3==0]과 같다. ​
range(12)는 0에서 12까지의 배열을 생성하는 함수이고, ​
x%3은 x를 3으로 나눈 나머지를 말한다. ​
이 문장은 0에서 12로 구성된 배열을 생성하고 ​
0,3,6,9,12를 제곱하라는 뜻이다. ​&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;포인터와 레퍼런스 타입에 대해 살펴보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;포인터&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;포인터 타입 변수가 가질 수 있는 값의 범위는 ​
메모리 주소와 영(nil)이다.  ​
포인터는 간접 주소 지정 방식과 동적 메모리 관리 방식을 제공한다. ​
포인터는 힙에 있는 메모리 위치를 접근할 때 사용된다.&lt;/p&gt;

&lt;p&gt;기본적 연산으로 assignment와 dereferencing이 있다. ​
Assignment는 포인터 변수의 값에 주소를 넣어 두는 것이다. ​
디레퍼런싱은 포인터의 값이 가리키는 주소에 저장된 값을 산출하는 것이다. ​
디레퍼런싱은 명시적이거나 암묵적이다. ​
C, C++에서는 명시적인 디레퍼런싱 연산자로 &lt;em&gt;를 사용한다. ​
j=&lt;/em&gt;ptr는 ptr의 값이 가리키는 주소에 저장된 값을 ​
변수 j의 메모리 위치에 넣어 두라는 의미이다. ​
아래 그림은 이것을 그림으로 나타낸 것이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl35.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;포인터 사용할 때 나타나는 문제는 다음의 두가지가 있다. ​
​&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;허상 포인터(dangling pointer)는 ​
힙-동적 변수에 할당된 메모리를 가리키지 않고 있는 포인터를 말한다.  ​
자세히 설명하면, ​
힙에 의해 변수에 메모리가 할당되면, ​
포인터는 이 메모리를 가리키고 있겠지만,  ​
이후 메모리가 해제되었다면, ​
이 포인터는 메모리를 가리키지 못하게 된다. ​
이러한 포인터를 허상 포인터라고 한다. ​
즉, 메모리는 없지만 포인터는 남아 있는 경우이다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;memory leakage(기억 상실)​
힙-동적 변수의 상실은 힙-동적 변수가 이미 메모리에 할당되어 있지만, ​
포인터가 상실되어 ​
사용자 프로그램에서 이 동적 변수에 더 이상 접근 가능하지
 않은 경우를 말한다. ​
즉, 포인터는 없지만 할당된 메모리는 남아 있는 경우이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;포인터는 언제 메모리에 할당되든지 어떤 변수든 가리킬 수 있으며,  ​
동적 스토리지 관리에서 사용된다. ​
포인터 산술 연산이 가능하고, ​
디레퍼런싱과 ‘무엇의 주소’ 연산이 가능하다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    float stuff[100];​
    float *p;​
    p = stuff;​

    *(p+5) is equivalent to stuff[5] and  p[5]​
    *(p+i) is equivalent to stuff[i] and  p[i]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;C, C++에서는 포인터에 대한 산술 연산이 가능하다. ​
5번째값, i번째값&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;레퍼런스&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;레퍼런스는 포인터와 유사하나, ​
기본적으로 다른점은 ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;포인터는 메모리의 주소를 가리키지만, ​
  (주소에 대한 연산이 나름의 의미를 갖지만)​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;레퍼런스는 메모리의 값을 가리킨다. ​
  (주소에 대한 연산이 무의미)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;허상 포인터와 허상 객체는 힙 관리 상의 문제이다. ​
포인터는 변수가 가리킬 수 있는 범위를 확장시킨다는 면에서 goto와 비슷하다. ​
레퍼런스는 포인터의 기능과 유연성을 제공하면서, 위험은 제거한다. ​
포인터와 레퍼런스는 동적 데이터 구조를 위해 프로
그래밍 언어의 필수적인 요소이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl36.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;이 그림에서는 허상 포인터의 예를 보여주고 있다. ​&lt;/p&gt;

&lt;p&gt;프로그램 코드가 이와 같을 때, ​
*q=30은 이미 해제된 메모리가 남아 있다고 착각한다.  ​
Q는 결국 아무것도 가리키지 않는 허상 포인터이다.&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">복잡한 데이터 타입</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">표현식과 대입문</title>
      <link href="https://lee989898.github.io/pl-14" rel="alternate" type="text/html" title="표현식과 대입문" />
      <published>2021-10-14T19:18:00+09:00</published>
      <updated>2021-10-14T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-14</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-14">&lt;h3 id=&quot;표현식과-대입문&quot;&gt;&lt;strong&gt;표현식과 대입문&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;표현식(expression)은 프로그래밍 언어에서 계산을 상술
(상세히 서술)하는 수단이다. ​
대입문은 변수의 값을 변화시키는 문장으로, 모든 명령형 언어의 필수적 요소이다. ​
대입문은 독립적으로 실행 가능한 문장인 반면, ​
표현식은 대입문의 일부분으로서, 독립적으로 실행될 수 있는 문장이 아니다. ​&lt;/p&gt;

&lt;p&gt;대입문과 표현식의 차이를 좀더 살펴 보자.  ​
변수가 메모리의 일정 부분임을 상술하는 수단이라는 것과, ​
대입문의 BNF 형식이 &lt;var&gt;=&lt;expression&gt;임을 알고 있다. ​
BNF의 형식으로부터, ​
표현식(&lt;expression&gt;)은 대입문의 일부분임을 알 수 있고, ​
대입문의 변수(&lt;var&gt;)가 가리키는 메모리에 저장된 값을 ​
표현식의 계산 결과로 변경시킨다는 것을 알 수 있다. ​&lt;/var&gt;&lt;/expression&gt;&lt;/expression&gt;&lt;/var&gt;&lt;/p&gt;

&lt;p&gt;그런데, 표현식의 계산 방식에 따라 계산 결과는 달라질 수 있다.  ​
표현식의 계산 방식을 이해하려면, ​
연산자와 오퍼랜드의 계산 순서에 대한 규칙을 알 필요가 있다.  ​
이들 순서는 결합 법칙과 우선순위 규칙에 의하며, ​
오퍼랜드 계산 순서는 오퍼랜드의 부수효과(부작용)때문에 중요하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;산술식&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;산술식은 연산자, 오퍼랜드, 괄호, 함수 호출로 구성된다. ​
연산자는 단항 연산자, 이진 연산자, 삼항 조건 연산자(?:) 등이 있다. ​&lt;/p&gt;

&lt;p&gt;표현식의 구현은, ​
메모리에서 오퍼랜드를 가지고 와서, ​
그 오퍼랜드에 산술 연산자를 실행한다. ​
산술식 설계시 고려사항 ​
연산자 우선 순위, 결합 법칙 등 ​
오퍼랜드 계산 순서와 부작용(부수효과) ​
연산자 오버로딩 ​
표현식에서 오퍼랜드 타입의 혼합&lt;/p&gt;

&lt;p&gt;연산자 우선순위 규칙은 우선 순위가 다르면서 이웃하는 연산자의
 계산 순서를 정의한다. ​
전형적인 우선순위 규칙은 괄호&amp;gt;단항연산&amp;gt;지수&amp;gt;곱셈과 나눗셈&amp;gt;덧셈과 뺄셈 ​&lt;/p&gt;

&lt;p&gt;연산자 결합 법칙은 우선 순위가 같으면서 이웃하는 연산자의 순서를 정의한다. ​
전형적인 결합법칙은 좌에서 우로(단, 지수는 우에서 좌로) 적용된다.  ​
괄호는 우선순위와 결합 법칙에 앞선다. 
​
C, C++에서 조건 표현식은 삼항 조건 연산자 ?:를 사용한다. ​
average = (count == 0)? 0 : sum / count와 같이 표현한다. ​
이것의 의미는 다음과 같다. ​
if (count == 0), average = 0​
else average = sum / count ​
이 문장을 이해하려면, 대입문의 BNF 형식 &lt;var&gt;=&lt;expr&gt;을 떠올리면 쉽다. ​
그러니까 &lt;var&gt;이 average이고, ​&lt;/var&gt;&lt;/expr&gt;&lt;/var&gt;&lt;/p&gt;
&lt;expr&gt;가 삼항 조건 표현식인 (count==0) ? 0 : sum/count이다. 

표현식에서 오퍼랜드는 어떻게 계산되는지 살펴 보면, ​
변수는 메모리에서 값을 가져온다.  ​
상수는 메모리에서 값을 가져오기도 하지만, 기계 언어에 내재되기도 한다. ​
괄호가 있는 표현식은 괄호속에 있는 모든 오퍼랜드와 연산자를 먼저 
계산하고, 괄호 전체를 계산한다. ​

오퍼랜드가 아무런 부작용(부수효과)가 없을 때, 
오퍼랜드 계산 순서는 결과에 무관하다. ​

그러나 함수가 오퍼랜드일 때, 계산 순서는 다른 결과를 가져온다.  
함수는 다수의 파라미터 또는 글로벌 변수를 변경시킬 수 있고,  ​
이때 함수 부수효과가 발생할 수 있다. ​
이로 인해 표현식의 계산 결과에 영향을 미칠 수 있다. ​


---

 ​&lt;img src=&quot;/assets/built/images/pl/pl37.png&quot; width=&quot;100%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;

---

위 그림에서 함수 부수효과 문제의 예를 보자. ​
다음 프로그램에서, ​
Main의 a = a + fun1( )의 값은 ​
먼저 a를 계산하느냐, fun1( )을 먼저 계산하느냐에 따라 달라진다. ​

1. 먼저 a를 계산(메모리에서 가져오는 fetch)하면, ​
a가 5이고, fun1()이 3이므로, 둘을 더하면 a는 8이다. ​

2. 먼저 fun1을 계산하면, ​
fun1은 3이지만 부수효과로서 a가 17이므로, ​
둘을 더하면 a는 20이 된다. 

수학에서 함수는 x에 대응하는 y값을 찾는 것이므로, 부수 효과가 없다.​
함수 언어에서도 마찬가지다. ​
부수효과는 본 뉴만 아키텍처 및
 이에 기반한 명령형 언어의 계산 모형으로 인해 발생한다. ​
본 뉴만 아키텍처 및 이를 그대로 본뜬 명령형 언어의 계산 모형은 ​
계산하여 변화된 값의 상태를 항상 메모리에 
저장하도록 설계되어 있기 때문이다. ​

함수 부수효과의 해결책은 다음 두가지가 있다. ​

+ C, C++ 처럼 함수 부수 효과를 허용하지 않도록 언어를 설계하는 것이다. ​
    함수에서 단일 파라미터만 허용하여, 단일 값을 반환한다. ​
    만일 다수의 파라미터가 필요하면, struct를 사용하여 하나의 파라미터로 만든다. ​
    함수에서 글로벌 변수를 접근 불허한다. ​
    단점은 파라미터 및 글로벌 변수에 융통성이 없다. ​

2. 자바처럼 오퍼랜드 계산 순서를 고정시킨다. ​
    좌에서 우로… ​
    단점은 컴파일러 최적화를 제한한다.  ​

최적화를 위해 표현식을 reordering하기도 하는데 고정 순서는 이를 불허한다. 

---

+ 과적 연산자

기계어에서는 정수의 덧셈 연산자와 부동점 소수의 덧셈 연산자를 구분한다. 
부동점 소수의 덧셈: FADD, ​
정수의 덧셈: ADD ​
프로그래머는 정수의 덧셈과, 부동점 소수의 덧셈에 모두 +를 쓰고 싶어한다.  ​

1. 그러면서, 컴파일러가 알아서 이들을 구분하여 번역하기 바란다. ​
2. 두개의 배열 변수의 덧셈도 +로 간단히 쓰고 싶어 한다.  ​

이와 같이 하나의 연산자를 여러가지 목적으로 사용하는 것을 ​
연산자의 과적(오버로딩)이라고 한다. 

정수와 부동점에 대한 +의 과적은 ​
일상적으로 허용되지만, C와 C++에서는 문제를 일으키기도 한다. 

___

+ 타입 변환

정수와 부동점 소수 간의 덧셈에서, ​
데이터를 어떤 유형으로, 그리고 어떤 포맷으로 변환할 것인가? ​
유형: 정수, 부동점 소수 ​
포맷: 십진수 vs 이진수, 부동점의 (싸인,지수부분,소수부분) 각 몇 비트? 

Narrowing conversion은 ‘원래 유형의 모든 값’을 포함할 수 없
는 유형으로 변환하는 것을 의미한다. ​
예를 들어, 더블 부동점 소수를 싱글 부동점 소수로 변환하는 경우. ​
이때 항상 safe하지는 않다. -&amp;gt; 값의 크기가 바뀐다. 짤린다. ​​

Widening conversion은 원래 유형의 근사값을 포
함하는 유형으로 변환하는 것을 의미한다. ​
예를 들어 정수를 부동점 소수로 변환하는 경우. ​
이때, safe하다. 즉, 근사값으로 바뀌므로 크기가 바뀌지 않는다. ​
다만 포맷(내부 표현 방식)의 차이로 인해 정확하게 같지 않을 경우도 있다.   

오퍼랜드의 타입이 혼합되어 있을 때, ​
명시적이거나 암묵적으로 타입 변환이 필요하다. ​
컴파일러에 의한 암묵적 타입 변환을 코어젼이라고
 한다. -&amp;gt; 대부분의 언어에서…   ​
프로그래머에 의한 명시적 타입 변환을 캐스팅이라고 한다. ​
C에서는 (int) angle과 같이 캐스팅을 괄호로 표시한다.  ​

___

+ 비교 및 부울 표현식

비교 표현식은 두개의 오퍼랜드를 비교하
기 위해 비교 연산자를 사용한다. 

부울 표현식은 부울 연산자 and, or, not를 사용한다. 

표현식의 Short-circuit evaluation에 대해 살펴 본다.
Short-circuit evaluation은 ​
표현식의 결과를 도출하는데 충분한 계산이 완료되면, ​
그 이후의 표현식 계산을 중단한다는 의미이다. ​
따라서, 표현식의 최소 계산이라고 번역하겠다.  

표현식에서 여러 오퍼랜드 중에서 몇 개만 해보고 그 결과를 알 수 있다면 ​
모든 오퍼랜드를 계산할 필요가 없다. ​
이것을 표현식의 최소 계산이라고 한다. ​

간단한 예를 보자. ​
(13 * a) * (b/13–1)에서, a가 0이면, 1
3*a가 0이므로 더 이상 계산할 필요가 없다. ​

만일 최소 계산을 채택하지 않을 경우, ​
다음 프로그램에서 예상치 않은 문제를 발생시킨다. ​

index = 0;​
while ((index &amp;lt; listlen) &amp;amp;&amp;amp; (LIST[index]!= key)) 
index = index + 1; 이고, ​
LIST 배열의 인덱스가 0에서 listlen-1까지 라고 가정하자. ​

index==listlen일 때, (index &amp;lt; listlen)을 만족시키지 못한다. ​
그런데 최소 계산을 채택하지 않기때문에 여기서 중단되지 않고, ​
그 이후의 (LIST[index]!= key))를 계산하게 되며, ​
이때, LIST[index]에서 인덱싱 문제가 발생하게 된다. ​

이와 같이 최소 계산을 채택하지 않을 경우 ​
불필요한 오류를 발생시키기도 한다. 

최소 계산은 표현식의 부작용에 영향을 받을 수도 있다. ​
(a &amp;gt; b) || (b++ / 3)에서 ​
||의 두번째 오퍼랜드를 먼저 계산하면 ​
b가 증가하여 첫째 오퍼랜드의 결과에 영향을 준다.   

---

+ 대입문과 혼합 타입의 대입문

대입문의 일반적 형식은 &lt;var&gt; = &lt;expression&gt;이다. ​
대입 연산자 = 대신에 :=를 쓰기도 한다. ​
= 대신에 :=을 쓰는 이유는 =의 의미가 ‘같다＇의 의미와 혼동되기 때문이다. ​
=를 대입 연산자로 사용하는 경우, ‘같다＇의 연산자로 ==를 사용한다. 

조건 타겟은 조건에 따라 타겟 변수가 결정된다. ​
펄에서 조건 타겟이 포함된 대입문의 예를 보자. ​
대입문 ($flag ? $total : $subtotal) = 0에서 ​
대입 연산자 =의 왼쪽에 조건식이 포함되어 있는데, ​
이 뜻은 만일 ($flag)이 참이면 $total = 0이고, ​
거짓이면 $subtotal = 0이다 ​

복합 대입문 연산자는 대입문의 =과 연산자를 연결한 것이다. 
단항 대입문 연산자는 ++과 같은 것을 의미한다. 

표현식에 대입문을 쓰기도 한다. ​
while ((ch = getchar())!= EOF){…}​
  ch = getchar()
위의 while 문의 조건식에 ch = getchar()라는 대입문이 들어가 있다. ​
이 대입문이 먼저 실행되고 나서, 조건식이 계산된다. ​
그러면 getchar 값이 ch에 할당되고, ​
ch!=eof가 참이면 {…}가 실행된다. ​
a=b+(c=d/b)-1의 경우처럼, ​
표현식에 대입문을 쓰는 것은 대입문의 이해를 어렵게 한다. 
 
​($first, $second, $third) = (20, 30, 4
0)와 같이 다수의 값을 할당할 수도 있고, ​ 
 
Interchange를 ($first, $second) =
($second, $first)와 같이 쓸 수도 있다. 

함수 언어에서 identifier는 값의 이름에 불과하며, ​
변수를 나타내는 것이 아니기때문에 이들의 값은 바뀔 수 없다. ​
val fruit = apples + oranges;에서 ​
이름 fruit는 apples와 oranges의 값을 더해서 나온 결과 값의 이름이다.  ​

대입문에서 혼합 타입이 가능하다. ​
이때 타입 변환이 발생한다. 
​

---
&lt;/expression&gt;&lt;/var&gt;&lt;/expr&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">표현식과 대입문</summary>
      

      
      
    </entry>
  
</feed>
