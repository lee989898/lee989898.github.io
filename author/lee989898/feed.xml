<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://lee989898.github.io/author/lee989898/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://lee989898.github.io/" rel="alternate" type="text/html" />
  <updated>2021-11-17T11:20:07+09:00</updated>
  <id>https://lee989898.github.io/author/lee989898/feed.xml</id>

  
  
  

  
    <title type="html">LEE | </title>
  

  
    <subtitle>공부 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">프로세스통신-socket</title>
      <link href="https://lee989898.github.io/st-09" rel="alternate" type="text/html" title="프로세스통신-socket" />
      <published>2021-11-16T01:06:00+09:00</published>
      <updated>2021-11-16T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/st-09</id>
      <content type="html" xml:base="https://lee989898.github.io/st-09">&lt;h3 id=&quot;프로세스통신-socket&quot;&gt;&lt;strong&gt;프로세스통신-socket&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Socket&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Pipe는 통신하는 프로세스들을 하나의 시스템 내부로 한정 ​&lt;/li&gt;
  &lt;li&gt;Socket은 같은 시스템에 속한 프로세스들 뿐만 아니라, 서로 다른 시스템들에 속한 프로세스들 간의 통신을 가능케 함​
    &lt;ul&gt;
      &lt;li&gt;socket() 시스템 호출에 의해 만들어 짐 ​&lt;/li&gt;
      &lt;li&gt;응용 프로그램의 관점에서는 pipe와 마찬가지로 파일 디스크립터를 통해 접근(read, write, 등) 가능​&lt;/li&gt;
      &lt;li&gt;Kernel의 관점에서 socket은 IPC를 위한 통신의 끝점(또는 출입구)에 해당함​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;전혀 관계없는 프로세스간에 통신을 위해 socket을 식별할 목적으로 이름을 붙임​
    &lt;ul&gt;
      &lt;li&gt;파일 이름 또는 번호​&lt;/li&gt;
      &lt;li&gt;bind() 시스템 호출 사용​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;이름 붙이기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Linux 도메인에서는 socket 이름으로 파일 이름 사용 (경로명 포함)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;INET(Internet) 도메인에서는 socket 이름으로 포트번호 사용​&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;Well-known port: ftp는 21번, telnet은 23번, 등등. ​&lt;/li&gt;
      &lt;li&gt;통신 상대 프로세스가 속한 컴퓨터 시스템 이름(IP address) + 
  포트 번호&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st21.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Stream Socket을 이용한 IPC&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Virtual circuit​
    &lt;ul&gt;
      &lt;li&gt;통신 대상에 연결(논리적 접속)을 설정​&lt;/li&gt;
      &lt;li&gt;그 연결을 통하여 데이터를 송수신​&lt;/li&gt;
      &lt;li&gt;송수신이 끝나면 연결 해제​&lt;/li&gt;
      &lt;li&gt;연결형 통신이라고 부름 : 전화에 비유​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Stream socket​
    &lt;ul&gt;
      &lt;li&gt;Virtual circuit 기능을 이용하여 구현한 socket​&lt;/li&gt;
      &lt;li&gt;프로세스간에 대량의 데이터를 송수신하는 경우 이용 ​&lt;/li&gt;
      &lt;li&gt;통신의 신뢰성 보증​&lt;/li&gt;
      &lt;li&gt;송신한 정보가 없어지거나 바뀌지 않음​&lt;/li&gt;
      &lt;li&gt;올바른 순서로 수신됨​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;연결형 프로토콜의 예 : TCP (Transmission Control Protocol)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Client :​
    &lt;ul&gt;
      &lt;li&gt;Socket 작성 : socket() 시스템 호출​&lt;/li&gt;
      &lt;li&gt;Socket에 이름 붙임 : bind()  생략 가능​&lt;/li&gt;
      &lt;li&gt;Server에 접속 요구 : connect()​&lt;/li&gt;
      &lt;li&gt;데이터 송수신 : read()/write()  socket이 파일 디스크립터로 접근 가능하므로​&lt;/li&gt;
      &lt;li&gt;Socket 제거 : close()​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Server : ​
    &lt;ul&gt;
      &lt;li&gt;Socket 작성 : socket() 시스템 호출​&lt;/li&gt;
      &lt;li&gt;Socket에 이름 붙임 : bind()​&lt;/li&gt;
      &lt;li&gt;Client의 접속 요구 받을 준비 : listen()​&lt;/li&gt;
      &lt;li&gt;접속 요구 허가 : accept()​&lt;/li&gt;
      &lt;li&gt;데이터 송수신 : read()/write()​&lt;/li&gt;
      &lt;li&gt;Socket 제거 : close()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st22.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Datagram Socket을 이용한 IPC&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Datagram​
    &lt;ul&gt;
      &lt;li&gt;통신 대상에 연결(논리적 접속)을 설정할 필요 없음​&lt;/li&gt;
      &lt;li&gt;개개의 데이터를 그때 그때 상대방에게 보냄​&lt;/li&gt;
      &lt;li&gt;비 연결형 통신이라고 부름 : 편지에 비유​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Datagram socket​
    &lt;ul&gt;
      &lt;li&gt;Datagram 기능을 이용하여 구현한 socket​&lt;/li&gt;
      &lt;li&gt;프로세스간에 작은 데이터를 계속해서 보내는 통신​&lt;/li&gt;
      &lt;li&gt;매번 데이터를 보낼 때마다 상대방을 지정 ​&lt;/li&gt;
      &lt;li&gt;전송 데이터의 신뢰성이 보증되지 않음 : 시간, 순서, 등​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;비 연결형 프로토콜의 예 : UDP (User Datagram Protocol)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Client :​
    &lt;ul&gt;
      &lt;li&gt;Socket 작성 : socket() 시스템 호출​&lt;/li&gt;
      &lt;li&gt;Socket에 이름 붙임 : bind()  생략 가능​&lt;/li&gt;
      &lt;li&gt;데이터 송신 : sendto() ​&lt;/li&gt;
      &lt;li&gt;데이터 수신 : recvfrom()​&lt;/li&gt;
      &lt;li&gt;Socket 제거 : close()​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Server : ​
    &lt;ul&gt;
      &lt;li&gt;Socket 작성 : socket() 시스템 호출​&lt;/li&gt;
      &lt;li&gt;Socket에 이름 붙임 : bind()​&lt;/li&gt;
      &lt;li&gt;데이터 수신 : recvfrom()​&lt;/li&gt;
      &lt;li&gt;데이터 송신 : sendto()​&lt;/li&gt;
      &lt;li&gt;Socket 제거 : close()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;socket() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int socket(int domain, int type, int protocol)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;소켓을 생성​
    &lt;ul&gt;
      &lt;li&gt;int domain :  사용하는 도메인의 종류​&lt;/li&gt;
      &lt;li&gt;int type :      사용하는 소켓 타입​&lt;/li&gt;
      &lt;li&gt;int protocol : 사용하는 프로토콜의 종류​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정상 종료시 생성된 소켓에 대한 파일 디스크립터 반환, 에러시 -1 반환&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Domain의 종류 ​
    &lt;ul&gt;
      &lt;li&gt;PF_UNIX : unix domain ​&lt;/li&gt;
      &lt;li&gt;PF_INET : inet domain​&lt;/li&gt;
      &lt;li&gt;그 이외​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Socket type의 종류​
    &lt;ul&gt;
      &lt;li&gt;Sock_stream : stream socket​&lt;/li&gt;
      &lt;li&gt;Sock_dgram : datagram socket​&lt;/li&gt;
      &lt;li&gt;그 이외​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용되는 고유의 protocol 지정. 대부분 0을 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;bind() system call​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int bind(int sockfd, struct sockaddr *my_addr, int len)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;int sockfd : socket() 시스템 호출에서 돌려 받은 socket 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;struct sockaddr *my_addr : 이름을 붙일 구조체​
    &lt;ul&gt;
      &lt;li&gt;struct sockaddr *my_addr 에는 다음을 지정​
        &lt;ul&gt;
          &lt;li&gt;Unix domain 또는 Inet domain 중 어느 쪽을 사용할 지​&lt;/li&gt;
          &lt;li&gt;Socket 이름​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;int len :  이름이 붙여진 구조체(*my_addr)의 길이​&lt;/li&gt;
  &lt;li&gt;Unix Domain에서 socket의 주소 정보는 socketaddr_un 구조체에서 정의​
```
#include &amp;lt;sys/un.h&amp;gt;​
#define UNIX_PATH_MAX 108​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;struct sockaddr_un {​
    sa_family_t   sun_family;     /* sa_family_t는 short과 같은 타입&lt;em&gt;/​
     /&lt;/em&gt; PF_UNIX 설정 &lt;em&gt;/​
    char sun_path[UNIX_PATH_MAX];   /&lt;/em&gt; 경로명 */​&lt;/p&gt;

&lt;p&gt;};&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ Inet Domain에서 socket의 주소 정보는 socketaddr_in 구조체에서 정의​

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;#include &amp;lt;netinet/in.h&amp;gt;​&lt;/p&gt;

&lt;p&gt;struct sockaddr_in {​
    sa_family_t     sin_family;   /* PF_INET 설정 &lt;em&gt;/
    u_int16_t        sin_port;      /&lt;/em&gt; 포트 번호 &lt;em&gt;/​
    struct in_addr   sin_addr;    /&lt;/em&gt; IP 주소 */​&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;}; ​ struct in_addr { u_int32_t  s_addr; };  /* IP 주소 */ ```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;connect() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;netinet/in.h&amp;gt;​
#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int connect(int sockfd, const struct socketaddr *serv_addr, socklen_t addr_len)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;스트림 소켓 이용시 client에서 호출 (서버에 접속 요청)​&lt;/li&gt;
  &lt;li&gt;정상 종료시 0을 반환, 에러시 -1 반환​
    &lt;ul&gt;
      &lt;li&gt;int sockfd : socket 파일 디스크립터를 지정​&lt;/li&gt;
      &lt;li&gt;struct sockaddr *serv_addr : 접속하고 싶은 서버의 소켓 주소 정보 ​&lt;/li&gt;
      &lt;li&gt;socklen_t addr_len : 서버의 소켓 주소 정보 구조체의 길이​
​
        &lt;blockquote&gt;
          &lt;p&gt;listen() system call&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/socket.h&amp;gt;​

int listen(int sockfd, int backlog)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;스트림 소켓 이용시 server에서 호출 정상 종료시 0을 반환, 에러시 -1 반환​&lt;/li&gt;
  &lt;li&gt;int sockfd : socket 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;int backlog : 연결 요청에 대한 대기열의 최대 길이(대개 5)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;accept() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int accept(int sockfd, struct sockaddr *client_addr, socklen_t *addrlen)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;스트림 소켓 이용시 server에서 호출​&lt;/li&gt;
  &lt;li&gt;정상 종료시 소켓에 대한 새로운 파일 디스크립터를 반환, 에러시 -1 반환​&lt;/li&gt;
  &lt;li&gt;int sockfd : socket 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;struct sockaddr *client_addr : client의 socket 주소 정보 구조체를 가리키는 포인터​&lt;/li&gt;
  &lt;li&gt;socklen_t *addrlen : client의 socket 주소 정보 구조체의 길이&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;send() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int send(int sockfd, const void *buf, size_t len, int flags)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Send() : 소켓으로 데이터 보냄&lt;/li&gt;
  &lt;li&gt;정상 종료시 실제 보낸 바이트 수를 반환, 에러시 -1 반환​&lt;/li&gt;
  &lt;li&gt;int sockfd : accept로 반환된 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;const void *buf : 송신 버퍼의 시작 주소​&lt;/li&gt;
  &lt;li&gt;size_t len : 송신 데이터의 길이​&lt;/li&gt;
  &lt;li&gt;int flags : 송신 옵션&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;recv() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int recv(int sockfd, void *buf, size_t len, int flags)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Recv() : 소켓으로부터 데이터 받음&lt;/li&gt;
  &lt;li&gt;정상 종료시 실제 받은 바이트 수를 반환, 에러시 -1 반환​&lt;/li&gt;
  &lt;li&gt;int sockfd : accept로 반환된 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;void *buf : 수신 버퍼의 시작 주소​&lt;/li&gt;
  &lt;li&gt;size_t len : 수신 데이터의 길이​&lt;/li&gt;
  &lt;li&gt;int flags : 수신 옵션&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;sendto() system call​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;​

int sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *to, socklen_t tolen)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;정상 종료시 실제 보낸 바이트 수를 반환, 에러시 -1 반환​&lt;/li&gt;
  &lt;li&gt;int sockfd : 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;const void *buf : 송신 버퍼의 시작 주소​&lt;/li&gt;
  &lt;li&gt;size_t len : 송신 데이터의 길이​&lt;/li&gt;
  &lt;li&gt;int flags : 송신 옵션 ​&lt;/li&gt;
  &lt;li&gt;const struct sockaddr *to : 받을 곳의 소켓 주소 정보 구조체를 가리키는 포인터​&lt;/li&gt;
  &lt;li&gt;socklen_t tolen : 받을 곳의 소켓 주소 정보 구조체의 길이​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;recvfrom() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;​
#include &amp;lt;sys/socket.h&amp;gt;​

int recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlen)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;정상 종료시 실제 받은 바이트 수를 반환, 에러시 -1 반환​&lt;/li&gt;
  &lt;li&gt;int sockfd : 파일 디스크립터를 지정​&lt;/li&gt;
  &lt;li&gt;void *buf : 수신 버퍼의 시작 주소​&lt;/li&gt;
  &lt;li&gt;size_t len : 수신 데이터의 길이​&lt;/li&gt;
  &lt;li&gt;int flags : 수신 옵션​&lt;/li&gt;
  &lt;li&gt;struct sockaddr *from : 보내는 곳의 소켓 주소 정보 구조체를 가리키는 포인터​&lt;/li&gt;
  &lt;li&gt;socklen_t tolen : 보내는 곳의 소켓 주소 정보 구조체의 길이&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="system" />
      

      
        <summary type="html">프로세스통신-socket</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">되추적</title>
      <link href="https://lee989898.github.io/algorithm-07" rel="alternate" type="text/html" title="되추적" />
      <published>2021-11-15T01:09:00+09:00</published>
      <updated>2021-11-15T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-07</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-07">&lt;h3 id=&quot;되추적&quot;&gt;&lt;strong&gt;되추적&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;되추적&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;완전 탐색을 개선한 기법&lt;/li&gt;
  &lt;li&gt;후보 해들을 단계적으로 만들어 가는 과정에서 후보 해들을 평가&lt;/li&gt;
  &lt;li&gt;만약 한 후보 해가 최종 해가 될 수 없다고 판단되면 탐색을 멈추고 다른 후보 해를 탐색&lt;/li&gt;
  &lt;li&gt;최적화 문제와 결정 문제 해결 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;하산 길 선택&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;하산 길에 갈림길에 안내 표지판이 없다면
    &lt;ol&gt;
      &lt;li&gt;갈림길에서 한 길을 선택한 후 그 길을 따라 계속해서 간다&lt;/li&gt;
      &lt;li&gt;길이 끊기면 절벽에 도달하면 갈림길로 되돌아온다&lt;/li&gt;
      &lt;li&gt;갈림길에서 다른 길을 선택해서 간다&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;상태공간트리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;특정 알고리즘의 진행 과정을 나타낸 트리&lt;/li&gt;
  &lt;li&gt;노드: 한 해의 구성요소들에 대한 특정 선택&lt;/li&gt;
  &lt;li&gt;후보 해: 루트 노드에서 종단 노드까지의 경로&lt;/li&gt;
  &lt;li&gt;후보 해 중에 해가 있음&lt;/li&gt;
  &lt;li&gt;해가 될 가능성이 전혀 없는 노드의 자손 노드들을 고려하지 않음&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;예: 미로 찾기&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;노드의 유망성
    &lt;ul&gt;
      &lt;li&gt;해가 될 가능성이 있는 노드는 유망하고 아니면 유망하지 않다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;되추적이란?
    &lt;ul&gt;
      &lt;li&gt;어떤 노드의 유망성을 점검한 후, 유망하지 않다고 판정이 되면 그 노드의 부모 노드로 돌아가서 다음 자식 노드에 대한 탐색을 계속한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;상태 공간 트리에서 깊이 우선 탐색
    &lt;ul&gt;
      &lt;li&gt;유망한 노드만 자식 노드 탐색&lt;/li&gt;
      &lt;li&gt;유망하지 않은 노드는 가지 쳐서 탐색 중단&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;순열 생성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&amp;lt;1,2, …, N&amp;gt;의 모든 순열을 생성하라&lt;/li&gt;
  &lt;li&gt;예: N = 3인 경우
    &lt;ul&gt;
      &lt;li&gt;&amp;lt;1,2,3&amp;gt;, &amp;lt;1,3,2&amp;gt;, &amp;lt;2,1,3&amp;gt;, &amp;lt;2,3,1&amp;gt;, &amp;lt;3,1,2&amp;gt;, &amp;lt;3,2,1&amp;gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag19.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;아이디어: 배열의 첫 번째, 두 번째와 세 번째 요소를 각각 첫 번째 요소와 교환한 후 배열의 나머지 부분에 대해 순열을 생성하는 일을 재귀적으로 반복한다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;permute(A[], k) // &amp;lt;A[k], A[k + 1], ..., A[N-1]&amp;gt;의 모든 순열을 생성
// 입력: A[0 .. N - 1] - 순열을 저장하는 배열, k - 배열 A의 지수
// 출력: &amp;lt;A[k], A[k + 1],..., A[N-1]&amp;gt;의 모든 수열
1 if (k = N) { A[0 .. N - 1]을 출력한다; return}
2 for(i = 1; i &amp;lt;= N; i++) // A[k]를 i로 정하기 전에 가능한지 확인
3   if(promising(A,k,i)) { // A[k]를 i로 정하는 것이 가능한 경우
4       A[k] = i
7       permute(A, k+1)} // A[k+1], ..., A[N-1]&amp;gt; 의 모든 순열을 생성

// 최초호출: permute(A[], 0) 

// A[k]를 i로 정하는 것이 가능한지 확인
promising(A[],k,i)
1 flag = true
2 j = 0
3 while(j &amp;lt; k &amp;amp;&amp;amp; flag){
4 if(j = A[j]) flag = false
5 j++       }
6 return flag

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;해밀토니안 회로 찾기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;헤밀토니안 회로: 연결된 무방향 그래프에서 한 정점에서 출발하여 모든 정점을 정확히 한번씩 방문하고 다시 출발 정점으로 돌아오는 경로&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;헤밀토니안 회로 찾기 문제: 연결된 무방향 그래프에서 해밀토니안 회로를 찾아라&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;가정: n - 그래프내의 정점들의 수
    &lt;ol&gt;
      &lt;li&gt;트리의 루트 노드에 시작 정점을 놓는다&lt;/li&gt;
      &lt;li&gt;for(i = 1; i &amp;lt; n; i++)&lt;/li&gt;
    &lt;/ol&gt;
    &lt;ul&gt;
      &lt;li&gt;트리의 수준 i에 i번째로 방문할 정점으로 시작 정점을 제외한 모든 정점을 선택하는 것을 고려한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;i번째 방문 정점 j의 선택 조건
    &lt;ol&gt;
      &lt;li&gt;i가 (n-1)이라면 j는 시작 정점과 인접해야 한다&lt;/li&gt;
      &lt;li&gt;i가 (n-1)보다 작다면 루트 노드로부터 j까지의 경로상의 (i-1)번째 정점과 인접해야 한다&lt;/li&gt;
      &lt;li&gt;j는 루트 노드로부터 j까지의 경로상에서 j 전에 방문한 (i-1)개의 정점들 중 하나가 되어서는 안된다&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위 조건들을 만족하면 트리의 다음 수준 (i + 1)에 대해 같은 과정을 계속하고 아니면 해 탐색을 멈추고 부모 노드로 되돌아가서 i번째로 방문할 정점으로 아직 선택안한 정점들 중의 하나를 선택하고 조건을 확인한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;n: 정점들의 수&lt;/li&gt;
  &lt;li&gt;i, 1 &amp;lt;= i &amp;lt;= n : 정점의 번호&lt;/li&gt;
  &lt;li&gt;1: 시작 정점&lt;/li&gt;
  &lt;li&gt;그래프 G = (V,E)는 인접 행렬 G로 표현한다.
    &lt;ul&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;G[i - 1][j - 1] = { 1, (i,j) $\in$ E&lt;/td&gt;
              &lt;td&gt;0, (i,j) $\notin$ E}&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;path[i], 0&amp;lt;= i &amp;lt;= n-1: 해밀토니안 회로에서 i번째 정점&lt;/li&gt;
  &lt;li&gt;path[0] = 1&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hamiltonian(G[][], i)
// 입력: i - 그래프의 정점
//      G[0 .. n - 1][0 .. n - 1] - 그래프의 인접 행렬
// 출력: 해밀토니안 회로
1 if (valid(G,i))
2   if ( i = n - 1) { path[0 .. n - 1]을 출력한다; return}
5   else // i번째로 방문할 정점을 모든 정점을 시도해 본다
6       for( j = 2; j &amp;lt;= n; j++){
7           path[i + 1] = j
8           hamiltonian(G,i + 1)
    }
// 최초 호출: hamiltonian(G, 0)

boolean valid(G[][], i) // 경로상의 i번째 정점이 유효한 선택인지 확인
1 if(i = n - 1 and G[path[n-1]-1][path[0] - 1] = 0)
    // 경로상의 마지막 정저이 첫 번째 정점과 인접하지 않은 경우
2   return false
3 else if( i &amp;gt; 0 and G[path[i - 1]- 1][path[i] - 1] = 0)
    // 경로상의 i번째 정점이 이미 선택되었는지를 확인
4   return false
5 else { // 경로상의 j번째 정점이 이미 선택되었는지를 확인
6    j = 1
7    while(j &amp;lt; i){
8       if(path[i] = path[j]) return false
9       j++ }
    }
10 return true

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;시간 복잡도: O($n^n)$&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;그래프 색칠하기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;m-색칠하기 문제: 무방향 그래프에서 최대 m(&amp;gt;1)개의 색들을 사용하여 인접한 정점들을 서로 다른 색으로 칠하라&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;응용 분야: 지도 색칠하기&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;지도에서 각 국가는 그래프에서 한 정점으로 나타내고 국경을 맞대고 있는 두 개의 국가들은 대응하는 정점들 사이의 간선으로 나타내면 모든 지도는 그에 상응하는 평면 그래프로 표현할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag20.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;m-색칠하기 상태 공간 트리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;수준 i, 1&amp;lt;=i&amp;lt;=n,에서 정점 i에 가능한 m개의 색들을 각각 시도해 본다(n은 정점들의 수)&lt;/li&gt;
  &lt;li&gt;루트 노드에서 종단 노드까지의 경로가 각각 후보 해가 된다. 이 경로상의 어떤 두 개의 인접한 정점들이 같은 색인지를 확인하여 같은 색이면 그 경로는 더 이상 고려하지 않고 가지 친다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;m-색칠하기 되추적 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;n: 정점들의 수&lt;/li&gt;
  &lt;li&gt;m: 색들의 수&lt;/li&gt;
  &lt;li&gt;i, 1&amp;lt;= i &amp;lt;= n: 정점의 번호&lt;/li&gt;
  &lt;li&gt;1: 시작 정점&lt;/li&gt;
  &lt;li&gt;그래프 G = (V,E)는 인접 행렬 G로 표현한다
    &lt;ul&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;G[i-1][j-1] = {1, (i,j) $\in$ E&lt;/td&gt;
              &lt;td&gt;0, (i,j) $\notin$ E}&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;vcolor[i], 1&amp;lt;=i&amp;lt;=n: 정점 i에 칠해진 색&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;m_coloring(G[][], i)
// 입력: G[0 .. n - 1][0 .. n - 1] - 그래프의 인접 행렬
//      i - 그래프의 정점
// 출력: vcolor[1..n] - 정점들에 칠해진 색들의 배열
1 if (valid(G, i))
2   if ( i = n){
3       vcolor[1 .. n] 을 출력한다
4       return
5   } else { //다음 정점에 모든 색을 시도해 본다
6       for( c = 1; c &amp;lt;= m; c++){
7           vcolor[i + 1] = c
8           m_coloring(G, i + 1) }
    }
// 최초 호출: hamiltonian(G,0)

// 정점 i에 칠해진 색이 유효한지 확인한다
boolean valid(int G[][], i)
1 j = 1
2 while(j &amp;lt; i){
    // i의 색이 인접한 정점(들)의 색과 같은지 확인
3   if (G[i - 1][j - 1] = 1 and vcolor[i] = vcolor[j])
4       return false
5   j++
    }
6 return true

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;시간복잡도: O($m^n$)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">되추적</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Key Management (KDC &amp;amp; CA)</title>
      <link href="https://lee989898.github.io/sc-13" rel="alternate" type="text/html" title="Key Management (KDC &amp; CA)" />
      <published>2021-11-11T01:06:00+09:00</published>
      <updated>2021-11-11T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-13</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-13">&lt;h3 id=&quot;key-management-kdc--ca&quot;&gt;&lt;strong&gt;Key Management (KDC &amp;amp; CA)&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Session Key&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Session: 회기, 입회기간&lt;/li&gt;
  &lt;li&gt;통신 seesion이 시작될 때 생성되서 종료될때 폐기되는 동적 대칭키&lt;/li&gt;
  &lt;li&gt;통신 session마다 다른 키를 사용하면 안전&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;다중사용자가 세션키사용 할 경우&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;2명의 사용자 간에 1개의 비밀키 사용&lt;/li&gt;
  &lt;li&gt;3명의 사용자 간에 3개의 비밀키 사용&lt;/li&gt;
  &lt;li&gt;사용자 1명 추가 시 3개의 비밀키가 추가로 필요&lt;/li&gt;
  &lt;li&gt;n명이면 n(n-1)/2 만큼의 키가 필요&lt;/li&gt;
  &lt;li&gt;대칭키 유지 및 관리 부하&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;KDC (Key Distribution Centre)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;중앙의 신뢰할 수 있는 키관리, 분배 책임주체&lt;/li&gt;
  &lt;li&gt;사용자들은 KDC 등록신청하면, KDC가 각 사용자들과 비밀키를 공유&lt;/li&gt;
  &lt;li&gt;각 사용자는 이 키를 사용하여 KDC와 통신한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc23.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Operation&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Alice와 Bob은 KDC와의 통신을 위한 $K_{A-KDC}$, $K_{B-KDC}$ 를 알고 있다. Alice는 KDC와 통신하여 세션키 R1 과 $K_{B-KDC}$(A,R1)을 얻는다.
Alice는 Bob에게 $K_{B-KDC}$(A,R1)을 보내고 Bob은 R1을 추출해낸다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;KDC 장단점&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;KDC의 장점
    &lt;ul&gt;
      &lt;li&gt;비밀키 방식은 비교적 속도가 빠름&lt;/li&gt;
      &lt;li&gt;서버를 사용하지 않는 경우보다 키 관리를 쉽게 해줌&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;KDC의 단점
    &lt;ul&gt;
      &lt;li&gt;단일 실패 지점 (SPoF, Single Point of Failure)
        &lt;ul&gt;
          &lt;li&gt;KDC가 고장나면 전혀 서비스를 할 수 없음&lt;/li&gt;
          &lt;li&gt;해결책: 미러 서버 가동
            &lt;ul&gt;
              &lt;li&gt;서버와 미러간의 일관성 문제 발생 가능&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;+KDC가 공격되면 모든 비밀키가 노출될 수 있음&lt;/li&gt;
      &lt;li&gt;KDC의 신뢰성이 매우 중요함&lt;/li&gt;
      &lt;li&gt;KDC에 대한 병목현상 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hierarchical Key Control&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;단일 KDC는 대규모 네트워크에서 비효율적&lt;/li&gt;
  &lt;li&gt;KDC를 계층화
    &lt;ul&gt;
      &lt;li&gt;local KDC
        &lt;ul&gt;
          &lt;li&gt;single LAN or building&lt;/li&gt;
          &lt;li&gt;같은 domain 에서의 통신시 키 분배&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;global KDC
        &lt;ul&gt;
          &lt;li&gt;다른 domain 간의 통신시 키 선택&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;KDC의 손상시 지역에 한정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;CA (Certification Authorities)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;for public key cryptography&lt;/li&gt;
  &lt;li&gt;전자서명을 위해선 신뢰성 있는 공개키 보관장소 필요 해커가 다른 사용자의 공개키를 자기것인 척 하는 것을 방지&lt;/li&gt;
  &lt;li&gt;공인인증서의 발급과 관리하는 기관&lt;/li&gt;
  &lt;li&gt;Role
    &lt;ul&gt;
      &lt;li&gt;사용자들의 공개키를 저장하고 관리&lt;/li&gt;
      &lt;li&gt;사용자들이 요청시 해당 공개키를 서명해서 전송(public key certificate, 공개키 인증서)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Operation&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Bob은 CA에 공개 키를 등록한다
    &lt;ul&gt;
      &lt;li&gt;Bob은 CA에 신원증멸 을 제공한다&lt;/li&gt;
      &lt;li&gt;CA는 Bob을 공개 키에 바인딩하는 인증서를 생성한다&lt;/li&gt;
      &lt;li&gt;CA가 디지털 서명한 Bob의 공개 키를 포함하는 인증서: CA는 “이것은 B의 공개 키이다”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Alice가 Bob의 공개 키를 원할 때:
    &lt;ul&gt;
      &lt;li&gt;Bob의 인증서를 얻는다.&lt;/li&gt;
      &lt;li&gt;CA의 공개 키를 Bob의 인증서에 적용하고 Bob의 공개 키를 가져온다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;공개키 인증서 (공인인증서, Public Key Certificate)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;특정 공개키가 해당 사용자의 공개키임을 신뢰할수있는 기관에서 보증하는 문서 -&amp;gt; 사용자 인증&lt;/li&gt;
  &lt;li&gt;사용자 공개키에 공인인증기관의 전자서명을 첨부한 것&lt;/li&gt;
  &lt;li&gt;4요소
    &lt;ul&gt;
      &lt;li&gt;공개키인증서: 공개키가 누구것인지, 대칭되는 비밀키는 누가 갖고있는지&lt;/li&gt;
      &lt;li&gt;인증서정책: 인증서 사용방식&lt;/li&gt;
      &lt;li&gt;인증서경로: 인증서를 연결하는 방식&lt;/li&gt;
      &lt;li&gt;인증서 철회리스트: 유효성확인&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;공개키 기반구조 (PKI, Public key Infrastructure)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;정의​
    &lt;ul&gt;
      &lt;li&gt;공개키 방식을 통해 암호화 및 전자서명/인증서의 사용을 가능하도록 해주는 기반구조로 X.509(표준), PGP, AADS/X9.59 등 있다​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;​구성 요소​
    &lt;ul&gt;
      &lt;li&gt;사용자 : 개인이나 기관 또는 응용 서비스​&lt;/li&gt;
      &lt;li&gt;인증기관(CA) : 공개키 인증서발급 및 관리​&lt;/li&gt;
      &lt;li&gt;등록기관(registration authority: RA): 사용자 인증서 신청시 인증기관대신 신분확인​&lt;/li&gt;
      &lt;li&gt;저장소(repository): 인증서,사용자정보,인증서취소,상호인증서 등을 저장 검색​&lt;/li&gt;
      &lt;li&gt;인증서정책(policy): 권한, 사용범위 정의​&lt;/li&gt;
      &lt;li&gt;공개키인증서​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;국내 인증기관(CA)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;전자서명법​
    &lt;ul&gt;
      &lt;li&gt;공인인증서: 전자서명을 생성하기 위하여 이용된 정보가 가입자에게 유일하게 속한다는 사실등을 확인하고 증명하는 전자정보. 이름, 유효기관, 발급기관, 전자서명방식, 인증번호등 포함​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;공인인증기관(CA) : 공인인증서의 발급과 관리를 담당하는 기관으로 금융결제원, 한국정보인증, 한국증권전산, 한국전자인증, 한국전산원, 한국무역정보통신, 코스콤​&lt;/li&gt;
  &lt;li&gt;주요역할​
    &lt;ul&gt;
      &lt;li&gt;공개키와 비밀키 생성, 인증서 발급/폐지​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;등록기관(RA, Registration Authority)​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;인증기관의 위임을 받아 사용자가 신청시 신원확인 및 공개키 생성/등록을 수행&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;국내 공인 인증서 발급절차​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;발급기관(CA or RA)에 공인인증서 발급신청(직접방문, 신분증제출)​&lt;/li&gt;
  &lt;li&gt;발급기관에서 등록확인서 발급 (참조번호, 인가코드)​&lt;/li&gt;
  &lt;li&gt;발급기관 홈페이지접속해서 공인인증서 발급 신청​&lt;/li&gt;
  &lt;li&gt;공인인증서 파일이 발급​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">Key Management (KDC &amp;amp; CA)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Concurrency</title>
      <link href="https://lee989898.github.io/pl-18" rel="alternate" type="text/html" title="Concurrency" />
      <published>2021-11-10T19:18:00+09:00</published>
      <updated>2021-11-10T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-18</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-18">&lt;h3 id=&quot;comcurrency&quot;&gt;&lt;strong&gt;Comcurrency&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Concurrency&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;동시 실행은
    &lt;ul&gt;
      &lt;li&gt;인스트럭션 수준&lt;/li&gt;
      &lt;li&gt;문장 수준&lt;/li&gt;
      &lt;li&gt;서브프로그램 수준&lt;/li&gt;
      &lt;li&gt;프로그램 수준​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이렇게 4개 수준에서 이루어 질 수 있다.&lt;br /&gt;
인스트럭션 수준에서는 두개 이상의 머신 인스트럭션을 동시에 실행한다. ​
문장 수준에서는 두개 이상의 고급언어 문장을 동시에 실행한다. ​&lt;br /&gt;
서브프로그램 수준에서는 두개 이산의 서브프로그램을 동시에 실행한다.&lt;br /&gt;
프로그램 수준에서는 두개 이상의 프로그램을 동시에 실행한다. ​&lt;/p&gt;

&lt;p&gt;동시 실행 통제 메커니즘은 프로그래밍의 유연성을 증가시킨다.&lt;br /&gt;
동시 실행 통제 메커니즘은 원래 운영체제의 문제를 풀기 위해 발명되었으나, ​다양한 응용 프로그램에서도 요구된다.&lt;/p&gt;

&lt;p&gt;프로그램 수준의 동시 실행 사례는 웹에서 볼 수 있다.&lt;br /&gt;
웹 브라우저는 다음과 같은 여러가지 기능을 동시에 실행해야 한다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;웹 서버에게 데이터를 주고 받기 ​&lt;/li&gt;
  &lt;li&gt;텍스트와 이미지를 스크린에 렌더링하기​&lt;/li&gt;
  &lt;li&gt;마우스와 키보드에 의한 사용자 액션에 대응하기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;IE9는 별도의 코어를 사용하여 클라이언트 측의 스크립트 코드를 인터프러터 방식으로 처리한다.  ​&lt;/p&gt;

&lt;p&gt;문장 수준의 동시 실행은 프로그램 수준의 경우와 매우 다르다.&lt;br /&gt;
언어 설계자는 문장 수준의 동시 실행을 위해 다음에 대해 중점을 둔다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;데이터를 다수의 메모리에 어떻게 분산시킬 것인가? ​&lt;/li&gt;
  &lt;li&gt;어느 문장을 동시 실행할 것인가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;동시 실행 알고리즘은 확장성이 있어야 한다.&lt;br /&gt;
사용하는 프로세서의 수를 증가시킬수록 실행 속도가 증가하면, ​ 확장성이 있다고 말한다.&lt;/p&gt;

&lt;p&gt;알고리즘은 이식성이 있어야 한다.&lt;br /&gt;
알고리듬이 다른 아키텍처의 기계에서 효율적으로 실행된다면, ​ 
이 알고리듬은 이식성이 있다고 말한다.&lt;br /&gt;
이식성은 하드웨어의 수명이 비교적 짧아지고 있어서, 매우 중요하다.&lt;/p&gt;

&lt;p&gt;플린은 컴퓨터를 다음과 같이 분류하였다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SISD는 하나의 인스트럭션이 하나의 데이터를 처리하는 것으로, ​
프로세서가 하나인 컴퓨터가 이에 속한다. ​&lt;/li&gt;
  &lt;li&gt;SIMD는 하나의 인스트럭션으로 여러 데이터를 처리한다. ​
벡터 프로세서가 이에 속하며, 벡터 프로세서는 ​
벡터 연산자의 여러 오퍼랜드를 저장하는 여러 개의 레지스터를 갖고 있어서, ​
이들 여러 오퍼랜드에 대해 하나의 인스트럭션을 실행한다.  ​&lt;/li&gt;
  &lt;li&gt;MISD는 하나의 데이터에 대해 다수의 인스트럭션을 차례로 동시 실행한다. ​마치 파이프라인처럼… 파이프라인 컴퓨터가 이에 속한다. ​&lt;/li&gt;
  &lt;li&gt;MIMD는 다수의 인스트럭션이 다수의 데이터를 동시 실행한다. ​
MIMD는 여러 개의 프로세서로 구성되며, 각 프로세서는 자신의 인스트럭션 스트림을 처리한다. ​MIMD 컴퓨터에는 분산형과 공유 메모리형, 두가지 유형이 있다. ​
분산 MIMD 머신은 하나의 랙에 구성되거나 각 지역에 분산되어 구성되며, ​각 프로세서는 자신의 고유 메모리를 갖는다. ​
공유메모리 MIMD 머신은 여러 프로세서가 하나의 메모리를 공유하며, ​
메모리 액세스의 충돌을 방지하기 위한 동기화 수단을 제공해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;플린의 분류에 따라, 각각의 머신을 그림으로 표현하면 이 아래 그림과 같다. PU는 프로세싱 유닛으로 싱글 코어 및 멀티코어 프로세서이다.&lt;/p&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl48.png&quot; width=&quot;25%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;동시 실행을 필요로 하는 이유는 다음과 같다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로그램이 하드웨어를 동시에 사용하도록 설계되었다면, ​
멀티 프로세서 머신에서 프로그램의 실행 속도는 빠르다.  ​&lt;/li&gt;
  &lt;li&gt;프로그램이 컴퓨트 바운드가 아니라면, ​
싱글 프로세서 머신에서 실행하더라도, ​
동시 실행하도록 짜여진 프로그램은 순차 실행하도록 짜여진 프로그램보다 빠르다. ​&lt;/li&gt;
  &lt;li&gt;동시 실행은 문제 해결책에 대한 다른 방식의 개념화 방법을 제공한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;문제의 해결책을 설계할 때 Recursion이 자연스러운 방법인 경우가 있는 것처럼, ​동시 실행이 자연스러운 문제가 많이 있다. ​
예를 들어 시뮬레이션은 여러 개의 엔티티를 포함하고, ​
여러 엔티티가 자신에게 주어진 역할을 수행한다. ​
이때 각 엔티티는 서로 종속되어 있지 않기 때문에 동시 실행이 가능하다.  ​
이와 같이 문제에 따라서 동시 실행이 자연스러운 경우가 있다. ​&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;어플리케이션 프로그램을 여러 머신에 분산시켜야 하는 경우가 있다.  ​이때, 각 머신은 특정 타스크(동시 실행 통제 메커니즘)를 실행하면서, 프로그램 실행을 동기화해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Semaphore&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;프로그램이 여러 서브프로그램으로 구성되어 있을 때, ​
동일 프로그램 내의 다른 서브프로그램과 동시 실행되는 서브프로그램을 
Task 또는 Process라고 한다. ​&lt;/p&gt;

&lt;p&gt;자바에서는 특정 메소드, 즉 run method가 Task의 역할을 하며, ​
이 메소드는 쓰레드라고 불리는 객체 내에서 실행된다.  ​
​
동시 실행되는 Task들 간에 실행 순서를 통제하는 것을 동기화라고 한다.&lt;br /&gt;
협력적 동기화는 타스크 A가 Task B의 종료를 기다렸다가, Task B의 종료 후 Task A가 실행하는 방식으로, 실행 순서를 통제한다.&lt;br /&gt;
경쟁적 동기화는 Task A, B가 공유 변수(데이터 위치) x를 접근할 필요가 있다면, ​Task B가 x를 접근하고 있는 동안, ​&lt;/p&gt;

&lt;p&gt;Task A는 Task B가 x의 접근을 종료하기를 기다리는 방식으로 실행 순서를 통제한다.&lt;/p&gt;

&lt;p&gt;가장 단순한 형태의 협력적 동기화의 예로 생산자-소비자 문제를 들 수 있다. ​&lt;/p&gt;

&lt;p&gt;하나의 서브 프로그램(생산자)이 데이터를 생산하고, ​다른 서브프로그램(소비자)이 그것을 소비한다.&lt;br /&gt;
생산된 데이터는 보통 스토리지 버퍼에 저장된다. ​&lt;/p&gt;

&lt;p&gt;경쟁적 동기화는 두 Task가 정확히 동시에 공유 변수에 대한 접근을 방지해야 한다.​&lt;/p&gt;

&lt;p&gt;만일 TOTAL이 공유 변수이고, ​
Task A가 TOTAL+1, Task B가 TOTAL*2라면, ​
Task A, B가 동시에 TOTAL을 변경하고자 한다면, ​
이들 간에 공유 변수에 대한 레이스 컨디션이 발생한다.&lt;br /&gt;
이를 해결하기 위해 상호배제를 보장해 줘야 하는데, ​이때 데드락이 발생할 수 있다. 따라서 데드락 방지책도 함께 제공해야한다&lt;/p&gt;

&lt;p&gt;동시 실행을 위한 언어 설계 시, 고려사항은 다음과 같다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;경쟁 및 협업 동기화​&lt;/li&gt;
  &lt;li&gt;Task 스케줄링​&lt;/li&gt;
  &lt;li&gt;Task를 언제 어떻게 생성하고, Task의 실행을 언제 어떻게 시작 및 종료시킬 것인가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;세마포어는 Task 동기화에 사용되는 단순한 메커니즘이다.&lt;br /&gt;
세마포어는 카운터(정수)와 Task 서술자를 저장하는 큐로 구성되며, ​
Task 서술자는 Task 실행 상태에 관한 모든 관련 정보를 저장한다.&lt;br /&gt;
연산자는 wait, release가 있다.&lt;/p&gt;

&lt;p&gt;협력 동기화를 위한 세마포어 변수는 다음과 같다.&lt;br /&gt;
엠티스팟 세마포어는 엠티스팟 카운터와 엠티스팟 큐로 구성되며, ​&lt;/p&gt;

&lt;p&gt;풀스팟 세마포어는 풀스팟 카운터와 풀스팟 튜로 구성된다.&lt;br /&gt;
엠티스팟 카운터는 버퍼의 비어있는 칸의 수를 나타내고,​
풀 카운터는 버퍼의 채워진 칸의 수를 나타낸다. ​
 ​
엠티스팟 큐는 버퍼에 빈칸이 생기기(즉, 아이템이 나가기)를 기다리는 생산자의 Task를 저장하고, 풀스팟 큐는 버퍼에 아이템이 채워지기를 기다리는 소비자의 Task를 저장한다.&lt;/p&gt;

&lt;p&gt;협력 동기화를 위해 필요한 공유 버퍼에 대한 연산자는 ​
디파짓과 펫치가 있다. ​&lt;/p&gt;

&lt;p&gt;먼저 디파짓을 살펴 보면, ​
디파짓은 공유 버퍼에 데이터를 넣기 위한 생산자의 액션으로 다음과 같이 진행된다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;버퍼에 빈칸이 있는지 엠티스팟 세마포어를 검사한다. ​&lt;/li&gt;
  &lt;li&gt;만일 적어도 하나 있으면, 디파짓을 실행하고, 엠티스팟의 카운터를 -1 하고, 풀스팟의 카운터를 +1한다. (버퍼에 채워진 칸이 하나 이상 있다는 것을 나타냄)​&lt;/li&gt;
  &lt;li&gt;만일 버퍼가 꽉차면, 엠티스팟 큐에 생산자의 타스크 서술자를 넣고, 버퍼에 빈칸이 생길 때까지 기다린다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음, 펫치를 살펴 보자.&lt;br /&gt;
펫치는 버퍼로부터 데이터를 빼내기 위한 소비자의 액션으로 다음과 같이 진행된다.&lt;br /&gt;
버퍼가 비어있지 않은지 풀스팟 세마포어를 검사한다.&lt;br /&gt;
만일 비어있지 않다면, 펫치를 실행하고(버퍼로부터 데이터를 빼내고), 엠티스팟 카운터를 -1하고, 풀스팟 카운터를 +1한다.&lt;br /&gt;
만일 버퍼가 비어있다면, 풀스팟 큐에 소비자의 타스크 서술자를 넣고, 데이터가 생길 때까지 기다린다.&lt;/p&gt;

&lt;p&gt;앞의 버퍼에 대한 연산에서 보았듯이, 디파짓과 펫치는 ​
세마포어의 카운터와 버퍼에 대한 조작(+, -, 디파짓, 펫치)을 수반한다. ​
 ​
디파짓과 펫치는, ​
이 연산을 세마포어에 대해 직접 수행할 수 있지만, ​
세마포어에 대한 ‘연산’을 별도로 정의하고,  ​
이를 통해 세마포어 조작을 간접적으로 수행하기도 한다. ​&lt;/p&gt;

&lt;p&gt;이때 세마포어에 대한 연산은 wait(빨간불)과 release(초록불)이다. ​
wait에서, 카운터가 0보다 크면 카운터 -1한다. ​
만일 카운터가 0보다 크지 않으면, 큐에 Task 서술자를 넣고 기다린다. ​
release에서, 큐가 비어 있으면, 카운터를 +1한다. ​
만일 큐가 비어 있지 않으면, 큐에서 Task를 빼서 실행한다.&lt;/p&gt;

&lt;p&gt;컴피티션이 언제 어디에서 일어나는가? ​
Shared variable을 서로 갱신하겠다고 동시에 요청할 때 발생한다.&lt;br /&gt;
이때 shared variable에 대한 mutual exclusion(상호배제)를 위해 ​
별도의 세마포어가 필요하다.&lt;br /&gt;
그런데 이 세마포어는 카운터가 필요없다.&lt;br /&gt;
이러한 이유로 이진 세마포어로 정의한다. ​&lt;/p&gt;

&lt;p&gt;만일 앞의 shared buffer의 협력적 동기화 문제에서, ​
한번에 하나의 타스크만 버퍼에 접근할 수 있다고 제한한다면, ​
Shared buffer에 대한 별도의 이진 세마포어가 필요하다. ​&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Monitor&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;세마포어의 사용은 동기화의 신뢰성 문제를 야기한다.&lt;/p&gt;

&lt;p&gt;모니터는 이와 같이 동기화의 신뢰성 문제를 해결하기 위한 방법으로, ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;공유 데이터 구조를 연산자로 캡슐화하여 ​&lt;/li&gt;
  &lt;li&gt;프로그래머로부터 공유 데이터구조의 상세 사항을 숨긴다.&lt;br /&gt;
이렇게 하여 동기화에 대한 책임을 런타임 시스템으로 돌린다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;모니터는 class로 구현될 수 있다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;공유 데이터 타입을 갖는 추상 데이터 타입으로 표현 ​&lt;/li&gt;
  &lt;li&gt;이 클래스의 객체에 대한 접근은 액세스 메소드에 동기화 modifier를 추가하여 통제한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;모니터는 concurrent pascal, ada, java 등에서 지원된다.&lt;/p&gt;

&lt;p&gt;사용자 프로그램은 모니터를 사용하여 공유 버퍼에 접근한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;공유 데이터는 사용자 프로그램 안에 없고, 모니터 안에 있다. ​&lt;/li&gt;
  &lt;li&gt;액세스 메커니즘은 모니터(런타임 시스템)의 일부분으로, 상호 배제를 보장한다. 즉, 모니터가 바쁠 땐, 모니터에 대한 호출이 block되고 큐에 들어가서 기다린다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl49.png&quot; width=&quot;25%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 모니터를 표현한 것이다. ​
모니터는 상호배제만을 제공하기 때문에, ​
협력 동기화에서 요구되는 프로세스 간의 협력은 프로그래머가 코딩해야 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;자바 쓰레드&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;쓰레드는 run 메소드를 실행하는 프로세스이다.&lt;br /&gt;
즉, run 메소드는 쓰레드에 할당되어야 실행된다.&lt;br /&gt;
쓰레드 클라스는 쓰레드가 아닌 다른 클라스의 부모가 될 수 없고, ​쓰레드의 서브 클래스에게 서비스를 제공한다. ​&lt;/p&gt;

&lt;p&gt;Run method는 자바에서 동시 실행 단위로서, ​
Run 메소드 코드는 main 메소드, 다른 run 메소드 등과 동시 실행 된다. ​&lt;/p&gt;

&lt;p&gt;Run 메소드로 클라스를 정의하는 방법은 두 가지가 있다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;첫째 방법은, 쓰레드 클래스의 서브클래스를 정의하여 서브 클라스의 run 메소드로 오버라이드하는 방법이다. 만일 새로운 서브 클래스가 다른 부모를 갖고 있으면, 이 방법은 동작하지 않는다. ​&lt;/li&gt;
  &lt;li&gt;둘째 방법은, 다른 부모로부터 상속된 서브 클래스를 정의하고 runnable 인터페이스를 구현하는 방법이다. Runnable은 run 메소드 프로토콜을 제공하기 때문에, runnable로 구현된 어떤 클래스도 run 메소드를 정의한다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정리하면, 쓰레드 클래스는 다른 클라스의 부모가 될 수 없기 때문에, ​
어플리케이션 클라스의 메소드를 쓰레드로 실행하려면 runnable로 실행해야 한다. ​&lt;/p&gt;

&lt;p&gt;​쓰레드 클라스는 동시 실행 자바 프로그램을 생성한다.&lt;br /&gt;
쓰레드 클라스는 컨스트럭트, 메소드 등으로 구성된다. ​&lt;/p&gt;

&lt;p&gt;쓰레드 클라스의 메소드는 ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Run 메소드는 쓰레드의 액션을 서술한다. ​&lt;/li&gt;
  &lt;li&gt;Start 메소드는 run 메소드를 호출하여, 그 쓰레드의 동시 실행을 시작한다.​&lt;/li&gt;
  &lt;li&gt;setPriority 메소드는 쓰레드의 우선순위를 변경하고 ​&lt;/li&gt;
  &lt;li&gt;getPriority 메소드는 쓰레드의 현재 우선순위를 반환한다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​아래 코드는 run 메소드로 쓰레드의 액션을 서술하고, ​
Start 메소드로 그 쓰레드의 동시 실행을 시작하는 것을 보여준다.&lt;/p&gt;

&lt;p&gt;Yield 메소드는 동시 실행중인 쓰레드로부터 프로세서의 자발적인 포기를 요구한다.&lt;br /&gt;
이 쓰레드는 즉시 프로세서를 포기하고 ready 큐로 들어 간다.&lt;br /&gt;
Sleep 메소드는 쓰레드가 지정된 시간이 지난 후에 block되기를 원한다.&lt;br /&gt;
이 쓰레드는 ready 큐에 들어간다. ​
Join 메소드는 메소드에게, ​다른 쓰레드의 run 메소드가 종료될 때까지, ​실행을 msec 단위로 지연시킬 것을 강요한다.  ​
아래 코드는 join 메소드의 사용 예를 보여준다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void run() {​

 
 Thread myTh = new Thread();​

 myTh.start();​

 // do part of the computation of this thread​

 myTh.join(); // Wait for myTh to complete​

 // do the rest of the computation of this thread​

}​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;세마포어 클라스는 카운팅 세마포어를 구현한다.&lt;br /&gt;
객체는 카운터만 있고, 큐는 없다.&lt;br /&gt;
메소드는 acquire 메소드(wait)와 release(release) 메소드가 있다.&lt;br /&gt;
아래 코드는 이들 메소드의 사용 예를 보여주고 있다.&lt;br /&gt;
디파짓과 펫치의 앞뒤에 이들 메소드가 있음을 주의하라. ​&lt;/p&gt;

&lt;p&gt;acquire()는 세마포어 -1 한다. ​
release()는 세마포어 +1 한다.&lt;br /&gt;
여기서 세마포어는 fullspot, emptyspot이다.&lt;/p&gt;

&lt;p&gt;자바 쓰레드에서 상호배제는 모니터 개념으로 구현한다.&lt;br /&gt;
이때 메소드는 synchronize로 지정된다.&lt;br /&gt;
ManageBuf에서 디파짓과 펫치를 synchronize로 정의하여, ​
동일한 객체에 대해 실행할 때 서로 방해하는 것을 방지한다. ​&lt;/p&gt;

&lt;p&gt;아래 코드는 모니터 개념으로 구현된 ManageBuf에서 ​
메소드가 synchronized로 지정된 예를 보여준다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ManageBuf {​

  private int [100] buf;​

   . . .​

  public synchronized void deposit(int item) { . . . }​

  public synchronized int fetch() { . . . }​

   . . .​

}​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;모니터는 상호배제를 구현하므로, 프로세스 간의 협력적 동기화를 구현하지 못한다.&lt;br /&gt;
따라서 프로세스 간의 협력 동기화의 구현을 위해, ​쓰레드 대기 리스트(wait list of threads)와 wait, notify, notifyAll을 구현한다.&lt;br /&gt;
각각의 객체(P-C 문제에서 producer, consumer가 객체)는 쓰레드 대기 리스트를 가지며, ​대기 리스트에 있는 쓰레드들은 이 객체로부터 자신의 실행에 필요한 ​이벤트를 기다리고 있는 것이다.&lt;br /&gt;
wait 메소드는 쓰레드를 대기 리스트에 넣고 기다리게 한다.&lt;br /&gt;
Notify 메소드는 어떤 대기 쓰레드에게 ‘기다리고 있는 이벤트가 발생했음’을 알린다. ​ 
Notify 메소드가 특정 쓰레드를 깨울 수는 없고, ​JVM이 쓰레드 대기 리스트에서 무작위로 하나를 선택한다.&lt;br /&gt;
NotifyAll 메소드는 ‘객체에서 발생된 이벤트’를 기다리고 있는 쓰레드를 ​모두 깨워서 task-ready queue에 넣는다.&lt;br /&gt;
이렇게 하는 이유는 대기 리스트에 있는 쓰레드들이 기다리고 있는 조건이 ​모두 다를 수 있기 때문이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;자바 쓰레드: Lock&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;자바 쓰레드는 lock을 지원한다.&lt;br /&gt;
자바 쓰레드에 미리 정의된 ReentrantLock 클라스는 ​Lock 인터페이스를 구현하는 데 사용되며, ​lock 인터페이스는 lock, unlock, tryLock 메소드를 선언한다.&lt;br /&gt;
lock 메소드는 try 블록을 사용하여 크리티칼 코드(크리티칼 섹션)를 둘러싼다.&lt;br /&gt;
unlock 메소드의 호출은 finally 절 안에 있어야 하며, lock의 해제를 보장한다.  ​&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Statement-Level Concurrency&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;고성능 포트란에서 두 개의 리스트에서 ​서로 대응되는 요소 간의 연산을 병렬 처리하고자 할 때 다음과 같은 문장이 추가된다.&lt;br /&gt;
PROCESSOR proc(n) -&amp;gt; 배열 처리 문장을 동시 실행(병렬 처리)하기 위해 프로세서 n개를 할당 ​DISTRIBUTE (BLOCK vs. CYCLIC) -&amp;gt; 같은 크기의 블록으로 나누어져 프로세서에 할당, 돌아가면서 하나씩 프로세서에 할당 ​ALIGN array1_elt WITH array2_elt -&amp;gt; 배열1에 배열2를 대응시킴&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">Comcurrency</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">NP-완전</title>
      <link href="https://lee989898.github.io/algorithm-06" rel="alternate" type="text/html" title="NP-완전" />
      <published>2021-11-09T01:09:00+09:00</published>
      <updated>2021-11-09T01:09:00+09:00</updated>
      <id>https://lee989898.github.io/algorithm-06</id>
      <content type="html" xml:base="https://lee989898.github.io/algorithm-06">&lt;h3 id=&quot;np-완전&quot;&gt;&lt;strong&gt;NP-완전&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;문제의 분류&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;풀 수 있는(solvable) 문제​
    &lt;ul&gt;
      &lt;li&gt;P 문제: 다항 시간 내에 풀 수 있는 문제 ​&lt;/li&gt;
      &lt;li&gt;NP 문제: 다항 시간 내에 풀 수 없는 문제​
        &lt;ul&gt;
          &lt;li&gt;비결정론적 다항 시간 알고리즘으로 해결할 수 있는 문제​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;NP-완전 문제: 지수 시간 내에 풀 수 있는 문제​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;풀 수 없는(unsolvable) 문제​
    &lt;ul&gt;
      &lt;li&gt;예: 정지 문제(Halting Problem)​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag14.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;결정 문제​
    &lt;ul&gt;
      &lt;li&gt;Yes 혹은 No의 해를 요구하는 문제​&lt;/li&gt;
      &lt;li&gt;예: 무방향그래프의 정점 s 에서 정점 f 까지 가는 경로의 거리가 K(상수) 이하인 경로가 있는가?​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;최적화 문제​
    &lt;ul&gt;
      &lt;li&gt;최적의 해를 요구하는 문제​&lt;/li&gt;
      &lt;li&gt;예: 무방향그래프의 정점 s 에서 정점 f 까지 가는 최단 경로의 거리는 얼마인가?​&lt;/li&gt;
      &lt;li&gt;최적화 문제는 모두 대응하는 결정 문제로 바꾼 다음 해결한다.​&lt;/li&gt;
      &lt;li&gt;최적화 문제는 대응하는 결정 문제보다 풀기가 쉽지 않다. ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;비결정론적 다항 시간 알고리즘에 의해 해결할 수 있는 결정 문제들의 집합​&lt;/li&gt;
  &lt;li&gt;비결정론적 다항 시간 알고리즘이란?​
    &lt;ul&gt;
      &lt;li&gt;한 결정 문제의 사례 I를 입력으로 받아 다음을 수행하는 2 단계 알고리즘​&lt;/li&gt;
      &lt;li&gt;비결정론적 ‘추측’ 단계: 주어진 사례 I에 대한 해 S를 ‘추측’한다.​&lt;/li&gt;
      &lt;li&gt;결정론적 ‘확인’ 단계: 사례 I와 해 S를 입력으로 받아 S가 I에  대한 해임을 결정론적 다항 시간에 확인하고 그 해가 맞으면 ‘Yes’ 라고 답하고 해가 아니라면 ‘No’ 라고 답하거나 알고리즘이 종료되지 않게 한다. ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;NP 문제는 해가 Yes 라는 근거가 주어졌을 때 그 해가 옳은 근거임을 다항 시간에 확인해 줄 수 있다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-완전 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;NP에 속하는 문제​&lt;/li&gt;
  &lt;li&gt;어떤 NP-완전 문제를 다항 시간 알고리즘에 의해 풀 수 있다면 나머지 모든 NP-완전 문제들도 다항 시간 알고리즘에 의해 풀 수 있다.​&lt;/li&gt;
  &lt;li&gt;NP-완전 문제는 결정 문제만으로 국한한다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-완전 문제의 핵심 원리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;결정 문제의 변환을 이용한 해결 과정​
    &lt;ul&gt;
      &lt;li&gt;결정 문제 A를 다항 시간에 해결할 수 있는지 알고 싶다.​&lt;/li&gt;
      &lt;li&gt;가정​
        &lt;ul&gt;
          &lt;li&gt;다항 시간에 해결 가능한 결정 문제 B를 이미 알고 있다.​&lt;/li&gt;
          &lt;li&gt;문제 A를 다항 시간에 문제 B로 변환할 수 있고 문제 B의 해(Yes 혹은 No)가 문제 A의 해와 항상 일치한다.​
            &lt;ol&gt;
              &lt;li&gt;문제 A의 사례를 문제 B의 사례로 변환한다. ​&lt;/li&gt;
              &lt;li&gt;변환된 문제 B의 사례를 문제 B의 알고리즘을 이용하여 해결한다.&lt;br /&gt;
주: 문제 A도 다항 시간에 해결할 수 있다.​&lt;/li&gt;
            &lt;/ol&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다항 시간에 해결할 수 있는 결정 문제가 아직까지 발견되지   않았다. 따라서 문제 A를 다항 시간에 해결할 수 있는지는 알 수 없다. ​&lt;/li&gt;
  &lt;li&gt;NP-완전 문제들은 서로 다항 시간에 변환 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-완전 정의&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;결정 문제 D는 다음 조건들을 만족시켜야 한다. ​
    &lt;ol&gt;
      &lt;li&gt;문제 D는 NP에 속한다.​&lt;/li&gt;
      &lt;li&gt;NP에 속한 모든 문제는 다항 시간에 문제 D로  변환 가능하다.​&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-hard&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;NP-완전보다 넓은 범위의 문제를 포함한다. ​&lt;/li&gt;
  &lt;li&gt;문제 A가 다음 조건을 만족하면 NP-hard이다.​
    &lt;ul&gt;
      &lt;li&gt;NP에 속한 모든 문제는 다항 시간에 문제 A로 변환 가능하다. ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;NP-완전 문제는 NP-hard에 속한다. ​&lt;/li&gt;
  &lt;li&gt;NP-hard 문제는 반드시 NP 문제일 필요는 없다.​&lt;/li&gt;
  &lt;li&gt;NP-hard는 최적화 문제도 포함한다.​&lt;/li&gt;
  &lt;li&gt;문제 A가 다음 조건들을 만족하면 NP-완전이다. ​
    &lt;ol&gt;
      &lt;li&gt;A는 NP에 속한다.​&lt;/li&gt;
      &lt;li&gt;A는 NP-hard이다. ​&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/ag/ag15.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;한 문제가 NP-hard에 속한다는 것을 증명하는 것은 매우 어렵다. 왜냐하면 NP에 속한 모든 문제를 다항 시간에 그 문제로 변환 가능함을 보여야 하기 때문이다. ​&lt;/li&gt;
  &lt;li&gt;정리: 한 NP-hard 문제를 다항 시간에 주어진 문제로 변환 가능하다면 그 문제는 NP-hard에 속한다. ​&lt;/li&gt;
  &lt;li&gt;한 문제가 NP-hard에 속한다는 증명은 이 정리를 이용한다.​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;문제 A의 NP-완전 증명 방법​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;문제 A가 NP에 속함을 보인다.​&lt;/li&gt;
  &lt;li&gt;한 NP-hard 문제 C의 사례를 다항 시간에 문제 A의 사례로 변환하는 알고리즘을 작성한다.​&lt;/li&gt;
  &lt;li&gt;2의 알고리즘을 수행하여 얻은 결과 사례 C와 사례 A의 Yes/No 해가 일치함을 보인다.​&lt;br /&gt;
주: 어떤 문제가 NP-완전 문제임을 증명하는 것은 쉽지 않다. ​&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;NP-완전 문제​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;논리곱 정규형-만족​&lt;/li&gt;
  &lt;li&gt;완전 부분 그래프​&lt;/li&gt;
  &lt;li&gt;정점 커버​&lt;/li&gt;
  &lt;li&gt;부분 집합의 합​&lt;/li&gt;
  &lt;li&gt;그래프 색칠하기​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;논리곱 정규형-만족 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;부울 연산식은 논리곱 정규형으로 표현될 수 있다.&lt;/li&gt;
  &lt;li&gt;문제: 논리곱 정규형의 주어진 부울 연산식의 값이 true가 되도록 부울 연산식의 변수들에 true나 false 값을 할당할 수 있는가?&lt;/li&gt;
  &lt;li&gt;예: a,b,c -부울 변수,$\bar{a}$, $\bar{b}$ , $\bar{c}$ : a,b,c의 역&lt;br /&gt;
부울 연산삭: ($\bar{a}$ $\lor$ $\bar{b}$ $\lor$ c) $\land$ ($\bar{a}$ $\lor$ b) $\land$ (a $\lor$ $\bar{b}$ $\lor$ $\bar{c}$ )
해: a = true, b = true, c = true&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;완전 부분 그래프​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무방향 그래프 내에 있는 최대 크기의 완전 부분 그래프를 찾아라&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/ag/ag16.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;정점 커버​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무방향 그래프 내에 있는 최소 크기의 정점 커버를 찾아라&lt;/li&gt;
  &lt;li&gt;정점 커버: 무방향 그래프에서 각 간선의 양쪽 끝의 두 정점들 중에서 적어도 1개의 정점을 포함하는 정점들의 집합&lt;/li&gt;
  &lt;li&gt;예: 아래 그래프에서 최소 크기의 정점 커버 C = {a,c,e}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/ag/ag17.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;부분 집합의 합 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;정수들의 집합 S의 요소들의 합이 K가 되는 S의 부분 집합을 찾아라.&lt;/li&gt;
  &lt;li&gt;예: S = {10,20,40,70,80}, K = 160
    &lt;ul&gt;
      &lt;li&gt;부분 집합{10,70,80}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;그래프 색칠하기 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;무방향 그래프에서 인접한 정점들을 서로 다른색으로 가장 적은 수의 색을 사용하여 색칠하라&lt;/li&gt;
  &lt;li&gt;예: 아래 그래프에서 a,c: 빨강, b,d: 초록, e: 파랑&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/ag/ag18.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;알고리즘&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">NP-완전</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">접근 제어</title>
      <link href="https://lee989898.github.io/sc-12" rel="alternate" type="text/html" title="접근 제어" />
      <published>2021-11-04T01:06:00+09:00</published>
      <updated>2021-11-04T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-12</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-12">&lt;h3 id=&quot;접근-제어&quot;&gt;&lt;strong&gt;접근 제어&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Access Control&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;허가되지 않은 사용자의 자원 접근 막고&lt;/li&gt;
  &lt;li&gt;정당한 사용자라도 허가되지 않은 방법으로 자원사용 막고&lt;/li&gt;
  &lt;li&gt;정당한 사용자가 허가된 방식으로만 자원에 접근하도록&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Access control components&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc17.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Authentication function: 사용자가 시스템에 접근할 수 있는지 결정&lt;/li&gt;
  &lt;li&gt;Access control function: 사용자의 요청이 허용되는지 결정&lt;/li&gt;
  &lt;li&gt;Security admin: 사용자의 요청이 자원에 어떻게 접근하는지를 명시한 권한 DB를 관리&lt;/li&gt;
  &lt;li&gt;Audit: 사용자가 시스템 자원에 접근하는 것을 기록, 감시&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Access control architecture&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc18.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Access Control Policy&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;접근 제어 정책&lt;/li&gt;
  &lt;li&gt;어떤 상황에서, 누구에게 어떤 종류의 접근이 허용되는지를 결정&lt;/li&gt;
  &lt;li&gt;권한 DB에 저장되며 보안 admin이 관리&lt;/li&gt;
  &lt;li&gt;종류 (동시에 사용가능)
    &lt;ul&gt;
      &lt;li&gt;Discretinoary access control(DAC)&lt;/li&gt;
      &lt;li&gt;Mandatory access control(MAC)&lt;/li&gt;
      &lt;li&gt;Role-based access control(RBAC)&lt;/li&gt;
      &lt;li&gt;Attribute-based access control(ABAC)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Discretinoary access control(DAC)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;임의 접근 제어&lt;/li&gt;
  &lt;li&gt;요청자의 신분에 따라 무엇을 할 수 있는지 정의&lt;/li&gt;
  &lt;li&gt;Window, unix 등 컴퓨터 시스템 널리 사용&lt;/li&gt;
  &lt;li&gt;Access Matrix 사용
    &lt;ul&gt;
      &lt;li&gt;주체와 객체, 권한을 행렬로 표현&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Access matrix
    &lt;ul&gt;
      &lt;li&gt;행: 자원접근 주체, subject&lt;/li&gt;
      &lt;li&gt;열: subject가 접근하는 대상자원, object&lt;/li&gt;
      &lt;li&gt;Entry: 허용되는 접근&lt;/li&gt;
      &lt;li&gt;-Matrix가 커질 수 있고, 희박해지면 메모리 낭비&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc19.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;방법1. ACL - Access control lists
    &lt;ul&gt;
      &lt;li&gt;Access matrix를 열로 분리&lt;/li&gt;
      &lt;li&gt;객체에 대한 권한을 가진 주체 파악에 유리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc20.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;방법2. Capablility tickets
    &lt;ul&gt;
      &lt;li&gt;Access matrix 행으로 분리&lt;/li&gt;
      &lt;li&gt;특정 주체에 대해 승인된 객체와 권한 명시&lt;/li&gt;
      &lt;li&gt;특정 사용자에 허가된 객체/권한들을 정리하기 쉬움&lt;/li&gt;
      &lt;li&gt;다른 주체에서 티켓을 빌려 주거나 양도 -&amp;gt; 보안문제 발생&lt;/li&gt;
      &lt;li&gt;티켓 무결성, 기밀성, 인증성&lt;/li&gt;
      &lt;li&gt;OS가 관리&lt;/li&gt;
      &lt;li&gt;분산, Cloud 환경에 적합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc21.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;방법 3. authorization table
    &lt;ul&gt;
      &lt;li&gt;한 행에 한 주제의 한 자원에 대한 권한명시&lt;/li&gt;
      &lt;li&gt;RDB로 구현 용이&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc22.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;DAC 장단점 분석
    &lt;ul&gt;
      &lt;li&gt;장점
        &lt;ul&gt;
          &lt;li&gt;객체별 세분화된 접근 제어가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;단점
        &lt;ul&gt;
          &lt;li&gt;Access Matrix 사용에 따른 메모리 낭비&lt;/li&gt;
          &lt;li&gt;주체나 객체별로 제어하기 때문에, 전체 자원의 일관성 있는 제어 어려움&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Role-based access control (RBAC)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;각 사용자 대신에 역할에 접근 권할을 할당&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;상업적으로 회사,기관,조직에서 많이 쓰임&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자 vs 역할 vs 자원의 관계는 다대다&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;관계는 동적이다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;RBAC 장단점 분석
    &lt;ul&gt;
      &lt;li&gt;장점
        &lt;ul&gt;
          &lt;li&gt;전체적으로 일관성있는 제어정책가능&lt;/li&gt;
          &lt;li&gt;직무분석 용이&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;단점
        &lt;ul&gt;
          &lt;li&gt;각 주체, 객체별 유연하게 하기 어려움&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Attribute-based access control(ABAC)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;가장 최근&lt;/li&gt;
  &lt;li&gt;주체와 자원의 속성을 표현&lt;/li&gt;
  &lt;li&gt;DAC, RBAC의 기본개념 실형가능&lt;/li&gt;
  &lt;li&gt;유연성과 표현력이 우수&lt;/li&gt;
  &lt;li&gt;3요소 - 속성, 정책 모델, 아키텍처 모델&lt;/li&gt;
  &lt;li&gt;+유연하고 세분화 보안정책 설계&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-설계자 과다업무, 비용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;속성
    &lt;ul&gt;
      &lt;li&gt;주체, 객체, 환경, 권한에 의해 미리 정의되고 할당된 요구되는 동작의 특정 측면을 정의하는 성질​&lt;/li&gt;
      &lt;li&gt;주체 속성​
        &lt;ul&gt;
          &lt;li&gt;주체는 정보가 객체사이에 이동하거나 시스템 상태를 변경하는 능동적 존재(User, application, process, device)​&lt;/li&gt;
          &lt;li&gt;주체의 이름, 소속, 직책 등​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;객체 속성​
        &lt;ul&gt;
          &lt;li&gt;정보를 포함하거나 받는 수동적 시스템 존재 (file, device, table, record, process, program, network)​&lt;/li&gt;
          &lt;li&gt;MS Word문서는 이름, 저자, 날짜 등을 속성으로 가짐​&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;환경 속성​
        &lt;ul&gt;
          &lt;li&gt;운영, 기술, 상황, 환경 기술​&lt;/li&gt;
          &lt;li&gt;현재 날짜, 시간, 네트워크 보안 레벨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">접근 제어</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">ImplementSubprogram</title>
      <link href="https://lee989898.github.io/pl-17" rel="alternate" type="text/html" title="ImplementSubprogram" />
      <published>2021-11-03T19:18:00+09:00</published>
      <updated>2021-11-03T19:18:00+09:00</updated>
      <id>https://lee989898.github.io/pl-17</id>
      <content type="html" xml:base="https://lee989898.github.io/pl-17">&lt;h3 id=&quot;implementsubprogram&quot;&gt;&lt;strong&gt;ImplementSubprogram&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;서브프로그램 호출과 반환의 구현, 이것을 서브프로그램 링키지(linkage)라고 합니다.​&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Semantics of Calls and Returns&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;서브프로그램 링키지는 호출과 반환에 관련된 액션들의 실행으로 구성된다. ​&lt;br /&gt;
이러한 액션들을 호출 및 반환 시맨틱이라고 한다. ​&lt;/p&gt;

&lt;p&gt;일반적인 서브프로그램 호출 시맨틱은 다음을 포함한다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;파라미터 패싱 방법의 구현, ​&lt;/li&gt;
  &lt;li&gt;로컬 변수에 대한 스토리지 할당 및 바인딩 (로컬 변수가 정적 변수가 아닐 경우) ​&lt;/li&gt;
  &lt;li&gt;콜러의 실행 상태 저장: ​
    &lt;ul&gt;
      &lt;li&gt;실행상태는 콜러의 재실행(resume)에 필요한 레지스터 값, CPU 상태 비트, 환경 포인터(EP)를 포함하며,​&lt;/li&gt;
      &lt;li&gt;EP는 콜리의 실행 중에, 로컬 변수 및 파라미터를 접근하는데 사용된다.  ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;콘트롤을 콜리에게 이전​&lt;/li&gt;
  &lt;li&gt;콜리에 나타나는 난로컬 변수의 접근 메커니즘의 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;서브프로그램의 반환 시맨틱은 다음을 포함한다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;포말 파라미터의 로컬 값을 액추얼 파라미터에게 인아웃 또는 아웃 모드로 카피​&lt;/li&gt;
  &lt;li&gt;로컬 변수의 스토리지를 해제​&lt;/li&gt;
  &lt;li&gt;콜러 실행 상태의 재저장​&lt;/li&gt;
  &lt;li&gt;콜러에게 콘트롤 이전&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Implementing “Simple” Subprograms&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;단순 서브프로그램의 호출 및 반환을 어떻게 구현하는지 보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;단순 서브프로그램에서는 ​서브프로그램의 중첩을 허용하지 않고, 모든 로컬 변수가 정적이다. ​&lt;/li&gt;
  &lt;li&gt;호출과 반환에 필요한 스토리지는 다음의 데이터를 포함한다. ​
    &lt;ul&gt;
      &lt;li&gt;콜러의 상태 정보, 파라미터, 복귀 주소, 함수의 반환값​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단순 서브프로그램은 서브프로그램 코드와 데이터로 구성되는데, ​
    &lt;ul&gt;
      &lt;li&gt;데이터 파트는 로컬 변수, 호출과 반환에 필요한 데이터(위에 언급된)를 포함한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;단순 서브프로그램의 호출 시맨틱스(액션과 그 순서)은 다음과 같다. ​&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;현재 수행중인 프로그램(콜러)의 실행 상태를 저장 ​&lt;/li&gt;
  &lt;li&gt;파라미터의 계산 및 패스​&lt;/li&gt;
  &lt;li&gt;콜리에게 복귀 주소를 패스​&lt;/li&gt;
  &lt;li&gt;콜리에게 컨트롤을 이전&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;단순 프로그램의 반환 시맨틱스(액션과 그 순서)는 다음과 같다. ​&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;포말 파라미터의 현재 값을 대응하는 액추얼 파라미터에게 카피 (만일 pass-by-value-result나 pass-by-value라면) ​&lt;/li&gt;
  &lt;li&gt;함수 값을 콜러에게 카피(만일 콜리가 함수라면) ​&lt;/li&gt;
  &lt;li&gt;콜러의 실행 상태를 재저장​&lt;/li&gt;
  &lt;li&gt;콜러에게 컨트롤을 재이전(되돌려줌)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;실행중인 서브프로그램의 데이터 파트를 위한 데이터 구조로 액티베이션 레코드를 정의한다.&lt;br /&gt;
액티베이션 레코드는 로컬 변수, 파라미터, 복귀 주소로 구성된다.&lt;br /&gt;
단순 서브프로그램의 액티베이션 레코드(AR)는 크기가 고정되어 있고, ​정적으로 할당된다.&lt;br /&gt;
따라서 스택에 저장되지 않는다. ​이러한 액티베이션 레코드는 recursion을 지원할 수 없다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl41.png&quot; width=&quot;25%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 단순 서브프로그램의 액티베이션 레코드의 예이다.&lt;br /&gt;
예에서 단순 서브프로그램은 A, B, C이고, 이들의 코드와 액티베이션 레코드는 오른쪽 그림과 같이 메모리에 할당된다.&lt;br /&gt;
메모리에 할당되는 A, B, C의 코드와 데이터의 위치는 ​정적으로 할당되기 때문에 호출되는 순서와 무관하다.&lt;br /&gt;
A, B, C 모두 별개로 컴파일될 수 있으며, ​이 경우 링커에 의해 그림과 같이 모아진다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Implementing Subprograms with Stack-Dynamic Local Variables&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;서브프로그램의 로컬 변수가 스택-동적일 경우, ​서브프로그램의 호출 및 반환 구현에 대해 알아보자.&lt;/p&gt;

&lt;p&gt;스택 동적 로컬 변수는 런타임 스택에 할당된다. ​장점은 recursion의 지원이다.  ​&lt;/p&gt;

&lt;p&gt;스택-동적 로컬 변수가 있는 서브프로그램의 호출과 반환을 구현하려면 ​액티베이션 레코드가 더욱 복잡해진다.  ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;컴파일러는 ‘스택에서 로컬 변수의 암묵적인 할당과 해제’를 지원하기 위한 코드를 생성해야 한다.  ​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Recursion은 하나의 서브프로그램에 대해 여러 개의 액티베이션 레코드를 추가할 가능성이 있다. ​즉, 액티베이션 레코드 여러 개가 스택에 생성된다.&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int AddTwo(int x,y)
{
  int sum;
  sum = x + y;
  return sum;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 함수를 실행하려면 어떤 데이터가 필요할까?&lt;br /&gt;
파라미터 x, y, 로컬 변수 sum, AddTwo 종료후 복귀할 return address&lt;br /&gt;
이와 같이, 액티베이션 레코드는 함수를 한번 실행하는데 필요한 데이터로 구성된다. ​&lt;/p&gt;

&lt;p&gt;그러면… 스택에 저장된 이들 변수를 어떻게 접근할까? ​&lt;br /&gt;
Caller의 스택 포인터를 이용하면 가능한가? 아니다.&lt;br /&gt;
SP는 액티베이션 레코드를 스택에 저장하고자 할 때, ​스택 메모리를 할당하고(나중에 해제하는) ‘시스템이 사용하는’ 레지스터이다.&lt;br /&gt;
따라서 서브프로그램이 사용할 수 있는 레지스터가 아니다.&lt;/p&gt;

&lt;p&gt;​액티베이션 레코드에 저장된 파라미터나 로컬 변수에 접근하려면, ​&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;액티베이션 레코드에 접근할 때, ​BP(베이스 포인터)를 사용한다.&lt;br /&gt;
BP는 AR의 맨앞의 주소를 말하며, ​서브프로그램의 실행 중에 변경되지 않는다.&lt;br /&gt;
BP는 지정된 레지스터에 저장되는데, 그림에서 이것을 BP라고 표시하자. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;파라미터나 로컬 변수에 접근하려면, ​BP+옵셋을 계산하여 스택에 저장된 파라미터나 로컬 변수에 접근한다. ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서브프로그램이 종료되어 반환될 때, ​BP는 ‘caller의 액티베이션 레코드의 BP’로 재저장된다.&lt;br /&gt;
여기서 return addr는 복귀 주소로, ​서브프로그램의 종료후 되돌아갈 caller의 위치를 나타낸다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;BP는 항상 현재 실행 중인 프로그램의 액티베이션 레코드의 시작 주소를 가리킨다.&lt;br /&gt;
서브 프로그램이 호출되면, 현재 BP는 callee의 액티베이션 레코드(dynamic link)에 저장되고 ​BP는 새로 생성된 callee의 액티베이션 레코드의 시작 주소를 가리키도록 새롭게 설정된다.&lt;br /&gt;
즉, callee로부터 반환되자마자, BP는 callee의 액티베이션 레코드(dynamic link)의 값으로 재저장된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl42.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl43.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;위 그림은 코드와 데이터, 서브프로그램 링키지 코드(AddTwo PROC),그리고 액티베이션 레코드가 저장된 스택을 보여준다.&lt;br /&gt;
esp, ebp는 각각 스택포인터, 베이스 포인터이며, eax는 반환값을 저장하는 장소이다&lt;/p&gt;

&lt;p&gt;AddTwo PROC은 스택에 할당된 액티베이션 레코드에 접근하여, ​스택에 저장된 두 수를 더하여 eax에 저장하여 반환하고, 반환후 5와 6이 저장되었던 8 바이트를 청소하고 종료하는 과정을 보여준다.&lt;br /&gt;
이때 EBP, ESP를 caller의 것으로 변경한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl44.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Recursion이 없이, 여러 서브프로그램으로 구성된 프로그램에서, ​메인이 B를 호출하고, ​B가 C를 호출하고, ​A가 C를 호출한다고 하자. &lt;br /&gt;
그렇게 되면, 위와 같이 액티베이션 레코드가 스택 메모리에 할당된다.&lt;br /&gt;
동적 링크는 바로 아래(caller)의 액티베이션 레코드를 가리킨다.&lt;/p&gt;

&lt;p&gt;이와 같이, 스택에 스택-동적 액티베이션 레코드가 연속적으로 쌓여진 것을 동적 체인(dynamic chain)이라고 한다.&lt;br /&gt;
로컬 변수의 접근은 BP와 옵셋을 계산에 의하며, 이러한 옵셋을 로컬 옵셋이라고 한다.&lt;br /&gt;
로컬 변수의 로컬 옵셋은 컴파일러에 의해 컴파일 타임에 결정된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl45.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl46.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;p&gt;​&lt;img src=&quot;/assets/built/images/pl/pl47.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; title=&quot;제목&quot; alt=&quot;프로그래밍언어&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Recursion이 있을 때, ​액티베이션 레코드는  위의 그림과 같다. ​
여기서 파라미터는 n이다.&lt;/p&gt;

&lt;p&gt;첫째, 둘째, 셋째 recursion을 호출했을 때 function value가 모두 ?
셋째 recursion을 종료되었을 때 둘째 호출이 종료되었을 때 function value가 모두 ?이 아니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Nested Subprograms&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;중첩 서브프로그램의 호출과 반환 구현 방법을 살펴 보자.&lt;/p&gt;

&lt;p&gt;서브프로그램이 그 안에 다른 서브프로그램을 포함하는 경우, 이것을 중첩 서브프로그램이라고 부른다.&lt;/p&gt;

&lt;p&gt;중첩 서브프로그램에서, 난로컬 변수에 어떻게 접근할 것인가?&lt;br /&gt;
이들 변수는 스택의 액티베이션 레코드에 있다. ​&lt;/p&gt;

&lt;p&gt;난로컬 변수에 접근하려면, ​먼저 스택에서 올바른 액티베이션 레코드를 찾아야 한다.&lt;br /&gt;
다음, 액티베이션 레코드 내에서 그 변수의 옵셋을 찾아야 한다. ​&lt;/p&gt;

&lt;p&gt;정적 스코프일 경우, ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;정적 조상 스코프에 선언된 변수가 나타나고 접근될 수 있다. ​&lt;/li&gt;
  &lt;li&gt;언급된 모든 난로컬 변수는 스택의 다른 액티베이션 레코드에 할당되어 있다. ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;올바른 액티베이션 레코드를 찾으려면, ​정적 조상의 액티베이션 레코드를 체인으로 연결하라.&lt;/p&gt;

&lt;p&gt;정적 링크는 정적 부모의 시작 주소를 가리키는 포인터이다.&lt;br /&gt;
정적 체인은 실행 중인 서브프로그램의 정적 부모를 포함해서 모든 정적 조상을 연결한다. ​&lt;/p&gt;

&lt;p&gt;체인을 따라가면, 올바른 액티베이션 레코드를 찾을 수 있다. ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;스코프의 중첩은 정적이기 때문에 컴파일 타임에 미리 알려진다. ​&lt;/li&gt;
  &lt;li&gt;따라서 쉽게 찾아갈 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정적 체인을 따라가는데 필요한 정보는&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;static_depth: 정적 스크프의 중첩 깊이​&lt;/li&gt;
  &lt;li&gt;Chain_offset(또는 nesting_depth): 난로컬 변수를 언급한 서브프로그램의 staic_depth 와 난로컬 변수를 선언한 서브프로그램의 static_depth 간의 차이 ​변수의 언급은 (chain_offset, local_offset)으로 표현되며, local_offset 은 액티베이션 레코드 내에서 언급된 변수의 옵셋이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;호출할 때, 액티베이션 레코드를 생성한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;동적 링크는 스택의 olld 탑 포인터이다​&lt;/li&gt;
  &lt;li&gt;정적 링크는 ‘가장 최근의 정적 부모’의 액티베이트 레코드를 가리킨다.​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;액티베이션 레코드를 생성한 후, 정적 체인을 생성하는 방법은 두가지가 있다.  ​&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;동적 체인을 따라가면서 부모 스코프를 찾는다. ​&lt;/li&gt;
  &lt;li&gt;컴파일러가 서브프로그램 호출을 만나면, 호출된 서브프로그램의 정적 부모를 찾아서 그 부모로부터의 nesting_depth를 기록한다. 그 서브프로그램이 호출될 때, 콜러의 정적 링크에 있는 값과 nesting_depth의 수로부터 callee의 정적 링크를 찾을 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;정적 체인은 다음과 같은 문제를 내포하고 있다.&lt;br /&gt;
중첩 깊이가 크면, 난로컬 변수에 대한 참조(레퍼런스)가 늦다.&lt;br /&gt;
난로컬 참조의 비용 산출이 어렵다.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Implementing Dynamic Scoping&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Deep Access
딥액세스는 동적 체인에서 액티베이션 레코드를 검색하여 난로컬 참조를 찾는다.&lt;/li&gt;
  &lt;li&gt;체인의 길이를 정적으로 결정할 수 없다. ​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 액티베이션 레코드는 검색 과정을 위해 변수명을 가져야 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Shallo Access
쉘로우 액세스는 각 변수명마다 하나의 스택을 유지하고, 중앙 테이블에 각 변수명에 대해 하나의 엔트리를 할당한다.  ​&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="pl" />
      

      
        <summary type="html">ImplementSubprogram</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">프로세스통신-pipe</title>
      <link href="https://lee989898.github.io/st-08" rel="alternate" type="text/html" title="프로세스통신-pipe" />
      <published>2021-11-03T01:06:00+09:00</published>
      <updated>2021-11-03T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/st-08</id>
      <content type="html" xml:base="https://lee989898.github.io/st-08">&lt;h3 id=&quot;프로세스통신-pipe&quot;&gt;&lt;strong&gt;프로세스통신-pipe&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Inter-Process Communication (IPC)​&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스들끼리 데이터를 주고 받는 기능 수행&lt;/li&gt;
  &lt;li&gt;예: Client/Serve 응용 프로그램, 등&lt;/li&gt;
  &lt;li&gt;Pipe/Socket: 파일 디스크립터를 사용하여 접근 가능한 IPC방법들&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Pipe&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;리눅스에서 가장 오래된 IPC이다&lt;/li&gt;
  &lt;li&gt;Pipe은 메모리 버퍼 영역을 가리킴​
    &lt;ul&gt;
      &lt;li&gt;읽기용 입구 하나, 쓰기용 입구 하나를 가짐​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파일 디스크립터로 접근(access)​
    &lt;ul&gt;
      &lt;li&gt;읽기용 입구와 쓰기용 입구에 각각 다른 파일 디스크립터가 할당됨​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;통신을 하게 될 프로세스들이 파일 디스크립터 들을 공유해야 : (예) 부모, 자식 관계​
    &lt;ul&gt;
      &lt;li&gt;프로세스는 pipe() system call을 사용하여 파이프를 생성한다&lt;/li&gt;
      &lt;li&gt;동일한 프로세스가 fork()를 호출하여 자식 프로세스를 생성한다&lt;/li&gt;
      &lt;li&gt;그러면 파이프는 parent 프로세스와 child 프로세스 간에 사용된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파이프의 한계
    &lt;ul&gt;
      &lt;li&gt;Half duplex: 데이터는 한 방향으로만 흐른다&lt;/li&gt;
      &lt;li&gt;공통 조상이 있는 프로세스 사이에서만 사용할 수 있다​
        &lt;ul&gt;
          &lt;li&gt;일반적으로 parent 프로세스와 child 프로세스 사이에 사용&lt;/li&gt;
          &lt;li&gt;프로세스가 파이프를 생성하면 모든 자식이 파이프를 상속할 수 있다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;휘발성: 파이프를 생성한 프로세스가 종료되면 사라진다&lt;/li&gt;
      &lt;li&gt;process는 파이프를 전달할 수 없으며 parent로부터 상속해야 한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;Linux 셸에서 파이프 기호는 “&lt;/td&gt;
          &lt;td&gt;“이다&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;% ls -alg&lt;/td&gt;
              &lt;td&gt;more​&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;%  cmd1&lt;/td&gt;
              &lt;td&gt;cmd2​&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;터미널에서 cmd1 입력&lt;/li&gt;
      &lt;li&gt;cmd1의 출력은 cmd2의 입력&lt;/li&gt;
      &lt;li&gt;cmd2의 출력은 터미널 화면에 연결한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st17.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Long pipes:​
    &lt;ul&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;$ pic paper.ms&lt;/td&gt;
              &lt;td&gt;tbl&lt;/td&gt;
              &lt;td&gt;eqn&lt;/td&gt;
              &lt;td&gt;ditroff -ms​&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Pipe을 이용하여 두 개의 프로세스 들이 통신을 할 경우, producer가 write한 순서대로 consumer가 read하게 된다​
    &lt;ul&gt;
      &lt;li&gt;선입선출(First-In First-Out)관계​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단방향 pipe : ​
    &lt;ul&gt;
      &lt;li&gt;Producer 프로세스는 pipe에 대한 write용 입구만 사용​&lt;/li&gt;
      &lt;li&gt;Consumer 프로세스는 pipe에 대한 read용 입구만 사용​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;쌍방향 pipe : ​
    &lt;ul&gt;
      &lt;li&gt;Pipe을 두 개 열어 사용​&lt;/li&gt;
      &lt;li&gt;하나의 pipe는 한쪽 방향의 통신에만 사용됨​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Pipe: pipe() system call&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;unistd.h&amp;gt;
int pipe(int fd[2]) // int fd[2]; 파일 디스크립터
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;정상 종료하면 0을 반환, 에러 발생시에는 -1을 반환​&lt;/li&gt;
  &lt;li&gt;pipe() system call은 인자로 넘겨 받은 fd[0], fd[1]에 파일 디스크립터를 저장해서 반환​&lt;/li&gt;
  &lt;li&gt;fd[0]: 읽기 모드에서 연 파일 디스크립터(읽기용 입구)​&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;fd[1]: 쓰기 모드에서 연 파일 디스크립터(쓰기용 출구)​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Pipe(), fork() 시스템 호출에 의해 부모/자식 프로세스가 fd[0], fd[1]를 공유한다고 가정​&lt;/li&gt;
  &lt;li&gt;쓰는 쪽(write() system call) 프로세스에서는 읽기용 파일 디스크립터(fd[0])를 닫아 놓음(close() system call)​&lt;/li&gt;
  &lt;li&gt;읽는 쪽(read() system call) 프로세스에서는 쓰기용 파일 디스크립터(fd[1])를 닫아 놓음(close() system call) ​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Pipe: popen()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

FILE *popen(const char *cmdstring, const char *type);
    반환값: 정상이면 파일 포인터, 오류 시 NULL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;popen은 “cmdstring”을 실행하기 위해 fork() 및 exec()를 수행한다​&lt;/li&gt;
  &lt;li&gt;popen의 유형은 “r” 또는 “w”이다​
    &lt;ul&gt;
      &lt;li&gt;type이 “r”이면 반환된 파일 포인터는 “cmdstring”의 stdout에 연결된다&lt;/li&gt;
      &lt;li&gt;type이 “w”인 경우 반환된 파일 포인터는 “cmdstring”의 표준 입력에 연결된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Pipe: pclose()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int pclose(FILE *fp);
    반환값: cmdstring의 종료 상태 또는 오류 시 -1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;“pclose”는 std I/O 스트림을 닫고 명령이 종료될 때까지 기다렸다가 셸의 종료 상태를 반환한다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;FIFO&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;파이프와 비슷하다, “named pipe” 라고 불리운다​&lt;/li&gt;
  &lt;li&gt;파일의 종류&lt;/li&gt;
  &lt;li&gt;FIFO는 파이프의 한계를 극복한다​&lt;/li&gt;
  &lt;li&gt;관련 없는 프로세스 간에 사용 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;    
#include &amp;lt;sys/stat.h&amp;gt;

int mkfifo(const char *filename, mode_t mode);
정상이면 0, 오류시 -1을 반환한다
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;FIFO 생성은 파일 생성과 유사하다
    &lt;ul&gt;
      &lt;li&gt;Mode: open() 함수와 동일한 권한&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;FIFO를 사용하는 것은 파일을 사용하는 것과 유사하다
    &lt;ul&gt;
      &lt;li&gt;생성되면 FIFO에 대한 열기, 닫기, 읽기, 쓰기, 연결 해제 등을 사용할 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파이프와 마찬가지로 읽기를 위해 열려 있는 프로세스가 없는 FIFO에 쓰면 SIGPIPE 신호가 생성된다&lt;/li&gt;
  &lt;li&gt;FIFO의 마지막 작성자가 FIFO를 닫으면 FIFO의 판독기에 대해 파일 끝이 생성된다&lt;/li&gt;
  &lt;li&gt;PIPE_BUF(커널의 파이프 버퍼 크기)는 FIFO에 원자적으로 쓸 수 있는 최대 데이터 양을 지정한다
    &lt;ul&gt;
      &lt;li&gt;여러 프로세스의 데이터 쓰기 &amp;lt;= PIPE_BUF는 인터리브되지 않는다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;FIFO 사용 예
    &lt;ul&gt;
      &lt;li&gt;셸 명령에서 중간 파일을 생성하지 않고 한 셸 파이프라인에서 다른 셸 파이프라인으로 데이터를 전달하는 데 사용​&lt;/li&gt;
      &lt;li&gt;클라이언트와 서버 간에 데이터를 전달하기 위해 클라이언트-서버 애플리케이션에서 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;FIFO : 출력 스트림 복제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;입력 스트림을 두 번 처리하는 절차 작성&lt;/li&gt;
  &lt;li&gt;tee(1)은 표준 입력을 표준 출력과 명령줄에 명명된 파일 모두에 복사한다&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkfifo fifo1​
$ prog3 &amp;lt; fifo1 &amp;amp;​
$ prog1 &amp;lt; infile | tee fifo1 | prog2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st18.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;FIFO : 클라이언트-서버 통신&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;서버는 클라이언트와 통신하기 위해 “well-known” FIFO를 생성한다(well-known: FIFO의 경로 이름은 서버에 접속해야 하는 모든 클라이언트에게 알려져 있음)&lt;/li&gt;
  &lt;li&gt;클라이언트 데이터의 interleaving을 피하기 위해 클라이언트는 한 번에 최대 PIPE_BUF 바이트를 써야 하다​&lt;/li&gt;
  &lt;li&gt;문제: 서버가 단일 “well-known” FIFO를 사용하여 클라이언트에 응답할 수 없음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st19.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;서버는 클라이언트별 FIFO를 사용하여 응답할 수 있도록 각 클라이언트에 대해 FIFO를 생성한다
    &lt;ul&gt;
      &lt;li&gt;e.g.: /tmp/serv1.XXXX, where XXXXX is client’s process ID ​&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서버는 SIGPIPE를 잡아야 함(1개의 작성자가 있는 FIFO, 판독기 없음)​
    &lt;ul&gt;
      &lt;li&gt;클라이언트는 서버에서 응답을 읽기 전에 요청을 보내고 종료하여 클라이언트별 FIFO를 하나의 작성자(서버)와 리더 없이 남겨둔다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/st/st20.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;시스템프로그래밍&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="system" />
      

      
        <summary type="html">프로세스통신-pipe</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">signature</title>
      <link href="https://lee989898.github.io/sc-10" rel="alternate" type="text/html" title="signature" />
      <published>2021-10-31T01:06:00+09:00</published>
      <updated>2021-10-31T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-10</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-10">&lt;h3 id=&quot;signature&quot;&gt;&lt;strong&gt;signature&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;서명&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;자기의 동일성을 표시하고 책임을 분명하기 하기 위하여 문서 따위에 자기 이름을 써넣음​&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;전자서명의 기본 아이디어&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;송신자(alice)는 자신의 비밀키로 암호화​&lt;/li&gt;
  &lt;li&gt;수신자는 송신자의 공개키로 복호화&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;시나리오:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ Bob은 public key를 공개된 장소에 두고, private key는 자신이 가지고 있다
+ Alice는 Bob의 public key를 가져와, 메시지를 암호화해서 전송​
+ 이 메시지는 다른 사람이 보더라도 풀 수 없다. 메시지를 복호화하려면 Bob의 private key가 필요하기 때문-&amp;gt;기밀성보장​
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;문제점1. Bob은 Alice가 메시지를 작성했다는것을 확신할 수 있을까? NO​&lt;/li&gt;
  &lt;li&gt;문제점2. Bob은 메시지가 중간에 변경되지않았다는것을 확신할 수 있을까? NO​&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;해결법&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Alice는 메시지로 MAC을 만들고, 이것을 Alice가 자신의 private key로 암호화 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc05.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;만들어진 것을 본래 메시지에 붙인다 -&amp;gt; 서명&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc06.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이것을 Bob의 public key로 암호화 해서 전송&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;다른 사람은 Bob의 private key가 없으므로 볼수없다 -&amp;gt; 기밀성​&lt;/li&gt;
  &lt;li&gt;Bob은 자신의 private key로 열면 평문과 시그니쳐가 나온다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc07.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Bob은 다음과 같이 무결성,인증을 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​   &lt;img src=&quot;/assets/built/images/sc/sc08.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">signature</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">이메일 보안</title>
      <link href="https://lee989898.github.io/sc-11" rel="alternate" type="text/html" title="이메일 보안" />
      <published>2021-10-31T01:06:00+09:00</published>
      <updated>2021-10-31T01:06:00+09:00</updated>
      <id>https://lee989898.github.io/sc-11</id>
      <content type="html" xml:base="https://lee989898.github.io/sc-11">&lt;h3 id=&quot;이메일-보안&quot;&gt;&lt;strong&gt;이메일 보안&lt;/strong&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;PGP&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;운영체제에 상관없이 확정성이 뛰어나다&lt;/li&gt;
  &lt;li&gt;S/MIME&lt;/li&gt;
  &lt;li&gt;공개키 기반의 프로토콜이다&lt;/li&gt;
  &lt;li&gt;RSA, El Gamel을 사용한다&lt;/li&gt;
  &lt;li&gt;대칭키 방식과도 연동된다(3DES)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Requirements of secure E-mail&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;기밀성&lt;/li&gt;
  &lt;li&gt;송신자 인증&lt;/li&gt;
  &lt;li&gt;메시지 무결성&lt;/li&gt;
  &lt;li&gt;수신자 인증&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Secure e-mail: 기밀성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc10.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;앨리스는 기밀성을 입증한 e-mail, m을 밥에게 보내고 싶다&lt;/li&gt;
  &lt;li&gt;랜덤 대칭키를 생성한다, K&lt;sub&gt;S&lt;/sub&gt;&lt;/li&gt;
  &lt;li&gt;메시지를  K&lt;sub&gt;S&lt;/sub&gt;로 encrypt한다&lt;/li&gt;
  &lt;li&gt;또한 K&lt;sub&gt;S&lt;/sub&gt;를 밥의 공개키로 encrypt한다&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;밥에게 K&lt;sub&gt;S&lt;/sub&gt;(m)과 K&lt;sub&gt;B&lt;/sub&gt;(K&lt;sub&gt;S&lt;/sub&gt;)를 보낸다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;밥은 그의 private키로 decrypt하여 K&lt;sub&gt;S&lt;/sub&gt;를 찾아낸다&lt;/li&gt;
  &lt;li&gt;K&lt;sub&gt;S&lt;/sub&gt;로 K&lt;sub&gt;S&lt;/sub&gt;(m)을 decrypt하여 m을 찾아낸다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Secure e-mail: 송신자 인증, 무결성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc11.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;앨리스는 송신자 인증과 메시지 무결성을 지키고 싶다&lt;/li&gt;
  &lt;li&gt;앨리스는 메세지를 digitally 사인한다&lt;/li&gt;
  &lt;li&gt;메시지와 디지털 시그니처 모두 보낸다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Secure e-mail: all together&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc12.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;앨리스는 보안,송신자 인증,메시지 무결성을 지키고 싶다&lt;/li&gt;
  &lt;li&gt;앨리스는 3가지 키를 사용한다
    &lt;ul&gt;
      &lt;li&gt;그녀의 private key&lt;/li&gt;
      &lt;li&gt;밥의 public key&lt;/li&gt;
      &lt;li&gt;새로 만들어진 대칭키&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Email 보안 표준&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;PGP&lt;/li&gt;
  &lt;li&gt;S/MIME
    &lt;ul&gt;
      &lt;li&gt;이메일을 위해 MIME에 보안서비스 제공 표준&lt;/li&gt;
      &lt;li&gt;인증,무결성,부인방지,기밀성 제공&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/sc/sc09.png&quot; width=&quot;50%&quot; height=&quot;25%&quot; title=&quot;제목&quot; alt=&quot;컴퓨터보안&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>lee989898</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">이메일 보안</summary>
      

      
      
    </entry>
  
</feed>
